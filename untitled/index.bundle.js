/*! For license information please see index.bundle.js.LICENSE.txt */
(self.webpackChunkescape_from_hyper_island=self.webpackChunkescape_from_hyper_island||[]).push([[826],{9327:(e,t,n)=>{"use strict";n.r(t),n.d(t,{BACKGROUND_NOISE_TAG:()=>C,Dataset:()=>I,UNKNOWN_TAG:()=>P,create:()=>j,deleteSavedTransferModel:()=>H,getMaxIntensityFrameIndex:()=>L,listSavedTransferModels:()=>G,spectrogram2IntensityCurve:()=>D,utils:()=>q,version:()=>F});var r=n(1740),i=n(9539),s=n(5934),a=n(2001),o=function(e,t){return(o=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)},l=function(){return(l=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)};function c(e,t,n,r){return new(n||(n=Promise))((function(i,s){function a(e){try{l(r.next(e))}catch(e){s(e)}}function o(e){try{l(r.throw(e))}catch(e){s(e)}}function l(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(a,o)}l((r=r.apply(e,t||[])).next())}))}function u(e,t){var n,r,i,s,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return s={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function o(s){return function(o){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(i=2&s[0]?r.return:s[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,s[1])).done)return i;switch(r=0,i&&(s=[2&s[0],i.value]),s[0]){case 0:case 1:i=s;break;case 4:return a.label++,{value:s[1],done:!1};case 5:a.label++,r=s[1],s=[0];continue;case 7:s=a.ops.pop(),a.trys.pop();continue;default:if(!(i=(i=a.trys).length>0&&i[i.length-1])&&(6===s[0]||2===s[0])){a=0;continue}if(3===s[0]&&(!i||s[1]>i[0]&&s[1]<i[3])){a.label=s[1];break}if(6===s[0]&&a.label<i[1]){a.label=i[1],i=s;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(s);break}i[2]&&a.ops.pop(),a.trys.pop();continue}s=t.call(e,a)}catch(e){s=[6,e],r=0}finally{n=i=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,o])}}}function h(e){var t="function"==typeof Symbol&&Symbol.iterator,n=t&&e[t],r=0;if(n)return n.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}function d(e,t){var n="function"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var r,i,s=n.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(r=s.next()).done;)a.push(r.value)}catch(e){i={error:e}}finally{try{r&&!r.done&&(n=s.return)&&n.call(s)}finally{if(i)throw i.error}}return a}function p(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(d(arguments[t]));return e}function f(e){return c(this,void 0,void 0,(function(){var t,r,s,a,o;return u(this,(function(l){switch(l.label){case 0:return t="file://",0!==e.indexOf("http://")&&0!==e.indexOf("https://")?[3,3]:[4,fetch(e)];case 1:return[4,l.sent().json()];case 2:return[2,l.sent()];case 3:return 0!==e.indexOf(t)?[3,5]:(r=n(9127),s=(0,i.promisify)(r.readFile),o=(a=JSON).parse,[4,s(e.slice(t.length),{encoding:"utf-8"})]);case 4:return[2,o.apply(a,[l.sent()])];case 5:throw new Error("Unsupported URL scheme in metadata URL: "+e+". Supported schemes are: http://, https://, and (node.js-only) file://")}}))}))}var m=null;function g(e){return null==m&&(m=(0,r.y3$)().epsilon()),(0,r.lub)((function(){var t=(0,r.Gi7)(e),n=t.mean,i=t.variance;return(0,r.hiC)((0,r.luU)(e,n),(0,r.IHx)((0,r._b3)(i),m))}))}function y(e){if(e.length<2)throw new Error("Cannot normalize a Float32Array with fewer than 2 elements.");return null==m&&(m=(0,r.y3$)().epsilon()),(0,r.lub)((function(){var t=(0,r.Gi7)((0,r.RRF)(e)),n=t.mean,i=t.variance,s=n.arraySync(),a=Math.sqrt(i.arraySync()),o=Array.from(e).map((function(e){return(e-s)/(a+m)}));return new Float32Array(o)}))}function v(e){return c(this,void 0,void 0,(function(){return u(this,(function(t){return[2,navigator.mediaDevices.getUserMedia({audio:null==e||e,video:!1})]}))}))}var x=function(){function e(e){var t=this;if(null==e)throw new Error("Required configuration object is missing for BrowserFftFeatureExtractor constructor");if(null==e.spectrogramCallback)throw new Error("spectrogramCallback cannot be null or undefined");if(!(e.numFramesPerSpectrogram>0))throw new Error("Invalid value in numFramesPerSpectrogram: "+e.numFramesPerSpectrogram);if(e.suppressionTimeMillis<0)throw new Error("Expected suppressionTimeMillis to be >= 0, but got "+e.suppressionTimeMillis);if(this.suppressionTimeMillis=e.suppressionTimeMillis,this.spectrogramCallback=e.spectrogramCallback,this.numFrames=e.numFramesPerSpectrogram,this.sampleRateHz=e.sampleRateHz||44100,this.fftSize=e.fftSize||1024,this.frameDurationMillis=this.fftSize/this.sampleRateHz*1e3,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.overlapFactor=e.overlapFactor,this.includeRawAudio=e.includeRawAudio,r.D5U.assert(this.overlapFactor>=0&&this.overlapFactor<1,(function(){return"Expected overlapFactor to be >= 0 and < 1, but got "+t.overlapFactor})),this.columnTruncateLength>this.fftSize)throw new Error("columnTruncateLength "+this.columnTruncateLength+" exceeds fftSize ("+this.fftSize+").");this.audioContextConstructor=window.AudioContext||window.webkitAudioContext}return e.prototype.start=function(e){return c(this,void 0,void 0,(function(){var t,n,r;return u(this,(function(i){switch(i.label){case 0:if(null!=this.frameIntervalTask)throw new Error("Cannot start already-started BrowserFftFeatureExtractor");return t=this,[4,v(e)];case 1:return t.stream=i.sent(),this.audioContext=new this.audioContextConstructor({sampleRate:this.sampleRateHz}),n=this.audioContext.createMediaStreamSource(this.stream),this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=0,n.connect(this.analyser),this.freqDataQueue=[],this.freqData=new Float32Array(this.fftSize),this.includeRawAudio&&(this.timeDataQueue=[],this.timeData=new Float32Array(this.fftSize)),r=Math.max(1,Math.round(this.numFrames*(1-this.overlapFactor))),this.tracker=new _(r,Math.round(this.suppressionTimeMillis/this.frameDurationMillis)),this.frameIntervalTask=setInterval(this.onAudioFrame.bind(this),this.fftSize/this.sampleRateHz*1e3),[2]}}))}))},e.prototype.onAudioFrame=function(){return c(this,void 0,void 0,(function(){var e,t,n,i;return u(this,(function(s){switch(s.label){case 0:return this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0?[2]:(this.freqDataQueue.push(this.freqData.slice(0,this.columnTruncateLength)),this.includeRawAudio&&(this.analyser.getFloatTimeDomainData(this.timeData),this.timeDataQueue.push(this.timeData.slice())),this.freqDataQueue.length>this.numFrames&&this.freqDataQueue.shift(),this.tracker.tick()?(e=b(this.freqDataQueue),t=w(e,[1,this.numFrames,this.columnTruncateLength,1]),n=void 0,this.includeRawAudio&&(i=b(this.timeDataQueue),n=w(i,[1,this.numFrames*this.fftSize])),[4,this.spectrogramCallback(t,n)]):[3,2]);case 1:s.sent()&&this.tracker.suppress(),(0,r.B90)([t,n]),s.label=2;case 2:return[2]}}))}))},e.prototype.stop=function(){return c(this,void 0,void 0,(function(){return u(this,(function(e){if(null==this.frameIntervalTask)throw new Error("Cannot stop because there is no ongoing streaming activity.");return clearInterval(this.frameIntervalTask),this.frameIntervalTask=null,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop(),[2]}))}))},e.prototype.setConfig=function(e){throw new Error("setConfig() is not implemented for BrowserFftFeatureExtractor.")},e.prototype.getFeatures=function(){throw new Error("getFeatures() is not implemented for BrowserFftFeatureExtractor. Use the spectrogramCallback field of the constructor config instead.")},e}();function b(e){var t=e[0].length,n=new Float32Array(e.length*t);return e.forEach((function(e,r){return n.set(e,r*t)})),n}function w(e,t){var n=new Float32Array(r.D5U.sizeFromShape(t));return n.set(e,n.length-e.length),(0,r.XeE)(n,t)}var _=function(){function e(e,t){var n=this;this.period=e,this.suppressionTime=null==t?0:t,this.counter=0,r.D5U.assert(this.period>0,(function(){return"Expected period to be positive, but got "+n.period}))}return e.prototype.tick=function(){return this.counter++,this.counter%this.period==0&&(null==this.suppressionOnset||this.counter-this.suppressionOnset>this.suppressionTime)},e.prototype.suppress=function(){this.suppressionOnset=this.counter},e}();function S(e){var t=0;e.forEach((function(e){t+=e.byteLength}));var n=new Uint8Array(t),r=0;return e.forEach((function(e){n.set(new Uint8Array(e),r),r+=e.byteLength})),n.buffer}function M(e){var t=0;e.forEach((function(e){return t+=e.length}));var n=new Float32Array(t),r=0;return e.forEach((function(e){n.set(e,r),r+=e.length})),n}function T(e){if(null==e)throw new Error("Received null or undefind string");for(var t=unescape(encodeURIComponent(e)),n=new Uint8Array(t.length),r=0;r<t.length;++r)n[r]=t.charCodeAt(r);return n.buffer}function E(e){if(null==e)throw new Error("Received null or undefind buffer");var t=new Uint8Array(e);return decodeURIComponent(escape(String.fromCharCode.apply(String,p(t))))}var A="TFJSSCDS",C="_background_noise_",I=function(){function e(e){if(this.examples={},this.label2Ids={},null!=e)for(var t=function(e){r.D5U.assert(null!=e,(function(){return"Received null or undefined buffer"}));var t=0,n=E(e.slice(t,A.length));r.D5U.assert(n===A,(function(){return"Deserialization error: Invalid descriptor"})),t+=A.length,t+=4;var i=new Uint32Array(e,t,1),s=t+=4;t=s+i[0];var a=E(e.slice(s,t));return{manifest:JSON.parse(a),data:e.slice(t)}}(e),n=0,i=0;i<t.manifest.length;++i){var s=t.manifest[i],a=s.spectrogramNumFrames*s.spectrogramFrameSize;null!=s.rawAudioNumSamples&&(a+=s.rawAudioNumSamples),a*=4,this.addExample(k({spec:s,data:t.data.slice(n,n+a)})),n+=a}}return e.prototype.addExample=function(e){r.D5U.assert(null!=e,(function(){return"Got null or undefined example"})),r.D5U.assert(null!=e.label&&e.label.length>0,(function(){return"Expected label to be a non-empty string, but got "+JSON.stringify(e.label)}));var t=function(){function e(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)}return e()+e()+"-"+e()+"-"+e()+"-"+e()+"-"+e()+e()+e()}();return this.examples[t]=e,e.label in this.label2Ids||(this.label2Ids[e.label]=[]),this.label2Ids[e.label].push(t),t},e.prototype.merge=function(e){var t,n,i,s;r.D5U.assert(e!==this,(function(){return"Cannot merge a dataset into itself"}));var a=e.getVocabulary();try{for(var o=h(a),l=o.next();!l.done;l=o.next()){var c=l.value,u=e.getExamples(c);try{for(var d=(i=void 0,h(u)),p=d.next();!p.done;p=d.next()){var f=p.value;this.addExample(f.example)}}catch(e){i={error:e}}finally{try{p&&!p.done&&(s=d.return)&&s.call(d)}finally{if(i)throw i.error}}}}catch(e){t={error:e}}finally{try{l&&!l.done&&(n=o.return)&&n.call(o)}finally{if(t)throw t.error}}},e.prototype.getExampleCounts=function(){var e={};for(var t in this.examples){var n=this.examples[t];n.label in e||(e[n.label]=0),e[n.label]++}return e},e.prototype.getExamples=function(e){var t=this;r.D5U.assert(null!=e,(function(){return"Expected label to be a string, but got "+JSON.stringify(e)})),r.D5U.assert(e in this.label2Ids,(function(){return'No example of label "'+e+'" exists in dataset'}));var n=[];return this.label2Ids[e].forEach((function(e){n.push({uid:e,example:t.examples[e]})})),n},e.prototype.getData=function(e,t){var n=this;r.D5U.assert(this.size()>0,(function(){return"Cannot get spectrograms as tensors because the dataset is empty"}));var i=this.getVocabulary();null!=e?r.D5U.assert(-1!==i.indexOf(e),(function(){return"Label "+e+" is not in the vocabulary ("+JSON.stringify(i)+")"})):r.D5U.assert(i.length>1,(function(){return"One-hot encoding of labels requires the vocabulary to have at least two words, but it has only "+i.length+" word."})),null==t&&(t={});var a,o,l=this.getSortedUniqueNumFrames();1===l.length?(a=null==t.numFrames?l[0]:t.numFrames,o=null==t.hopFrames?1:t.hopFrames):(a=t.numFrames,r.D5U.assert(null!=a&&Number.isInteger(a)&&a>0,(function(){return"There are "+l.length+" unique lengths among the "+n.size()+" examples of this Dataset, hence numFrames is required. But it is not provided."})),r.D5U.assert(a<=l[0],(function(){return"numFrames ("+a+") exceeds the minimum numFrames ("+l[0]+") among the examples of the Dataset."})),o=t.hopFrames,r.D5U.assert(null!=o&&Number.isInteger(o)&&o>0,(function(){return"There are "+l.length+" unique lengths among the "+n.size()+" examples of this Dataset, hence hopFrames is required. But it is not provided."})));var c=null==t.normalize||t.normalize;return(0,r.lub)((function(){for(var l,u,d,p=[],f=[],m=[],y=0;y<i.length;++y){var v=i[y];if(null==e||v===e){var x=n.label2Ids[v],b=function(i){var s,l,u=n.examples[i].spectrogram,x=u.frameSize;null==d?d=x:r.D5U.assert(x===d,(function(){return"Mismatch in frameSize  ("+x+" vs "+d+")"}));var b=u.data.length/x,w=null;v!==C&&(w=null==u.keyFrameIndex?L(u).dataSync()[0]:u.keyFrameIndex);var _=(0,r.wOQ)(u.data,[b,x,1]),S=R(b,w,a,o),M=function(n){var i=(0,r.lub)((function(){var e=(0,r.tPi)(_,[n[0],0,0],[n[1]-n[0],-1,-1]);return c?g(e):e}));t.getDataset?f.push(i.dataSync()):p.push(i),null==e&&m.push(y)};try{for(var T=(s=void 0,h(S)),E=T.next();!E.done;E=T.next())M(E.value)}catch(e){s={error:e}}finally{try{E&&!E.done&&(l=T.return)&&l.call(T)}finally{if(s)throw s.error}}(0,r.B90)(_)};try{for(var w=(l=void 0,h(x)),_=w.next();!_.done;_=w.next())b(_.value)}catch(e){l={error:e}}finally{try{_&&!_.done&&(u=w.return)&&u.call(w)}finally{if(l)throw l.error}}}}null!=t.augmentByMixingNoiseRatio&&n.augmentByMixingNoise(t.getDataset?f:p,m,t.augmentByMixingNoiseRatio);var S=null==t.shuffle||t.shuffle;if(t.getDataset){var M=null==t.datasetBatchSize?32:t.datasetBatchSize,T=null==t.datasetValidationSplit?.15:t.datasetValidationSplit;r.D5U.assert(T>0&&T<1,(function(){return"Invalid dataset validation split: "+T}));var E=f.map((function(e,t){return[e,m[t]]}));r.D5U.shuffle(E),f=E.map((function(e){return e[0]}));var A=E.map((function(e){return e[1]})),I=function(e,t,n){var i,s,a,o,l,c,u,d;r.D5U.assert(n>0&&n<1,(function(){return"validationSplit is expected to be >0 and <1, but got "+n}));for(var p=!Array.isArray(e[0]),f=t,m=[],g=0;g<f.length;++g){var y=f[g];null==m[y]&&(m[y]=[]),m[y].push(g)}var v=m.length,x=[],b=[];for(m.map((function(e){return r.D5U.shuffle(e)})),g=0;g<v;++g)for(var w=m[g],_=Math.round(w.length*(1-n)),S=0;S<w.length;++S)S<_?x.push(w[S]):b.push(w[S]);if(p){var M=[],T=[],E=[],A=[];try{for(var C=h(x),I=C.next();!I.done;I=C.next()){var N=I.value;M.push(e[N]),T.push(t[N])}}catch(e){i={error:e}}finally{try{I&&!I.done&&(s=C.return)&&s.call(C)}finally{if(i)throw i.error}}try{for(var k=h(b),R=k.next();!R.done;R=k.next())N=R.value,E.push(e[N]),A.push(t[N])}catch(e){a={error:e}}finally{try{R&&!R.done&&(o=k.return)&&o.call(k)}finally{if(a)throw a.error}}return{trainXs:M,trainYs:T,valXs:E,valYs:A}}M=[],T=[],E=[],A=[];try{for(var D=h(x),L=D.next();!L.done;L=D.next())N=L.value,M.push(e[N]),T.push(t[N])}catch(e){l={error:e}}finally{try{L&&!L.done&&(c=D.return)&&c.call(D)}finally{if(l)throw l.error}}try{for(var F=h(b),P=F.next();!P.done;P=F.next())N=P.value,E.push(e[N]),A.push(t[N])}catch(e){u={error:e}}finally{try{P&&!P.done&&(d=F.return)&&d.call(F)}finally{if(u)throw u.error}}return{trainXs:M,trainYs:T,valXs:E,valYs:A}}(f,A,T),N=I.trainXs,k=I.trainYs,D=I.valXs,F=I.valYs,P=(0,s.array)(N).map((function(e){return(0,r.wOQ)(e,[a,d,1])})),O=(0,s.array)(k).map((function(e){return(0,r.L9e)((0,r.lfX)([e],i.length),[0])})),z=(0,s.zip)({xs:P,ys:O});S&&(z=z.shuffle(f.length)),z=z.batch(M).prefetch(4);var B=(0,s.array)(D).map((function(e){return(0,r.wOQ)(e,[a,d,1])})),U=(0,s.array)(F).map((function(e){return(0,r.L9e)((0,r.lfX)([e],i.length),[0])})),$=(0,s.zip)({xs:B,ys:U});return[z,$=$.batch(M).prefetch(4)]}if(S){var V=[];p.forEach((function(e,t){V.push({x:e,y:m[t]})})),r.D5U.shuffle(V),p=V.map((function(e){return e.x})),m=V.map((function(e){return e.y}))}var W=null==e?(0,r.pju)((0,r.lfX)((0,r.RRF)(m,"int32"),i.length),"float32"):void 0;return{xs:(0,r.knu)(p),ys:W}}))},e.prototype.augmentByMixingNoise=function(e,t,n){var i,s;if(null==e||0===e.length)throw new Error("Cannot perform augmentation because data is null or empty");for(var a=e[0]instanceof Float32Array,o=this.getVocabulary(),l=[],c=[],u=0;u<t.length;++u)o[t[u]]===C?l.push(u):c.push(u);if(0===l.length)throw new Error("Cannot perform augmentation by mixing with noise when there is no example with label "+C);var d=[],f=[],m=function(i){var s=l[function(e,t){return Math.floor((t-0)*Math.random())+0}(0,l.length)],o=a?(0,r.RRF)(e[i]):e[i],c=a?(0,r.RRF)(e[s]):e[s],u=(0,r.lub)((function(){return g((0,r.IHx)(o,(0,r.dC7)(c,n)))}));a?d.push(u.dataSync()):d.push(u),f.push(t[i])};try{for(var y=h(c),v=y.next();!v.done;v=y.next())m(v.value)}catch(e){i={error:e}}finally{try{v&&!v.done&&(s=y.return)&&s.call(y)}finally{if(i)throw i.error}}console.log("Data augmentation: mixing noise: added "+d.length+" examples"),d.forEach((function(t){return e.push(t)})),t.push.apply(t,p(f))},e.prototype.getSortedUniqueNumFrames=function(){for(var e,t,n=new Set,r=this.getVocabulary(),i=0;i<r.length;++i){var s=r[i],a=this.label2Ids[s];try{for(var o=(e=void 0,h(a)),l=o.next();!l.done;l=o.next()){var c=l.value,u=this.examples[c].spectrogram,d=u.data.length/u.frameSize;n.add(d)}}catch(t){e={error:t}}finally{try{l&&!l.done&&(t=o.return)&&t.call(o)}finally{if(e)throw e.error}}}var f=p(n);return f.sort(),f},e.prototype.removeExample=function(e){if(!(e in this.examples))throw new Error("Nonexistent example UID: "+e);var t=this.examples[e].label;delete this.examples[e];var n=this.label2Ids[t].indexOf(e);this.label2Ids[t].splice(n,1),0===this.label2Ids[t].length&&delete this.label2Ids[t]},e.prototype.setExampleKeyFrameIndex=function(e,t){if(!(e in this.examples))throw new Error("Nonexistent example UID: "+e);var n=this.examples[e].spectrogram,i=n.data.length/n.frameSize;r.D5U.assert(t>=0&&t<i&&Number.isInteger(t),(function(){return"Invalid keyFrameIndex: "+t+". Must be >= 0, < "+i+", and an integer."})),n.keyFrameIndex=t},e.prototype.size=function(){return Object.keys(this.examples).length},e.prototype.durationMillis=function(){var e=0;for(var t in this.examples){var n=this.examples[t].spectrogram,r=23.22|n.frameDurationMillis;e+=n.data.length/n.frameSize*r}return e},e.prototype.empty=function(){return 0===this.size()},e.prototype.clear=function(){this.examples={}},e.prototype.getVocabulary=function(){var e=new Set;for(var t in this.examples){var n=this.examples[t];e.add(n.label)}var r=p(e);return r.sort(),r},e.prototype.serialize=function(e){var t,n,i,s,a=this.getVocabulary();r.D5U.assert(!this.empty(),(function(){return"Cannot serialize empty Dataset"})),null!=e&&(Array.isArray(e)||(e=[e]),e.forEach((function(e){if(-1===a.indexOf(e))throw new Error('Word label "'+e+'" does not exist in the vocabulary of this dataset. The vocabulary is: '+JSON.stringify(a)+".")})));var o=[],l=[];try{for(var c=h(a),u=c.next();!u.done;u=c.next()){var d=u.value;if(null==e||-1!==e.indexOf(d)){var p=this.label2Ids[d];try{for(var f=(i=void 0,h(p)),m=f.next();!m.done;m=f.next()){var g=m.value,y=N(this.examples[g]);o.push(y.spec),l.push(y.data)}}catch(e){i={error:e}}finally{try{m&&!m.done&&(s=f.return)&&s.call(f)}finally{if(i)throw i.error}}}}}catch(e){t={error:e}}finally{try{u&&!u.done&&(n=c.return)&&n.call(c)}finally{if(t)throw t.error}}return function(e){var t=T(JSON.stringify(e.manifest)),n=T(A),r=new Uint32Array([1]),i=new Uint32Array([t.byteLength]);return S([S([n,r.buffer,i.buffer]),t,e.data])}({manifest:o,data:S(l)})},e}();function N(e){var t=null!=e.rawAudio,n={label:e.label,spectrogramNumFrames:e.spectrogram.data.length/e.spectrogram.frameSize,spectrogramFrameSize:e.spectrogram.frameSize};null!=e.spectrogram.keyFrameIndex&&(n.spectrogramKeyFrameIndex=e.spectrogram.keyFrameIndex);var r=e.spectrogram.data.buffer.slice(0);return t&&(n.rawAudioNumSamples=e.rawAudio.data.length,n.rawAudioSampleRateHz=e.rawAudio.sampleRateHz,r=S([r,e.rawAudio.data.buffer])),{spec:n,data:r}}function k(e){var t={frameSize:e.spec.spectrogramFrameSize,data:new Float32Array(e.data.slice(0,4*e.spec.spectrogramFrameSize*e.spec.spectrogramNumFrames))};null!=e.spec.spectrogramKeyFrameIndex&&(t.keyFrameIndex=e.spec.spectrogramKeyFrameIndex);var n={label:e.spec.label,spectrogram:t};return null!=e.spec.rawAudioNumSamples&&(n.rawAudio={sampleRateHz:e.spec.rawAudioSampleRateHz,data:new Float32Array(e.data.slice(4*e.spec.spectrogramFrameSize*e.spec.spectrogramNumFrames))}),n}function R(e,t,n,i){if(r.D5U.assert(Number.isInteger(e)&&e>0,(function(){return"snippetLength must be a positive integer, but got "+e})),null!=t&&r.D5U.assert(Number.isInteger(t)&&t>=0,(function(){return"focusIndex must be a non-negative integer, but got "+t})),r.D5U.assert(Number.isInteger(n)&&n>0,(function(){return"windowLength must be a positive integer, but got "+n})),r.D5U.assert(Number.isInteger(i)&&i>0,(function(){return"windowHop must be a positive integer, but got "+i})),r.D5U.assert(n<=e,(function(){return"windowLength ("+n+") exceeds snippetLength ("+e+")"})),r.D5U.assert(t<e,(function(){return"focusIndex ("+t+") equals or exceeds snippetLength ("+e+")"})),n===e)return[[0,e]];var s=[];if(null==t){for(var a=0;a+n<=e;)s.push([a,a+n]),a+=i;return s}var o=Math.floor(n/2),l=t-o;for(l<0?l=0:l+n>e&&(l=e-n);!(l-i<0||t>=l-i+n);)l-=i;for(;l+n<=e&&!(t<l);)s.push([l,l+n]),l+=i;return s}function D(e){return(0,r.lub)((function(){var t=e.data.length/e.frameSize,n=(0,r.odF)(e.data,[t,e.frameSize]);return(0,r.J69)(n,-1)}))}function L(e){return(0,r.lub)((function(){return(0,r.NqF)(D(e))}))}var F="0.5.4",P="_unknown_",O="tfjs-speech-commands-saved-model-metadata",z="indexeddb://tfjs-speech-commands-model/",B={localStorage:"undefined"==typeof window?null:window.localStorage},U=.25,$=function(){function e(t,n,i){this.MODEL_URL_PREFIX="https://storage.googleapis.com/tfjs-models/tfjs/speech-commands/v"+function(e){return e.split(".").slice(0,2).join(".")}(F)+"/browser_fft",this.SAMPLE_RATE_HZ=44100,this.FFT_SIZE=1024,this.DEFAULT_SUPPRESSION_TIME_MILLIS=0,this.streaming=!1,this.transferRecognizers={},r.D5U.assert(null==n&&null==i||null!=n&&null!=i,(function(){return"modelURL and metadataURL must be both provided or both not provided."})),null==n?(null==t?t=e.DEFAULT_VOCABULARY_NAME:r.D5U.assert(-1!==e.VALID_VOCABULARY_NAMES.indexOf(t),(function(){return"Invalid vocabulary name: '"+t+"'"})),this.vocabulary=t,this.modelArtifactsOrURL=this.MODEL_URL_PREFIX+"/"+this.vocabulary+"/model.json",this.metadataOrURL=this.MODEL_URL_PREFIX+"/"+this.vocabulary+"/metadata.json"):(r.D5U.assert(null==t,(function(){return"vocabulary name must be null or undefined when modelURL is provided"})),this.modelArtifactsOrURL=n,this.metadataOrURL=i),this.parameters={sampleRateHz:this.SAMPLE_RATE_HZ,fftSize:this.FFT_SIZE}}return e.prototype.listen=function(e,t){return c(this,void 0,void 0,(function(){var n,i,s,a,o,l=this;return u(this,(function(h){switch(h.label){case 0:if(this.streaming)throw new Error("Cannot start streaming again when streaming is ongoing.");return[4,this.ensureModelLoaded()];case 1:if(h.sent(),null==t&&(t={}),n=null==t.probabilityThreshold?0:t.probabilityThreshold,t.includeEmbedding&&(n=0),r.D5U.assert(n>=0&&n<=1,(function(){return"Invalid probabilityThreshold value: "+n})),i=null!=t.invokeCallbackOnNoiseAndUnknown&&t.invokeCallbackOnNoiseAndUnknown,t.includeEmbedding&&(i=!0),t.suppressionTimeMillis<0)throw new Error("suppressionTimeMillis is expected to be >= 0, but got "+t.suppressionTimeMillis);return s=null==t.overlapFactor?.5:t.overlapFactor,r.D5U.assert(s>=0&&s<1,(function(){return"Expected overlapFactor to be >= 0 and < 1, but got "+s})),a=function(s,a){return c(l,void 0,void 0,(function(){var a,o,l,c,h,f,m,y,v,x,b;return u(this,(function(u){switch(u.label){case 0:return a=g(s),t.includeEmbedding?[4,this.ensureModelWithEmbeddingOutputCreated()]:[3,2];case 1:return u.sent(),b=d(this.modelWithEmbeddingOutput.predict(a),2),o=b[0],l=b[1],[3,3];case 2:o=this.model.predict(a),u.label=3;case 3:return[4,o.data()];case 4:return c=u.sent(),[4,(h=o.argMax(-1)).data()];case 5:return f=u.sent()[0],m=Math.max.apply(Math,p(c)),(0,r.B90)([o,h,a]),m<n?[2,!1]:[3,6];case 6:return y=void 0,t.includeSpectrogram?(v={},[4,s.data()]):[3,8];case 7:v.data=u.sent(),v.frameSize=this.nonBatchInputShape[1],y=v,u.label=8;case 8:return x=!0,i||this.words[f]!==C&&this.words[f]!==P||(x=!1),x&&e({scores:c,spectrogram:y,embedding:l}),[2,x]}}))}))},o=null==t.suppressionTimeMillis?this.DEFAULT_SUPPRESSION_TIME_MILLIS:t.suppressionTimeMillis,this.audioDataExtractor=new x({sampleRateHz:this.parameters.sampleRateHz,numFramesPerSpectrogram:this.nonBatchInputShape[0],columnTruncateLength:this.nonBatchInputShape[1],suppressionTimeMillis:o,spectrogramCallback:a,overlapFactor:s}),[4,this.audioDataExtractor.start(t.audioTrackConstraints)];case 2:return h.sent(),this.streaming=!0,[2]}}))}))},e.prototype.ensureModelLoaded=function(){return c(this,void 0,void 0,(function(){var e,t,n,i,s=this;return u(this,(function(o){switch(o.label){case 0:return null!=this.model?[2]:[4,this.ensureMetadataLoaded()];case 1:return o.sent(),"string"!=typeof this.modelArtifactsOrURL?[3,3]:[4,(0,a.FB)(this.modelArtifactsOrURL)];case 2:return e=o.sent(),[3,5];case 3:return[4,(0,a.FB)(r.io.fromMemory(this.modelArtifactsOrURL.modelTopology,this.modelArtifactsOrURL.weightSpecs,this.modelArtifactsOrURL.weightData))];case 4:e=o.sent(),o.label=5;case 5:if(1!==e.inputs.length)throw new Error("Expected model to have 1 input, but got a model with "+e.inputs.length+" inputs");if(4!==e.inputs[0].shape.length)throw new Error("Expected model to have an input shape of rank 4, but got an input shape of rank "+e.inputs[0].shape.length);if(1!==e.inputs[0].shape[3])throw new Error("Expected model to have an input shape with 1 as the last dimension, but got input shape"+JSON.stringify(e.inputs[0].shape[3])+"}");if(2!==(t=e.outputShape).length)throw new Error("Expected loaded model to have an output shape of rank 2,but received shape "+JSON.stringify(t));if(t[1]!==this.words.length)throw new Error("Mismatch between the last dimension of model's output shape ("+t[1]+") and number of words ("+this.words.length+").");return this.model=e,this.freezeModel(),this.nonBatchInputShape=e.inputs[0].shape.slice(1),this.elementsPerExample=1,e.inputs[0].shape.slice(1).forEach((function(e){return s.elementsPerExample*=e})),this.warmUpModel(),n=this.parameters.fftSize/this.parameters.sampleRateHz*1e3,i=e.inputs[0].shape[1],this.parameters.spectrogramDurationMillis=i*n,[2]}}))}))},e.prototype.ensureModelWithEmbeddingOutputCreated=function(){return c(this,void 0,void 0,(function(){var e,t;return u(this,(function(n){switch(n.label){case 0:return null!=this.modelWithEmbeddingOutput?[2]:[4,this.ensureModelLoaded()];case 1:for(n.sent(),t=this.model.layers.length-2;t>=0;--t)if("Dense"===this.model.layers[t].getClassName()){e=this.model.layers[t];break}if(null==e)throw new Error("Failed to find second last dense layer in the original model.");return this.modelWithEmbeddingOutput=(0,a.o4)({inputs:this.model.inputs,outputs:[this.model.outputs[0],e.output]}),[2]}}))}))},e.prototype.warmUpModel=function(){var e=this;(0,r.lub)((function(){for(var t=(0,r.lls)([1].concat(e.nonBatchInputShape)),n=0;n<3;++n)e.model.predict(t)}))},e.prototype.ensureMetadataLoaded=function(){return c(this,void 0,void 0,(function(){var e,t,n;return u(this,(function(r){switch(r.label){case 0:return null!=this.words?[2]:"string"!=typeof this.metadataOrURL?[3,2]:[4,f(this.metadataOrURL)];case 1:return t=r.sent(),[3,3];case 2:t=this.metadataOrURL,r.label=3;case 3:if(null==(e=t).wordLabels){if(null==(n=e.words))throw new Error('Cannot find field "words" or "wordLabels" in metadata JSON file');this.words=n}else this.words=e.wordLabels;return[2]}}))}))},e.prototype.stopListening=function(){return c(this,void 0,void 0,(function(){return u(this,(function(e){switch(e.label){case 0:if(!this.streaming)throw new Error("Cannot stop streaming when streaming is not ongoing.");return[4,this.audioDataExtractor.stop()];case 1:return e.sent(),this.streaming=!1,[2]}}))}))},e.prototype.isListening=function(){return this.streaming},e.prototype.wordLabels=function(){return this.words},e.prototype.params=function(){return this.parameters},e.prototype.modelInputShape=function(){if(null==this.model)throw new Error("Model has not been loaded yet. Load model by calling ensureModelLoaded(), recognize(), or listen().");return this.model.inputs[0].shape},e.prototype.recognize=function(e,t){return c(this,void 0,void 0,(function(){var n,i,s,a,o,l,c,h,d,p,f,m,g;return u(this,(function(u){switch(u.label){case 0:return null==t&&(t={}),[4,this.ensureModelLoaded()];case 1:return u.sent(),null!=e?[3,3]:[4,this.recognizeOnline()];case 2:n=u.sent(),e=n.data,u.label=3;case 3:if(e instanceof r.esB)this.checkInputTensorShape(e),s=e,i=e.shape[0];else{if(e.length%this.elementsPerExample)throw new Error("The length of the input Float32Array "+e.length+" is not divisible by the number of tensor elements per per example expected by the model "+this.elementsPerExample+".");i=e.length/this.elementsPerExample,s=(0,r.yXz)(e,[i].concat(this.nonBatchInputShape))}return o={scores:null},t.includeEmbedding?[4,this.ensureModelWithEmbeddingOutputCreated()]:[3,5];case 4:return u.sent(),l=this.modelWithEmbeddingOutput.predict(s),a=l[0],o.embedding=l[1],[3,6];case 5:a=this.model.predict(s),u.label=6;case 6:return 1!==i?[3,8]:(c=o,[4,a.data()]);case 7:return c.scores=u.sent(),[3,10];case 8:return h=(0,r.HHK)(a),d=h.map((function(e){return e.data()})),p=o,[4,Promise.all(d)];case 9:p.scores=u.sent(),(0,r.B90)(h),u.label=10;case 10:return t.includeSpectrogram?(f=o,m={},e instanceof r.esB?[4,e.data()]:[3,12]):[3,14];case 11:return g=u.sent(),[3,13];case 12:g=e,u.label=13;case 13:f.spectrogram=(m.data=g,m.frameSize=this.nonBatchInputShape[1],m),u.label=14;case 14:return(0,r.B90)(a),[2,o]}}))}))},e.prototype.recognizeOnline=function(){return c(this,void 0,void 0,(function(){var e=this;return u(this,(function(t){return[2,new Promise((function(t,n){e.audioDataExtractor=new x({sampleRateHz:e.parameters.sampleRateHz,numFramesPerSpectrogram:e.nonBatchInputShape[0],columnTruncateLength:e.nonBatchInputShape[1],suppressionTimeMillis:0,spectrogramCallback:function(n){return c(e,void 0,void 0,(function(){var e,r,i;return u(this,(function(s){switch(s.label){case 0:return e=g(n),[4,this.audioDataExtractor.stop()];case 1:return s.sent(),r=t,i={},[4,e.data()];case 2:return r.apply(void 0,[(i.data=s.sent(),i.frameSize=this.nonBatchInputShape[1],i)]),e.dispose(),[2,!1]}}))}))},overlapFactor:0}),e.audioDataExtractor.start()}))]}))}))},e.prototype.createTransfer=function(e){if(null==this.model)throw new Error("Model has not been loaded yet. Load model by calling ensureModelLoaded(), recognizer(), or listen().");r.D5U.assert(null!=e&&"string"==typeof e&&e.length>1,(function(){return"Expected the name for a transfer-learning recognized to be a non-empty string, but got "+JSON.stringify(e)})),r.D5U.assert(null==this.transferRecognizers[e],(function(){return"There is already a transfer-learning model named '"+e+"'"}));var t=new V(e,this.parameters,this.model);return this.transferRecognizers[e]=t,t},e.prototype.freezeModel=function(){var e,t;try{for(var n=h(this.model.layers),r=n.next();!r.done;r=n.next())r.value.trainable=!1}catch(t){e={error:t}}finally{try{r&&!r.done&&(t=n.return)&&t.call(n)}finally{if(e)throw e.error}}},e.prototype.checkInputTensorShape=function(e){var t=this.model.inputs[0].shape.length;if(e.shape.length!==t)throw new Error("Expected input Tensor to have rank "+t+", but got rank "+e.shape.length+" that differs ");var n=e.shape.slice(1),i=this.model.inputs[0].shape.slice(1);if(!r.D5U.arraysEqual(n,i))throw new Error("Expected input to have shape [null,"+i+"], but got shape [null,"+n+"]")},e.VALID_VOCABULARY_NAMES=["18w","directional4w"],e.DEFAULT_VOCABULARY_NAME="18w",e}(),V=function(e){function t(t,n,i){var s=e.call(this)||this;return s.name=t,s.parameters=n,s.baseModel=i,r.D5U.assert(null!=t&&"string"==typeof t&&t.length>0,(function(){return"The name of a transfer model must be a non-empty string, but got "+JSON.stringify(t)})),s.nonBatchInputShape=s.baseModel.inputs[0].shape.slice(1),s.words=null,s.dataset=new I,s}return function(e,t){function n(){this.constructor=e}o(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}(t,e),t.prototype.collectExample=function(e,t){return c(this,void 0,void 0,(function(){var n,i,s,a,o=this;return u(this,(function(l){if(r.D5U.assert(!this.streaming,(function(){return"Cannot start collection of transfer-learning example because a streaming recognition or transfer-learning example collection is ongoing"})),r.D5U.assert(null!=e&&"string"==typeof e&&e.length>0,(function(){return"Must provide a non-empty string when collecting transfer-learning example"})),null==t&&(t={}),null!=t.durationMultiplier&&null!=t.durationSec)throw new Error("durationMultiplier and durationSec are mutually exclusive, but are both specified.");return null!=t.durationSec?(r.D5U.assert(t.durationSec>0,(function(){return"Expected durationSec to be > 0, but got "+t.durationSec})),i=this.parameters.fftSize/this.parameters.sampleRateHz,n=Math.ceil(t.durationSec/i)):null!=t.durationMultiplier?(r.D5U.assert(t.durationMultiplier>=1,(function(){return"Expected duration multiplier to be >= 1, but got "+t.durationMultiplier})),n=Math.round(this.nonBatchInputShape[0]*t.durationMultiplier)):n=this.nonBatchInputShape[0],null!=t.snippetDurationSec&&(r.D5U.assert(t.snippetDurationSec>0,(function(){return"snippetDurationSec is expected to be > 0, but got "+t.snippetDurationSec})),r.D5U.assert(null!=t.onSnippet,(function(){return"onSnippet must be provided if snippetDurationSec is provided."}))),null!=t.onSnippet&&r.D5U.assert(null!=t.snippetDurationSec,(function(){return"snippetDurationSec must be provided if onSnippet is provided."})),s=this.parameters.fftSize/this.parameters.sampleRateHz,a=s*n,this.streaming=!0,[2,new Promise((function(r){var i=null==t.snippetDurationSec?1:t.snippetDurationSec/a,s=1-i,l=Math.round(1/i),h=0,d=-1,p=[];o.audioDataExtractor=new x({sampleRateHz:o.parameters.sampleRateHz,numFramesPerSpectrogram:n,columnTruncateLength:o.nonBatchInputShape[1],suppressionTimeMillis:0,spectrogramCallback:function(n,i){return c(o,void 0,void 0,(function(){var s,a,o,c,f,m,v,x,b,w,_,S,T,E,A,C,I,N,k,R;return u(this,(function(u){switch(u.label){case 0:return null!=t.onSnippet?[3,7]:(s=g(n),o=(a=this.dataset).addExample,c={label:e},f={},[4,s.data()]);case 1:return c.spectrogram=(f.data=u.sent(),f.frameSize=this.nonBatchInputShape[1],f),t.includeRawAudio?(v={},[4,i.data()]):[3,3];case 2:return v.data=u.sent(),v.sampleRateHz=this.audioDataExtractor.sampleRateHz,m=v,[3,4];case 3:m=void 0,u.label=4;case 4:return o.apply(a,[(c.rawAudio=m,c)]),s.dispose(),[4,this.audioDataExtractor.stop()];case 5:return u.sent(),this.streaming=!1,this.collateTransferWords(),x=r,b={},[4,n.data()];case 6:return x.apply(void 0,[(b.data=u.sent(),b.frameSize=this.nonBatchInputShape[1],b)]),[3,13];case 7:return[4,n.data()];case 8:for(w=u.sent(),-1===d&&(d=w.length),_=d-1;0!==w[_]&&_>=0;)_--;return S=d-_-1,d=_+1,T=w.slice(w.length-S,w.length),p.push(T),null!=t.onSnippet&&t.onSnippet({data:T,frameSize:this.nonBatchInputShape[1]}),h++!==l?[3,13]:[4,this.audioDataExtractor.stop()];case 9:return u.sent(),this.streaming=!1,this.collateTransferWords(),E=y(M(p)),A={data:E,frameSize:this.nonBatchInputShape[1]},I=(C=this.dataset).addExample,N={label:e,spectrogram:A},t.includeRawAudio?(R={},[4,i.data()]):[3,11];case 10:return R.data=u.sent(),R.sampleRateHz=this.audioDataExtractor.sampleRateHz,k=R,[3,12];case 11:k=void 0,u.label=12;case 12:I.apply(C,[(N.rawAudio=k,N)]),r(A),u.label=13;case 13:return[2,!1]}}))}))},overlapFactor:s,includeRawAudio:t.includeRawAudio}),o.audioDataExtractor.start(t.audioTrackConstraints)}))]}))}))},t.prototype.clearExamples=function(){var e=this;r.D5U.assert(null!=this.words&&this.words.length>0&&!this.dataset.empty(),(function(){return"No transfer learning examples exist for model name "+e.name})),this.dataset.clear(),this.words=null},t.prototype.countExamples=function(){if(this.dataset.empty())throw new Error("No examples have been collected for transfer-learning model named '"+this.name+"' yet.");return this.dataset.getExampleCounts()},t.prototype.getExamples=function(e){return this.dataset.getExamples(e)},t.prototype.setExampleKeyFrameIndex=function(e,t){this.dataset.setExampleKeyFrameIndex(e,t)},t.prototype.removeExample=function(e){this.dataset.removeExample(e),this.collateTransferWords()},t.prototype.isDatasetEmpty=function(){return this.dataset.empty()},t.prototype.loadExamples=function(e,t){var n,r,i,s;void 0===t&&(t=!1);var a=new I(e);t&&this.clearExamples();var o=a.getVocabulary();try{for(var l=h(o),c=l.next();!c.done;c=l.next()){var u=c.value,d=a.getExamples(u);try{for(var p=(i=void 0,h(d)),f=p.next();!f.done;f=p.next()){var m=f.value;this.dataset.addExample(m.example)}}catch(e){i={error:e}}finally{try{f&&!f.done&&(s=p.return)&&s.call(p)}finally{if(i)throw i.error}}}}catch(e){n={error:e}}finally{try{c&&!c.done&&(r=l.return)&&r.call(l)}finally{if(n)throw n.error}}this.collateTransferWords()},t.prototype.serializeExamples=function(e){return this.dataset.serialize(e)},t.prototype.collateTransferWords=function(){this.words=this.dataset.getVocabulary()},t.prototype.collectTransferDataAsTensors=function(e,t){var n=this.nonBatchInputShape[0];e=e||U;var r=Math.round(e*n),i=this.dataset.getData(null,l({numFrames:n,hopFrames:r},t));return{xs:i.xs,ys:i.ys}},t.prototype.collectTransferDataAsTfDataset=function(e,t,n,r){void 0===t&&(t=.15),void 0===n&&(n=32);var i=this.nonBatchInputShape[0];e=e||U;var s=Math.round(e*i);return this.dataset.getData(null,l({numFrames:i,hopFrames:s,getDataset:!0,datasetBatchSize:n,datasetValidationSplit:t},r))},t.prototype.train=function(e){return c(this,void 0,void 0,(function(){var t,n=this;return u(this,(function(i){return r.D5U.assert(null!=this.words&&this.words.length>0,(function(){return"Cannot train transfer-learning model '"+n.name+"' because no transfer learning example has been collected."})),r.D5U.assert(this.words.length>1,(function(){return"Cannot train transfer-learning model '"+n.name+"' because only 1 word label ('"+JSON.stringify(n.words)+"') has been collected for transfer learning. Requires at least 2."})),null!=e.fineTuningEpochs&&r.D5U.assert(e.fineTuningEpochs>=0&&Number.isInteger(e.fineTuningEpochs),(function(){return"If specified, fineTuningEpochs must be a non-negative integer, but received "+e.fineTuningEpochs})),null==e&&(e={}),null==this.model&&this.createTransferModelFromBaseModel(),this.secondLastBaseDenseLayer.trainable=!1,this.model.compile({loss:"categoricalCrossentropy",optimizer:e.optimizer||"sgd",metrics:["acc"]}),t=null==e.fitDatasetDurationMillisThreshold?6e4:e.fitDatasetDurationMillisThreshold,this.dataset.durationMillis()>t?(console.log("Detected large dataset: total duration = "+this.dataset.durationMillis()+" ms > "+t+" ms. Training transfer model using fitDataset() instead of fit()"),[2,this.trainOnDataset(e)]):[2,this.trainOnTensors(e)]}))}))},t.prototype.trainOnDataset=function(e){return c(this,void 0,void 0,(function(){var t,n,i,s,a,o,l,c,h;return u(this,(function(u){switch(u.label){case 0:return r.D5U.assert(e.epochs>0,(function(){return"Invalid config.epochs"})),t=null==e.batchSize?32:e.batchSize,n=e.windowHopRatio||U,i=d(this.collectTransferDataAsTfDataset(n,e.validationSplit,t,{augmentByMixingNoiseRatio:e.augmentByMixingNoiseRatio}),2),s=i[0],a=i[1],o=r.D5U.now(),[4,this.model.fitDataset(s,{epochs:e.epochs,validationData:e.validationSplit>0?a:null,callbacks:null==e.callback?null:[e.callback]})];case 1:return l=u.sent(),console.log("fitDataset() took "+(r.D5U.now()-o).toFixed(2)+" ms"),null!=e.fineTuningEpochs&&e.fineTuningEpochs>0?(c=r.D5U.now(),[4,this.fineTuningUsingTfDatasets(e,s,a)]):[3,3];case 2:return h=u.sent(),console.log("fitDataset() (fine-tuning) took "+(r.D5U.now()-c).toFixed(2)+" ms"),[2,[l,h]];case 3:return[2,l]}}))}))},t.prototype.trainOnTensors=function(e){return c(this,void 0,void 0,(function(){var t,n,i,s,a,o,l,c,h,d;return u(this,(function(u){switch(u.label){case 0:t=e.windowHopRatio||U,n=this.collectTransferDataAsTensors(t,{augmentByMixingNoiseRatio:e.augmentByMixingNoiseRatio}),i=n.xs,s=n.ys,console.log("Training data: xs.shape = "+i.shape+", ys.shape = "+s.shape),u.label=1;case 1:return u.trys.push([1,,6,7]),null!=e.validationSplit?(c=function(e,t,n){return r.D5U.assert(n>0&&n<1,(function(){return"validationSplit is expected to be >0 and <1, but got "+n})),(0,r.lub)((function(){for(var i=(0,r.NqF)(t,-1).dataSync(),s=[],a=0;a<i.length;++a){var o=i[a];null==s[o]&&(s[o]=[]),s[o].push(a)}var l=s.length,c=[],u=[];for(s.map((function(e){return r.D5U.shuffle(e)})),a=0;a<l;++a)for(var h=s[a],d=Math.round(h.length*(1-n)),p=0;p<h.length;++p)p<d?c.push(h[p]):u.push(h[p]);return{trainXs:(0,r.Iqj)(e,c),trainYs:(0,r.Iqj)(t,c),valXs:(0,r.Iqj)(e,u),valYs:(0,r.Iqj)(t,u)}}))}(i,s,e.validationSplit),a=c.trainXs,o=c.trainYs,l=[c.valXs,c.valYs]):(a=i,o=s),[4,this.model.fit(a,o,{epochs:null==e.epochs?20:e.epochs,validationData:l,batchSize:e.batchSize,callbacks:null==e.callback?null:[e.callback]})];case 2:return h=u.sent(),null!=e.fineTuningEpochs&&e.fineTuningEpochs>0?[4,this.fineTuningUsingTensors(e,a,o,l)]:[3,4];case 3:return d=u.sent(),[2,[h,d]];case 4:return[2,h];case 5:return[3,7];case 6:return(0,r.B90)([i,s,a,o,l]),[7];case 7:return[2]}}))}))},t.prototype.fineTuningUsingTfDatasets=function(e,t,n){return c(this,void 0,void 0,(function(){var r,i,s;return u(this,(function(a){switch(a.label){case 0:return r=this.secondLastBaseDenseLayer.trainable,this.secondLastBaseDenseLayer.trainable=!0,i=null==e.fineTuningOptimizer?"sgd":e.fineTuningOptimizer,this.model.compile({loss:"categoricalCrossentropy",optimizer:i,metrics:["acc"]}),[4,this.model.fitDataset(t,{epochs:e.fineTuningEpochs,validationData:n,callbacks:null==e.callback?null:[e.callback]})];case 1:return s=a.sent(),this.secondLastBaseDenseLayer.trainable=r,[2,s]}}))}))},t.prototype.fineTuningUsingTensors=function(e,t,n,r){return c(this,void 0,void 0,(function(){var i,s,a;return u(this,(function(o){switch(o.label){case 0:return i=this.secondLastBaseDenseLayer.trainable,this.secondLastBaseDenseLayer.trainable=!0,s=null==e.fineTuningOptimizer?"sgd":e.fineTuningOptimizer,this.model.compile({loss:"categoricalCrossentropy",optimizer:s,metrics:["acc"]}),[4,this.model.fit(t,n,{epochs:e.fineTuningEpochs,validationData:r,batchSize:e.batchSize,callbacks:null==e.fineTuningCallback?null:[e.fineTuningCallback]})];case 1:return a=o.sent(),this.secondLastBaseDenseLayer.trainable=i,[2,a]}}))}))},t.prototype.evaluate=function(e){return c(this,void 0,void 0,(function(){var t=this;return u(this,(function(n){return r.D5U.assert(null!=e.wordProbThresholds&&e.wordProbThresholds.length>0,(function(){return"Received null or empty wordProbThresholds"})),r.D5U.assert(this.words[0]===C,(function(){return"Cannot perform evaluation when the first tag is not "+C})),[2,(0,r.lub)((function(){for(var n=[],i=0,s=t.collectTransferDataAsTensors(e.windowHopRatio),a=s.xs,o=s.ys.argMax(-1).dataSync(),l=t.model.predict(a),c=(0,r.Fp7)((0,r.tPi)(l,[0,1],[l.shape[0],l.shape[1]-1]),-1),u=l.shape[0],h=0;h<e.wordProbThresholds.length;++h){for(var d=e.wordProbThresholds[h],p=c.greater((0,r.iD$)(d)).dataSync(),f=0,m=0,g=0,y=0,v=0;v<u;++v)0===o[v]?(f++,p[v]&&g++):(m++,p[v]&&y++);var x=g/f,b=y/m;n.push({probThreshold:d,fpr:x,tpr:b}),console.log("ROC thresh="+d+": fpr="+x.toFixed(4)+", tpr="+b.toFixed(4)),h>0&&(i+=Math.abs(n[h-1].fpr-n[h].fpr)*(n[h-1].tpr+n[h].tpr)/2)}return{rocCurve:n,auc:i}}))]}))}))},t.prototype.createTransferModelFromBaseModel=function(){var e=this;r.D5U.assert(null!=this.words,(function(){return"No word example is available for tranfer-learning model of name "+e.name}));for(var t=this.baseModel.layers,n=t.length-2;n>=0&&"dense"!==t[n].getClassName().toLowerCase();)n--;if(n<0)throw new Error("Cannot find a hidden dense layer in the base model.");this.secondLastBaseDenseLayer=t[n];var i=this.secondLastBaseDenseLayer.output;this.transferHead=(0,a.Pe)(),this.transferHead.add(a.ug.dense({units:this.words.length,activation:"softmax",inputShape:i.shape.slice(1),name:"NewHeadDense"}));var s=this.transferHead.apply(i);this.model=(0,a.o4)({inputs:this.baseModel.inputs,outputs:s})},t.prototype.modelInputShape=function(){return this.baseModel.inputs[0].shape},t.prototype.getMetadata=function(){return{tfjsSpeechCommandsVersion:F,modelName:this.name,timeStamp:(new Date).toISOString(),wordLabels:this.wordLabels()}},t.prototype.save=function(e){return c(this,void 0,void 0,(function(){var t,n,r;return u(this,(function(i){return t=null!=e,e=e||W(this.name),t||(n=B.localStorage.getItem(O),(r=null==n?{}:JSON.parse(n))[this.name]=this.getMetadata(),B.localStorage.setItem(O,JSON.stringify(r))),console.log("Saving model to "+e),[2,this.model.save(e)]}))}))},t.prototype.load=function(e){return c(this,void 0,void 0,(function(){var t,n,r;return u(this,(function(i){switch(i.label){case 0:if(t=null!=e,e=e||W(this.name),!t){if(null==(n=JSON.parse(B.localStorage.getItem(O)))||null==n[this.name])throw new Error("Cannot find metadata for transfer model named "+this.name+'"');this.words=n[this.name].wordLabels,console.log("Loaded word list for model named "+this.name+": "+this.words)}return r=this,[4,(0,a.FB)(e)];case 1:return r.model=i.sent(),console.log("Loaded model from "+e+":"),this.model.summary(),[2]}}))}))},t.prototype.createTransfer=function(e){throw new Error("Creating transfer-learned recognizer from a transfer-learned recognizer is not supported.")},t}($);function W(e){return""+z+e}function G(){return c(this,void 0,void 0,(function(){var e,t,n;return u(this,(function(i){switch(i.label){case 0:return[4,r.io.listModels()];case 1:for(n in e=i.sent(),t=[],e)n.startsWith(z)&&t.push(n.slice(z.length));return[2,t]}}))}))}function H(e){return c(this,void 0,void 0,(function(){var t;return u(this,(function(n){switch(n.label){case 0:return null==(t=JSON.parse(B.localStorage.getItem(O)))&&(t={}),null!=t[e]&&delete t[e],B.localStorage.setItem(O,JSON.stringify(t)),[4,r.io.removeModel(W(e))];case 1:return n.sent(),[2]}}))}))}function j(e,t,n,i){if(r.D5U.assert(null==n&&null==i||null!=n&&null!=i,(function(){return"customModelURL and customMetadataURL must be both provided or both not provided."})),null!=n&&r.D5U.assert(null==t,(function(){return"vocabulary name must be null or undefined when modelURL is provided."})),"BROWSER_FFT"===e)return new $(t,n,i);throw"SOFT_FFT"===e?new Error("SOFT_FFT SpeechCommandRecognizer has not been implemented yet."):new Error("Invalid fftType: '"+e+"'")}var q={concatenateFloat32Arrays:M,normalizeFloat32Array:y,normalize:g,playRawAudio:function(e,t){var n=new(window.AudioContext||window.webkitAudioContext),r=n.createBuffer(1,e.data.length,e.sampleRateHz);r.getChannelData(0).set(e.data);var i=n.createBufferSource();i.buffer=r,i.connect(n.destination),i.start(),i.onended=function(){null!=t&&t()}}}},2948:(e,t,n)=>{var r=n(2140),i=n(9980),s=n(1730),a=n(1133),o=n(4026),l=n(865),c=n(8721);c.alea=r,c.xor128=i,c.xorwow=s,c.xorshift7=a,c.xor4096=o,c.tychei=l,e.exports=c},2140:function(e,t,n){var r;!function(e,i,s){function a(e){var t,n=this,r=(t=4022871197,function(e){e=e.toString();for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function o(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function l(e,t){var n=new a(e),r=t&&t.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,r&&("object"==typeof r&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.alea=l}(0,e=n.nmd(e),n.amdD)},865:function(e,t,n){var r;!function(e,i,s){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,i=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^i,i=i-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^i,t.a=i-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function o(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function l(e,t){var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.tychei=l}(0,e=n.nmd(e),n.amdD)},9980:function(e,t,n){var r;!function(e,i,s){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function o(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function l(e,t){var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.xor128=l}(0,e=n.nmd(e),n.amdD)},4026:function(e,t,n){var r;!function(e,i,s){function a(e){var t=this;t.next=function(){var e,n,r=t.w,i=t.X,s=t.i;return t.w=r=r+1640531527|0,n=i[s+34&127],e=i[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=i[s]=n^e,t.i=s,n+(r^r>>>16)|0},function(e,t){var n,r,i,s,a,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),i=0,s=-32;s<l;++s)t&&(r^=t.charCodeAt((s+32)%t.length)),0===s&&(a=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(a=a+1640531527|0,i=0==(n=o[127&s]^=r+a)?i+1:0);for(i>=128&&(o[127&(t&&t.length||0)]=-1),i=127,s=512;s>0;--s)r=o[i+34&127],n=o[i=i+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[i]=r^n;e.w=a,e.X=o,e.i=i}(t,e)}function o(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function l(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,r&&(r.X&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.xor4096=l}(0,e=n.nmd(e),n.amdD)},1133:function(e,t,n){var r;!function(e,i,s){function a(e){var t=this;t.next=function(){var e,n,r=t.x,i=t.i;return e=r[i],n=(e^=e>>>7)^e<<24,n^=(e=r[i+1&7])^e>>>10,n^=(e=r[i+3&7])^e>>>3,n^=(e=r[i+4&7])^e<<7,e=r[i+7&7],n^=(e^=e<<13)^e<<9,r[i]=n,t.i=i+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function o(e,t){return t.x=e.x.slice(),t.i=e.i,t}function l(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,r&&(r.x&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.xorshift7=l}(0,e=n.nmd(e),n.amdD)},1730:function(e,t,n){var r;!function(e,i,s){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function o(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function l(e,t){var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.xorwow=l}(0,e=n.nmd(e),n.amdD)},8721:(e,t,n)=>{var r;!function(i,s){var a,o=this,l=256,c=s.pow(l,6),u=s.pow(2,52),h=2*u,d=255;function p(e,t,n){var r=[],d=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,v(i)]:null==e?function(){try{var e;return a&&(e=a.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),v(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,v(i)]}}():e,3),r),p=new f(r),x=function(){for(var e=p.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=p.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|p.g(4)},x.quick=function(){return p.g(4)/4294967296},x.double=x,y(v(p.S),i),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(s.random=e,t):e})(x,d,"global"in t?t.global:this==s,t.state)}function f(e){var t,n=e.length,r=this,i=0,s=r.i=r.j=0,a=r.S=[];for(n||(e=[n++]);i<l;)a[i]=i++;for(i=0;i<l;i++)a[i]=a[s=d&s+e[i%n]+(t=a[i])],a[s]=t;(r.g=function(e){for(var t,n=0,i=r.i,s=r.j,a=r.S;e--;)t=a[i=d&i+1],n=n*l+a[d&(a[i]=a[s=d&s+t])+(a[s]=t)];return r.i=i,r.j=s,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],i=typeof e;if(t&&"object"==i)for(n in e)try{r.push(g(e[n],t-1))}catch(e){}return r.length?r:"string"==i?e:e+"\0"}function y(e,t){for(var n,r=e+"",i=0;i<r.length;)t[d&i]=d&(n^=19*t[d&i])+r.charCodeAt(i++);return v(t)}function v(e){return String.fromCharCode.apply(0,e)}if(s.seedrandom=p,y(s.random(),i),e.exports){e.exports=p;try{a=n(914)}catch(e){}}else void 0===(r=function(){return p}.call(t,n,t,e))||(e.exports=r)}([],Math)},8713:(e,t,n)=>{"use strict";n.d(t,{JL:()=>r,Zu:()=>i});class r{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class i{refCount(e){return s("refCount")}incRef(e){return s("incRef")}timerAvailable(){return!0}time(e){return s("time")}read(e){return s("read")}readSync(e){return s("readSync")}readToGPU(e,t){return s("readToGPU")}numDataIds(){return s("numDataIds")}disposeData(e,t){return s("disposeData")}write(e,t,n){return s("write")}move(e,t,n,r,i){return s("move")}memory(){return s("memory")}floatPrecision(){return s("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return s("dispose")}}function s(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},3337:(e,t,n)=>{"use strict";function r(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,i=e.length,s=0,a=!1;for(;r<i;){s=r+(i-r>>>1);const o=n(t,e[s]);o>0?r=s+1:(i=s,a=!o)}return a?r:-r-1}(e,t,n||i)}(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function i(e,t){return e>t?1:e<t?-1:0}function s(e,t,n,r,i){return l(e,t,n,r,i,0)}function a(e,t,n,r,i,s){return l(e,t,n,r,i,0,!1,s,!0)}function o(e,t,n,r,i,s){return l(e,t,n,r,i,s,!0)}function l(e,t,n,i,s,a,o=!1,l=!1,d=!1){const p=[];for(let e=0;e<t.length;e++)t[e]>s&&p.push({score:t[e],boxIndex:e,suppressBeginIndex:0});p.sort(h);const f=a>0?-.5/a:0,m=[],g=[];for(;m.length<n&&p.length>0;){const t=p.pop(),{score:n,boxIndex:a,suppressBeginIndex:o}=t;if(n<s)break;let l=!1;for(let n=m.length-1;n>=o;--n){const r=c(e,a,m[n]);if(r>=i){l=!0;break}if(t.score=t.score*u(i,f,r),t.score<=s)break}t.suppressBeginIndex=m.length,l||(t.score===n?(m.push(a),g.push(t.score)):t.score>s&&r(p,t,h))}const y=m.length,v=n-y;l&&v>0&&(m.push(...new Array(v).fill(0)),g.push(...new Array(v).fill(0)));const x={selectedIndices:m};return o&&(x.selectedScores=g),d&&(x.validOutputs=y),x}function c(e,t,n){const r=e.subarray(4*t,4*t+4),i=e.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),a=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(i[0],i[2]),u=Math.min(i[1],i[3]),h=Math.max(i[0],i[2]),d=Math.max(i[1],i[3]),p=(o-s)*(l-a),f=(h-c)*(d-u);if(p<=0||f<=0)return 0;const m=Math.max(s,c),g=Math.max(a,u),y=Math.min(o,h),v=Math.min(l,d),x=Math.max(y-m,0)*Math.max(v-g,0);return x/(p+f-x)}function u(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function h(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}n.d(t,{GP:()=>s,qP:()=>a,pA:()=>o})},8333:(e,t,n)=>{"use strict";n.d(t,{Z:()=>i});var r=n(2657);function i(e,t){const n=[];for(let e=0;e<t.length;e++)t[e]&&n.push(e);const i=(0,r.f)(e,"int32"),s=(0,r.f)([n.length,e.length],"int32");for(let t=0;t<n.length;t++){const r=i.indexToLoc(n[t]),a=t*e.length;s.values.set(r,a)}return s.toTensor()}},7097:(e,t,n)=>{"use strict";n.d(t,{BV:()=>b,wv:()=>x});var r=n(8713),i=n(2885),s=n(5938),a=n(9121),o=n(6151),l=n(4706),c=n(9122),u=n(9115);class h{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new p)}profileKernel(e,t,n){let r;const s=()=>{r=n()};let a;const o=c.now();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(const e of r)e.dataSync();a=Promise.resolve({kernelMs:c.now()-o})}if((0,i.OB)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<r.length;t++){const n=r[t];n.data().then((t=>{d(t,n.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:i,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),r,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],i,n[2])}))}))}}function d(e,t,n){if("float32"!==t)return!1;for(let t=0;t<e.length;t++){const r=e[t];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class p{logKernelProfile(e,t,n,r,i,s){const a="number"==typeof r?u.oj(`${r}ms`,9):r.error,o=u.oj(e,25),l=t.rank,c=t.size,h=u.oj(t.shape.toString(),14);let d="";for(const e in i){const n=i[e];if(null!=n){const r=n.shape||t.shape,i=r.length;d+=`${e}: ${i}D ${i>0?r:""} `}}console.log(`%c${o}\t%c${a}\t%c${l}D ${h}\t%c${c}\t%c${d}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}var f=n(4077),m=n(747);function g(e){return null!=e.kernelName}class y{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class v{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new y}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(l.Z(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new h(this.backendInstance),!0}setupRegisteredKernels(){(0,o.tr)(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){(0,o.tr)(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof r.Zu||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId||(this.registry[e]=n,this.pendingBackendInit=null,0)))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,l.Z(`Initialization of backend ${e} failed`),l.Z(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(t){return l.Z(`Initialization of backend ${e} failed`),l.Z(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:i}=this.initializeBackend(n);if(i||r)return{name:n,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,i=this.readSync(t),s=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,i,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return v.nextTensorId++}nextVariableId(){return v.nextVariableId++}clone(e){const t=b.runKernel(a.iJ,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e};return b.runKernel(a.RF,t,{dtype:"float32"})}})),[],{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,null==(0,o.pI)(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let i=0;n.forEach((e=>{i+="complex64"===e.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-t-i-s;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),i=this.state.numBytes,s=this.state.numTensors;let a,l;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const c=g(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(g(e)){const{kernelName:t,inputs:i,attrs:s}=e;null==this.backendName&&this.backend;const c=(0,o.pI)(t,this.backendName);u.hu(null!=c,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),a=()=>{const e=this.backend.numDataIds();l=c.kernelFunc({inputs:i,attrs:s,backend:this.backend});const a=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,a);const o=a.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,i,o);n=this.saveTensorsForBackwardMode(e)}return o}}else{const{forwardFunc:t}=e,i=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};a=()=>{const e=this.backend.numDataIds();l=this.tidy((()=>t(this.backend,i)));const n=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,e,n),n}}const{inputs:h,attrs:d}=e,p=g(e)?null:e.backwardsFunc;let f;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(f=this.profiler.profileKernel(c,h,(()=>a())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),t=f.outputs):t=a()})),r&&this.addTapeNode(c,h,t,p,n,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map((e=>null!=h[e]?h[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map((e=>this.keep(this.clone(e))));return t}getTensorsForGradient(e,t,n){const r=(0,o.uk)(e);if(null!=r){const e=r.inputsToSave||[],i=r.outputsToSave||[];let s;r.saveAllInputs?(u.hu(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(t).map((e=>t[e]))):s=e.map((e=>t[e]));const a=n.filter(((e,t)=>i[t]));return s.concat(a)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let i=e;"string"===n&&u.HD(e[0])&&(i=e.map((e=>c.encodeString(e))));const s=r.write(i,t,n),a=new f.es(t,n,s,this.nextTensorId());if(this.trackTensor(a,r),"string"===n){const e=this.state.tensorInfo.get(s),t=(0,u.Ub)(i);this.state.numBytes+=t-e.bytes,e.bytes=t}return a}makeTensorFromDataId(e,t,n,r){const i={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:i}=e,s=new f.es(r,i,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const i=new f._w(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[i.name])throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*u.bT(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof f._w||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*u.bT(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const e of this.state.activeProfile.kernels)e.kernelTimeMs=await e.kernelTimeMs,e.extraInfo=await e.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,i,s){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:i},l=(0,o.uk)(e);null!=l&&(r=l.gradFunc),null!=r&&(a.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=u.wT(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],i,s))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=(0,m.getTensorsInContainer)(e),n=new Set(t.map((e=>e.id)));for(let e=0;e<this.state.activeScope.track.length;e++){const t=this.state.activeScope.track[e];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n,r=!1){if(u.hu(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const i=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));u.hu(i instanceof f.es,(()=>"The result y returned by f() must be a tensor."));const s=function(e,t,n){const r={},i={};for(let e=0;e<t.length;e++)r[t[e].id]=!0;for(let n=0;n<e.length;n++){const s=e[n],a=s.inputs;for(const e in a){const n=a[e];let o=!1;for(let e=0;e<t.length;e++)if(r[n.id]){s.outputs.forEach((e=>r[e.id]=!0)),o=!0,i[s.id]=!0;break}if(o)break}}const s={};s[n.id]=!0;const a={};for(let t=e.length-1;t>=0;t--){const n=e[t],r=n.inputs;for(let e=0;e<n.outputs.length;e++)if(s[n.outputs[e].id]){for(const e in r)s[r[e].id]=!0,a[n.id]=!0;break}}const o=[];for(let t=0;t<e.length;t++){const n=e[t];if(i[n.id]&&a[n.id]){const e={};for(const t in n.inputs){const i=n.inputs[t];r[i.id]&&(e[t]=i)}const t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,o.push(t)}}return o}(this.state.activeTape,t,i);if(!r&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[i.id]=null==n?function(e){const t=(0,u.p8)((0,u.NA)(e),"float32");return b.makeTensor(t,e,"float32")}(i.shape):n,function(e,t,n,r){for(let i=t.length-1;i>=0;i--){const s=t[i],a=[];if(s.outputs.forEach((t=>{const n=e[t.id];null!=n?a.push(n):a.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const o=s.gradient(a);for(const t in s.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const i=n((()=>o[t]()));if("float32"!==i.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${i.dtype}'`);const a=s.inputs[t];if(!u.cO(i.shape,a.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${t}' has shape '${i.shape}', which does not match the shape of the input '${a.shape}'`);if(null==e[a.id])e[a.id]=i;else{const t=e[a.id];e[a.id]=r(t,i),t.dispose()}}}}(e,s,(e=>this.tidy(e)),w);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:i,grads:r}}))}customGrad(e){return u.hu(u.mf(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{let n;u.hu(t.every((e=>e instanceof f.es)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};return t.forEach(((e,t)=>{r[t]=e})),this.runKernelFunc({forwardFunc:(r,i)=>(n=e(...t,i),u.hu(n.value instanceof f.es,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),u.hu(u.mf(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(e,r)=>{const i=n.gradFunc(e,r),s=Array.isArray(i)?i:[i];u.hu(s.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),u.hu(s.every((e=>e instanceof f.es)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const a={};return s.forEach(((e,t)=>{a[t]=()=>e})),a},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=(0,c.now)(),n=await this.backend.time(e);return n.wallMs=(0,c.now)()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new y;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function x(){const e=(0,s.D)();if(null==e._tfengine){const t=new i.qA(e);e._tfengine=new v(t)}return(0,i.iG)(e._tfengine.ENV),(0,f.Vi)((()=>e._tfengine)),e._tfengine}v.nextTensorId=0,v.nextVariableId=0;const b=x();function w(e,t){const n={a:e,b:t};return b.runKernel(a.mm,n)}},2885:(e,t,n)=>{"use strict";n.d(t,{OB:()=>a,Vi:()=>o,iG:()=>l,qA:()=>i});var r=n(9115);class i{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=s,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(a().getBool("IS_TEST")||a().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];a().getBool("IS_TEST")||a().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if((0,r.tI)(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);"tfjsflags"in e&&e.tfjsflags.split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}(t,n)}))}}function s(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("=")))),t}function a(){return o}let o=null;function l(e){o=e}},5938:(e,t,n)=>{"use strict";n.d(t,{D:()=>s,R:()=>a});var r=n(4155);let i;function s(){if(null==i){let e;if("undefined"!=typeof window)e=window;else if(void 0!==n.g)e=n.g;else if(void 0!==r)e=r;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}i=e}return i}function a(e,t){const n=function(){const e=s();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}},4368:(e,t,n)=>{"use strict";n.d(t,{B9:()=>g,CQ:()=>x,Cd:()=>b,Cn:()=>y,G4:()=>o,MX:()=>u,N5:()=>f,N8:()=>h,N_:()=>w,R:()=>l,SR:()=>d,VY:()=>A,XV:()=>v,cF:()=>c,cj:()=>_,jq:()=>T,lu:()=>m,sq:()=>p,x3:()=>S,y3:()=>E,ze:()=>M});var r=n(7097),i=n(2885),s=n(4077),a=n(747);function o(){(0,i.OB)().set("PROD",!0)}function l(){(0,i.OB)().set("DEBUG",!0)}function c(){(0,i.OB)().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function u(e){(0,i.OB)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function h(){r.BV.disposeVariables()}function d(){return r.BV}function p(){return r.BV.memory()}function f(e){return r.BV.profile(e)}function m(e,t){return r.BV.tidy(e,t)}function g(e){(0,a.getTensorsInContainer)(e).forEach((e=>e.dispose()))}function y(e){return r.BV.keep(e)}function v(e){return r.BV.time(e)}function x(e){return r.BV.setBackend(e)}function b(){return r.BV.ready()}function w(){return r.BV.backendName}function _(e){r.BV.removeBackend(e)}function S(e){return r.BV.findBackend(e)}function M(e){return r.BV.findBackendFactory(e)}function T(e,t,n=1){return r.BV.registerBackend(e,t,n)}function E(){return r.BV.backend}function A(e,t){(0,i.OB)().setPlatform(e,t)}(0,s.FZ)(u)},633:(e,t,n)=>{"use strict";n.d(t,{UQ:()=>o,cb:()=>d,fN:()=>u,h7:()=>c,pn:()=>h,ti:()=>l});var r=n(7097),i=n(4077),s=n(3740),a=n(9115);function o(e){return a.hu(a.mf(e),(()=>"The f passed in grad(f) must be a function")),(t,n)=>{const i=(0,s._1)(t,"x","tf.grad","string_or_numeric"),o=null!=n?(0,s._1)(n,"dy","tf.grad"):null;return r.BV.tidy((()=>{const{value:t,grads:n}=r.BV.gradients((()=>e(i)),[i],o);return null!=o&&a.k5(t.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),p(n),n[0]}))}}function l(e){return a.hu(a.mf(e),(()=>"The f passed in grads(f) must be a function")),(t,n)=>{a.hu(Array.isArray(t),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));const i=(0,s.sI)(t,"args","tf.grads","string_or_numeric"),o=null!=n?(0,s._1)(n,"dy","tf.grads"):null;return r.BV.tidy((()=>{const{value:t,grads:n}=r.BV.gradients((()=>e(...i)),i,o);return null!=o&&a.k5(t.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),p(n),n}))}}function c(e){return a.hu(a.mf(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(t,n)=>{a.hu(t instanceof i.es,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),a.hu(null==n||n instanceof i.es,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));const{grads:s,value:o}=r.BV.gradients((()=>e(t)),[t],n);return p(s),{grad:s[0],value:o}}}function u(e){return a.hu(a.mf(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(t,n)=>{a.hu(Array.isArray(t)&&t.every((e=>e instanceof i.es)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),a.hu(null==n||n instanceof i.es,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));const s=r.BV.gradients((()=>e(...t)),t,n);return null!=n&&a.k5(s.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),p(s.grads),s}}function h(e,t){a.hu(a.mf(e),(()=>"The f passed in variableGrads(f) must be a function")),a.hu(null==t||Array.isArray(t)&&t.every((e=>e instanceof i._w)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in r.BV.registeredVariables)t.push(r.BV.registeredVariables[e])}const s=n?t.filter((e=>!e.trainable)):null,o=t.length;t=t.filter((e=>e.trainable)),a.hu(t.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`));const{value:l,grads:c}=r.BV.gradients(e,t,null,!0);a.hu(c.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),a.hu(0===l.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${l.rank} tensor`));const u={};return t.forEach(((e,t)=>{null!=c[t]&&(u[e.name]=c[t])})),null!=s&&s.forEach((e=>u[e.name]=null)),{value:l,grads:u}}function d(e){return r.BV.customGrad(e)}function p(e){if(e.filter((e=>null==e)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}},1740:(e,t,n)=>{"use strict";n.d(t,{SYM:()=>Je.SY,VGw:()=>Je.VG,SpW:()=>Je.Sp,zJI:()=>Pt,HeW:()=>zt,a4z:()=>$t,DBS:()=>Gt,mm_:()=>Je.mm,Xze:()=>Je.Xz,oT6:()=>Je.oT,IKK:()=>Je.IK,sJF:()=>Je.sJ,aJk:()=>Je.aJ,M2y:()=>Je.M2,qw7:()=>Je.qw,jMg:()=>Je.jM,QCc:()=>Je.QC,Oyi:()=>Je.Oy,JhU:()=>Je.Jh,_k9:()=>Je._k,IMb:()=>Je.IM,ROF:()=>Je.RO,XLW:()=>Je.XL,zws:()=>Je.zw,zvY:()=>Je.zv,eEB:()=>Je.eE,Ly9:()=>Je.Ly,RFZ:()=>Je.RF,gJX:()=>Je.gJ,xnO:()=>Je.xn,Zz9:()=>Je.Zz,yj2:()=>Je.yj,Eh3:()=>Je.Eh,mhS:()=>Je.mh,wUP:()=>Je.wU,wm:()=>Je.wm,x12:()=>Je.x1,o2y:()=>Je.o2,ik2:()=>Je.ik,mc4:()=>Je.mc,TR1:()=>Je.TR,VcC:()=>Je.Vc,Byc:()=>Je.By,iHb:()=>Je.iH,JLz:()=>ir.JL,QRR:()=>Je.QR,T0n:()=>Je.T0,cie:()=>Je.ci,sL$:()=>Je.sL,y7R:()=>Je.y7,$w:()=>Je.$w,p4S:()=>Je.p4,Vn9:()=>Je.Vn,ekb:()=>Je.ek,ViN:()=>v.Vi,$g6:()=>Je.$g,SX0:()=>Je.SX,HEU:()=>Je.HE,qAh:()=>v.qA,hdR:()=>Je.hd,Omj:()=>Je.Om,NEP:()=>Je.NE,YFo:()=>Je.YF,Y0y:()=>Je.Y0,vwp:()=>Je.vw,deh:()=>Je.de,Uyb:()=>Je.Uy,OR:()=>Je.OR,jeX:()=>Je.je,eBW:()=>Je.eB,sHE:()=>Je.sH,_V0:()=>Je._V,luS:()=>Je.lu,q1x:()=>Je.q1,qi_:()=>Je.qi,iZT:()=>Je.iZ,Acj:()=>Je.Ac,Qg5:()=>Je.Qg,iJz:()=>Je.iJ,J_u:()=>Je.J_,avt:()=>Je.av,iWB:()=>Je.iW,r7n:()=>Je.r7,Zuw:()=>ir.Zu,eZ0:()=>Je.eZ,Hhh:()=>Je.Hh,J$2:()=>Je.J$,vtC:()=>Je.vt,CAk:()=>Je.CA,e7N:()=>Je.e7,ZbH:()=>Je.Zb,kU:()=>Je.kU,qCd:()=>Je.qC,PYm:()=>Je.PY,VfG:()=>Je.Vf,MZg:()=>Je.MZ,qIC:()=>Je.qI,YoZ:()=>Je.Yo,mTV:()=>Je.mT,OAf:()=>Je.OA,OU7:()=>Je.OU,OV7:()=>Je.OV,vFR:()=>Je.vF,BMI:()=>Je.BM,q2K:()=>Je.q2,c17:()=>Je.c1,q8u:()=>Je.q8,jQs:()=>Je.jQ,Vbg:()=>Je.Vb,rIn:()=>jt,NZg:()=>Je.NZ,wYn:()=>Je.wY,kuV:()=>Je.ku,uv1:()=>Je.uv,cye:()=>Je.cy,W0H:()=>Je.W0,yQU:()=>Je.yQ,zvA:()=>Kt.zvA,we_:()=>Je.we,qWM:()=>Je.qW,gaJ:()=>Ft,eEe:()=>Xt,QiL:()=>Je.Qi,lyA:()=>Je.ly,Kgp:()=>Je.Kg,pe_:()=>Je.pe,o0g:()=>Je.o0,DlI:()=>Je.Dl,gVI:()=>qt,e6w:()=>Je.e6,yw1:()=>Yt.yw,xJR:()=>Je.xJ,oHH:()=>Je.oH,$HU:()=>Je.$H,IH3:()=>Zt.I,qkr:()=>Je.qk,SbG:()=>Je.Sb,HZH:()=>Je.HZ,_Yw:()=>Je._Y,zbQ:()=>Je.zb,dpD:()=>Je.dp,Hmb:()=>Je.Hm,mKl:()=>Je.mK,b9H:()=>Je.b9,e07:()=>Je.e0,bV0:()=>Je.bV,DYp:()=>Ht,xQA:()=>Je.xQ,nr8:()=>Je.nr,PhF:()=>Je.Ph,oFR:()=>Je.oF,a5O:()=>Je.a5,i5y:()=>Je.i5,RQH:()=>Je.RQ,wYB:()=>Je.w3,p2w:()=>Je.p2,Gcp:()=>Je.Gc,MRv:()=>Je.MR,TQc:()=>Je.TQ,O3z:()=>Je.O3,nhH:()=>Je.nh,w3H:()=>Je.YW,ZjV:()=>Je.Zj,D2d:()=>Je.D2,L8s:()=>Je.L8,FKq:()=>Je.FK,bK0:()=>Je.bK,_tC:()=>Je._t,h8e:()=>Je.h8,jQk:()=>Je.m2,_JP:()=>Je._J,s1s:()=>Je.s1,XkS:()=>Je.Xk,Tr8:()=>Je.Tr,GBy:()=>Je.GB,sEM:()=>Je.sE,MIZ:()=>Je.MI,esB:()=>Se.es,YDk:()=>Se.YD,n9L:()=>Je.n9,cWu:()=>Je.cW,wx7:()=>Je.wx,G3Y:()=>Je.G3,kpP:()=>Je.kp,ToN:()=>Je.To,Qvg:()=>Je.Qv,XDQ:()=>Je.XD,_wD:()=>Se._w,RuY:()=>Je.Ru,usg:()=>Je.us,WnP:()=>Kt.WnP,Khb:()=>Kt.Khb,__u:()=>Kt.__u,IHx:()=>Kt.IHx,QBD:()=>Kt.QBD,$6P:()=>Kt.$6P,YjB:()=>Kt.YjB,NqF:()=>Kt.NqF,vHJ:()=>Kt.vHJ,ZRM:()=>Kt.ZRM,VfV:()=>Kt.VfV,z4N:()=>Kt.z4N,fvJ:()=>Kt.fvJ,C80:()=>Kt.C80,wS1:()=>Kt.wS1,uR5:()=>Kt.uR5,y3$:()=>Et.y3,Wap:()=>h,zEQ:()=>Kt.zEQ,tgs:()=>Kt.tgs,Dxk:()=>Kt.Dxk,JY5:()=>Kt.JY5,p3b:()=>Kt.p3b,E4h:()=>Kt.E4h,yE8:()=>Kt.yE8,anm:()=>Kt.anm,XsQ:()=>Kt.XsQ,UFq:()=>Kt.UFq,Jyw:()=>Ze,Xhn:()=>a,f3b:()=>Kt.f3b,pju:()=>Kt.pju,mDi:()=>Kt.mDi,iUl:()=>Kt.iUl,d9v:()=>Kt.d9v,PYB:()=>Kt.PYB,zoF:()=>Kt.zoF,gME:()=>Kt.gME,Izb:()=>Kt.Izb,MNy:()=>Kt.MNy,ZaL:()=>Kt.ZaL,PAt:()=>Kt.PAt,Tek:()=>Kt.Tek,bc:()=>Kt.bc,pdZ:()=>Kt.pdZ,$QV:()=>Kt.$QV,T3b:()=>Qe.T3,mCk:()=>Kt.mCk,f9Y:()=>Kt.f9Y,mew:()=>Kt.mew,$Gn:()=>Kt.$Gn,zbp:()=>Kt.zbp,cbc:()=>Dt.cb,ppE:()=>Kt.ppE,MXe:()=>Et.MX,nTT:()=>Kt.nTT,B10:()=>Kt.B10,C2$:()=>r,Ka3:()=>Kt.Ka3,WmZ:()=>Kt.WmZ,cFr:()=>Et.cF,B90:()=>Et.B9,N8o:()=>Et.N8,hiC:()=>Kt.hiC,NTj:()=>Kt.NTj,AKD:()=>Kt.AKD,rvX:()=>Kt.rvX,WYO:()=>Kt.WYO,pyx:()=>Kt.pyx,Ra$:()=>Et.R,G48:()=>Et.G4,GRh:()=>Kt.GRh,SRH:()=>Et.SR,OBj:()=>v.OB,DgJ:()=>Kt.DgJ,qNN:()=>Kt.qNN,d2q:()=>Kt.d2q,Qqt:()=>Kt.Qqt,dt4:()=>Kt.dt4,t$B:()=>Kt.t$B,iyy:()=>Kt.iyy,kp_:()=>Kt.kp_,hlL:()=>Kt.hlL,x3e:()=>Et.x3,zel:()=>Et.ze,GWj:()=>Kt.GWj,qPi:()=>Kt.qPi,imm:()=>Kt.imm,Iqj:()=>Kt.Iqj,dbB:()=>Kt.dbB,DaI:()=>o,N_N:()=>Et.N_,ukX:()=>Qe.uk,pIF:()=>Qe.pI,trD:()=>Qe.tr,UQy:()=>Dt.UQ,tiA:()=>Dt.ti,pjt:()=>Kt.pjt,brS:()=>Kt.brS,Sxn:()=>Kt.Sxn,asL:()=>Kt.asL,BHj:()=>Kt.BHj,V3u:()=>Kt.V3u,io:()=>i,wx0:()=>Kt.wx0,xVT:()=>Kt.xVT,UWc:()=>Kt.UWc,i2d:()=>Kt.i2d,CnY:()=>Et.Cn,GDt:()=>d,hi7:()=>Kt.hi7,d9m:()=>Kt.d9m,zN1:()=>Kt.zN1,$r2:()=>Kt.$r2,SX3:()=>Kt.SX3,G9k:()=>Kt.G9k,cM7:()=>Kt.cM7,Krr:()=>Kt.Krr,e_t:()=>Kt.e_t,CmS:()=>Kt.CmS,l_t:()=>Kt.l_t,HvI:()=>Kt.HvI,hJK:()=>Kt.hJK,K5V:()=>Kt.K5V,egP:()=>Kt.egP,MB5:()=>Kt.MB5,eab:()=>Kt.eab,OI3:()=>Kt.OI3,mAU:()=>s,Fp7:()=>Kt.Fp7,_sB:()=>Kt._sB,YQQ:()=>Kt.YQQ,Ip$:()=>Kt.Ip$,gWQ:()=>Kt.gWQ,J69:()=>Kt.J69,sq6:()=>Et.sq,ry_:()=>Kt.ry_,VV$:()=>Kt.VV$,LTh:()=>Kt.LTh,VdP:()=>Kt.VdP,wQq:()=>Kt.wQq,Gi7:()=>Kt.Gi7,p_:()=>Kt.p_,dC7:()=>Kt.dC7,rq4:()=>Kt.rq4,SJ_:()=>Kt.SJ_,W76:()=>Kt.W76,glt:()=>en,KOy:()=>Kt.KOy,Quu:()=>Kt.Quu,lfX:()=>Kt.lfX,iUs:()=>Kt.iUs,JpU:()=>Kt.JpU,op:()=>Kt.op,N2O:()=>Kt.N2O,vku:()=>Kt.vku,pNR:()=>Kt.pNR,koy:()=>Kt.koy,t1L:()=>Kt.t1L,lGY:()=>Kt.lGY,d_R:()=>Kt.d_R,sQ3:()=>Kt.sQ3,AL3:()=>Kt.AL3,S0v:()=>Kt.S0v,WVs:()=>Kt.WVs,N5s:()=>Et.N5,TN_:()=>Kt.TN_,wzB:()=>Kt.wzB,nGf:()=>Kt.nGf,LGj:()=>Kt.LGj,w6H:()=>Kt.w6H,Cd_:()=>Et.Cd,kwC:()=>Kt.kwC,M25:()=>Kt.M25,jqO:()=>Et.jq,LiG:()=>Qe.Li,wCN:()=>Qe.wC,UYe:()=>Kt.UYe,btT:()=>Kt.btT,cjG:()=>Et.cj,XLQ:()=>Kt.XLQ,GYS:()=>Kt.GYS,SDf:()=>Kt.SDf,diP:()=>Kt.diP,sx7:()=>Kt.sx7,mG2:()=>Kt.mG2,QEs:()=>Kt.QEs,NMM:()=>Kt.NMM,bp0:()=>Kt.bp0,iD$:()=>Kt.iD$,snQ:()=>Kt.snQ,yV1:()=>ot,zcT:()=>Kt.zcT,U8D:()=>Kt.U8D,U_I:()=>Kt.U_I,m7h:()=>l,CQI:()=>Et.CQ,VYu:()=>Et.VY,ODp:()=>Kt.ODp,XD2:()=>Kt.XD2,Xxe:()=>Kt.Xxe,tdS:()=>Kt.tdS,O$l:()=>Kt.O$l,R_K:()=>Kt.R_K,tPi:()=>Kt.tPi,jZU:()=>Kt.jZU,SmN:()=>Kt.SmN,CnO:()=>Kt.CnO,p0P:()=>Kt.p0P,kuN:()=>lt,XAC:()=>Kt.XAC,Wvh:()=>Kt.Wvh,fBT:()=>Kt.fBT,rVs:()=>Kt.rVs,ers:()=>Kt.ers,uN7:()=>Kt.uN7,Vl2:()=>Kt.Vl2,_b3:()=>Kt._b3,h62:()=>Kt.h62,$i:()=>Kt.$i,L9e:()=>Kt.L9e,knu:()=>Kt.knu,Nbs:()=>Kt.Nbs,NXj:()=>Kt.NXj,Z_8:()=>Kt.Z_8,luU:()=>Kt.luU,Smz:()=>Kt.Smz,z4k:()=>Yt.z4,ORZ:()=>Kt.ORZ,AEp:()=>Kt.AEp,XeE:()=>Kt.XeE,RRF:()=>Kt.RRF,odF:()=>Kt.odF,wOQ:()=>Kt.wOQ,yXz:()=>Kt.yXz,Bfx:()=>Kt.Bfx,xZs:()=>Kt.xZs,piX:()=>dt,p3L:()=>c,lub:()=>Et.lu,Gg6:()=>Kt.Gg6,XVJ:()=>Et.XV,hg7:()=>Kt.hg7,p_j:()=>Jt,p4s:()=>Kt.p4s,Xu6:()=>Kt.Xu6,Two:()=>Kt.Two,bt3:()=>Qe.bt,nEe:()=>Qe.nE,pUJ:()=>Kt.pUJ,HHK:()=>Kt.HHK,x8V:()=>Yt.x8,GaM:()=>Kt.GaM,D5U:()=>pt,h76:()=>Dt.h7,fNQ:()=>Dt.fN,VD$:()=>Kt.VD$,pnJ:()=>Dt.pn,jTM:()=>Tt,arb:()=>Kt.arb,itS:()=>Kt.itS,lls:()=>Kt.lls,P84:()=>Kt.P84});var r={};n.r(r),n.d(r,{isBrowser:()=>y,isMobile:()=>g,mockIsMobile:()=>m});var i={};n.r(i),n.d(i,{browserFiles:()=>Ce,browserHTTPRequest:()=>Oe,concatenateArrayBuffers:()=>N,copyModel:()=>fe,decodeWeights:()=>E,encodeWeights:()=>T,fromMemory:()=>$e,fromMemorySync:()=>Ve,getLoadHandlers:()=>U,getModelArtifactsForJSON:()=>D,getModelArtifactsInfoForJSON:()=>L,getSaveHandlers:()=>B,http:()=>Pe,isHTTPScheme:()=>Le,listModels:()=>de,loadWeights:()=>ke,moveModel:()=>me,registerLoadRouter:()=>z,registerSaveRouter:()=>O,removeModel:()=>pe,weightsLoaderFactory:()=>Re,withSaveHandler:()=>We,withSaveHandlerSync:()=>Ge});var s={};n.r(s),n.d(s,{confusionMatrix:()=>Ke});var a={};n.r(a),n.d(a,{fromPixels:()=>st,fromPixelsAsync:()=>rt,toPixels:()=>it});var o={};n.r(o),n.d(o,{prepareAndValidate:()=>at});var l={};n.r(l),n.d(l,{Serializable:()=>ct,SerializationMap:()=>ut,registerClass:()=>ht});var c={};n.r(c),n.d(c,{TEST_EPSILON_FLOAT16:()=>ft,encodeStrings:()=>Mt,expectArrayBuffersEqual:()=>St,expectArraysClose:()=>mt,expectArraysEqual:()=>xt,expectNumbersClose:()=>bt,expectPromiseToFail:()=>vt,expectValuesInRange:()=>_t,testEpsilon:()=>gt});var u={};n.r(u),n.d(u,{collectGatherOpShapeInfo:()=>Qn,computeOutShape:()=>Jn,segOpComputeOptimalWindowSize:()=>Zn});var h={};n.r(h),n.d(h,{ERF_A1:()=>yn,ERF_A2:()=>vn,ERF_A3:()=>xn,ERF_A4:()=>bn,ERF_A5:()=>wn,ERF_P:()=>gn,PARALLELIZE_THRESHOLD:()=>on,SELU_SCALE:()=>mn.$,SELU_SCALEALPHA:()=>mn.y,applyActivation:()=>an.QH,assertAndGetBroadcastShape:()=>Ze.assertAndGetBroadcastShape,assertAxesAreInnerMostDims:()=>tn.lB,assertParamsConsistent:()=>nn,assignToTypedArray:()=>Cn,axesAreInnerMostDims:()=>tn.YB,calculateShapes:()=>ot.calculateShapes,checkEinsumDimSizes:()=>Ln,checkPadOnDimRoundingMode:()=>sn.m,combineLocations:()=>tn.Vh,complexWithEvenIndex:()=>Tn,complexWithOddIndex:()=>En,computeConv2DInfo:()=>sn.Ix,computeConv3DInfo:()=>sn.jw,computeDefaultPad:()=>sn.aO,computeDilation2DInfo:()=>sn.Rf,computeOptimalWindowSize:()=>ln,computeOutAndReduceShapes:()=>tn.kz,computeOutShape:()=>rn,computePool2DInfo:()=>sn.Xw,computePool3DInfo:()=>sn.pl,convertConv2DDataFormat:()=>sn.sl,decodeEinsumEquation:()=>Rn,eitherStridesOrDilationsAreOne:()=>sn.jT,expandShapeToKeepDim:()=>tn.rv,exponent:()=>Nn,exponents:()=>In,fromStringArrayToUint8:()=>tr,fromUint8ToStringArray:()=>er,getAxesPermutation:()=>tn.Q3,getBroadcastDims:()=>Ze.getBroadcastDims,getComplexWithIndex:()=>An,getEinsumComputePath:()=>Fn,getEinsumPermutation:()=>Dn,getFusedBiasGradient:()=>an.pf,getFusedDyActivation:()=>an.Fr,getImageCenter:()=>cn,getInnerMostAxes:()=>tn.sY,getPermuted:()=>hn,getReductionAxes:()=>Ze.getReductionAxes,getReshaped:()=>un,getReshapedPermuted:()=>dn,getSliceBeginCoords:()=>pn,getSliceSize:()=>fn,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Bn,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Un,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>$n,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Gn,getSparseReshapeInputOutputMismatchErrorMessage:()=>jn,getSparseReshapeInputOutputMultipleErrorMessage:()=>Hn,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Vn,getSparseReshapeNegativeOutputDimErrorMessage:()=>Wn,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Kn,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>qn,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Xn,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Yn,getUndoAxesPermutation:()=>tn.LJ,isIdentityPermutation:()=>Pn,log:()=>_n.c,mergeRealAndImagArrays:()=>Sn,prepareAndValidate:()=>at,prepareSplitSize:()=>zn,segment_util:()=>u,shouldFuse:()=>an.uy,slice_util:()=>lt,splitRealAndImagArrays:()=>Mn,tupleValuesAreOne:()=>sn.I0,upcastType:()=>Yt.x8,validateInput:()=>ot.validateInput,validateUpdateShape:()=>ot.validateUpdateShape,warn:()=>_n.Z});var d={};n.r(d),n.d(d,{nonMaxSuppressionV3Impl:()=>nr.GP,nonMaxSuppressionV4Impl:()=>nr.qP,nonMaxSuppressionV5Impl:()=>nr.pA,whereImpl:()=>rr.Z});var p=n(7097);let f;function m(e){f=e}function g(e){if(void 0!==f)return f;if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function y(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}var v=n(2885),x=n(4155);const b=(0,v.OB)();b.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),b.registerFlag("IS_BROWSER",(()=>y())),b.registerFlag("IS_NODE",(()=>void 0!==x&&void 0!==x.versions&&void 0!==x.versions.node)),b.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),b.registerFlag("PROD",(()=>!1)),b.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>b.getBool("DEBUG"))),b.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),b.registerFlag("IS_TEST",(()=>!1)),b.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0)),b.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),b.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));var w=n(1661),_=n(701),S=n(9115);const M={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};async function T(e,t){const n=[],r=[],i=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let s=0;s<i.length;++s){const a=i[s],o=Array.isArray(e)?e[s].tensor:e[a];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${o.dtype}`);const l={name:a,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise((async e=>{const t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+4*t.length,r=new Uint8Array(n);let i=0;for(let e=0;e<t.length;e++){const n=t[e],s=new Uint8Array(new Uint32Array([n.length]).buffer);r.set(s,i),i+=4,r.set(n,i),i+=n.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}return{data:A(await Promise.all(r)),specs:n}}function E(e,t){const n={};let r,i=0;for(const s of t){const t=s.name,a=s.dtype,o=s.shape,l=(0,S.NA)(o);let c;if("quantization"in s){const n=s.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${s.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${s.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${s.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${a}.`)}const o=M[n.dtype],u=e.slice(i,i+l*o),h="uint8"===n.dtype?new Uint8Array(u):new Uint16Array(u);if("float32"===a)if("uint8"===n.dtype||"uint16"===n.dtype){c=new Float32Array(h.length);for(let e=0;e<h.length;e++){const t=h[e];c[e]=t*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===r&&(r=F()),c=r(h)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${t}': ${a}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);c=new Int32Array(h.length);for(let e=0;e<h.length;e++){const t=h[e];c[e]=Math.round(t*n.scale+n.min)}}i+=l*o}else if("string"===a){const t=(0,S.NA)(s.shape);c=[];for(let n=0;n<t;n++){const t=new Uint32Array(e.slice(i,i+4))[0];i+=4;const n=new Uint8Array(e.slice(i,i+t));c.push(n),i+=t}}else{const r=M[a],s=e.slice(i,i+l*r);if("float32"===a)c=new Float32Array(s);else if("int32"===a)c=new Int32Array(s);else if("bool"===a)c=new Uint8Array(s);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${t}': ${a}`);{c=new Float32Array(s);const e=new Float32Array(c.length/2),r=new Float32Array(c.length/2);for(let t=0;t<e.length;t++)e[t]=c[2*t],r[t]=c[2*t+1];const i=(0,_.X)(e,o,"float32"),a=(0,_.X)(r,o,"float32");n[t]=(0,w.P)(i,a),i.dispose(),a.dispose()}}i+=l*r}"complex64"!==a&&(n[t]=(0,_.X)(c,o,a))}return n}function A(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const r=new Uint8Array(t);let i=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),i),i+=e.byteLength})),r.buffer}const C="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function I(e){return C?Buffer.byteLength(e):new Blob([e]).size}function N(e){if(1===e.length)return e[0];let t=0;e.forEach((e=>{t+=e.byteLength}));const n=new Uint8Array(t);let r=0;return e.forEach((e=>{n.set(new Uint8Array(e),r),r+=e.byteLength})),n.buffer}function k(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function R(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}async function D(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),null!=e.weightsManifest){const[r,i]=await t(e.weightsManifest);n.weightSpecs=r,n.weightData=i}return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),n}function L(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:I(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:I(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function F(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0==(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{const i=new ArrayBuffer(4*r.length),s=new Uint32Array(i);for(let i=0;i<r.length;i++){const a=r[i],o=e[n[a>>10]+(1023&a)]+t[a>>10];s[i]=o}return new Float32Array(i)}}class P{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==P.instance&&(P.instance=new P),P.instance}static registerSaveRouter(e){P.getInstance().saveRouters.push(e)}static registerLoadRouter(e){P.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return P.getHandlers(e,"save")}static getLoadHandlers(e,t){return P.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?P.getInstance().loadRouters:P.getInstance().saveRouters).forEach((t=>{const i=t(e,n);null!==i&&r.push(i)})),r}}const O=e=>P.registerSaveRouter(e),z=e=>P.registerLoadRouter(e),B=e=>P.getSaveHandlers(e),U=(e,t)=>P.getLoadHandlers(e,t),$="tensorflowjs",V="models_store",W="model_info_store";function G(){if(!(0,v.OB)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function H(e){const t=e.result;t.createObjectStore(V,{keyPath:"modelPath"}),t.createObjectStore(W,{keyPath:"modelPath"})}class j{constructor(e){if(this.indexedDB=G(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open($,1);r.onupgradeneeded=()=>H(r),r.onsuccess=()=>{const i=r.result;if(null==t){const t=i.transaction(V,"readonly"),r=t.objectStore(V).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return i.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(i.close(),n(r.error)),t.oncomplete=()=>i.close()}else{const r=L(t),s=i.transaction(W,"readwrite");let a=s.objectStore(W);const o=a.put({modelPath:this.modelPath,modelArtifactsInfo:r});let l;o.onsuccess=()=>{l=i.transaction(V,"readwrite");const o=l.objectStore(V).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r});o.onsuccess=()=>e({modelArtifactsInfo:r}),o.onerror=e=>{a=s.objectStore(W);const t=a.delete(this.modelPath);t.onsuccess=()=>(i.close(),n(o.error)),t.onerror=e=>(i.close(),n(o.error))}},o.onerror=e=>(i.close(),n(o.error)),s.oncomplete=()=>{null==l?i.close():l.oncomplete=()=>i.close()}}},r.onerror=e=>n(r.error)}))}}j.URL_SCHEME="indexeddb://";const q=e=>{return(0,v.OB)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(j.URL_SCHEME)?(t=e.slice(j.URL_SCHEME.length),new j(t)):null;var t};P.registerSaveRouter(q),P.registerLoadRouter(q);class X{constructor(){this.indexedDB=G()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open($,1);n.onupgradeneeded=()=>H(n),n.onsuccess=()=>{const r=n.result,i=r.transaction(W,"readonly"),s=i.objectStore(W).getAll();s.onsuccess=()=>{const t={};for(const e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(r.close(),t(s.error)),i.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(j.URL_SCHEME)?t.slice(j.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open($,1);r.onupgradeneeded=()=>H(r),r.onsuccess=()=>{const i=r.result,s=i.transaction(W,"readwrite"),a=s.objectStore(W),o=a.get(e);let l;o.onsuccess=()=>{if(null==o.result)return i.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=a.delete(e),s=()=>{l=i.transaction(V,"readwrite");const r=l.objectStore(V).delete(e);r.onsuccess=()=>t(o.result.modelArtifactsInfo),r.onerror=e=>n(o.error)};r.onsuccess=s,r.onerror=e=>(s(),i.close(),n(o.error))}},o.onerror=e=>(i.close(),n(o.error)),s.oncomplete=()=>{null==l?i.close():l.oncomplete=()=>i.close()}},r.onerror=e=>n(r.error)}))}}const Y="/",K="tensorflowjs_models",Z="info",J="model_topology",Q="weight_specs",ee="weight_data",te="model_metadata";function ne(e){return{info:[K,e,Z].join(Y),topology:[K,e,J].join(Y),weightSpecs:[K,e,Q].join(Y),weightData:[K,e,ee].join(Y),modelMetadata:[K,e,te].join(Y)}}function re(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function ie(e){const t=e.split(Y);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Y)}class se{constructor(e){if(!(0,v.OB)().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=ne(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=L(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(e){if(C)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let e=0,r=t.length;e<r;e++)n+=String.fromCharCode(t[e]);return btoa(n)}(e.weightData));const i={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:r}}catch(e){throw re(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(null!=i){const e=JSON.parse(i);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(C){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n.set([t.charCodeAt(e)],e);return n.buffer}(s),t}}se.URL_SCHEME="localstorage://";const ae=e=>{return(0,v.OB)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(se.URL_SCHEME)?(t=e.slice(se.URL_SCHEME.length),new se(t)):null;var t};P.registerSaveRouter(ae),P.registerLoadRouter(ae);class oe{constructor(){(0,S.hu)((0,v.OB)().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),(0,S.hu)("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=K+Y,n=Y+Z;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);i.startsWith(t)&&i.endsWith(n)&&(e[ie(i)]=JSON.parse(this.LS.getItem(i)))}return e}async removeModel(e){var t;const n=ne(e=(t=e).startsWith(se.URL_SCHEME)?t.slice(se.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return re(n),r}}const le="://";class ce{constructor(){this.managers={}}static getInstance(){return null==ce.instance&&(ce.instance=new ce),ce.instance}static registerManager(e,t){(0,S.hu)(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(le)&&(e=e.slice(0,e.indexOf(le))),(0,S.hu)(e.length>0,(()=>"scheme must not be an empty string."));const n=ce.getInstance();(0,S.hu)(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}function ue(e){if(-1===e.indexOf(le))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ce.getSchemes().join(",")}`);return{scheme:e.split(le)[0],path:e.split(le)[1]}}async function he(e,t,n=!1){(0,S.hu)(e!==t,(()=>`Old path and new path are the same: '${e}'`));const r=P.getLoadHandlers(e);(0,S.hu)(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),(0,S.hu)(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));const i=r[0],s=P.getSaveHandlers(t);(0,S.hu)(s.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),(0,S.hu)(s.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));const a=s[0],o=ue(e).scheme,l=ue(e).path,c=o===ue(e).scheme,u=await i.load();n&&c&&await ce.getManager(o).removeModel(l);const h=await a.save(u);return n&&!c&&await ce.getManager(o).removeModel(l),h.modelArtifactsInfo}async function de(){const e=ce.getSchemes(),t={};for(const n of e){const e=await ce.getManager(n).listModels();for(const r in e)t[n+le+r]=e[r]}return t}async function pe(e){const t=ue(e);return ce.getManager(t.scheme).removeModel(t.path)}async function fe(e,t){return he(e,t,!1)}async function me(e,t){return he(e,t,!0)}class ge{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if((0,v.OB)().get("IS_BROWSER")){(0,v.OB)().setPlatform("browser",new ge);try{ce.registerManager(se.URL_SCHEME,new oe)}catch(e){}try{ce.registerManager(j.URL_SCHEME,new X)}catch(e){}}var ye=n(4155);let ve;(0,v.OB)().get("IS_NODE")&&!(0,v.OB)().get("IS_BROWSER")&&(0,v.OB)().setPlatform("node",new class{constructor(){this.util=n(8628),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=(0,v.OB)().global.fetch?(0,v.OB)().global.fetch(e,t):(null==ve&&(ve=n(5410)),ve(e,t))}now(){const e=ye.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}});var xe=n(2657),be=n(2271),we=n(8723),_e=n(9798),Se=n(4077);(0,p.wv)();const Me={buffer:xe.f,cast:be.p,clone:we.d,print:_e.S};function Te(e){return new Promise((e=>setTimeout(e))).then(e)}(0,Se.Vp)(Me);class Ee{constructor(e){if(!(0,v.OB)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Ee.URL_SCHEME)&&(e=e.slice(Ee.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=R(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),i=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=r,await Te((()=>i.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=t,await Te((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:L(e)}}}}Ee.URL_SCHEME="downloads://";class Ae{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{const n=new FileReader;n.onload=n=>{const r=JSON.parse(n.target.result),i=r.modelTopology;if(null==i)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:i});const s=D(r,(e=>this.loadWeights(e)));e(s)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){const t=[],n=[];for(const r of e)t.push(...r.weights),n.push(...r.paths);const r=this.checkManifestAndWeightFiles(e),i=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(i).then((e=>[t,N(e)]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{const i=new FileReader;i.onload=e=>{const t=e.target.result;n(t)},i.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),i.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map((e=>k(e.name))),r={};for(const i of e)i.paths.forEach((e=>{const i=k(e);if(-1!==t.indexOf(i))throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),-1===n.indexOf(i))throw new Error(`Weight file with basename '${i}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(i)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}function Ce(e){return new Ae(e)}function Ie(e,t,n,r){!function(e){(0,S.hu)(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){(0,S.hu)(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),(0,S.hu)(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),(0,S.hu)(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let i=0;return Promise.all(e.map((s=>(s.then((s=>{const a=n+ ++i/e.length*(r-n);return t(a),s})),s))))}async function Ne(e,t){null==t&&(t={});const n=null==t.fetchFunc?(0,v.OB)().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),i=(null==t.onProgress?await Promise.all(r):await Ie(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(i):await Ie(i,t.onProgress,.5,1)}async function ke(e,t="",n,r){return Re((e=>Ne(e,{requestInit:r})))(e,t,n)}function Re(e){return async(t,n="",r)=>{const i=t.map((()=>!1)),s={},a=null!=r?r.map((()=>!1)):[],o=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const l="quantization"in e?e.quantization.dtype:e.dtype,c=M[l]*S.NA(e.shape),u=()=>{i[t]=!0,null==s[t]&&(s[t]=[]),s[t].push({manifestEntry:e,groupOffset:n,sizeBytes:c})};null!=r?r.forEach(((t,n)=>{t===e.name&&(u(),a[n]=!0)})):u(),o.push(e.name),n+=c}))})),!a.every((e=>e))){const e=r.filter(((e,t)=>!a[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}const l=i.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),c=[];l.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(n.endsWith("/")?"":"/")+e;c.push(t)}))}));const u=await e(c),h={};let d=0;return l.forEach((e=>{const n=t[e].paths.length;let r=0;for(let e=0;e<n;e++)r+=u[d+e].byteLength;const i=new ArrayBuffer(r),a=new Uint8Array(i);let o=0;for(let e=0;e<n;e++){const t=new Uint8Array(u[d+e]);a.set(t,o),o+=t.byteLength}s[e].forEach((e=>{const t=E(i.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(const e in t)h[e]=t[e]})),d+=n})),h}}P.registerSaveRouter((e=>(0,v.OB)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ee.URL_SCHEME)?function(e="model"){return new Ee(e)}(e.slice(Ee.URL_SCHEME.length)):null));class De{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?((0,S.hu)("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=(0,v.OB)().platform.fetch,(0,S.hu)(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&(0,S.hu)(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=R(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:L(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(e){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return D(t,(e=>this.loadWeights(e)))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?");return[e.substring(0,t)+"/",n>t?e.substring(n):""]}(t),i=this.weightPathPrefix||n,s=[];for(const t of e)s.push(...t.weights);const a=[],o=[];for(const t of e)for(const e of t.paths)null!=this.weightUrlConverter?o.push(this.weightUrlConverter(e)):a.push(i+e+r);return this.weightUrlConverter&&a.push(...await Promise.all(o)),[s,N(await Ne(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function Le(e){return null!=e.match(De.URL_SCHEME_REGEX)}De.URL_SCHEME_REGEX=/^https?:\/\//;const Fe=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>Le(e))):Le(e),n)return Pe(e,t)}return null};function Pe(e,t){return new De(e,t)}function Oe(e,t){return Pe(e,t)}P.registerSaveRouter(Fe),P.registerLoadRouter(Fe);class ze{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class Be{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Ue{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function $e(e,t,n,r){const i=arguments;return new Ue(Ve(...i))}function Ve(e,t,n,r){return 1===arguments.length?null!=e.modelTopology||null!=e.weightSpecs?new ze(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ze({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ze({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function We(e){return new Be(e)}function Ge(e){return new Be(e)}var He=n(3740),je=n(8687),qe=n(6708),Xe=n(2668),Ye=n(9065);const Ke=(0,Xe.op)({confusionMatrix_:function(e,t,n){const r=(0,He._1)(e,"labels","confusionMatrix"),i=(0,He._1)(t,"predictions","confusionMatrix");S.hu(null==n||n>0&&Number.isInteger(n),(()=>`If provided, numClasses must be a positive integer, but got ${n}`)),S.hu(1===r.rank,(()=>`Expected the rank of labels to be 1, but got ${r.rank}`)),S.hu(1===i.rank,(()=>`Expected the rank of predictions to be 1, but got ${i.rank}`)),S.hu(r.shape[0]===i.shape[0],(()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${i.shape[0]}. Labels and predictions should have the same number of elements.`)),S.hu(n>0&&Number.isInteger(n),(()=>`numClasses is required to be a positive integer, but got ${n}`));const s=(0,qe.l)((0,be.p)(r,"int32"),n),a=(0,qe.l)((0,be.p)(i,"int32"),n),o=(0,Ye.p)(s),l=(0,je.O)(o,a);return(0,be.p)(l,"int32")}});var Ze=n(2200),Je=n(9121),Qe=n(6151),et=n(9906);let tt;function nt(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,i=!1,s=!1,a=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)i=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)s=!0;else if(null!=e.getContext)a=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(i){const t=2;if(i&&e.readyState<t)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=(0,Qe.pI)(Je.eB,p.BV.backendName)){const n={pixels:e},r={numChannels:t};return p.BV.runKernel(Je.eB,n,r)}const[l,c]=i?[e.videoWidth,e.videoHeight]:[e.width,e.height];let u,h;if(a)u=e.getContext("2d").getImageData(0,0,l,c).data;else if(r||n)u=e.data;else if(s||i||o){if(null==tt)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");tt=new OffscreenCanvas(1,1).getContext("2d")}else tt=document.createElement("canvas").getContext("2d");tt.canvas.width=l,tt.canvas.height=c,tt.drawImage(e,0,0,l,c),u=tt.getImageData(0,0,l,c).data}if(4===t)h=new Int32Array(u);else{const e=l*c;h=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)h[n*t+e]=u[4*n+e]}const d=[c,l,t];return(0,et.w)(h,d,"int32")}async function rt(e,t=3){let n=null;if((0,v.OB)().getBool("WRAP_TO_IMAGEBITMAP")&&function(e){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&function(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function(e){return null!=e&&e.data instanceof Uint8Array}(e)}(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(e){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return nt(n,t)}async function it(e,t){let n=(0,He._1)(e,"img","toPixels");if(!(e instanceof Se.es)){const e=n;n=(0,be.p)(e,"int32"),e.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[r,i]=n.shape.slice(0,2),s=2===n.rank?1:n.shape[2];if(s>4||2===s)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if("float32"!==n.dtype&&"int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);const a=await n.data(),o="float32"===n.dtype?255:1,l=new Uint8ClampedArray(i*r*4);for(let e=0;e<r*i;++e){const t=[0,0,0,255];for(let r=0;r<s;r++){const i=a[e*s+r];if("float32"===n.dtype){if(i<0||i>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${i}.`)}else if("int32"===n.dtype&&(i<0||i>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${i}.`);1===s?(t[0]=i*o,t[1]=i*o,t[2]=i*o):t[r]=i*o}const r=4*e;l[r+0]=Math.round(t[0]),l[r+1]=Math.round(t[1]),l[r+2]=Math.round(t[2]),l[r+3]=Math.round(t[3])}if(null!=t){t.width=i,t.height=r;const e=t.getContext("2d"),n=new ImageData(l,i,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),l}const st=(0,Xe.op)({fromPixels_:nt});function at(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===(0,S.NA)(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const i=t.shape,s=i[i.length-1];let a=1;for(let e=0;e<i.length-1;++e)a*=i[e];const o=e.shape,l=i.slice();l.pop();let c=1;for(let e=s;e<n;++e)c*=o[e],l.push(o[e]);const u=[...(0,S.e3)(e.shape).map((e=>e/c)),1].slice(0,s);return[l,a,c,u]}var ot=n(3028),lt=n(7650);class ct{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class ut{constructor(){this.classNameMap={}}static getMap(){return null==ut.instance&&(ut.instance=new ut),ut.instance}static register(e){ut.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function ht(e){(0,S.hu)(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),(0,S.hu)("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),(0,S.hu)(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),ut.register(e)}var dt=n(747),pt=n(9122);const ft=.1;function mt(e,t,n){return null==n&&(n=gt()),yt(e,t,((e,t)=>wt(e,t,n)))}function gt(){return 32===p.BV.backend.floatPrecision()?.001:ft}function yt(e,t,n){let r=!0;if(((0,S.fU)(e)||(0,S.fU)(t))&&(r=!1),(0,S.fU)(e)&&(0,S.fU)(t)&&(r=!0),r){const n=e.constructor.name,r=t.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){const n=(0,He.C)(e),r=(0,He.C)(t);if(!(0,S.cO)(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}const i=(0,S.fU)(e)?e:(0,S.xH)(e),s=(0,S.fU)(t)?t:(0,S.xH)(t);if(i.length!==s.length)throw new Error(`Arrays have different lengths actual: ${i.length} vs expected: ${s.length}.\nActual:   ${i}.\nExpected: ${s}.`);for(let e=0;e<s.length;++e){const t=i[e],r=s[e];if(!n(t,r))throw new Error(`Arrays differ: actual[${e}] = ${t}, expected[${e}] = ${r}.\nActual:   ${i}.\nExpected: ${s}.`)}}function vt(e,t){e().then((()=>t.fail()),(()=>t()))}function xt(e,t){const n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return(0,S.HD)(e)||(0,S.HD)(e[0])||(0,S.HD)(t)||(0,S.HD)(t[0])?yt(e,n,((e,t)=>e==t)):yt(e,t,((e,t)=>wt(e,t,0)))}function bt(e,t,n){if(null==n&&(n=gt()),!wt(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`)}function wt(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function _t(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function St(e,t){const n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let e=0;e<r.length;e++)if(n[e]!==r[e])throw new Error(`Expected ArrayBuffer value at ${e} to be ${r[e]} but got ${n[e]} instead`)}function Mt(e){for(let t=0;t<e.length;t++){const n=e[t];Array.isArray(n)?Mt(n):e[t]=(0,pt.encodeString)(n)}return e}const Tt="3.18.0";var Et=n(4368),At=n(6407),Ct=n(1274),It=n(4841),Nt=n(3261),kt=n(248),Rt=n(6577),Dt=n(633),Lt=n(9494);class Ft extends ct{minimize(e,t=!1,n){const{value:r,grads:i}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:i[e.name]})));this.applyGradients(e)}else this.applyGradients(i);return(0,Et.B9)(i),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return(0,Dt.pn)(e,t)}dispose(){null!=this.iterations_&&(0,Et.B9)(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:(0,Lt.i)(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Ft,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class Pt extends Ft{constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=p.BV.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=p.BV.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:(0,Et.lu)((()=>(0,Rt.P)(r).variable(!1)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:(0,Et.lu)((()=>(0,Rt.P)(r).variable(!1)))});const i=Array.isArray(e)?e[n].tensor:e[t];if(null==i)return;const s=this.accumulatedGrads[n].variable,a=this.accumulatedUpdates[n].variable;(0,Et.lu)((()=>{const e=(0,At.I)((0,It.d)(s,this.rho),(0,It.d)((0,kt.h)(i),1-this.rho)),t=(0,It.d)((0,Ct.h)((0,Nt._)((0,At.I)(a,this.epsilon)),(0,Nt._)((0,At.I)(s,this.epsilon))),i),n=(0,At.I)((0,It.d)(a,this.rho),(0,It.d)((0,kt.h)(t),1-this.rho));s.assign(e),a.assign(n);const o=(0,At.I)((0,It.d)(t,-this.learningRate),r);r.assign(o)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,Et.B9)(this.accumulatedGrads.map((e=>e.variable))),(0,Et.B9)(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}Pt.className="Adadelta",ht(Pt);var Ot=n(4006);class zt extends Ft{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=p.BV.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:(0,Et.lu)((()=>(0,Ot.h)(r.shape,this.initialAccumulatorValue).variable(e)))}}const i=Array.isArray(e)?e[n].tensor:e[t];if(null==i)return;const s=this.accumulatedGrads[n].variable;(0,Et.lu)((()=>{const e=(0,At.I)(s,(0,kt.h)(i));s.assign(e);const t=(0,At.I)((0,It.d)((0,Ct.h)(i,(0,Nt._)((0,At.I)(e,p.BV.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,Et.B9)(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}zt.className="Adagrad",ht(zt);var Bt=n(3453),Ut=n(827);class $t extends Ft{constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,Et.lu)((()=>{this.accBeta1=(0,Lt.i)(t).variable(),this.accBeta2=(0,Lt.i)(n).variable()})),null==r&&(this.epsilon=p.BV.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);(0,Et.lu)((()=>{const n=(0,Ut.l)(1,this.accBeta1),r=(0,Ut.l)(1,this.accBeta2);t.forEach(((t,i)=>{const s=p.BV.registeredVariables[t];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${t}/m`,variable:(0,Et.lu)((()=>(0,Rt.P)(s).variable(!1)))}),null==this.accumulatedSecondMoment[i]&&(this.accumulatedSecondMoment[i]={originalName:`${t}/v`,variable:(0,Et.lu)((()=>(0,Rt.P)(s).variable(!1)))});const a=Array.isArray(e)?e[i].tensor:e[t];if(null==a)return;const o=this.accumulatedFirstMoment[i].variable,l=this.accumulatedSecondMoment[i].variable,c=(0,At.I)((0,It.d)(o,this.beta1),(0,It.d)(a,1-this.beta1)),u=(0,At.I)((0,It.d)(l,this.beta2),(0,It.d)((0,kt.h)(a),1-this.beta2)),h=(0,Ct.h)(c,n),d=(0,Ct.h)(u,r);o.assign(c),l.assign(u);const f=(0,At.I)((0,It.d)((0,Ct.h)(h,(0,At.I)((0,Nt._)(d),this.epsilon)),-this.learningRate),s);s.assign(f)})),this.accBeta1.assign((0,It.d)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,It.d)(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,Et.B9)(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&(0,Et.B9)(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),(0,Et.lu)((()=>{this.accBeta1.assign((0,Bt.s)(this.beta1,this.iterations_+1)),this.accBeta2.assign((0,Bt.s)(this.beta2,this.iterations_+1))}));const t=e.length/2;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}$t.className="Adam",ht($t);var Vt=n(6235),Wt=n(632);class Gt extends Ft{constructor(e,t,n,r=null,i=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,Et.lu)((()=>{this.iteration=(0,Lt.i)(0).variable(),this.accBeta1=(0,Lt.i)(t).variable()})),null==r&&(this.epsilon=p.BV.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);(0,Et.lu)((()=>{const n=(0,Ut.l)(1,this.accBeta1),r=(0,Ct.h)(-this.learningRate,(0,At.I)((0,It.d)(this.iteration,this.decay),1));t.forEach(((t,i)=>{const s=p.BV.registeredVariables[t];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${t}/m`,variable:(0,Rt.P)(s).variable(!1)}),null==this.accumulatedWeightedInfNorm[i]&&(this.accumulatedWeightedInfNorm[i]={originalName:`${t}/v`,variable:(0,Rt.P)(s).variable(!1)});const a=Array.isArray(e)?e[i].tensor:e[t];if(null==a)return;const o=this.accumulatedFirstMoment[i].variable,l=this.accumulatedWeightedInfNorm[i].variable,c=(0,At.I)((0,It.d)(o,this.beta1),(0,It.d)(a,1-this.beta1)),u=(0,It.d)(l,this.beta2),h=(0,Vt.W)(a),d=(0,Wt.g)(u,h);o.assign(c),l.assign(d);const f=(0,At.I)((0,It.d)((0,Ct.h)(r,n),(0,Ct.h)(c,(0,At.I)(d,this.epsilon))),s);s.assign(f)})),this.iteration.assign((0,At.I)(this.iteration,1)),this.accBeta1.assign((0,It.d)(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,Et.B9)(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&(0,Et.B9)(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}Gt.className="Adamax",ht(Gt);class Ht extends Ft{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const i=p.BV.registeredVariables[t];(0,Et.lu)((()=>{const e=(0,At.I)((0,It.d)(this.c,r),i);i.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=(0,Et.Cn)((0,Lt.i)(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}Ht.className="SGD",ht(Ht);class jt extends Ht{constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=(0,Lt.i)(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=p.BV.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:(0,Et.lu)((()=>(0,Rt.P)(r).variable(e)))}}const i=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&(0,Et.lu)((()=>{let e;const t=(0,At.I)((0,It.d)(this.m,i),s);e=this.useNesterov?(0,At.I)((0,It.d)(this.c,(0,At.I)(s,(0,It.d)(t,this.m))),r):(0,At.I)((0,It.d)(this.c,t),r),i.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,Et.B9)(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}jt.className="Momentum",ht(jt);class qt extends Ft{constructor(e,t=.9,n=0,r=null,i=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,null==r&&(this.epsilon=p.BV.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=p.BV.registeredVariables[t],i=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:(0,Et.lu)((()=>(0,Rt.P)(r).variable(i)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:(0,Et.lu)((()=>(0,Rt.P)(r).variable(i)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:(0,Et.lu)((()=>(0,Rt.P)(r).variable(i)))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const a=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;(0,Et.lu)((()=>{const e=(0,At.I)((0,It.d)(a,this.decay),(0,It.d)((0,kt.h)(s),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,i=(0,At.I)((0,It.d)(t,this.decay),(0,It.d)(s,1-this.decay)),l=(0,Ct.h)((0,It.d)(s,this.learningRate),(0,Nt._)((0,Ut.l)(e,(0,At.I)((0,kt.h)(i),this.epsilon)))),c=(0,At.I)((0,It.d)(o,this.momentum),l);a.assign(e),t.assign(i),o.assign(c);const u=(0,Ut.l)(r,c);r.assign(u)}else{const e=(0,At.I)((0,It.d)(a,this.decay),(0,It.d)((0,kt.h)(s),1-this.decay)),t=(0,At.I)((0,It.d)(o,this.momentum),(0,Ct.h)((0,It.d)(s,this.learningRate),(0,Nt._)((0,At.I)(e,this.epsilon))));a.assign(e),o.assign(t);const n=(0,Ut.l)(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,Et.B9)(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&(0,Et.B9)(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&(0,Et.B9)(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}qt.className="RMSProp",ht(qt);class Xt{static sgd(e){return new Ht(e)}static momentum(e,t,n=!1){return new jt(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,i=!1){return new qt(e,t,n,r,i)}static adam(e=.001,t=.9,n=.999,r=null){return new $t(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new Pt(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,i=0){return new Gt(e,t,n,r,i)}static adagrad(e,t=.1){return new zt(e,t)}}var Yt=n(1221),Kt=n(4376),Zt=n(9876);const Jt={sgd:Xt.sgd,momentum:Xt.momentum,adadelta:Xt.adadelta,adagrad:Xt.adagrad,rmsprop:Xt.rmsprop,adamax:Xt.adamax,adam:Xt.adam},Qt="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function en(){return new Promise((e=>Qt((()=>e()))))}var tn=n(3591);function nn(e,t){const n=e[0].length;e.forEach(((e,t)=>{S.hu(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),S.hu(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,i)=>{for(let s=0;s<n;s++)S.hu(s===t||e[s]===r[s],(()=>`Error in concat${n}D: Shape of tensors[${i}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${i}.`))}))}function rn(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var sn=n(2582),an=n(9323);const on=30;function ln(e){return e<=on?e:(0,S.jP)(e,Math.floor(Math.sqrt(e)))}function cn(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function un(e,t,n,r=!0){let i=[];if(r)i=i.concat(t.slice(0)),i.push(e[0]/n),i=i.concat(e.slice(1));else{i=i.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)i=i.concat([e[r+1]/t[r],t[r]]);i=i.concat(e.slice(n+1))}return i}function hn(e,t,n=!0){const r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{const n=[],i=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?i.push(r):n.push(r);r.push(...n),r.push(0),r.push(...i)}return r}function dn(e,t,n,r=!0){const i=[];r?i.push(e[0]/n):i.push(e[0]*n);for(let n=1;n<e.length;++n)n<=t.length?r?i.push(t[n-1]*e[n]):i.push(e[n]/t[n-1]):i.push(e[n]);return i}function pn(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function fn(e,t,n){const r=e.slice(0,1);for(let i=0;i<n;++i)r.push(e[i+1]-t[i][0]-t[i][1]);return r}var mn=n(3179);const gn=.3275911,yn=.254829592,vn=-.284496736,xn=1.421413741,bn=-1.453152027,wn=1.061405429;var _n=n(4706);function Sn(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function Mn(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function Tn(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=0;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function En(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=2;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function An(e,t){return{real:e[2*t],imag:e[2*t+1]}}function Cn(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function In(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let i=0;i<Math.ceil(e/2);i++){const s=(t?2:-2)*Math.PI*(i/e);n[i]=Math.cos(s),r[i]=Math.sin(s)}return{real:n,imag:r}}function Nn(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const kn=/->/g;function Rn(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(kn,"").length)/"->".length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("->").');const[r,i]=e.split("->");(0,S.hu)(-1===r.indexOf("..."),(()=>'The ellipsis notation ("...") is not supported yet.'));const s=r.split(","),a=s.length;if(t!==a)throw new Error(`Expected ${a} input tensors, received ${t}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let e=0;e<i.length;++e){const t=i[e];if(!s.some((e=>-1!==e.indexOf(t))))throw new Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===o.indexOf(t)&&o.push(t)}for(let e=0;e<r.length;++e){const t=r[e];-1===o.indexOf(t)&&","!==t&&o.push(t)}const l=new Array(s.length);for(let e=0;e<a;++e){if(new Set(s[e].split("")).size!==s[e].length)throw new Error(`Found duplicate axes in input component ${s[e]}. Support for duplicate axes in input is not implemented yet.`);l[e]=[];for(let t=0;t<s[e].length;++t)l[e].push(o.indexOf(s[e][t]))}const c=o.length,u=[];for(let e=i.length;e<c;++e)u.push(e);return{allDims:o,summedDims:u,idDims:l}}function Dn(e,t){let n=new Array(e);n.fill(-1);for(let e=0;e<t.length;++e)n[t[e]]=e;const r=[];for(let t=0;t<e;++t)-1===n[t]&&r.push(t);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function Ln(e,t,n){const r=new Array(e);for(let e=0;e<n.length;++e){const i=n[e].shape;for(let n=0;n<t[e].length;++n)void 0===r[t[e][n]]?r[t[e][n]]=i[n]:(0,S.hu)(r[t[e][n]]===i[n],(()=>`Expected dimension ${r[t[e][n]]} at axis ${n} of input shaped ${JSON.stringify(i)}, but got dimension ${i[n]}`))}}function Fn(e,t){const n=e,r=[];let i=0;0===e.length&&n.push(-1),i=e.length+1;for(let e=0;e<i;++e)r.push([]);const s=[];for(let e=0;e<n.length;++e){const i=On(t,n[e]);for(const t of i)-1===s.indexOf(t)&&(r[e].push(t),s.push(t))}return{path:n,steps:r}}function Pn(e){return e.every(((e,t)=>e===t))}function On(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function zn(e,t,n=0){let r=[];if("number"==typeof t)(0,S.hu)(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{const i=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);(0,S.hu)(i<=1,(()=>"There should be only one negative value in split array."));const s=t.indexOf(-1);if(-1!==s){const r=t.reduce(((e,t)=>t>0?e+t:e));t[s]=e.shape[n]-r}(0,S.hu)(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function Bn(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function Un(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function $n(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function Vn(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function Wn(e,t){return`size ${e} must be non-negative, not ${t}`}function Gn(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Hn(e,t){return`Input to reshape is a SparseTensor with ${(0,S.NA)(e)}\n  dense values, but the requested shape requires a multiple of ${(0,S.NA)(t)}. inputShape=${e} outputShape= ${t}`}function jn(e,t){return`Input to reshape is a tensor with ${(0,S.NA)(e)} dense values, but the requested shape has ${(0,S.NA)(t)}. inputShape=${e} outputShape=${t}`}function qn(){return"segment ids must be >= 0"}function Xn(){return"segment ids are not increasing"}function Yn(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Kn(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function Zn(e,t){let n,r=!1;for(e<=on?(n=e,r=!0):n=(0,S.jP)(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=(0,S.jP)(e,n+1);return n}function Jn(e,t,n){const r=[],i=e.length;for(let s=0;s<i;s++)s!==t?r.push(e[s]):r.push(n);return r}function Qn(e,t,n,r){const i=t.shape.length,s=e.shape.length;if(0!==r&&(r<-i||r>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${r}`);if(r<0&&(r+=i),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(e.shape[n]!==t.shape[n])throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);const a=e.shape[n],o=[];let l=1,c=1,u=1;for(let t=0;t<r;++t)o.push(e.shape[t]),l*=e.shape[t];for(let t=r;t<n;t++)o.push(e.shape[t]),c*=e.shape[t];for(let e=r;e<i;e++)o.push(t.shape[e]);for(let t=n+1;t<s;t++)o.push(e.shape[t]),u*=e.shape[t];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:a,outputShape:o}}function er(e){try{return e.map((e=>(0,pt.decodeString)(e)))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function tr(e){return e.map((e=>(0,pt.encodeString)(e)))}var nr=n(3337),rr=n(8333),ir=n(8713)},9121:(e,t,n)=>{"use strict";n.d(t,{$H:()=>ht,$g:()=>Q,$w:()=>X,Ac:()=>ge,BM:()=>Oe,By:()=>U,CA:()=>Te,D2:()=>$t,Dl:()=>lt,Eh:()=>k,FK:()=>Rt,G3:()=>en,GB:()=>Dt,Gc:()=>Pt,HE:()=>te,HZ:()=>pt,Hh:()=>Fe,Hm:()=>mt,IK:()=>c,IM:()=>b,J$:()=>Se,J_:()=>xe,Jh:()=>y,Kg:()=>st,L8:()=>Ft,Ly:()=>M,M2:()=>d,MI:()=>Kt,MR:()=>kt,MZ:()=>ke,NE:()=>ie,NZ:()=>Xe,O3:()=>Ot,OA:()=>Ue,OR:()=>ue,OU:()=>$e,OV:()=>Be,Om:()=>ne,Oy:()=>m,PY:()=>Ie,Ph:()=>Mt,QC:()=>g,QR:()=>W,Qg:()=>ve,Qi:()=>rt,Qv:()=>rn,RF:()=>E,RO:()=>v,RQ:()=>At,Ru:()=>an,SX:()=>ee,SY:()=>r,Sb:()=>vt,Sp:()=>s,T0:()=>G,TQ:()=>Lt,TR:()=>B,To:()=>nn,Tr:()=>Xt,Uy:()=>ce,VG:()=>i,Vb:()=>qe,Vc:()=>V,Vf:()=>Ne,Vn:()=>Z,W0:()=>et,XD:()=>sn,XL:()=>w,Xk:()=>qt,Xz:()=>o,Y0:()=>ae,YF:()=>se,YW:()=>Bt,Yo:()=>Pe,Zb:()=>Ae,Zj:()=>Ut,Zz:()=>I,_J:()=>Ht,_V:()=>hn,_Y:()=>gt,_k:()=>x,_t:()=>Vt,a5:()=>Nt,aJ:()=>h,av:()=>be,b9:()=>cn,bK:()=>Wt,bV:()=>wt,c1:()=>Ge,cW:()=>Jt,ci:()=>H,cy:()=>Qe,de:()=>le,dp:()=>ft,e0:()=>bt,e6:()=>ct,e7:()=>Ee,eB:()=>ln,eE:()=>T,eZ:()=>Le,ek:()=>K,gJ:()=>A,h8:()=>on,hd:()=>re,i5:()=>It,iH:()=>$,iJ:()=>ye,iW:()=>we,iZ:()=>me,ik:()=>O,jM:()=>f,jQ:()=>je,je:()=>he,kU:()=>Ce,kp:()=>tn,ku:()=>Ke,lu:()=>dn,ly:()=>it,m2:()=>Gt,mK:()=>xt,mT:()=>ze,mc:()=>z,mh:()=>R,mm:()=>a,n9:()=>Zt,nh:()=>zt,nr:()=>St,o0:()=>ot,o2:()=>P,oF:()=>Tt,oH:()=>J,oT:()=>l,p2:()=>Et,p4:()=>Y,pe:()=>at,q1:()=>fe,q2:()=>We,q8:()=>He,qC:()=>Re,qI:()=>De,qW:()=>tt,qi:()=>pe,qk:()=>dt,qw:()=>p,r7:()=>_e,s1:()=>jt,sE:()=>Yt,sH:()=>de,sJ:()=>u,sL:()=>j,us:()=>un,uv:()=>Je,vF:()=>Ve,vt:()=>Me,vw:()=>oe,w3:()=>Ct,wU:()=>D,wY:()=>Ye,we:()=>nt,wm:()=>L,wx:()=>Qt,x1:()=>F,xJ:()=>ut,xQ:()=>_t,xn:()=>C,y7:()=>q,yQ:()=>Ze,yj:()=>N,zb:()=>yt,zv:()=>S,zw:()=>_});const r="Abs",i="Acos",s="Acosh",a="Add",o="AddN",l="All",c="Any",u="ArgMax",h="ArgMin",d="Asin",p="Asinh",f="Atan",m="Atanh",g="Atan2",y="AvgPool",v="AvgPoolGrad",x="AvgPool3D",b="AvgPool3DGrad",w="BatchMatMul",_="BatchToSpaceND",S="Bincount",M="BroadcastTo",T="BroadcastArgs",E="Cast",A="Ceil",C="ClipByValue",I="Complex",N="ComplexAbs",k="Concat",R="Conv2D",D="Conv2DBackpropFilter",L="Conv2DBackpropInput",F="Conv3D",P="Conv3DBackpropFilterV2",O="Conv3DBackpropInputV2",z="Cos",B="Cosh",U="Cumprod",$="Cumsum",V="CropAndResize",W="DenseBincount",G="DepthToSpace",H="DepthwiseConv2dNative",j="DepthwiseConv2dNativeBackpropFilter",q="DepthwiseConv2dNativeBackpropInput",X="Diag",Y="Dilation2D",K="Dilation2DBackpropInput",Z="Dilation2DBackpropFilter",J="RealDiv",Q="Einsum",ee="Elu",te="EluGrad",ne="Erf",re="Equal",ie="Exp",se="ExpandDims",ae="Expm1",oe="FFT",le="Fill",ce="FlipLeftRight",ue="Floor",he="FloorDiv",de="FusedBatchNorm",pe="GatherV2",fe="GatherNd",me="Greater",ge="GreaterEqual",ye="Identity",ve="IFFT",xe="Imag",be="IsFinite",we="IsInf",_e="IsNan",Se="LeakyRelu",Me="Less",Te="LessEqual",Ee="LinSpace",Ae="Log",Ce="Log1p",Ie="LogicalAnd",Ne="LogicalNot",ke="LogicalOr",Re="LogSoftmax",De="LowerBound",Le="LRN",Fe="LRNGrad",Pe="Max",Oe="Maximum",ze="MaxPool",Be="MaxPoolGrad",Ue="MaxPool3D",$e="MaxPool3DGrad",Ve="MaxPoolWithArgmax",We="Mean",Ge="Min",He="Minimum",je="MirrorPad",qe="Mod",Xe="Multinomial",Ye="Multiply",Ke="Neg",Ze="NotEqual",Je="NonMaxSuppressionV3",Qe="NonMaxSuppressionV4",et="NonMaxSuppressionV5",tt="OnesLike",nt="OneHot",rt="Pack",it="PadV2",st="Pool",at="Pow",ot="Prelu",lt="Prod",ct="Range",ut="Real",ht="Reciprocal",dt="Relu",pt="Reshape",ft="ResizeNearestNeighbor",mt="ResizeNearestNeighborGrad",gt="ResizeBilinear",yt="ResizeBilinearGrad",vt="Relu6",xt="Reverse",bt="Round",wt="Rsqrt",_t="ScatterNd",St="SearchSorted",Mt="Select",Tt="Selu",Et="Slice",At="Sin",Ct="Sinh",It="Sign",Nt="Sigmoid",kt="Softplus",Rt="Sqrt",Dt="Sum",Lt="SpaceToBatchND",Ft="SplitV",Pt="Softmax",Ot="SparseFillEmptyRows",zt="SparseReshape",Bt="SparseSegmentMean",Ut="SparseSegmentSum",$t="SparseToDense",Vt="SquaredDifference",Wt="Square",Gt="StridedSlice",Ht="StringNGrams",jt="StringSplit",qt="StringToHashBucketFast",Xt="Sub",Yt="Tan",Kt="Tanh",Zt="Tile",Jt="TopK",Qt="Transform",en="Transpose",tn="Unique",nn="Unpack",rn="UnsortedSegmentSum",sn="UpperBound",an="ZerosLike",on="Step",ln="FromPixels",cn="RotateWithOffset",un="_FusedMatMul",hn="FusedConv2D",dn="FusedDepthwiseConv2D"},6151:(e,t,n)=>{"use strict";n.d(t,{Li:()=>d,T3:()=>m,bt:()=>f,nE:()=>p,pI:()=>l,tr:()=>u,uk:()=>c,wC:()=>h});var r=n(2885),i=n(5938),s=n(4706);const a=(0,i.R)("kernelRegistry",(()=>new Map)),o=(0,i.R)("gradRegistry",(()=>new Map));function l(e,t){const n=g(e,t);return a.get(n)}function c(e){return o.get(e)}function u(e){const t=a.entries(),n=[];for(;;){const{done:r,value:i}=t.next();if(r)break;const[s,a]=i,[o]=s.split("_");o===e&&n.push(a)}return n}function h(e){const{kernelName:t,backendName:n}=e,r=g(t,n);a.has(r)&&s.Z(`The kernel '${t}' for backend '${n}' is already registered`),a.set(r,e)}function d(e){const{kernelName:t}=e;o.has(t)&&(0,r.OB)().getBool("DEBUG")&&s.Z(`Overriding the gradient for '${t}'`),o.set(t,e)}function p(e,t){const n=g(e,t);if(!a.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);a.delete(n)}function f(e){if(!o.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);o.delete(e)}function m(e,t){u(e).forEach((e=>{h(Object.assign({},e,{backendName:t}))}))}function g(e,t){return`${t}_${e}`}},4706:(e,t,n)=>{"use strict";n.d(t,{Z:()=>i,c:()=>s});var r=n(2885);function i(...e){(0,r.OB)().getBool("IS_TEST")||(0,r.OB)().getBool("PROD")||console.warn(...e)}function s(...e){(0,r.OB)().getBool("IS_TEST")||(0,r.OB)().getBool("PROD")||console.log(...e)}},6235:(e,t,n)=>{"use strict";n.d(t,{W:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({abs_:function(e){const t=(0,s._1)(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return r.BV.runKernel(i.yj,e)}{const e={x:t};return r.BV.runKernel(i.SY,e)}}})},7839:(e,t,n)=>{"use strict";n.d(t,{K:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({acos_:function(e){const t={x:(0,s._1)(e,"x","acos")};return r.BV.runKernel(i.VG,t)}})},1470:(e,t,n)=>{"use strict";n.d(t,{_:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({acosh_:function(e){const t={x:(0,s._1)(e,"x","acosh")};return r.BV.runKernel(i.Sp,t)}})},6407:(e,t,n)=>{"use strict";n.d(t,{I:()=>o});var r=n(7097),i=n(9121),s=n(747),a=n(3740);const o=(0,n(2668).op)({add_:function(e,t){let n=(0,a._1)(e,"a","add"),o=(0,a._1)(t,"b","add");[n,o]=(0,s.makeTypesMatch)(n,o);const l={a:n,b:o};return r.BV.runKernel(i.mm,l)}})},3135:(e,t,n)=>{"use strict";n.d(t,{Q:()=>o});var r=n(7097),i=n(9121),s=n(3740),a=n(9115);const o=(0,n(2668).op)({addN_:function(e){a.hu(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),a.hu(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));const t=e.map(((e,t)=>(0,s._1)(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!a.cO(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const o=t;return r.BV.runKernel(i.Xz,o)}})},781:(e,t,n)=>{"use strict";n.d(t,{$:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({all_:function(e,t=null,n=!1){const a={x:(0,s._1)(e,"x","all","bool")},o={axis:t,keepDims:n};return r.BV.runKernel(i.oT,a,o)}})},2998:(e,t,n)=>{"use strict";n.d(t,{Y:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({any_:function(e,t=null,n=!1){const a={x:(0,s._1)(e,"x","any","bool")},o={axis:t,keepDims:n};return r.BV.runKernel(i.IK,a,o)}})},47:(e,t,n)=>{"use strict";n.d(t,{N:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({argMax_:function(e,t=0){const n={x:(0,s._1)(e,"x","argMax")},a={axis:t};return r.BV.runKernel(i.sJ,n,a)}})},7394:(e,t,n)=>{"use strict";n.d(t,{v:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({argMin_:function(e,t=0){const n={x:(0,s._1)(e,"x","argMin")},a={axis:t};return r.BV.runKernel(i.aJ,n,a)}})},2421:(e,t,n)=>{"use strict";n.d(t,{Z:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({asin_:function(e){const t={x:(0,s._1)(e,"x","asin")};return r.BV.runKernel(i.M2,t)}})},1891:(e,t,n)=>{"use strict";n.d(t,{V:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({asinh_:function(e){const t={x:(0,s._1)(e,"x","asinh")};return r.BV.runKernel(i.qw,t)}})},7037:(e,t,n)=>{"use strict";n.d(t,{z:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({atan_:function(e){const t={x:(0,s._1)(e,"x","atan")};return r.BV.runKernel(i.jM,t)}})},9812:(e,t,n)=>{"use strict";n.d(t,{f:()=>o});var r=n(7097),i=n(9121),s=n(747),a=n(3740);const o=(0,n(2668).op)({atan2_:function(e,t){let n=(0,a._1)(e,"a","atan2"),o=(0,a._1)(t,"b","atan2");[n,o]=(0,s.makeTypesMatch)(n,o);const l={a:n,b:o};return r.BV.runKernel(i.QC,l)}})},369:(e,t,n)=>{"use strict";n.d(t,{C:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({atanh_:function(e){const t={x:(0,s._1)(e,"x","atanh")};return r.BV.runKernel(i.Oy,t)}})},5176:(e,t,n)=>{"use strict";n.d(t,{w:()=>h});var r=n(7097),i=n(9121),s=n(3740),a=n(9115),o=n(2271),l=n(2582),c=n(2668),u=n(4968);const h=(0,c.op)({avgPool_:function(e,t,n,c,h){const d=(0,s._1)(e,"x","avgPool","float32");a.hu(l.jT(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let p=d,f=!1;3===d.rank&&(f=!0,p=(0,u.X)(d,[1,d.shape[0],d.shape[1],d.shape[2]])),a.hu(4===p.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${p.rank}.`)),l.m("avgPool",c,h);const m={x:p},g={filterSize:t,strides:n,pad:c,dimRoundingMode:h};let y=r.BV.runKernel(i.Jh,m,g);return y=(0,o.p)(y,d.dtype),f?(0,u.X)(y,[y.shape[1],y.shape[2],y.shape[3]]):y}})},1749:(e,t,n)=>{"use strict";n.d(t,{u:()=>h});var r=n(7097),i=n(9121),s=n(3740),a=n(9115),o=n(2582),l=n(2271),c=n(2668),u=n(4968);const h=(0,c.op)({avgPool3d_:function(e,t,n,c,h,d="NDHWC"){const p=(0,s._1)(e,"x","avgPool3d","float32");let f=p,m=!1;4===p.rank&&(m=!0,f=(0,u.X)(p,[1,p.shape[0],p.shape[1],p.shape[2],p.shape[3]])),a.hu(5===f.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${f.rank}.`)),a.hu("NDHWC"===d,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${d}`)),(0,o.m)("avgPool3d",c,h);const g={x:f},y={filterSize:t,strides:n,pad:c,dimRoundingMode:h,dataFormat:d};let v=r.BV.runKernel(i._k,g,y);return v=(0,l.p)(v,f.dtype),m?(0,u.X)(v,[v.shape[1],v.shape[2],v.shape[3],v.shape[4]]):v}})},3591:(e,t,n)=>{"use strict";n.d(t,{LJ:()=>u,Q3:()=>c,Vh:()=>s,YB:()=>i,kz:()=>a,lB:()=>l,rv:()=>o,sY:()=>h});var r=n(9115);function i(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function s(e,t,n){const r=e.length+t.length,i=[];let s=0,a=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?i.push(e[s++]):i.push(t[a++]);return i}function a(e,t){const n=[],r=e.length;for(let i=0;i<r;i++)-1===t.indexOf(i)&&n.push(e[i]);return[n,t.map((t=>e[t]))]}function o(e,t){return s(e,t.map((e=>1)),t)}function l(e,t,n){r.hu(i(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function c(e,t){if(i(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function u(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function h(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}},8441:(e,t,n)=>{"use strict";n.d(t,{E:()=>o});var r=n(7097),i=n(9121),s=n(3740),a=n(9115);const o=(0,n(2668).op)({batchToSpaceND_:function(e,t,n){const o=(0,s._1)(e,"x","batchToSpaceND"),l=t.reduce(((e,t)=>e*t));a.hu(o.rank>=1+t.length,(()=>`input rank is ${o.rank} but should be > than blockShape.length ${t.length}`)),a.hu(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),a.hu(o.shape[0]%l==0,(()=>`input tensor batch is ${o.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${l}`));const c={x:o},u={blockShape:t,crops:n};return r.BV.runKernel(i.zw,c,u)}})},7505:(e,t,n)=>{"use strict";n.d(t,{t:()=>l});var r=n(7097),i=n(9121),s=n(3740),a=n(9115),o=n(4968);const l=(0,n(2668).op)({batchNorm_:function(e,t,n,l,c,u){null==u&&(u=.001);const h=(0,s._1)(e,"x","batchNorm"),d=(0,s._1)(t,"mean","batchNorm"),p=(0,s._1)(n,"variance","batchNorm");let f,m;null!=c&&(f=(0,s._1)(c,"scale","batchNorm")),null!=l&&(m=(0,s._1)(l,"offset","batchNorm")),a.hu(d.rank===p.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),a.hu(null==m||d.rank===m.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),a.hu(null==f||d.rank===f.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const g=function(e){let t;return t=0===e.rank||1===e.rank?(0,o.X)(e,[1,1,1,e.size]):2===e.rank?(0,o.X)(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?(0,o.X)(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(h),y={x:g,scale:f,offset:m,mean:d,variance:p},v={varianceEpsilon:u},x=r.BV.runKernel(i.sH,y,v);return(0,o.X)(x,h.shape)}})},3865:(e,t,n)=>{"use strict";n.d(t,{y:()=>o});var r=n(7097),i=n(9121),s=n(3740),a=n(9115);const o=(0,n(2668).op)({bincount_:function(e,t,n){const o=(0,s._1)(e,"x","bincount"),l=(0,s._1)(t,"weights","bincount");a.hu("int32"===o.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${o.dtype}`)),a.hu(n>=0,(()=>`size must be non-negative, but got ${n}.`)),a.hu(l.size===o.size||0===l.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${o.shape}, weights shape: ${l.shape}.`));const c={x:o,weights:l},u={size:n};return r.BV.runKernel(i.zv,c,u)}})},8194:(e,t,n)=>{"use strict";n.d(t,{X:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({broadcastArgs_:function(e,t){const n=(0,s._1)(e,"s0","broadcastArgs","int32"),a=(0,s._1)(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==a.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${a.rank}`);const o={s0:n,s1:a};return r.BV.runKernel(i.eE,o)}})},8247:(e,t,n)=>{"use strict";n.d(t,{U:()=>c});var r=n(7097),i=n(9121),s=n(3740),a=n(8723),o=n(2668),l=n(4968);const c=(0,o.op)({broadcastTo_:function(e,t){let n=(0,s._1)(e,"broadcastTo","x");const o=n.shape;if(t.some((e=>!(e>0)||e%1!=0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=(0,l.X)(n,e)}const c=n.shape,u=Array.from(t);for(let e=t.length-1;e>=0;e--)if(c[e]===t[e])u[e]=1;else if(1!==n.shape[e])throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${t}].`);if(0===u.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return(0,a.d)(n);const h={x:n},d={reps:u};return r.BV.runKernel(i.n9,h,d)}})},2200:(e,t,n)=>{"use strict";function r(e,t){const n=e.length,r=[];for(let i=0;i<n;i++){const s=n-1-i,a=e[s]||1;(t[t.length-1-i]||1)>1&&1===a&&r.unshift(s)}return r}function i(e,t){const n=[];for(let r=0;r<t.length;r++){const i=e[e.length-r-1],s=t.length-r-1,a=t[s];(null==i||1===i&&a>1)&&n.unshift(s)}return n}function s(e,t){const n=[],r=Math.max(e.length,t.length);for(let i=0;i<r;i++){let r=e[e.length-i-1];null==r&&(r=1);let s=t[t.length-i-1];if(null==s&&(s=1),1===r)n.unshift(s);else if(1===s)n.unshift(r);else{if(r!==s)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);n.unshift(r)}}return n}n.r(t),n.d(t,{assertAndGetBroadcastShape:()=>s,getBroadcastDims:()=>r,getReductionAxes:()=>i})},2657:(e,t,n)=>{"use strict";n.d(t,{f:()=>s});var r=n(4077),i=n(9115);function s(e,t="float32",n){return t=t||"float32",i.Mu(e),new r.YD(e,t,n)}},2271:(e,t,n)=>{"use strict";n.d(t,{p:()=>o});var r=n(7097),i=n(9121),s=n(3740),a=n(9115);const o=(0,n(2668).op)({cast_:function(e,t){const n=(0,s._1)(e,"x","cast");if(!a.LP(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const o={x:n},l={dtype:t};return r.BV.runKernel(i.RF,o,l)}})},6825:(e,t,n)=>{"use strict";n.d(t,{m:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({ceil_:function(e){const t={x:(0,s._1)(e,"x","ceil","float32")};return r.BV.runKernel(i.gJ,t)}})},2279:(e,t,n)=>{"use strict";n.d(t,{i:()=>o});var r=n(7097),i=n(9121),s=n(3740),a=n(9115);const o=(0,n(2668).op)({clipByValue_:function(e,t,n){const o=(0,s._1)(e,"x","clipByValue");a.hu(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`));const l={x:o},c={clipValueMin:t,clipValueMax:n};return r.BV.runKernel(i.xn,l,c)}})},8723:(e,t,n)=>{"use strict";n.d(t,{d:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({clone_:function(e){const t={x:(0,s._1)(e,"x","clone","string_or_numeric")};return r.BV.runKernel(i.iJ,t)}})},1661:(e,t,n)=>{"use strict";n.d(t,{P:()=>o});var r=n(7097),i=n(9121),s=n(3740),a=n(9115);const o=(0,n(2668).op)({complex_:function(e,t){const n=(0,s._1)(e,"real","complex"),o=(0,s._1)(t,"imag","complex");a.k5(n.shape,o.shape,`real and imag shapes, ${n.shape} and ${o.shape}, must match in call to tf.complex().`);const l={real:n,imag:o};return r.BV.runKernel(i.Zz,l)}})},6884:(e,t,n)=>{"use strict";n.d(t,{z:()=>l});var r=n(7097),i=n(9121),s=n(3740),a=n(9115),o=n(8723);const l=(0,n(2668).op)({concat_:function(e,t=0){(0,a.hu)(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=(0,s.sI)(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return(0,o.d)(n[0]);const l=n,c={axis:t};return r.BV.runKernel(i.Eh,l,c)}})},1355:(e,t,n)=>{"use strict";n.d(t,{P:()=>c});var r=n(3740),i=n(9115),s=n(4794),a=n(2582),o=n(2668),l=n(4968);const c=(0,o.op)({conv1d_:function(e,t,n,o,c="NWC",u=1,h){const d=(0,r._1)(e,"x","conv1d"),p=(0,r._1)(t,"filter","conv1d");let f=d,m=!1;2===d.rank&&(m=!0,f=(0,l.X)(d,[1,d.shape[0],d.shape[1]])),i.hu(3===f.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${f.rank}.`)),i.hu(3===p.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${p.rank}.`)),a.m("conv1d",o,h),i.hu(f.shape[2]===p.shape[1],(()=>`Error in conv1d: depth of input (${f.shape[2]}) must match input depth for filter ${p.shape[1]}.`)),i.hu(a.jT(n,u),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${u}'`)),i.hu("NWC"===c,(()=>`Error in conv1d: got dataFormat of ${c} but only NWC is currently supported.`));const g=(0,l.X)(p,[1,p.shape[0],p.shape[1],p.shape[2]]),y=(0,l.X)(f,[f.shape[0],1,f.shape[1],f.shape[2]]),v=[1,n],x=[1,u],b=(0,s.T)(y,g,v,o,"NHWC",x,h);return m?(0,l.X)(b,[b.shape[2],b.shape[3]]):(0,l.X)(b,[b.shape[0],b.shape[2],b.shape[3]])}})},4794:(e,t,n)=>{"use strict";n.d(t,{T:()=>u});var r=n(7097),i=n(9121),s=n(3740),a=n(9115),o=n(2582),l=n(2668),c=n(4968);const u=(0,l.op)({conv2d_:function(e,t,n,l,u="NHWC",h=[1,1],d){const p=(0,s._1)(e,"x","conv2d","float32"),f=(0,s._1)(t,"filter","conv2d","float32");let m=p,g=!1;3===p.rank&&(g=!0,m=(0,c.X)(p,[1,p.shape[0],p.shape[1],p.shape[2]])),a.hu(4===m.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${m.rank}.`)),a.hu(4===f.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${f.rank}.`)),o.m("conv2d",l,d);const y="NHWC"===u?m.shape[3]:m.shape[1];a.hu(y===f.shape[2],(()=>`Error in conv2d: depth of input (${y}) must match input depth for filter ${f.shape[2]}.`)),a.hu(o.jT(n,h),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${h}'`));const v={x:m,filter:f},x={strides:n,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d},b=r.BV.runKernel(i.mh,v,x);return g?(0,c.X)(b,[b.shape[1],b.shape[2],b.shape[3]]):b}})},6013:(e,t,n)=>{"use strict";n.d(t,{p:()=>c});var r=n(7097),i=n(9121),s=n(9115),a=n(2582),o=n(2668),l=n(4968);const c=(0,o.op)({conv2DBackpropFilter_:function(e,t,n,o,c,u="NHWC",h){let d=e;3===e.rank&&(d=(0,l.X)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let p=t;3===p.rank&&(p=(0,l.X)(t,[1,t.shape[0],t.shape[1],t.shape[2]])),s.hu(4===d.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${d.shape}.`)),s.hu(4===p.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${p.shape}.`)),s.hu(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const f="NHWC"===u?d.shape[3]:d.shape[1],m="NHWC"===u?p.shape[3]:p.shape[1];s.hu(f===n[2],(()=>`Error in conv2dDerFilter: depth of input ${f}) must match input depth in filter (${n[2]}.`)),s.hu(m===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${m}) must match output depth for filter (${n[3]}).`)),a.m("conv2dDerFilter",c,h);const g={x:d,dy:p},y={strides:o,pad:c,dataFormat:u,dimRoundingMode:h,filterShape:n};return r.BV.runKernel(i.wU,g,y)}})},9832:(e,t,n)=>{"use strict";n.d(t,{_:()=>c});var r=n(7097),i=n(9121),s=n(9115),a=n(2582),o=n(2668),l=n(4968);const c=(0,o.op)({conv2DBackpropInput_:function(e,t,n,o,c,u="NHWC",h){s.hu(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let d=e,p=t,f=!1;3===t.rank&&(f=!0,p=(0,l.X)(t,[1,t.shape[0],t.shape[1],t.shape[2]]),d=[1,e[0],e[1],e[2]]),s.hu(4===d.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${d.length}.`)),s.hu(4===p.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${p.rank}`)),s.hu(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const m="NHWC"===u?d[3]:d[1],g="NHWC"===u?p.shape[3]:p.shape[1];s.hu(m===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${m}) must match input depth for filter ${n.shape[2]}.`)),s.hu(g===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${g}) must match output depth for filter ${n.shape[3]}.`)),a.m("conv2dDerInput",c,h);const y={dy:p,filter:n},v={strides:o,pad:c,dataFormat:u,dimRoundingMode:h,inputShape:d},x=r.BV.runKernel(i.wm,y,v);return f?(0,l.X)(x,[x.shape[1],x.shape[2],x.shape[3]]):x}})},1405:(e,t,n)=>{"use strict";n.d(t,{b:()=>s});var r=n(3740),i=n(9832);const s=(0,n(2668).op)({conv2dTranspose_:function(e,t,n,s,a,o){const l=(0,r._1)(e,"x","conv2dTranspose"),c=(0,r._1)(t,"filter","conv2dTranspose");return(0,i._)(n,l,c,s,a,"NHWC",o)}})},473:(e,t,n)=>{"use strict";n.d(t,{p:()=>u});var r=n(7097),i=n(9121),s=n(3740),a=n(9115),o=n(2582),l=n(2668),c=n(4968);const u=(0,l.op)({conv3d_:function(e,t,n,l,u="NDHWC",h=[1,1,1]){const d=(0,s._1)(e,"x","conv3d"),p=(0,s._1)(t,"filter","conv3d");let f=d,m=!1;4===d.rank&&(m=!0,f=(0,c.X)(d,[1,d.shape[0],d.shape[1],d.shape[2],d.shape[3]])),a.hu(5===f.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${f.rank}.`)),a.hu(5===p.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${p.rank}.`)),a.hu(f.shape[4]===p.shape[3],(()=>`Error in conv3d: depth of input (${f.shape[4]}) must match input depth for filter ${p.shape[3]}.`)),a.hu((0,o.jT)(n,h),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${h}'`)),a.hu("NDHWC"===u,(()=>`Error in conv3d: got dataFormat of ${u} but only NDHWC is currently supported.`));const g={x:f,filter:p},y={strides:n,pad:l,dataFormat:u,dilations:h},v=r.BV.runKernel(i.x1,g,y);return m?(0,c.X)(v,[v.shape[1],v.shape[2],v.shape[3],v.shape[4]]):v}})},7594:(e,t,n)=>{"use strict";n.d(t,{_:()=>l});var r=n(7097),i=n(9121),s=n(9115),a=n(2668),o=n(4968);const l=(0,a.op)({conv3DBackpropInput_:function(e,t,n,a,l){s.hu(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let c=e,u=t,h=!1;4===t.rank&&(h=!0,u=(0,o.X)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),c=[1,e[0],e[1],e[2],e[3]]);const d=c[4],p=u.shape[4];s.hu(5===c.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${c.length}.`)),s.hu(5===u.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${u.rank}`)),s.hu(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),s.hu(d===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${d}) must match input depth for filter ${n.shape[3]}.`)),s.hu(p===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${p}) must match output depth for filter ${n.shape[4]}.`));const f={dy:u,filter:n},m={pad:l,strides:a,inputShape:c},g=r.BV.runKernel(i.ik,f,m);return h?(0,o.X)(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}})},2582:(e,t,n)=>{"use strict";n.d(t,{I0:()=>f,Ix:()=>o,Rf:()=>i,Xw:()=>s,aO:()=>c,jT:()=>m,jw:()=>l,m:()=>y,pl:()=>a,sl:()=>g});var r=n(9115);function i(e,t,n,r,i="NHWC",s){return o(e,[...t,e[3]],n,s,r,null,null,g(i))}function s(e,t,n,r,i,s,a="channelsLast"){const[l,c]=u(t);let h;if("channelsLast"===a)h=[l,c,e[3],e[3]];else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);h=[l,c,e[1],e[1]]}return o(e,h,n,r,i,s,!1,a)}function a(e,t,n,r,i,s,a="NDHWC"){const[o,c,u]=h(t);let d,p;if("NDHWC"===a)p="channelsLast",d=[o,c,u,e[4],e[4]];else{if("NCDHW"!==a)throw new Error(`Unknown dataFormat ${a}`);p="channelsFirst",d=[o,c,u,e[1],e[1]]}return l(e,d,n,r,i,!1,p,s)}function o(e,t,n,r,i,s,a=!1,o="channelsLast"){let[l,h,f,m]=[-1,-1,-1,-1];if("channelsLast"===o)[l,h,f,m]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,m,h,f]=e}const[g,y,,v]=t,[x,b]=u(n),[w,_]=u(r),S=d(g,w),M=d(y,_),{padInfo:T,outHeight:E,outWidth:A}=function(e,t,n,r,i,s,a,o,l){let u,h,d;if("number"==typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const i=function(e,t,n,r,i){null==r&&(r=c(e,t,n));const s=e[1];return[p((e[0]-t+2*r)/n+1,i),p((s-t+2*r)/n+1,i)]}([t,n],s,r,e,o);h=i[0],d=i[1]}else if("same"===e){h=Math.ceil(t/r),d=Math.ceil(n/i);const e=Math.max(0,(h-1)*r+s-t),o=Math.max(0,(d-1)*i+a-n),l=Math.floor(e/2),c=e-l,p=Math.floor(o/2);u={top:l,bottom:c,left:p,right:o-p,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((t-s+1)/r),d=Math.ceil((n-a+1)/i);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const c="channelsLast"===l?e[1][0]:e[2][0],f="channelsLast"===l?e[1][1]:e[2][1],m="channelsLast"===l?e[2][0]:e[3][0],g="channelsLast"===l?e[2][1]:e[3][1];u={top:c,bottom:f,left:m,right:g,type:0===c&&0===f&&0===m&&0===g?"VALID":"EXPLICIT"},h=p((t-s+c+f)/r+1,o),d=p((n-a+m+g)/i+1,o)}}return{padInfo:u,outHeight:h,outWidth:d}}(i,h,f,x,b,S,M,s,o),C=a?v*m:v;let I;return"channelsFirst"===o?I=[l,C,E,A]:"channelsLast"===o&&(I=[l,E,A,C]),{batchSize:l,dataFormat:o,inHeight:h,inWidth:f,inChannels:m,outHeight:E,outWidth:A,outChannels:C,padInfo:T,strideHeight:x,strideWidth:b,filterHeight:g,filterWidth:y,effectiveFilterHeight:S,effectiveFilterWidth:M,dilationHeight:w,dilationWidth:_,inShape:e,outShape:I,filterShape:t}}function l(e,t,n,r,i,s=!1,a="channelsLast",o){let[l,u,f,m,g]=[-1,-1,-1,-1,-1];if("channelsLast"===a)[l,u,f,m,g]=e;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,g,u,f,m]=e}const[y,v,x,,b]=t,[w,_,S]=h(n),[M,T,E]=h(r),A=d(y,M),C=d(v,T),I=d(x,E),{padInfo:N,outDepth:k,outHeight:R,outWidth:D}=function(e,t,n,r,i,s,a,o,l,u,h){let d,f,m,g;if("number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,r,i,s){null==i&&(i=c(e,t,r));const a=e[1],o=e[2];return[p((e[0]-t+2*i)/r+1,s),p((a-t+2*i)/r+1,s),p((o-t+2*i)/r+1,s),1]}([t,n,r,1],o,0,i,e,h);f=s[0],m=s[1],g=s[2]}else if("same"===e){f=Math.ceil(t/i),m=Math.ceil(n/s),g=Math.ceil(r/a);const e=(f-1)*i+o-t,c=(m-1)*s+l-n,h=(g-1)*a+u-r,p=Math.floor(e/2),y=e-p,v=Math.floor(c/2),x=c-v,b=Math.floor(h/2);d={top:v,bottom:x,left:b,right:h-b,front:p,back:y,type:"SAME"}}else{if("valid"!==e)throw Error(`Unknown padding parameter: ${e}`);d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},f=Math.ceil((t-o+1)/i),m=Math.ceil((n-l+1)/s),g=Math.ceil((r-u+1)/a)}return{padInfo:d,outDepth:f,outHeight:m,outWidth:g}}(i,u,f,m,w,_,S,A,C,I,o),L=s?b*g:b;let F;return"channelsFirst"===a?F=[l,L,k,R,D]:"channelsLast"===a&&(F=[l,k,R,D,L]),{batchSize:l,dataFormat:a,inDepth:u,inHeight:f,inWidth:m,inChannels:g,outDepth:k,outHeight:R,outWidth:D,outChannels:L,padInfo:N,strideDepth:w,strideHeight:_,strideWidth:S,filterDepth:y,filterHeight:v,filterWidth:x,effectiveFilterDepth:A,effectiveFilterHeight:C,effectiveFilterWidth:I,dilationDepth:M,dilationHeight:T,dilationWidth:E,inShape:e,outShape:F,filterShape:t}}function c(e,t,n,r=1){const i=d(t,r);return Math.floor((e[0]*(n-1)-n+i)/2)}function u(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function h(e){return"number"==typeof e?[e,e,e]:e}function d(e,t){return t<=1?e:e+(e-1)*(t-1)}function p(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function f(e){const[t,n,r]=u(e);return 1===t&&1===n&&1===r}function m(e,t){return f(e)||f(t)}function g(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function y(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)r.hu(r.GN(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{r.hu(r.GN(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}},173:(e,t,n)=>{"use strict";n.d(t,{m:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({cos_:function(e){const t={x:(0,s._1)(e,"x","cos","float32")};return r.BV.runKernel(i.mc,t)}})},2699:(e,t,n)=>{"use strict";n.d(t,{f:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({cosh_:function(e){const t={x:(0,s._1)(e,"x","cosh","float32")};return r.BV.runKernel(i.TR,t)}})},9640:(e,t,n)=>{"use strict";n.d(t,{$:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({cumprod_:function(e,t=0,n=!1,a=!1){const o={x:(0,s._1)(e,"x","cumprod")},l={axis:t,exclusive:n,reverse:a};return r.BV.runKernel(i.By,o,l)}})},7405:(e,t,n)=>{"use strict";n.d(t,{z:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({cumsum_:function(e,t=0,n=!1,a=!1){const o={x:(0,s._1)(e,"x","cumsum")},l={axis:t,exclusive:n,reverse:a};return r.BV.runKernel(i.iH,o,l)}})},5746:(e,t,n)=>{"use strict";n.d(t,{p:()=>o});var r=n(7097),i=n(9121),s=n(3740),a=n(9115);const o=(0,n(2668).op)({denseBincount_:function(e,t,n,o=!1){const l=(0,s._1)(e,"x","denseBincount"),c=(0,s._1)(t,"weights","denseBincount");a.hu("int32"===l.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${l.dtype}`)),a.hu(l.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${l.rank}.`)),a.hu(n>=0,(()=>`size must be non-negative, but got ${n}.`)),a.hu(c.size===l.size||0===c.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${l.shape}, weights shape: ${c.shape}.`));const u={x:l,weights:c},h={size:n,binaryOutput:o};return r.BV.runKernel(i.QR,u,h)}})},9112:(e,t,n)=>{"use strict";n.d(t,{n:()=>o});var r=n(7097),i=n(9121),s=n(3740),a=n(9115);const o=(0,n(2668).op)({depthToSpace_:function(e,t,n="NHWC"){const o=(0,s._1)(e,"x","depthToSpace","float32"),l="NHWC"===n?o.shape[1]:o.shape[2],c="NHWC"===n?o.shape[2]:o.shape[3],u="NHWC"===n?o.shape[3]:o.shape[1];a.hu(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),a.hu(l*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${l} and ${t}  for depthToSpace with input shape\n    ${o.shape}`)),a.hu(c*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${c} and ${t} for depthToSpace with input shape\n        ${o.shape}`)),a.hu(u%(t*t)==0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${u} for depthToSpace with input shape ${o.shape}`));const h={x:o},d={blockSize:t,dataFormat:n};return r.BV.runKernel(i.T0,h,d)}})},4718:(e,t,n)=>{"use strict";n.d(t,{B:()=>u});var r=n(7097),i=n(9121),s=n(3740),a=n(9115),o=n(2582),l=n(2668),c=n(4968);const u=(0,l.op)({depthwiseConv2d_:function(e,t,n,l,u="NHWC",h=[1,1],d){const p=(0,s._1)(e,"x","depthwiseConv2d","float32"),f=(0,s._1)(t,"filter","depthwiseConv2d","float32");let m=p,g=!1;3===p.rank&&(g=!0,m=(0,c.X)(p,[1,p.shape[0],p.shape[1],p.shape[2]])),a.hu(4===m.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${m.rank}.`)),a.hu(4===f.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`)),a.hu(m.shape[3]===f.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${m.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`)),o.m("depthwiseConv2d",l,d);const y={x:m,filter:f},v={strides:n,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d},x=r.BV.runKernel(i.ci,y,v);return g?(0,c.X)(x,[x.shape[1],x.shape[2],x.shape[3]]):x}})},8098:(e,t,n)=>{"use strict";n.d(t,{z:()=>o});var r=n(7097),i=n(9121),s=n(2668),a=n(4968);const o=(0,s.op)({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,s,o,l=[1,1],c){let u=e;3===e.rank&&(u=(0,a.X)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let h=t;3===h.rank&&(h=(0,a.X)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const d={x:u,dy:h},p={strides:s,pad:o,dimRoundingMode:c,dilations:l,filterShape:n};return r.BV.runKernel(i.sL,d,p)}})},4375:(e,t,n)=>{"use strict";n.d(t,{v:()=>o});var r=n(7097),i=n(9121),s=n(2668),a=n(4968);const o=(0,s.op)({depthwiseConv2dNativeBackpropInput_:function(e,t,n,s,o,l=[1,1],c){let u=t,h=!1;3===t.rank&&(h=!0,u=(0,a.X)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const d={dy:u,filter:n},p={strides:s,pad:o,dimRoundingMode:c,dilations:l,inputShape:e},f=r.BV.runKernel(i.y7,d,p);return h?(0,a.X)(f,[f.shape[1],f.shape[2],f.shape[3]]):f}})},557:(e,t,n)=>{"use strict";n.d(t,{W:()=>c});var r=n(7097),i=n(9121),s=n(3740),a=n(9115),o=n(2668),l=n(4968);const c=(0,o.op)({dilation2d_:function(e,t,n,o,c=[1,1],u="NHWC"){const h=(0,s._1)(e,"x","dilation2d"),d=(0,s._1)(t,"filter","dilation2d");a.hu(3===h.rank||4===h.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${h.rank}.`)),a.hu(3===d.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${d.rank}.`)),a.hu("NHWC"===u,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${u}`));let p=h,f=!1;3===h.rank&&(p=(0,l.X)(h,[1,h.shape[0],h.shape[1],h.shape[2]]),f=!0);const m={x:p,filter:d},g={strides:n,pad:o,dilations:c},y=r.BV.runKernel(i.p4,m,g);return f?(0,l.X)(y,[y.shape[1],y.shape[2],y.shape[3]]):y}})},1274:(e,t,n)=>{"use strict";n.d(t,{h:()=>l});var r=n(7097),i=n(9121),s=n(747),a=n(3740),o=n(9165);const l=(0,n(2668).op)({div_:function(e,t){let n=(0,a._1)(e,"a","div"),l=(0,a._1)(t,"b","div");if([n,l]=(0,s.makeTypesMatch)(n,l),"int32"===n.dtype&&"int32"===l.dtype)return(0,o.q)(n,l);const c={a:n,b:l};return r.BV.runKernel(i.oH,c,{})}})},9322:(e,t,n)=>{"use strict";n.d(t,{N:()=>u});var r=n(747),i=n(3740),s=n(1274),a=n(6477),o=n(2668),l=n(5912),c=n(6577);const u=(0,o.op)({divNoNan_:function(e,t){let n=(0,i._1)(e,"a","div"),o=(0,i._1)(t,"b","div");[n,o]=(0,r.makeTypesMatch)(n,o);const u=(0,s.h)(n,o),h=(0,c.P)(u),d=(0,a.D)(o,h);return(0,l.a)(d,h,u)}})},548:(e,t,n)=>{"use strict";n.d(t,{A:()=>l});var r=n(3740),i=n(9115),s=n(8687),a=n(2668),o=n(4968);const l=(0,a.op)({dot_:function(e,t){const n=(0,r._1)(e,"t1","dot"),a=(0,r._1)(t,"t2","dot");i.hu(!(1!==n.rank&&2!==n.rank||1!==a.rank&&2!==a.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${a.rank}.`));const l=1===n.rank?n.size:n.shape[1],c=1===a.rank?a.size:a.shape[0];if(i.hu(l===c,(()=>`Error in dot: inner dimensions of inputs must match, but got ${l} and ${c}.`)),1===n.rank&&1===a.rank){const e=(0,o.X)(n,[1,-1]),t=(0,o.X)(a,[-1,1]),r=(0,s.O)(e,t);return(0,o.X)(r,[])}if(1===n.rank&&2===a.rank){const e=(0,o.X)(n,[1,-1]),t=(0,o.X)(a,[a.shape[0],a.shape[1]]),r=(0,s.O)(e,t);return(0,o.X)(r,[r.size])}if(2===n.rank&&1===a.rank){const e=(0,o.X)(a,[-1,1]),t=(0,s.O)(n,e);return(0,o.X)(t,[t.size])}{const e=(0,o.X)(a,[a.shape[0],a.shape[1]]);return(0,s.O)(n,e)}}})},4653:(e,t,n)=>{"use strict";n.d(t,{W:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({einsum_:function(e,...t){const n=t.map(((e,t)=>(0,s._1)(e,`tensors${t}`,"einsum"))),a={equation:e};return r.BV.runKernel(i.$g,n,a)}})},3233:(e,t,n)=>{"use strict";n.d(t,{p:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({elu_:function(e){const t={x:(0,s._1)(e,"x","elu","float32")};return r.BV.runKernel(i.SX,t)}})},6477:(e,t,n)=>{"use strict";n.d(t,{D:()=>l});var r=n(7097),i=n(9121),s=n(747),a=n(3740),o=n(2200);const l=(0,n(2668).op)({equal_:function(e,t){let n=(0,a._1)(e,"a","equal","string_or_numeric"),l=(0,a._1)(t,"b","equal","string_or_numeric");[n,l]=(0,s.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const c={a:n,b:l};return r.BV.runKernel(i.hd,c)}})},4650:(e,t,n)=>{"use strict";n.d(t,{q:()=>l});var r=n(7097),i=n(9121),s=n(3740),a=n(9115),o=n(2271);const l=(0,n(2668).op)({erf_:function(e){let t=(0,s._1)(e,"x","erf");a.hu("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=(0,o.p)(t,"float32"));const n={x:t};return r.BV.runKernel(i.Om,n)}})},1954:(e,t,n)=>{"use strict";n.d(t,{d:()=>i});var r=n(3561);const i=(0,n(2668).op)({euclideanNorm_:function(e,t=null,n=!1){return(0,r.K)(e,"euclidean",t,n)}})},4842:(e,t,n)=>{"use strict";n.d(t,{Q:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({exp_:function(e){const t={x:(0,s._1)(e,"x","exp")};return r.BV.runKernel(i.NE,t)}})},1300:(e,t,n)=>{"use strict";n.d(t,{d:()=>o});var r=n(7097),i=n(9121),s=n(3740),a=n(9115);const o=(0,n(2668).op)({expandDims_:function(e,t=0){const n=(0,s._1)(e,"x","expandDims","string_or_numeric");a.hu(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const o={input:n},l={dim:t};return r.BV.runKernel(i.YF,o,l)}})},3426:(e,t,n)=>{"use strict";n.d(t,{t:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({expm1_:function(e){const t={x:(0,s._1)(e,"x","expm1")};return r.BV.runKernel(i.Y0,t)}})},4006:(e,t,n)=>{"use strict";n.d(t,{h:()=>s});var r=n(7097),i=n(9121);function s(e,t,n){const s={shape:e,value:t,dtype:n};return r.BV.runKernel(i.de,{},s)}},6943:(e,t,n)=>{"use strict";n.d(t,{G:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({floor_:function(e){const t={x:(0,s._1)(e,"x","floor","float32")};return r.BV.runKernel(i.OR,t)}})},9165:(e,t,n)=>{"use strict";n.d(t,{q:()=>o});var r=n(7097),i=n(9121),s=n(747),a=n(3740);const o=(0,n(2668).op)({floorDiv_:function(e,t){let n=(0,a._1)(e,"a","floorDiv"),o=(0,a._1)(t,"b","floorDiv");[n,o]=(0,s.makeTypesMatch)(n,o);const l={a:n,b:o};return r.BV.runKernel(i.je,l)}})},4624:(e,t,n)=>{"use strict";n.r(t),n.d(t,{conv2d:()=>v,depthwiseConv2d:()=>_,matMul:()=>M});var r=n(7097),i=n(633),s=n(9121),a=n(747),o=n(3740),l=n(9115),c=n(6407),u=n(2200),h=n(4794),d=n(6013),p=n(9832),f=n(2582),m=n(9323),g=n(2668),y=n(4968);const v=(0,g.op)({fusedConv2d_:function({x:e,filter:t,strides:n,pad:g,dataFormat:v="NHWC",dilations:x=[1,1],dimRoundingMode:b,bias:w,activation:_="linear",preluActivationWeights:S,leakyreluAlpha:M}){if(_=_||"linear",!1===(0,m.uy)(r.BV.state.gradientDepth,_)){l.hu("NHWC"===v,(()=>`Error in fused conv2d: got dataFormat of ${v} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let r=(0,h.T)(e,t,n,g,v,x,b);return null!=w&&(r=(0,c.I)(r,w)),(0,m.QH)(r,_,S,M)}const T=(0,o._1)(e,"x","conv2d","float32"),E=(0,o._1)(t,"filter","conv2d","float32");let A=T,C=!1;3===T.rank&&(C=!0,A=(0,y.X)(T,[1,T.shape[0],T.shape[1],T.shape[2]])),l.hu(4===A.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${A.rank}.`)),l.hu(4===E.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${E.rank}.`)),f.m("fused conv2d",g,b);const I="NHWC"===v?A.shape[3]:A.shape[1];l.hu(E.shape[2]===I,(()=>`Error in conv2d: depth of input (${I}) must match input depth for filter ${E.shape[2]}.`)),l.hu(f.jT(n,x),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${x}'`));const N=f.Ix(A.shape,E.shape,n,x,g,b);let k,R;if(null!=w&&(k=(0,o._1)(w,"bias","fused conv2d"),[k]=(0,a.makeTypesMatch)(k,T),"NHWC"===v?u.assertAndGetBroadcastShape(N.outShape,k.shape):(l.hu(k.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${k.shape.length}.`)),l.hu(0===k.shape.length||k.shape[0]===N.outChannels||1===k.shape[0],(()=>`Error in fused conv2d: bias shape (${k.shape}) is not compatible with the number of output channels (${N.outChannels})`)))),null!=S){const e=S.shape;if(l.hu(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)l.hu(1===e[0]||e[0]===N.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${N.outChannels}).`));else if(3===e.length)try{u.assertAndGetBroadcastShape(e,N.outShape)}catch(t){const n=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${N.outShape}).`;throw Error(n)}R=(0,o._1)(S,"prelu weights","fused conv2d")}const D=(e,t)=>{l.hu("NHWC"===v,(()=>`Error in gradient of fused conv2D: got dataFormat of ${v} but only NHWC is currently supported.`));const[r,i,s,a]=t,o=(0,m.Fr)(e,s,_);l.hu(f.I0(x),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${x}'`));const c=[(0,p._)(i.shape,o,r,n,g),(0,d.p)(i,o,r.shape,n,g)];if(null!=a){const e=(0,m.pf)(a,o);c.push(e)}return c},L={x:A,filter:E,bias:k,preluActivationWeights:R},F={strides:n,pad:g,dataFormat:v,dilations:x,dimRoundingMode:b,activation:_,leakyreluAlpha:M};if(null==w){const e=(0,i.cb)(((e,t,n)=>{let i=r.BV.runKernel(s._V,L,F);return n([t,e,i]),C&&(i=(0,y.X)(i,[i.shape[1],i.shape[2],i.shape[3]])),{value:i,gradFunc:D}}));return e(A,E)}{const e=(0,i.cb)(((e,t,n,i)=>{let a=r.BV.runKernel(s._V,L,F);return i([t,e,a,n]),C&&(a=(0,y.X)(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:D}}));return e(A,E,k)}}});var x=n(4718),b=n(8098),w=n(4375);const _=(0,g.op)({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:n,pad:h,dataFormat:d="NHWC",dilations:p=[1,1],dimRoundingMode:g,bias:v,activation:_="linear",preluActivationWeights:S,leakyreluAlpha:M}){if(!1===(0,m.uy)(r.BV.state.gradientDepth,_)){let r=(0,x.B)(e,t,n,h,d,p,g);return null!=v&&(r=(0,c.I)(r,v)),(0,m.QH)(r,_,S,M)}const T=(0,o._1)(e,"x","depthwiseConv2d","float32"),E=(0,o._1)(t,"filter","depthwiseConv2d","float32");let A=T,C=!1;3===T.rank&&(C=!0,A=(0,y.X)(T,[1,T.shape[0],T.shape[1],T.shape[2]])),l.hu(4===A.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${A.rank}.`)),l.hu(4===E.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${E.rank}.`)),l.hu(A.shape[3]===E.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${A.shape[3]}) must match the inChannels dimension in filter ${E.shape[2]}.`)),null==p&&(p=[1,1]),l.hu(f.jT(n,p),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${p}'`)),f.m("fused depthwiseConv2d",h,g);const I=f.Ix(A.shape,E.shape,n,p,h,g,!0);let N,k;null!=v&&(N=(0,o._1)(v,"bias","fused conv2d"),[N]=(0,a.makeTypesMatch)(N,T),u.assertAndGetBroadcastShape(I.outShape,N.shape)),null!=S&&(k=(0,o._1)(S,"prelu weights","fused depthwiseConv2d"));const R=(e,t)=>{l.hu(f.I0(p),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${p}'`));const[r,i,s,a]=t,o=(0,m.Fr)(e,s,_),c=(0,w.v)(i.shape,o,r,n,h,p,g),u=(0,b.z)(i,o,r.shape,n,h,p,g);return null!=a?[c,u,(0,m.pf)(N,o)]:[c,u]},D={x:A,filter:E,bias:N,preluActivationWeights:k},L={strides:n,pad:h,dataFormat:d,dilations:p,dimRoundingMode:g,activation:_,leakyreluAlpha:M};if(null==v){const e=(0,i.cb)(((e,t,n)=>{let i=r.BV.runKernel(s.lu,D,L);return n([t,e,i]),C&&(i=(0,y.X)(i,[i.shape[1],i.shape[2],i.shape[3]])),{value:i,gradFunc:R}}));return e(A,E)}{const e=(0,i.cb)(((e,t,n,i)=>{let a=r.BV.runKernel(s.lu,D,L);return i([t,e,a,n]),C&&(a=(0,y.X)(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:R}}));return e(A,E,N)}}});var S=n(8687);const M=(0,g.op)({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:h=!1,bias:d,activation:p="linear",preluActivationWeights:f,leakyreluAlpha:g}){if(!1===(0,m.uy)(r.BV.state.gradientDepth,p)){let r=(0,S.O)(e,t,n,h);return null!=d&&(r=(0,c.I)(r,d)),(0,m.QH)(r,p,f,g)}let v=(0,o._1)(e,"a","fused matMul"),x=(0,o._1)(t,"b","fused matMul");[v,x]=(0,a.makeTypesMatch)(v,x);const b=n?v.shape[v.rank-2]:v.shape[v.rank-1],w=h?x.shape[x.rank-1]:x.shape[x.rank-2],_=n?v.shape[v.rank-1]:v.shape[v.rank-2],M=h?x.shape[x.rank-2]:x.shape[x.rank-1],T=v.shape.slice(0,-2),E=x.shape.slice(0,-2),A=l.NA(T),C=l.NA(E);l.hu(b===w,(()=>`Error in fused matMul: inner shapes (${b}) and (${w}) of Tensors with shapes ${v.shape} and ${x.shape} and transposeA=${n} and transposeB=${h} must match.`));const I=u.assertAndGetBroadcastShape(v.shape.slice(0,-2),x.shape.slice(0,-2)).concat([_,M]),N=n?(0,y.X)(v,[A,b,_]):(0,y.X)(v,[A,_,b]),k=h?(0,y.X)(x,[C,M,w]):(0,y.X)(x,[C,w,M]);let R,D;null!=d&&(R=(0,o._1)(d,"bias","fused matMul"),[R]=(0,a.makeTypesMatch)(R,v),u.assertAndGetBroadcastShape(I,R.shape)),null!=f&&(D=(0,o._1)(f,"prelu weights","fused matMul"));const L=(e,t)=>{const[r,i,s,a]=t,o=(0,m.Fr)((0,y.X)(e,s.shape),s,p);let l,c;return n||h?!n&&h?(l=(0,S.O)(o,i,!1,!1),c=(0,S.O)(o,r,!0,!1)):n&&!h?(l=(0,S.O)(i,o,!1,!0),c=(0,S.O)(r,o,!1,!1)):(l=(0,S.O)(i,o,!0,!0),c=(0,S.O)(o,r,!0,!0)):(l=(0,S.O)(o,i,!1,!0),c=(0,S.O)(r,o,!0,!1)),null!=d?[l,c,(0,m.pf)(a,o)]:[l,c]},F={a:N,b:k,bias:R,preluActivationWeights:D},P={transposeA:n,transposeB:h,activation:p,leakyreluAlpha:g};if(null==d){const e=(0,i.cb)(((e,t,n)=>{const i=r.BV.runKernel(s.us,F,P);return n([e,t,i]),{value:(0,y.X)(i,I),gradFunc:L}}));return e(N,k)}{const e=(0,i.cb)(((e,t,n,i)=>{const a=r.BV.runKernel(s.us,F,P);return i([e,t,a,n]),{value:(0,y.X)(a,I),gradFunc:L}}));return e(N,k,R)}}})},9323:(e,t,n)=>{"use strict";n.d(t,{Fr:()=>f,QH:()=>g,pf:()=>m,uy:()=>y});var r=n(2200),i=n(3233),s=n(9133),a=n(4841),o=n(8151),l=n(7409),c=n(3582),u=n(4968),h=n(625),d=n(1901),p=n(5475);function f(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return(0,a.d)(e,(0,d.N)(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function m(e,t){let n=t;const i=r.getReductionAxes(e.shape,t.shape);return i.length>0&&(n=(0,p.S)(n,i)),(0,u.X)(n,e.shape)}function g(e,t,n,r){if("linear"===t)return e;if("relu"===t)return(0,l.U)(e);if("elu"===t)return(0,i.p)(e);if("relu6"===t)return(0,c.b)(e);if("prelu"===t)return(0,o.A)(e,n);if("leakyrelu"===t)return(0,s.h)(e,r);if("sigmoid"===t)return(0,h.X)(e);throw new Error(`Unknown fused activation ${t}.`)}const y=(e,t)=>!(e>0)||"linear"===t},4926:(e,t,n)=>{"use strict";n.d(t,{I:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({gather_:function(e,t,n=0,a=0){const o={x:(0,s._1)(e,"x","gather"),indices:(0,s._1)(t,"indices","gather","int32")},l={axis:n,batchDims:a};return r.BV.runKernel(i.qi,o,l)}})},7494:(e,t,n)=>{"use strict";n.d(t,{d:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({gatherND_:function(e,t){const n=(0,s._1)(t,"indices","gatherND","int32"),a={params:(0,s._1)(e,"x","gatherND","string_or_numeric"),indices:n};return r.BV.runKernel(i.q1,a)}})},636:(e,t,n)=>{"use strict";n.d(t,{p:()=>l});var r=n(7097),i=n(9121),s=n(747),a=n(3740),o=n(2200);const l=(0,n(2668).op)({greater_:function(e,t){let n=(0,a._1)(e,"a","greater","string_or_numeric"),l=(0,a._1)(t,"b","greater","string_or_numeric");[n,l]=(0,s.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const c={a:n,b:l};return r.BV.runKernel(i.iZ,c)}})},7630:(e,t,n)=>{"use strict";n.d(t,{b:()=>l});var r=n(7097),i=n(9121),s=n(747),a=n(3740),o=n(2200);const l=(0,n(2668).op)({greaterEqual_:function(e,t){let n=(0,a._1)(e,"a","greaterEqual","string_or_numeric"),l=(0,a._1)(t,"b","greaterEqual","string_or_numeric");[n,l]=(0,s.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const c={a:n,b:l};return r.BV.runKernel(i.Ac,c)}})},4386:(e,t,n)=>{"use strict";n.d(t,{a:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({imag_:function(e){const t={input:(0,s._1)(e,"input","imag")};return r.BV.runKernel(i.J_,t)}})},3305:(e,t,n)=>{"use strict";n.d(t,{I:()=>c});var r=n(7097),i=n(9121),s=n(3740),a=n(9115),o=n(2668),l=n(4968);const c=(0,o.op)({resizeBilinear_:function(e,t,n=!1,o=!1){const c=(0,s._1)(e,"images","resizeBilinear");a.hu(3===c.rank||4===c.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${c.rank}.`)),a.hu(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),a.hu(!1===o||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let u=c,h=!1;3===c.rank&&(h=!0,u=(0,l.X)(c,[1,c.shape[0],c.shape[1],c.shape[2]]));const[]=t,d={images:u},p={alignCorners:n,halfPixelCenters:o,size:t},f=r.BV.runKernel(i._Y,d,p);return h?(0,l.X)(f,[f.shape[1],f.shape[2],f.shape[3]]):f}})},5098:(e,t,n)=>{"use strict";n.d(t,{j:()=>c});var r=n(7097),i=n(9121),s=n(3740),a=n(9115),o=n(2668),l=n(4968);const c=(0,o.op)({resizeNearestNeighbor_:function(e,t,n=!1,o=!1){const c=(0,s._1)(e,"images","resizeNearestNeighbor");a.hu(3===c.rank||4===c.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${c.rank}.`)),a.hu(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),a.hu("float32"===c.dtype||"int32"===c.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),a.hu(!1===o||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let u=c,h=!1;3===c.rank&&(h=!0,u=(0,l.X)(c,[1,c.shape[0],c.shape[1],c.shape[2]]));const[]=t,d={images:u},p={alignCorners:n,halfPixelCenters:o,size:t},f=r.BV.runKernel(i.dp,d,p);return h?(0,l.X)(f,[f.shape[1],f.shape[2],f.shape[3]]):f}})},3963:(e,t,n)=>{"use strict";n.d(t,{x:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({isFinite_:function(e){const t={x:(0,s._1)(e,"x","isFinite")};return r.BV.runKernel(i.av,t)}})},4365:(e,t,n)=>{"use strict";n.d(t,{U:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({isInf_:function(e){const t={x:(0,s._1)(e,"x","isInf")};return r.BV.runKernel(i.iW,t)}})},6230:(e,t,n)=>{"use strict";n.d(t,{i:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({isNaN_:function(e){const t={x:(0,s._1)(e,"x","isNaN")};return r.BV.runKernel(i.r7,t)}})},9133:(e,t,n)=>{"use strict";n.d(t,{h:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({leakyRelu_:function(e,t=.2){const n={x:(0,s._1)(e,"x","leakyRelu")},a={alpha:t};return r.BV.runKernel(i.J$,n,a)}})},6573:(e,t,n)=>{"use strict";n.d(t,{d:()=>l});var r=n(7097),i=n(9121),s=n(747),a=n(3740),o=n(2200);const l=(0,n(2668).op)({less_:function(e,t){let n=(0,a._1)(e,"a","less","string_or_numeric"),l=(0,a._1)(t,"b","less","string_or_numeric");[n,l]=(0,s.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const c={a:n,b:l};return r.BV.runKernel(i.vt,c)}})},624:(e,t,n)=>{"use strict";n.d(t,{z:()=>l});var r=n(7097),i=n(9121),s=n(747),a=n(3740),o=n(2200);const l=(0,n(2668).op)({lessEqual_:function(e,t){let n=(0,a._1)(e,"a","lessEqual","string_or_numeric"),l=(0,a._1)(t,"b","lessEqual","string_or_numeric");[n,l]=(0,s.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const c={a:n,b:l};return r.BV.runKernel(i.CA,c)}})},4135:(e,t,n)=>{"use strict";n.d(t,{S:()=>s});var r=n(7097),i=n(9121);function s(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const s={start:e,stop:t,num:n};return r.BV.runKernel(i.e7,{},s)}},9648:(e,t,n)=>{"use strict";n.d(t,{G:()=>c});var r=n(7097),i=n(9121),s=n(3740),a=n(9115),o=n(2668),l=n(4968);const c=(0,o.op)({localResponseNormalization_:function(e,t=5,n=1,o=1,c=.5){const u=(0,s._1)(e,"x","localResponseNormalization");a.hu(4===u.rank||3===u.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${u.rank}.`)),a.hu(a.GN(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let h=u,d=!1;3===u.rank&&(d=!0,h=(0,l.X)(u,[1,u.shape[0],u.shape[1],u.shape[2]]));const p={x:h},f={depthRadius:t,bias:n,alpha:o,beta:c},m=r.BV.runKernel(i.eZ,p,f);return d?(0,l.X)(m,[m.shape[1],m.shape[2],m.shape[3]]):m}})},2597:(e,t,n)=>{"use strict";n.d(t,{c:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({log_:function(e){const t={x:(0,s._1)(e,"x","log","float32")};return r.BV.runKernel(i.Zb,t)}})},7474:(e,t,n)=>{"use strict";n.d(t,{K:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({log1p_:function(e){const t={x:(0,s._1)(e,"x","log1p")};return r.BV.runKernel(i.kU,t)}})},3888:(e,t,n)=>{"use strict";n.d(t,{e:()=>u});var r=n(633),i=n(3740),s=n(4841),a=n(7370),o=n(2668),l=n(625),c=n(3694);const u=(0,o.op)({logSigmoid_:function(e){const t=(0,i._1)(e,"x","logSigmoid"),n=(0,r.cb)((e=>({value:(0,a.W)((0,c.W)((0,a.W)(e))),gradFunc:t=>(0,s.d)(t,(0,l.X)((0,a.W)(e)))})));return n(t)}})},1510:(e,t,n)=>{"use strict";n.d(t,{C:()=>p});var r=n(633),i=n(3740),s=n(2271),a=n(4842),o=n(2597),l=n(3307),c=n(4841),u=n(2668),h=n(827),d=n(5475);const p=(0,u.op)({logSoftmax_:function(e,t=-1){const n=(0,i._1)(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);const u=(0,r.cb)(((e,n)=>{const r=(0,l.F)(e,t,!0),i=(0,h.l)(e,r),u=(0,h.l)((0,s.p)(i,"float32"),(0,o.c)((0,d.S)((0,a.Q)(i),t,!0)));return n([u]),{value:u,gradFunc:(e,n)=>{const[r]=n,i=(0,a.Q)(r);return(0,h.l)(e,(0,c.d)((0,d.S)(e,t,!0),i))}}}));return u(n)}})},1391:(e,t,n)=>{"use strict";n.d(t,{l:()=>f});var r=n(3740),i=n(9115),s=n(6407),a=n(3591),o=n(4842),l=n(2597),c=n(3307),u=n(2668),h=n(4968),d=n(827),p=n(5475);const f=(0,u.op)({logSumExp_:function(e,t=null,n=!1){const u=(0,r._1)(e,"x","logSumExp"),f=(0,i.EC)(t,u.shape),m=(0,c.F)(u,f,!0),g=(0,d.l)(u,m),y=(0,o.Q)(g),v=(0,p.S)(y,f),x=(0,l.c)(v),b=(0,s.I)((0,h.X)(m,x.shape),x);if(n){const e=(0,a.rv)(b.shape,f);return(0,h.X)(b,e)}return b}})},2856:(e,t,n)=>{"use strict";n.d(t,{H:()=>o});var r=n(7097),i=n(9121),s=n(3740),a=n(2200);const o=(0,n(2668).op)({logicalAnd_:function(e,t){const n=(0,s._1)(e,"a","logicalAnd","bool"),o=(0,s._1)(t,"b","logicalAnd","bool");(0,a.assertAndGetBroadcastShape)(n.shape,o.shape);const l={a:n,b:o};return r.BV.runKernel(i.PY,l)}})},8651:(e,t,n)=>{"use strict";n.d(t,{h:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({logicalNot_:function(e){const t={x:(0,s._1)(e,"x","logicalNot","bool")};return r.BV.runKernel(i.Vf,t)}})},5750:(e,t,n)=>{"use strict";n.d(t,{K:()=>o});var r=n(7097),i=n(9121),s=n(3740),a=n(2200);const o=(0,n(2668).op)({logicalOr_:function(e,t){const n=(0,s._1)(e,"a","logicalOr","bool"),o=(0,s._1)(t,"b","logicalOr","bool");(0,a.assertAndGetBroadcastShape)(n.shape,o.shape);const l={a:n,b:o};return r.BV.runKernel(i.MZ,l)}})},596:(e,t,n)=>{"use strict";n.d(t,{e:()=>l});var r=n(3740),i=n(2200),s=n(2856),a=n(8651),o=n(5750);const l=(0,n(2668).op)({logicalXor_:function(e,t){const n=(0,r._1)(e,"a","logicalXor","bool"),l=(0,r._1)(t,"b","logicalXor","bool");return(0,i.assertAndGetBroadcastShape)(n.shape,l.shape),(0,s.H)((0,o.K)(e,t),(0,a.h)((0,s.H)(e,t)))}})},9876:(e,t,n)=>{"use strict";var r;n.d(t,{I:()=>r}),function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(r||(r={}))},4608:(e,t,n)=>{"use strict";n.d(t,{e:()=>i});var r=n(3336);function i(e,t){return(0,r.z)(e,t,"left")}},8687:(e,t,n)=>{"use strict";n.d(t,{O:()=>o});var r=n(7097),i=n(9121),s=n(747),a=n(3740);const o=(0,n(2668).op)({matMul_:function(e,t,n=!1,o=!1){let l=(0,a._1)(e,"a","matMul"),c=(0,a._1)(t,"b","matMul");[l,c]=(0,s.makeTypesMatch)(l,c);const u={a:l,b:c},h={transposeA:n,transposeB:o};return r.BV.runKernel(i.XL,u,h)}})},3307:(e,t,n)=>{"use strict";n.d(t,{F:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({max_:function(e,t=null,n=!1){const a={x:(0,s._1)(e,"x","max")},o={reductionIndices:t,keepDims:n};return r.BV.runKernel(i.Yo,a,o)}})},1174:(e,t,n)=>{"use strict";n.d(t,{_:()=>u});var r=n(7097),i=n(9121),s=n(3740),a=n(9115),o=n(2582),l=n(2668),c=n(4968);const u=(0,l.op)({maxPool_:function(e,t,n,l,u){const h=(0,s._1)(e,"x","maxPool");let d=h,p=!1;3===h.rank&&(p=!0,d=(0,c.X)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),a.hu(4===d.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${d.rank}.`)),a.hu(o.jT(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),o.m("maxPool",l,u);const f={x:d},m={filterSize:t,strides:n,pad:l,dimRoundingMode:u},g=r.BV.runKernel(i.mT,f,m);return p?(0,c.X)(g,[g.shape[1],g.shape[2],g.shape[3]]):g}})},5020:(e,t,n)=>{"use strict";n.d(t,{Y:()=>u});var r=n(7097),i=n(9121),s=n(3740),a=n(9115),o=n(2582),l=n(2668),c=n(4968);const u=(0,l.op)({maxPool3d_:function(e,t=[1,1,1],n,l,u,h="NDHWC"){const d=(0,s._1)(e,"x","maxPool3d");let p=d,f=!1;4===d.rank&&(f=!0,p=(0,c.X)(d,[1,d.shape[0],d.shape[1],d.shape[2],d.shape[3]])),a.hu(5===p.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${p.rank}.`)),a.hu("NDHWC"===h,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${h}`)),(0,o.m)("maxPool3d",l,u);const m={x:p},g={filterSize:t,strides:n,pad:l,dimRoundingMode:u,dataFormat:h},y=r.BV.runKernel(i.OA,m,g);return f?(0,c.X)(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}})},6877:(e,t,n)=>{"use strict";n.d(t,{I:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({maxPoolWithArgmax_:function(e,t,n,a,o=!1){const l={x:(0,s._1)(e,"x","maxPoolWithArgmax")},c={filterSize:t,strides:n,pad:a,includeBatchInIndex:o},u=r.BV.runKernel(i.vF,l,c);return{result:u[0],indexes:u[1]}}})},632:(e,t,n)=>{"use strict";n.d(t,{g:()=>c});var r=n(7097),i=n(9121),s=n(747),a=n(3740),o=n(2200),l=n(2271);const c=(0,n(2668).op)({maximum_:function(e,t){let n=(0,a._1)(e,"a","maximum"),c=(0,a._1)(t,"b","maximum");[n,c]=(0,s.makeTypesMatch)(n,c),"bool"===n.dtype&&(n=(0,l.p)(n,"int32"),c=(0,l.p)(c,"int32")),(0,o.assertAndGetBroadcastShape)(n.shape,c.shape);const u={a:n,b:c};return r.BV.runKernel(i.BM,u)}})},5130:(e,t,n)=>{"use strict";n.d(t,{J:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({mean_:function(e,t=null,n=!1){const a={x:(0,s._1)(e,"x","mean")},o={axis:t,keepDims:n};return r.BV.runKernel(i.q2,a,o)}})},5735:(e,t,n)=>{"use strict";n.d(t,{V:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({min_:function(e,t=null,n=!1){const a={x:(0,s._1)(e,"x","min")},o={axis:t,keepDims:n};return r.BV.runKernel(i.c1,a,o)}})},4513:(e,t,n)=>{"use strict";n.d(t,{L:()=>c});var r=n(7097),i=n(9121),s=n(747),a=n(3740),o=n(2200),l=n(2271);const c=(0,n(2668).op)({minimum_:function(e,t){let n=(0,a._1)(e,"a","minimum"),c=(0,a._1)(t,"b","minimum");[n,c]=(0,s.makeTypesMatch)(n,c),"bool"===n.dtype&&(n=(0,l.p)(n,"int32"),c=(0,l.p)(c,"int32")),(0,o.assertAndGetBroadcastShape)(n.shape,c.shape);const u={a:n,b:c};return r.BV.runKernel(i.q8,u)}})},1483:(e,t,n)=>{"use strict";n.d(t,{V:()=>o});var r=n(7097),i=n(9121),s=n(3740),a=n(9115);const o=(0,n(2668).op)({mirrorPad_:function(e,t,n){a.hu("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const o=(0,s._1)(e,"x","mirrorPad");if(0===o.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");a.hu(t.length===o.rank,(()=>`Padding doesn't match input. Must be ${o.rank}. Got ${t.length}.`));const l="reflect"===n?1:0;for(let e=0;e<o.rank;e++)a.hu(2===t[e].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),a.hu(t[e][0]>=0&&t[e][0]<=o.shape[e]-l&&t[e][1]>=0&&t[e][1]<=o.shape[e]-l,(()=>`Padding in dimension ${e} cannot be greater than or equal to ${o.shape[e]-l} or less than 0 for input of shape ${o.shape}`));const c={paddings:t,mode:n},u={x:o};return r.BV.runKernel(i.jQ,u,c)}})},5228:(e,t,n)=>{"use strict";n.d(t,{w:()=>o});var r=n(7097),i=n(9121),s=n(747),a=n(3740);const o=(0,n(2668).op)({mod_:function(e,t){let n=(0,a._1)(e,"a","mod"),o=(0,a._1)(t,"b","mod");[n,o]=(0,s.makeTypesMatch)(n,o);const l={a:n,b:o};return r.BV.runKernel(i.Vb,l)}})},4841:(e,t,n)=>{"use strict";n.d(t,{d:()=>o});var r=n(7097),i=n(9121),s=n(747),a=n(3740);const o=(0,n(2668).op)({mul_:function(e,t){let n=(0,a._1)(e,"a","mul"),o=(0,a._1)(t,"b","mul");[n,o]=(0,s.makeTypesMatch)(n,o);const l={a:n,b:o};return r.BV.runKernel(i.wY,l)}})},686:(e,t,n)=>{"use strict";n.d(t,{S:()=>l});var r=n(7097),i=n(9121),s=n(3740),a=n(2668),o=n(4968);const l=(0,a.op)({multinomial_:function(e,t,n,a=!1){const l=(0,s._1)(e,"logits","multinomial"),c=l.size,u=l.rank;if(c<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${c}.`);if(u>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${u}`);n=n||Math.random();const h={logits:1===u?(0,o.X)(l,[1,-1]):l},d={numSamples:t,seed:n,normalized:a},p=r.BV.runKernel(i.NZ,h,d);return 1===u?(0,o.X)(p,[p.size]):p}})},7370:(e,t,n)=>{"use strict";n.d(t,{W:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({neg_:function(e){const t={x:(0,s._1)(e,"x","neg")};return r.BV.runKernel(i.ku,t)}})},3561:(e,t,n)=>{"use strict";n.d(t,{K:()=>y});var r=n(3740),i=n(9115),s=n(6235),a=n(3591),o=n(3307),l=n(5735),c=n(2668),u=n(3453),h=n(4968),d=n(9494),p=n(3261),f=n(248),m=n(5475);function g(e,t,n=null){if(0===e.rank)return(0,s.W)(e);if(1!==e.rank&&null===n)return g((0,h.X)(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return(0,m.S)((0,s.W)(e),n);if(t===1/0)return(0,o.F)((0,s.W)(e),n);if(t===-1/0)return(0,l.V)((0,s.W)(e),n);if("euclidean"===t||2===t)return(0,p._)((0,m.S)((0,u.s)((0,s.W)(e),(0,d.i)(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return(0,o.F)((0,m.S)((0,s.W)(e),n[0]),n[1]-1);if(t===1/0)return(0,o.F)((0,m.S)((0,s.W)(e),n[1]),n[0]);if(t===-1/0)return(0,l.V)((0,m.S)((0,s.W)(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return(0,p._)((0,m.S)((0,f.h)(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const y=(0,c.op)({norm_:function(e,t="euclidean",n=null,s=!1){const o=g(e=(0,r._1)(e,"x","norm"),t,n);let l=o.shape;if(s){const t=(0,i.EC)(n,e.shape);l=a.rv(o.shape,t)}return(0,h.X)(o,l)}})},6500:(e,t,n)=>{"use strict";n.d(t,{Q:()=>l});var r=n(7097),i=n(9121),s=n(747),a=n(3740),o=n(2200);const l=(0,n(2668).op)({notEqual_:function(e,t){let n=(0,a._1)(e,"a","notEqual","string_or_numeric"),l=(0,a._1)(t,"b","notEqual","string_or_numeric");[n,l]=(0,s.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const c={a:n,b:l};return r.BV.runKernel(i.yQ,c)}})},6708:(e,t,n)=>{"use strict";n.d(t,{l:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({oneHot_:function(e,t,n=1,a=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const o={indices:(0,s._1)(e,"indices","oneHot","int32")},l={depth:t,onValue:n,offValue:a};return r.BV.runKernel(i.we,o,l)}})},4917:(e,t,n)=>{"use strict";n.d(t,{i:()=>o});var r=n(7097),i=n(9115),s=n(1661),a=n(723);function o(e,t="float32"){if("complex64"===t){const t=o(e,"float32"),n=(0,a.l)(e,"float32");return(0,s.P)(t,n)}const n=(0,i.p8)((0,i.NA)(e),t);return r.BV.makeTensor(n,e,t)}},7846:(e,t,n)=>{"use strict";n.d(t,{J:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({onesLike_:function(e){const t={x:(0,s._1)(e,"x","onesLike")};return r.BV.runKernel(i.qW,t)}})},2668:(e,t,n)=>{"use strict";n.d(t,{op:()=>a,z:()=>s});var r=n(7097),i=n(9115);const s="__op";function a(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const a=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=s;const o=(...e)=>{r.BV.startScope(n);try{const t=a(...e);return(0,i.tI)(t)&&console.error("Cannot return a Promise inside of tidy."),r.BV.endScope(t),t}catch(e){throw r.BV.endScope(null),e}};return Object.defineProperty(o,"name",{value:n,configurable:!0}),o}},4376:(e,t,n)=>{"use strict";n.d(t,{zvA:()=>S.z,WnP:()=>r.W,Khb:()=>i.K,__u:()=>s._,IHx:()=>a.I,QBD:()=>o.Q,$6P:()=>l.$,YjB:()=>c.Y,NqF:()=>u.N,vHJ:()=>h.v,ZRM:()=>d.Z,VfV:()=>p.V,z4N:()=>f.z,fvJ:()=>m.f,C80:()=>g.C,wS1:()=>y.w,uR5:()=>v.u,zEQ:()=>A,tgs:()=>I.t,Dxk:()=>k,JY5:()=>R,p3b:()=>D,E4h:()=>C.E,yE8:()=>L.y,anm:()=>Bn,XsQ:()=>F.X,UFq:()=>P.U,f3b:()=>O.f,pju:()=>z.p,mDi:()=>B.m,iUl:()=>U.i,d9v:()=>$.d,PYB:()=>V.P,zoF:()=>b.z,gME:()=>W,Izb:()=>G,MNy:()=>H,ZaL:()=>j,PAt:()=>q.P,Tek:()=>X.T,bc:()=>Y.b,pdZ:()=>K.p,$QV:()=>J,mCk:()=>Q.m,f9Y:()=>ee.f,mew:()=>Kn,$Gn:()=>te.$,zbp:()=>ne.z,ppE:()=>re.p,nTT:()=>ie.n,B10:()=>se.B,Ka3:()=>le,WmZ:()=>ce.W,hiC:()=>ue.h,NTj:()=>he.N,AKD:()=>de.A,rvX:()=>Xn,WYO:()=>pe.W,pyx:()=>fe.p,GRh:()=>Yn,DgJ:()=>me.D,qNN:()=>ge.q,d2q:()=>ye.d,Qqt:()=>ve.Q,dt4:()=>xe.d,t$B:()=>be.t,iyy:()=>Se,kp_:()=>on.k,hlL:()=>Me.h,GWj:()=>Te.G,qPi:()=>Ee.q,imm:()=>Jn,Iqj:()=>Ae.I,dbB:()=>qn.d,pjt:()=>Ce.p,brS:()=>Ie.b,Sxn:()=>ln.S,asL:()=>Ne.a,BHj:()=>$r,V3u:()=>Zn,wx0:()=>cn.w,xVT:()=>ke.x,UWc:()=>Re.U,i2d:()=>De.i,hi7:()=>Le.h,d9m:()=>Fe.d,zN1:()=>Pe.z,$r2:()=>Vr,SX3:()=>Oe.S,G9k:()=>ze.G,cM7:()=>Be.c,Krr:()=>Ue.K,e_t:()=>$e.e,CmS:()=>Ve.C,l_t:()=>We.l,HvI:()=>Ge.H,hJK:()=>He.h,K5V:()=>je.K,egP:()=>qe.e,MB5:()=>Wr,eab:()=>Xe.e,OI3:()=>w.O,Fp7:()=>Ye.F,_sB:()=>Ke._,YQQ:()=>Ze.Y,Ip$:()=>Je.I,gWQ:()=>Qe.g,J69:()=>et.J,ry_:()=>rt,VV$:()=>it.V,LTh:()=>st.L,VdP:()=>at.V,wQq:()=>ot.w,Gi7:()=>ht,p_:()=>Wn,dC7:()=>_.d,rq4:()=>dt,SJ_:()=>pt.S,W76:()=>ft.W,KOy:()=>$n.K,Quu:()=>mt.Q,lfX:()=>gt.l,iUs:()=>tt.i,JpU:()=>yt.J,op:()=>S.op,N2O:()=>vt,vku:()=>xt.v,pNR:()=>bt,koy:()=>wt,t1L:()=>_t,lGY:()=>St,d_R:()=>Mt.d,sQ3:()=>Tt.s,AL3:()=>Et.A,S0v:()=>At.S,WVs:()=>Ct.W,TN_:()=>It,wzB:()=>kt,nGf:()=>Rt,LGj:()=>Dt.L,w6H:()=>Lt.w,kwC:()=>Ft.k,M25:()=>Pt.M,UYe:()=>Ot.U,btT:()=>zt.b,XLQ:()=>we.X,GYS:()=>Bt.G,SDf:()=>Ut,diP:()=>$t,sx7:()=>Vt,mG2:()=>Wt,QEs:()=>un.Q,NMM:()=>Gt.N,bp0:()=>Ht.b,iD$:()=>jt.i,snQ:()=>Gn.s,zcT:()=>Hn.z,U8D:()=>qt.U,U_I:()=>Xt.U,ODp:()=>Yt.O,XD2:()=>M.X,Xxe:()=>Kt.X,tdS:()=>Ur,O$l:()=>Zt.O,R_K:()=>Jt.R,tPi:()=>T.t,jZU:()=>Qt,SmN:()=>en,CnO:()=>tn,p0P:()=>nn,XAC:()=>rn.X,Wvh:()=>sn.W,fBT:()=>an.f,rVs:()=>Gr,ers:()=>jn.e,uN7:()=>Br,Vl2:()=>hn.V,_b3:()=>dn._,h62:()=>ct.h,$i:()=>pn.$,L9e:()=>fn.L,knu:()=>mn.k,Nbs:()=>gn.N,NXj:()=>yn.N,Z_8:()=>Hr,luU:()=>ut.l,Smz:()=>vn.S,ORZ:()=>xn.O,AEp:()=>E.A,XeE:()=>bn.X,RRF:()=>wn.R,odF:()=>Sn,wOQ:()=>Mn.w,yXz:()=>Tn,Bfx:()=>En,xZs:()=>An,Gg6:()=>_e.G,hg7:()=>Cn.h,p4s:()=>Un.p,Xu6:()=>In.X,Two:()=>Nn.T,pUJ:()=>kn.p,HHK:()=>Rn.H,GaM:()=>Dn.G,VD$:()=>Ln,arb:()=>Fn.a,itS:()=>Pn.i,lls:()=>On.l,P84:()=>zn.P});var r=n(6235),i=n(7839),s=n(1470),a=n(6407),o=n(3135),l=n(781),c=n(2998),u=n(47),h=n(7394),d=n(2421),p=n(1891),f=n(7037),m=n(9812),g=n(369),y=n(5176),v=n(1749),x=n(3740),b=n(6884),w=n(8687),_=n(4841),S=n(2668),M=n(625),T=n(2676),E=n(1869);const A=(0,S.op)({basicLSTMCell_:function(e,t,n,r,i,s){const o=(0,x._1)(e,"forgetBias","basicLSTMCell"),l=(0,x._1)(t,"lstmKernel","basicLSTMCell"),c=(0,x._1)(n,"lstmBias","basicLSTMCell"),u=(0,x._1)(r,"data","basicLSTMCell"),h=(0,x._1)(i,"c","basicLSTMCell"),d=(0,x._1)(s,"h","basicLSTMCell"),p=(0,b.z)([u,d],1),f=(0,w.O)(p,l),m=(0,a.I)(f,c),g=m.shape[0],y=m.shape[1]/4,v=[g,y],S=(0,T.t)(m,[0,0],v),A=(0,T.t)(m,[0,y],v),C=(0,T.t)(m,[0,2*y],v),I=(0,T.t)(m,[0,3*y],v),N=(0,a.I)((0,_.d)((0,M.X)(S),(0,E.A)(A)),(0,_.d)(h,(0,M.X)((0,a.I)(o,C))));return[N,(0,_.d)((0,E.A)(N),(0,M.X)(I))]}});var C=n(8441),I=n(7505),N=n(9115);const k=(0,S.op)({batchNorm2d_:function(e,t,n,r,i,s){const a=(0,x._1)(e,"x","batchNorm"),o=(0,x._1)(t,"mean","batchNorm"),l=(0,x._1)(n,"variance","batchNorm");let c,u;return null!=i&&(c=(0,x._1)(i,"scale","batchNorm")),null!=r&&(u=(0,x._1)(r,"offset","batchNorm")),N.hu(2===a.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`)),N.hu(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`)),N.hu(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=c&&N.hu(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`)),null!=u&&N.hu(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`)),(0,I.t)(a,o,l,u,c,s)}}),R=(0,S.op)({batchNorm3d_:function(e,t,n,r,i,s){const a=(0,x._1)(e,"x","batchNorm"),o=(0,x._1)(t,"mean","batchNorm"),l=(0,x._1)(n,"variance","batchNorm");let c,u;return null!=i&&(c=(0,x._1)(i,"scale","batchNorm")),null!=r&&(u=(0,x._1)(r,"offset","batchNorm")),N.hu(3===a.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`)),N.hu(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`)),N.hu(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=c&&N.hu(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`)),null!=u&&N.hu(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`)),(0,I.t)(a,o,l,u,c,s)}}),D=(0,S.op)({batchNorm4d_:function(e,t,n,r,i,s){const a=(0,x._1)(e,"x","batchNorm"),o=(0,x._1)(t,"mean","batchNorm"),l=(0,x._1)(n,"variance","batchNorm");let c,u;return null!=i&&(c=(0,x._1)(i,"scale","batchNorm")),null!=r&&(u=(0,x._1)(r,"offset","batchNorm")),N.hu(4===a.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`)),N.hu(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`)),N.hu(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=c&&N.hu(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`)),null!=u&&N.hu(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`)),(0,I.t)(a,o,l,u,c,s)}});var L=n(3865),F=n(8194),P=n(8247),O=n(2657),z=n(2271),B=n(6825),U=n(2279),$=n(8723),V=n(1661);const W=(0,S.op)({concat1d_:function(e){return(0,b.z)(e,0)}}),G=(0,S.op)({concat2d_:function(e,t){return(0,b.z)(e,t)}}),H=(0,S.op)({concat3d_:function(e,t){return(0,b.z)(e,t)}}),j=(0,S.op)({concat4d_:function(e,t){return(0,b.z)(e,t)}});var q=n(1355),X=n(4794),Y=n(1405),K=n(473),Z=n(7594);const J=(0,S.op)({conv3dTranspose_:function(e,t,n,r,i){const s=(0,x._1)(e,"x","conv3dTranspose"),a=(0,x._1)(t,"filter","conv3dTranspose");return(0,Z._)(n,s,a,r,i)}});var Q=n(173),ee=n(2699),te=n(9640),ne=n(7405),re=n(5746),ie=n(9112),se=n(4718),ae=n(7097),oe=n(9121);const le=(0,S.op)({diag_:function(e){const t={x:(0,x._1)(e,"x","diag")};return ae.BV.runKernel(oe.$w,t)}});var ce=n(557),ue=n(1274),he=n(9322),de=n(548),pe=n(4653),fe=n(3233),me=n(6477),ge=n(4650),ye=n(1954),ve=n(4842),xe=n(1300),be=n(3426),we=n(4968),_e=n(7501);const Se=(0,S.op)({eye_:function(e,t,n,r="float32"){null==t&&(t=e);const i=(0,O.f)([e,t],r),s=e<=t?e:t;for(let e=0;e<s;++e)i.set(1,e,e);const a=(0,we.X)(i.toTensor(),[e,t]);if(null==n)return a;if(1===n.length)return(0,_e.G)((0,xe.d)(a,0),[n[0],1,1]);if(2===n.length)return(0,_e.G)((0,xe.d)((0,xe.d)(a,0),0),[n[0],n[1],1,1]);if(3===n.length)return(0,_e.G)((0,xe.d)((0,xe.d)((0,xe.d)(a,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});var Me=n(4006),Te=n(6943),Ee=n(9165),Ae=n(4926),Ce=n(636),Ie=n(7630),Ne=n(4386),ke=n(3963),Re=n(4365),De=n(6230),Le=n(9133),Fe=n(6573),Pe=n(624),Oe=n(4135),ze=n(9648),Be=n(2597),Ue=n(7474),$e=n(3888),Ve=n(1510),We=n(1391),Ge=n(2856),He=n(8651),je=n(5750),qe=n(596),Xe=n(4608),Ye=n(3307),Ke=n(1174),Ze=n(5020),Je=n(6877),Qe=n(632),et=n(5130),tt=n(4917),nt=n(4077);function rt(e,t,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=(0,x._1)(e,"x","meshgrid",e instanceof nt.es?e.dtype:"float32");if(void 0===t)return[r];let i=(0,x._1)(t,"y","meshgrid",t instanceof nt.es?t.dtype:"float32");const s=(0,N.NA)(r.shape),a=(0,N.NA)(i.shape);return"xy"===n?(r=(0,we.X)(r,[1,-1]),i=(0,we.X)(i,[-1,1]),[(0,w.O)((0,tt.i)([a,1],r.dtype),r),(0,w.O)(i,(0,tt.i)([1,s],i.dtype))]):(r=(0,we.X)(r,[-1,1]),i=(0,we.X)(i,[1,-1]),[(0,w.O)(r,(0,tt.i)([1,a],r.dtype)),(0,w.O)((0,tt.i)([s,1],i.dtype),i)])}var it=n(5735),st=n(4513),at=n(1483),ot=n(5228),lt=n(3591),ct=n(248),ut=n(827);const ht=(0,S.op)({moments_:function(e,t=null,n=!1){e=(0,x._1)(e,"x","moments");const r=(0,N.EC)(t,e.shape),i=(0,et.J)(e,r,n);let s=i.shape;n||(s=(0,lt.rv)(i.shape,r));const a=(0,ct.h)((0,ut.l)((0,z.p)(e,"float32"),(0,we.X)(i,s)));return{mean:i,variance:(0,et.J)(a,r,n)}}}),dt=(0,S.op)({multiRNNCell_:function(e,t,n,r){const i=(0,x._1)(t,"data","multiRNNCell"),s=(0,x.sI)(n,"c","multiRNNCell"),a=(0,x.sI)(r,"h","multiRNNCell");let o=i;const l=[];for(let t=0;t<e.length;t++){const n=e[t](o,s[t],a[t]);l.push(n[0]),l.push(n[1]),o=n[1]}const c=[],u=[];for(let e=0;e<l.length;e+=2)c.push(l[e]),u.push(l[e+1]);return[c,u]}});var pt=n(686),ft=n(7370),mt=n(6500),gt=n(6708),yt=n(7846);const vt=(0,S.op)({outerProduct_:function(e,t){const n=(0,x._1)(e,"v1","outerProduct"),r=(0,x._1)(t,"v2","outerProduct");N.hu(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));const i=(0,we.X)(n,[-1,1]),s=(0,we.X)(r,[1,-1]);return(0,w.O)(i,s)}});var xt=n(9682);const bt=(0,S.op)({pad1d_:function(e,t,n=0){return(0,N.hu)(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),(0,xt.v)(e,[t],n)}}),wt=(0,S.op)({pad2d_:function(e,t,n=0){return(0,N.hu)(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),(0,xt.v)(e,t,n)}}),_t=(0,S.op)({pad3d_:function(e,t,n=0){return(0,N.hu)(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),(0,xt.v)(e,t,n)}}),St=(0,S.op)({pad4d_:function(e,t,n=0){return(0,N.hu)(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),(0,xt.v)(e,t,n)}});var Mt=n(5860),Tt=n(3453),Et=n(8151),At=n(9798),Ct=n(9451);const It=(0,S.op)({rand_:function(e,t,n){const r=(0,N.NA)(e);let i=null;if(null==n||"float32"===n)i=new Float32Array(r);else if("int32"===n)i=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);i=new Uint8Array(r)}for(let e=0;e<r;e++)i[e]=t();return ae.BV.makeTensor(i,e,n)}});var Nt=n(6845);const kt=(0,S.op)({randomGamma_:function(e,t,n=1,r="float32",i){if(null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const s=new Nt.T9(t,n,r,i),a=(0,O.f)(e,r);for(let e=0;e<a.values.length;e++)a.values[e]=s.nextValue();return a.toTensor()}}),Rt=(0,S.op)({randomNormal_:function(e,t=0,n=1,r,i){if(null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const s=new Nt.Yi(t,n,r,!1,i),a=(0,O.f)(e,r);for(let e=0;e<a.values.length;e++)a.values[e]=s.nextValue();return a.toTensor()}});var Dt=n(5002),Lt=n(7245),Ft=n(766),Pt=n(9036),Ot=n(7409),zt=n(3582),Bt=n(7486);const Ut=(0,S.op)({reverse1d_:function(e){const t=(0,x._1)(e,"x","reverse");return N.hu(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),(0,Bt.G)(t,0)}}),$t=(0,S.op)({reverse2d_:function(e,t){const n=(0,x._1)(e,"x","reverse");return N.hu(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),(0,Bt.G)(n,t)}}),Vt=(0,S.op)({reverse3d_:function(e,t){const n=(0,x._1)(e,"x","reverse");return N.hu(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),(0,Bt.G)(n,t)}}),Wt=(0,S.op)({reverse4d_:function(e,t){const n=(0,x._1)(e,"x","reverse");return N.hu(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),(0,Bt.G)(n,t)}});var Gt=n(7809),Ht=n(2634),jt=n(9494),qt=n(5503),Xt=n(8678),Yt=n(6567),Kt=n(4434),Zt=n(9331),Jt=n(3254);const Qt=(0,S.op)({slice1d_:function(e,t,n){const r=(0,x._1)(e,"x","slice1d");return N.hu(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),(0,T.t)(r,[t],[n])}}),en=(0,S.op)({slice2d_:function(e,t,n){const r=(0,x._1)(e,"x","slice2d");return N.hu(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),(0,T.t)(r,t,n)}}),tn=(0,S.op)({slice3d_:function(e,t,n){const r=(0,x._1)(e,"x","slice3d");return N.hu(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),(0,T.t)(r,t,n)}}),nn=(0,S.op)({slice4d_:function(e,t,n){const r=(0,x._1)(e,"x","slice4d");return N.hu(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),(0,T.t)(r,t,n)}});var rn=n(682),sn=n(3694),an=n(7918),on=n(7020),ln=n(8447),cn=n(4415),un=n(3710),hn=n(8644),dn=n(3261),pn=n(5265),fn=n(9590),mn=n(2991),gn=n(1901),yn=n(5158),vn=n(5475),xn=n(1173),bn=n(701),wn=n(6092),_n=n(7852);function Sn(e,t,n){if((0,N.Cq)(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=(0,x.C)(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,_n.H)(e,t,r,n)}var Mn=n(9906);function Tn(e,t,n){if((0,N.Cq)(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=(0,x.C)(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return(0,_n.H)(e,t,r,n)}function En(e,t,n){if((0,N.Cq)(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=(0,x.C)(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return(0,_n.H)(e,t,r,n)}function An(e,t,n){if((0,N.Cq)(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=(0,x.C)(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,(0,_n.H)(e,t,r,n)}var Cn=n(3243),In=n(3596),Nn=n(9608),kn=n(8749),Rn=n(4136),Dn=n(4978);function Ln(e,t=!0,n,r){return ae.BV.makeVariable(e,t,n,r)}var Fn=n(5912),Pn=n(6380),On=n(723),zn=n(6577);const Bn=async function(e,t,n){const r=(0,x._1)(e,"tensor","boolMask"),i=(0,x._1)(t,"mask","boolMask","bool"),s=null==n?0:n,a=i.rank,o=r.shape;N.hu(a>0,(()=>"mask cannot be scalar")),N.k5(o.slice(s,s+a),i.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let e=s;e<s+a;e++)l*=o[e];const c=o.slice(0,s).concat([l],o.slice(s+a)),u=(0,we.X)(r,c),h=(0,we.X)(i,[-1]),d=await(0,Pn.i)(h),p=(0,fn.L)(d,[1]),f=(0,Ae.I)(u,p,s);return e!==r&&r.dispose(),t!==i&&i.dispose(),p.dispose(),u.dispose(),h.dispose(),d.dispose(),f};var Un=n(9065),$n=n(3561),Vn=n(747);const Wn=(0,S.op)({movingAverage_:function(e,t,n,r,i=!0){const s=(0,x._1)(e,"v","movingAverage"),o=(0,x._1)(t,"x","movingAverage"),l=(0,x._1)(n,"decay","movingAverage");(0,Vn.assertTypesMatch)(s,o),N.hu(N.cO(s.shape,o.shape),(()=>"Shape mismatch in v and x"));const c=(0,jt.i)(1),u=(0,ut.l)(c,l);let h=(0,_.d)((0,ut.l)(o,s),u);if(i){N.hu(null!=r,(()=>"When using zeroDebias: true, step is required."));const e=(0,x._1)(r,"step","movingAverage");h=(0,ue.h)(h,(0,ut.l)(c,(0,Tt.s)(l,e)))}return(0,a.I)(s,h)}});var Gn=n(3100),Hn=n(3336),jn=n(9758),qn=n(7494);const Xn=(0,S.op)({dropout_:function(e,t,n,r){const i=(0,x._1)(e,"x","dropout");if(N.hu("float32"===i.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`)),N.hu(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof nt.es?i.clone():i;const s=function(e,t){if(null==t)return e.shape.slice();if(N.cO(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(i,n),o=1-t,l=(0,ue.h)((0,Te.G)((0,a.I)((0,Dt.L)(s,0,1,"float32",r),o)),o);return(0,_.d)(i,l)}});function Yn(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function Kn(e,t,n){const r=1-e%2,i=new Float32Array(e);for(let s=0;s<e;++s){const a=2*Math.PI*s/(e+r-1);i[s]=t-n*Math.cos(a)}return(0,wn.R)(i,"float32")}const Zn=async function(e,t,n=1){const r=(0,x._1)(e,"predictions","inTopK"),i=(0,x._1)(t,"targets","inTopK");(0,N.hu)(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),(0,N.hu)(r.rank-1===i.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${i.rank}`)),(0,N.k5)(r.shape.slice(0,r.shape.length-1),i.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=r.shape[r.shape.length-1];(0,N.hu)(n>0&&n<=s,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`));const a=await r.data(),o=await i.data(),[l,c]=[a.length/s,s],u=(0,N.WP)("bool",l);for(let e=0;e<l;e++){const t=e*c,r=a.subarray(t,t+c),i=[];for(let e=0;e<r.length;e++)i.push({value:r[e],index:e});i.sort(((e,t)=>t.value-e.value)),u[e]=0;for(let t=0;t<n;t++)if(i[t].index===o[e]){u[e]=1;break}}return e!==r&&r.dispose(),t!==i&&i.dispose(),(0,bn.X)(u,i.shape,"bool")};var Jn=n(4624);const Qn=(0,S.op)({hammingWindow_:function(e){return Kn(e,.54,.46)}}),er=(0,S.op)({hannWindow_:function(e){return Kn(e,.5,.5)}}),tr=(0,S.op)({frame_:function(e,t,n,r=!1,i=0){let s=0;const a=[];for(;s+t<=e.size;)a.push((0,T.t)(e,s,t)),s+=n;if(r)for(;s<e.size;){const r=s+t-e.size,o=(0,b.z)([(0,T.t)(e,s,t-r),(0,Me.h)([r],i)]);a.push(o),s+=n}return 0===a.length?Sn([],[0,t]):(0,we.X)((0,b.z)(a),[a.length,t])}}),nr=(0,S.op)({stft_:function(e,t,n,r,i=er){null==r&&(r=Yn(t));const s=tr(e,t,n),a=(0,_.d)(s,i(t));return(0,un.Q)(a,r)}}),rr=(0,S.op)({cropAndResize_:function(e,t,n,r,i="bilinear",s=0){const a=(0,x._1)(e,"image","cropAndResize"),o=(0,x._1)(t,"boxes","cropAndResize","float32"),l=(0,x._1)(n,"boxInd","cropAndResize","int32"),c=o.shape[0];N.hu(4===a.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`)),N.hu(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${o.shape}.`)),N.hu(1===l.rank&&l.shape[0]===c,(()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${o.shape}.`)),N.hu(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),N.hu(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),N.hu("bilinear"===i||"nearest"===i,(()=>`method must be bilinear or nearest, but was ${i}`));const u={image:a,boxes:o,boxInd:l},h={method:i,extrapolationValue:s,cropSize:r};return ae.BV.runKernel(oe.Vc,u,h)}}),ir=(0,S.op)({flipLeftRight_:function(e){const t=(0,x._1)(e,"image","flipLeftRight","float32");N.hu(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return ae.BV.runKernel(oe.Uy,n,{})}}),sr=(0,S.op)({grayscaleToRGB_:function(e){const t=(0,x._1)(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];N.hu(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),N.hu(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));const i=new Array(t.rank);return i.fill(1,0,n),i[n]=3,(0,_e.G)(t,i)}}),ar=(0,S.op)({rotateWithOffset_:function(e,t,n=0,r=.5){const i=(0,x._1)(e,"image","rotateWithOffset","float32");N.hu(4===i.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`));const s={image:i},a={radians:t,fillValue:n,center:r};return ae.BV.runKernel(oe.b9,s,a)}});function or(e,t,n,r,i,s){null==r&&(r=.5),null==i&&(i=Number.NEGATIVE_INFINITY),null==s&&(s=0);const a=e.shape[0];return n=Math.min(n,a),N.hu(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),N.hu(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),N.hu(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),N.hu(1===t.rank,(()=>"scores must be a 1D tensor")),N.hu(t.shape[0]===a,(()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${t.shape[0]}`)),N.hu(0<=s&&s<=1,(()=>`softNmsSigma must be in [0, 1], but was '${s}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:i,softNmsSigma:s}}const lr=(0,S.op)({nonMaxSuppression_:function(e,t,n,r=.5,i=Number.NEGATIVE_INFINITY){const s=(0,x._1)(e,"boxes","nonMaxSuppression","float32"),a=(0,x._1)(t,"scores","nonMaxSuppression","float32"),o=or(s,a,n,r,i),l={maxOutputSize:n=o.maxOutputSize,iouThreshold:r=o.iouThreshold,scoreThreshold:i=o.scoreThreshold};return ae.BV.runKernel(oe.uv,{boxes:s,scores:a},l)}});var cr=n(3337);const ur=(0,S.op)({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,i=Number.NEGATIVE_INFINITY,s=0){const a=(0,x._1)(e,"boxes","nonMaxSuppression"),o=(0,x._1)(t,"scores","nonMaxSuppression"),l=or(a,o,n,r,i,s),c={boxes:a,scores:o},u={maxOutputSize:n=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:i=l.scoreThreshold,softNmsSigma:s=l.softNmsSigma},h=ae.BV.runKernel(oe.W0,c,u);return{selectedIndices:h[0],selectedScores:h[1]}}}),hr=(0,S.op)({nonMaxSuppressionPadded_:function(e,t,n,r=.5,i=Number.NEGATIVE_INFINITY,s=!1){const a=(0,x._1)(e,"boxes","nonMaxSuppression"),o=(0,x._1)(t,"scores","nonMaxSuppression"),l=or(a,o,n,r,i,null),c={boxes:a,scores:o},u={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s},h=ae.BV.runKernel(oe.cy,c,u);return{selectedIndices:h[0],validOutputs:h[1]}}});var dr=n(3305),pr=n(5098);const fr=(0,S.op)({threshold_:function(e,t="binary",n=!1,r=.5){const i=(0,x._1)(e,"image","threshold"),s=i.shape[0]*i.shape[1];let o,l,c,u,h=(0,_.d)((0,wn.R)([r]),255);if(N.hu(3===i.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`)),N.hu(3===i.shape[2]||1===i.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`)),N.hu("int32"===i.dtype||"float32"===i.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`)),N.hu("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===i.shape[2]){[o,l,c]=(0,hn.V)(i,[1,1,1],-1);const e=(0,_.d)(o,.2989),t=(0,_.d)(l,.587),n=(0,_.d)(c,.114);u=(0,a.I)((0,a.I)(e,t),n)}else u=e;"otsu"===t&&(h=function(e,t){let n,r,i,s,o,l,c=(0,wn.R)([-1]),u=(0,wn.R)([0]),h=(0,wn.R)([0]);for(let d=0;d<e.size-1;d++){n=(0,T.t)(e,0,d+1),r=(0,T.t)(e,d+1),o=(0,ue.h)((0,vn.S)(n),t),l=(0,ue.h)((0,vn.S)(r),t);const p=(0,vn.S)((0,_.d)(n,(0,Lt.w)(0,n.size)));i=(0,ue.h)(p,(0,vn.S)(n));const f=(0,Me.h)(r.shape,n.size),m=(0,a.I)((0,Lt.w)(0,r.size),f),g=(0,_.d)(r,m);s=(0,ue.h)((0,vn.S)(g),(0,vn.S)(r));const y=(0,ut.l)(i,s),v=(0,ut.l)(i,s),x=(0,_.d)(o,l);h=(0,_.d)((0,_.d)(x,y),v);const b=(0,Ce.p)(h,u);u=(0,Fn.a)(b,h,u),c=(0,Fn.a)(b,(0,wn.R)([d]),c)}return c}((0,L.y)((0,z.p)((0,Gt.N)(u),"int32"),(0,bn.X)([]),256),s));const d=n?(0,Pe.z)(u,h):(0,Ce.p)(u,h);return(0,z.p)((0,_.d)(d,255),"int32")}}),mr=(0,S.op)({transform_:function(e,t,n="nearest",r="constant",i=0,s){const a=(0,x._1)(e,"image","transform","float32"),o=(0,x._1)(t,"transforms","transform","float32");N.hu(4===a.rank,(()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`)),N.hu(2===o.rank&&(o.shape[0]===a.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),N.hu(null==s||2===s.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`));const l={image:a,transforms:o},c={interpolation:n,fillMode:r,fillValue:i,outputShape:s};return ae.BV.runKernel(oe.wx,l,c)}}),gr=(0,S.op)({bandPart_:function(e,t,n){(0,N.hu)(t%1==0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),(0,N.hu)(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`));const r=(0,x._1)(e,"a","bandPart");(0,N.hu)(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const i=r.shape,[s,a]=r.shape.slice(-2);if(!(t<=s))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`);if(!(n<=a))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${a}).`);t<0&&(t=s),n<0&&(n=a);const o=(0,we.X)((0,Lt.w)(0,s,1,"int32"),[-1,1]),l=(0,Lt.w)(0,a,1,"int32"),c=(0,ut.l)(o,l),u=(0,Ge.H)((0,Pe.z)(c,(0,jt.i)(+t,"int32")),(0,Ie.b)(c,(0,jt.i)(-n,"int32"))),h=(0,On.l)([s,a],r.dtype);return(0,we.X)((0,mn.k)((0,Rn.H)((0,we.X)(r,[-1,s,a])).map((e=>(0,Fn.a)(u,e,h)))),i)}}),yr=(0,S.op)({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,(0,N.hu)(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)(0,N.hu)(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=(0,hn.V)(e,e.shape[0],0).map((e=>(0,fn.L)(e,[0])));(0,N.hu)(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],r=e;for(let t=0;t<e.length;++t)n.push(ae.BV.tidy((()=>{let e=r[t];if(t>0)for(let r=0;r<t;++r){const t=(0,_.d)((0,vn.S)((0,_.d)(n[r],e)),n[r]);e=(0,ut.l)(e,t)}return(0,ue.h)(e,(0,$n.K)(e,"euclidean"))})));return t?(0,mn.k)(n,0):n}});var vr=n(4368);function xr(e,t=!1){return ae.BV.tidy((()=>{(0,N.hu)(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],r=e.shape[1];let i=Se(n),s=(0,$.d)(e);const a=Sn([[1]],[1,1]);let o=(0,$.d)(a);const l=n>=r?r:n;for(let e=0;e<l;++e){const t=s,l=o,c=i;[o,s,i]=ae.BV.tidy((()=>{const t=(0,T.t)(s,[e,e],[n-e,1]),l=(0,$n.K)(t),c=(0,T.t)(s,[e,e],[1,1]),u=(0,Fn.a)((0,Ce.p)(c,0),Sn([[-1]]),Sn([[1]])),h=(0,ut.l)(c,(0,_.d)(u,l)),d=(0,ue.h)(t,h);o=1===d.shape[0]?(0,$.d)(a):(0,b.z)([a,(0,T.t)(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=(0,ft.W)((0,ue.h)((0,w.O)(u,h),l)),f=(0,T.t)(s,[e,0],[n-e,r]),m=(0,_.d)(p,o),g=(0,Un.p)(o);if(0===e)s=(0,ut.l)(f,(0,w.O)(m,(0,w.O)(g,f)));else{const t=(0,ut.l)(f,(0,w.O)(m,(0,w.O)(g,f)));s=(0,b.z)([(0,T.t)(s,[0,0],[e,r]),t],0)}const y=(0,Un.p)(m),v=(0,T.t)(i,[0,e],[n,i.shape[1]-e]);if(0===e)i=(0,ut.l)(v,(0,w.O)((0,w.O)(v,o),y));else{const t=(0,ut.l)(v,(0,w.O)((0,w.O)(v,o),y));i=(0,b.z)([(0,T.t)(i,[0,0],[n,e]),t],1)}return[o,s,i]})),(0,vr.B9)([t,l,c])}return!t&&n>r&&(i=(0,T.t)(i,[0,0],[n,r]),s=(0,T.t)(s,[0,0],[r,r])),[i,s]}))}const br=(0,S.op)({qr_:function(e,t=!1){if((0,N.hu)(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return xr(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=(0,Rn.H)((0,we.X)(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),i=[],s=[];return r.forEach((e=>{const[n,r]=xr(e,t);i.push(n),s.push(r)})),[(0,we.X)((0,mn.k)(i,0),e.shape),(0,we.X)((0,mn.k)(s,0),e.shape)]}}});var wr=n(9876);const _r=(0,S.op)({computeWeightedLoss_:function(e,t,n=wr.I.SUM_BY_NONZERO_WEIGHTS){const r=(0,x._1)(e,"losses","computeWeightedLoss");let i=null;null!=t&&(i=(0,x._1)(t,"weights","computeWeightedLoss"));const s=null==i?r:(0,_.d)(r,i);if(n===wr.I.NONE)return s;if(n===wr.I.SUM)return(0,vn.S)(s);if(n===wr.I.MEAN){if(null==i)return(0,et.J)(s);{const e=r.size/i.size,t=(0,ue.h)((0,vn.S)(s),(0,vn.S)(i));return e>1?(0,ue.h)(t,(0,jt.i)(e)):t}}if(n===wr.I.SUM_BY_NONZERO_WEIGHTS){if(null==i)return(0,ue.h)((0,vn.S)(s),(0,jt.i)(r.size));{const e=(0,_.d)(i,(0,tt.i)(r.shape)),t=(0,z.p)((0,vn.S)((0,mt.Q)(e,(0,jt.i)(0))),"float32");return(0,ue.h)((0,vn.S)(s),t)}}throw Error(`Unknown reduction: ${n}`)}}),Sr=(0,S.op)({absoluteDifference_:function(e,t,n,i=wr.I.SUM_BY_NONZERO_WEIGHTS){const s=(0,x._1)(e,"labels","absoluteDifference"),a=(0,x._1)(t,"predictions","absoluteDifference");let o=null;null!=n&&(o=(0,x._1)(n,"weights","absoluteDifference")),(0,N.k5)(s.shape,a.shape,"Error in absoluteDifference: ");const l=(0,r.W)((0,ut.l)(s,a));return _r(l,o,i)}}),Mr=(0,S.op)({cosineDistance_:function(e,t,n,r,i=wr.I.SUM_BY_NONZERO_WEIGHTS){const s=(0,x._1)(e,"labels","cosineDistance"),a=(0,x._1)(t,"predictions","cosineDistance");let o=null;null!=r&&(o=(0,x._1)(r,"weights","cosineDistance")),(0,N.k5)(s.shape,a.shape,"Error in cosineDistance: ");const l=(0,jt.i)(1),c=(0,ut.l)(l,(0,vn.S)((0,_.d)(s,a),n,!0));return _r(c,o,i)}}),Tr=(0,S.op)({hingeLoss_:function(e,t,n,r=wr.I.SUM_BY_NONZERO_WEIGHTS){let i=(0,x._1)(e,"labels","hingeLoss");const s=(0,x._1)(t,"predictions","hingeLoss");let a=null;null!=n&&(a=(0,x._1)(n,"weights","hingeLoss")),(0,N.k5)(i.shape,s.shape,"Error in hingeLoss: ");const o=(0,jt.i)(1);i=(0,ut.l)((0,_.d)((0,jt.i)(2),i),o);const l=(0,Ot.U)((0,ut.l)(o,(0,_.d)(i,s)));return _r(l,a,r)}}),Er=(0,S.op)({huberLoss_:function(e,t,n,i=1,s=wr.I.SUM_BY_NONZERO_WEIGHTS){const o=(0,x._1)(e,"labels","huberLoss"),l=(0,x._1)(t,"predictions","huberLoss");let c=null;null!=n&&(c=(0,x._1)(n,"weights","huberLoss")),(0,N.k5)(o.shape,l.shape,"Error in huberLoss: ");const u=(0,jt.i)(i),h=(0,r.W)((0,ut.l)(l,o)),d=(0,st.L)(h,u),p=(0,ut.l)(h,d),f=(0,a.I)((0,_.d)((0,jt.i)(.5),(0,ct.h)(d)),(0,_.d)(u,p));return _r(f,c,s)}}),Ar=(0,S.op)({logLoss_:function(e,t,n,r=1e-7,i=wr.I.SUM_BY_NONZERO_WEIGHTS){const s=(0,x._1)(e,"labels","logLoss"),o=(0,x._1)(t,"predictions","logLoss");let l=null;null!=n&&(l=(0,x._1)(n,"weights","logLoss")),(0,N.k5)(s.shape,o.shape,"Error in logLoss: ");const c=(0,jt.i)(1),u=(0,jt.i)(r),h=(0,ft.W)((0,_.d)(s,(0,Be.c)((0,a.I)(o,u)))),d=(0,_.d)((0,ut.l)(c,s),(0,Be.c)((0,a.I)((0,ut.l)(c,o),u))),p=(0,ut.l)(h,d);return _r(p,l,i)}}),Cr=(0,S.op)({meanSquaredError_:function(e,t,n,r=wr.I.SUM_BY_NONZERO_WEIGHTS){const i=(0,x._1)(e,"labels","meanSquaredError"),s=(0,x._1)(t,"predictions","meanSquaredError");let a=null;null!=n&&(a=(0,x._1)(n,"weights","meanSquaredError")),(0,N.k5)(i.shape,s.shape,"Error in meanSquaredError: ");const o=(0,pn.$)(i,s);return _r(o,a,r)}}),Ir=(0,S.op)({sigmoidCrossEntropy_:function(e,t,n,i=0,s=wr.I.SUM_BY_NONZERO_WEIGHTS){let o=(0,x._1)(e,"multiClassLabels","sigmoidCrossEntropy");const l=(0,x._1)(t,"logits","sigmoidCrossEntropy");let c=null;if(null!=n&&(c=(0,x._1)(n,"weights","sigmoidCrossEntropy")),(0,N.k5)(o.shape,l.shape,"Error in sigmoidCrossEntropy: "),i>0){const e=(0,jt.i)(i),t=(0,jt.i)(1),n=(0,jt.i)(.5);o=(0,a.I)((0,_.d)(o,(0,ut.l)(t,e)),(0,_.d)(n,e))}const u=function(e,t){const n=(0,x._1)(e,"labels","sigmoidCrossEntropyWithLogits"),i=(0,x._1)(t,"logits","sigmoidCrossEntropyWithLogits");(0,N.k5)(n.shape,i.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=(0,Ot.U)(i),o=(0,_.d)(i,n),l=(0,Ue.K)((0,ve.Q)((0,ft.W)((0,r.W)(i))));return(0,a.I)((0,ut.l)(s,o),l)}(o,l);return _r(u,c,s)}});var Nr=n(633);const kr=(0,S.op)({softmaxCrossEntropy_:function(e,t,n,r=0,i=wr.I.SUM_BY_NONZERO_WEIGHTS){let s=(0,x._1)(e,"onehotLabels","softmaxCrossEntropy");const o=(0,x._1)(t,"logits","softmaxCrossEntropy");let l=null;if(null!=n&&(l=(0,x._1)(n,"weights","softmaxCrossEntropy")),(0,N.k5)(s.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const e=(0,jt.i)(r),t=(0,jt.i)(1),n=(0,jt.i)(s.shape[1]);s=(0,a.I)((0,_.d)(s,(0,ut.l)(t,e)),(0,ue.h)(e,n))}const c=function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);const r=(0,Nr.cb)(((e,t,r)=>{const i=(0,We.l)(t,[n],!0),s=(0,ut.l)((0,z.p)(t,"float32"),i);r([e,s]);const a=(0,ft.W)((0,_.d)(s,e));return{value:(0,vn.S)(a,[n]),gradFunc:(e,t)=>{const[r,i]=t,s=(0,lt.rv)(e.shape,[n]);return[(0,_.d)((0,we.X)(e,s),(0,ut.l)((0,z.p)(r,"float32"),(0,ve.Q)(i))),(0,_.d)((0,we.X)(e,s),(0,ut.l)((0,ve.Q)(i),(0,z.p)(r,"float32")))]}}}));return r(e,t)}(s,o);return _r(c,l,i)}}),Rr=(0,S.op)({sparseFillEmptyRows_:function(e,t,n,r){const i=(0,x._1)(e,"indices","sparseFillEmptyRows","int32"),s=(0,x._1)(t,"values","sparseFillEmptyRows"),a=(0,x._1)(n,"denseShape","sparseFillEmptyRows","int32"),o=(0,x._1)(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==i.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${i.shape}`);if(1!==s.rank)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==a.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:i,values:s,denseShape:a,defaultValue:o},c=ae.BV.runKernel(oe.O3,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}}),Dr=(0,S.op)({sparseReshape_:function(e,t,n){const r=(0,x._1)(e,"inputIndices","sparseReshape","int32"),i=(0,x._1)(t,"inputShape","sparseReshape","int32"),s=(0,x._1)(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==i.rank)throw new Error(`Input shape should be Tensor1D but received shape ${i.shape}`);if(1!==s.rank)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const a={inputIndices:r,inputShape:i,newShape:s},o=ae.BV.runKernel(oe.nh,a);return{outputIndices:o[0],outputShape:o[1]}}}),Lr=(0,S.op)({sparseSegmentMean_:function(e,t,n){const r=(0,x._1)(e,"data","sparseSegmentMean"),i=(0,x._1)(t,"indices","sparseSegmentMean","int32"),s=(0,x._1)(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${i.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);const a={data:r,indices:i,segmentIds:s};return ae.BV.runKernel(oe.YW,a)}}),Fr=(0,S.op)({sparseSegmentSum_:function(e,t,n){const r=(0,x._1)(e,"data","sparseSegmentSum"),i=(0,x._1)(t,"indices","sparseSegmentSum","int32"),s=(0,x._1)(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${i.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);const a={data:r,indices:i,segmentIds:s};return ae.BV.runKernel(oe.Zj,a)}}),Pr=(0,S.op)({stringNGrams_:function(e,t,n,r,i,s,a,o){const l=(0,x._1)(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=(0,x._1)(t,"dataSplits","stringNGrams");if("int32"!==c.dtype)throw new Error("Data splits must be of datatype int32");const u={separator:n,nGramWidths:r,leftPad:i,rightPad:s,padWidth:a,preserveShortSequences:o},h={data:l,dataSplits:c},d=ae.BV.runKernel(oe._J,h,u);return{nGrams:d[0],nGramsSplits:d[1]}}}),Or=(0,S.op)({stringSplit_:function(e,t,n=!0){const r=(0,x._1)(e,"input","stringSplit","string"),i=(0,x._1)(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==i.rank)throw new Error(`Delimiter should be a scalar but received shape ${i.shape}`);const s={skipEmpty:n},a={input:r,delimiter:i},o=ae.BV.runKernel(oe.s1,a,s);return{indices:o[0],values:o[1],shape:o[2]}}}),zr=(0,S.op)({stringToHashBucketFast_:function(e,t){const n=(0,x._1)(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const i={input:n};return ae.BV.runKernel(oe.Xk,i,r)}}),Br={fft:on.k,ifft:ln.S,rfft:un.Q,irfft:cn.w},Ur={hammingWindow:Qn,hannWindow:er,frame:tr,stft:nr},$r={flipLeftRight:ir,grayscaleToRGB:sr,resizeNearestNeighbor:pr.j,resizeBilinear:dr.I,rotateWithOffset:ar,cropAndResize:rr,nonMaxSuppression:lr,nonMaxSuppressionAsync:async function(e,t,n,r=.5,i=Number.NEGATIVE_INFINITY){const s=(0,x._1)(e,"boxes","nonMaxSuppressionAsync"),a=(0,x._1)(t,"scores","nonMaxSuppressionAsync"),o=or(s,a,n,r,i);n=o.maxOutputSize,r=o.iouThreshold,i=o.scoreThreshold;const l=await Promise.all([s.data(),a.data()]),c=l[0],u=l[1],{selectedIndices:h}=(0,cr.GP)(c,u,n,r,i);return s!==e&&s.dispose(),a!==t&&a.dispose(),(0,wn.R)(h,"int32")},nonMaxSuppressionWithScore:ur,nonMaxSuppressionWithScoreAsync:async function(e,t,n,r=.5,i=Number.NEGATIVE_INFINITY,s=0){const a=(0,x._1)(e,"boxes","nonMaxSuppressionAsync"),o=(0,x._1)(t,"scores","nonMaxSuppressionAsync"),l=or(a,o,n,r,i,s);n=l.maxOutputSize,r=l.iouThreshold,i=l.scoreThreshold,s=l.softNmsSigma;const c=await Promise.all([a.data(),o.data()]),u=c[0],h=c[1],{selectedIndices:d,selectedScores:p}=(0,cr.pA)(u,h,n,r,i,s);return a!==e&&a.dispose(),o!==t&&o.dispose(),{selectedIndices:(0,wn.R)(d,"int32"),selectedScores:(0,wn.R)(p)}},nonMaxSuppressionPadded:hr,nonMaxSuppressionPaddedAsync:async function(e,t,n,r=.5,i=Number.NEGATIVE_INFINITY,s=!1){const a=(0,x._1)(e,"boxes","nonMaxSuppressionAsync"),o=(0,x._1)(t,"scores","nonMaxSuppressionAsync"),l=or(a,o,n,r,i,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([a.data(),o.data()]),{selectedIndices:f,validOutputs:m}=(0,cr.qP)(d,p,c,u,h,s);return a!==e&&a.dispose(),o!==t&&o.dispose(),{selectedIndices:(0,wn.R)(f,"int32"),validOutputs:(0,jt.i)(m,"int32")}},threshold:fr,transform:mr},Vr={bandPart:gr,gramSchmidt:yr,qr:br},Wr={absoluteDifference:Sr,computeWeightedLoss:_r,cosineDistance:Mr,hingeLoss:Tr,huberLoss:Er,logLoss:Ar,meanSquaredError:Cr,sigmoidCrossEntropy:Ir,softmaxCrossEntropy:kr},Gr={sparseFillEmptyRows:Rr,sparseReshape:Dr,sparseSegmentMean:Lr,sparseSegmentSum:Fr},Hr={stringNGrams:Pr,stringSplit:Or,stringToHashBucketFast:zr}},9682:(e,t,n)=>{"use strict";n.d(t,{v:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({pad_:function(e,t,n=0){const a=(0,s._1)(e,"x","pad");if(0===a.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const o={paddings:t,constantValue:n},l={x:a};return r.BV.runKernel(i.ly,l,o)}})},5860:(e,t,n)=>{"use strict";n.d(t,{d:()=>d});var r=n(3740),i=n(9115),s=n(5176),a=n(8441),o=n(2582),l=n(1174),c=n(2668),u=n(4968),h=n(7918);const d=(0,c.op)({pool_:function(e,t,n,c,d,p,f){null==d&&(d=[1,1]),null==p&&(p=1),0===c&&(c="valid");const m=(0,r._1)(e,"x","maxPool");let g=m,y=!1;3===m.rank&&(y=!0,g=(0,u.X)(m,[1,m.shape[0],m.shape[1],m.shape[2]])),i.hu(o.jT(p,d),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${p} and dilations '${d}'`));const v=o.Xw(g.shape,t,p,d,c),x=[v.dilationHeight,v.dilationWidth];let b;b="same"===c?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))).map((e=>e-1)),r=n.map((e=>Math.floor(e/2))),i=n.map(((e,t)=>e-r[t]));return n.map(((e,t)=>[r[t],i[t]]))}([v.filterHeight,v.filterWidth],x):[[0,0],[0,0]];const w=1===x[0]&&1===x[1],[_,S]=function(e,t,n){const r=n.map((e=>e[0])),i=n.map((e=>e[1])),s=e.concat(r,i),a=t.map(((e,t)=>(e-s[t]%e)%e)),o=i.map(((e,t)=>e+a[t]));return[t.map(((e,t)=>[r[t],o[t]])),t.map(((e,t)=>[0,a[t]]))]}([v.inHeight,v.inWidth],x,b),M=w?c:"valid",T=w?g:(0,h.f)(g,x,_),E=("avg"===n?()=>(0,s.w)(T,t,p,M,f):()=>(0,l._)(T,t,p,M,f))(),A=w?E:(0,a.E)(E,x,S);return y?(0,u.X)(A,[A.shape[1],A.shape[2],A.shape[3]]):A}})},3453:(e,t,n)=>{"use strict";n.d(t,{s:()=>o});var r=n(7097),i=n(9121),s=n(747),a=n(3740);const o=(0,n(2668).op)({pow_:function(e,t){let n=(0,a._1)(e,"base","pow"),o=(0,a._1)(t,"exp","pow");[n,o]=(0,s.makeTypesMatch)(n,o);const l={a:n,b:o};return r.BV.runKernel(i.pe,l)}})},8151:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({prelu_:function(e,t){const n={x:(0,s._1)(e,"x","prelu"),alpha:(0,s._1)(t,"alpha","prelu")};return r.BV.runKernel(i.o0,n)}})},9798:(e,t,n)=>{"use strict";function r(e,t=!1){console.log(e.toString(t))}n.d(t,{S:()=>r})},9451:(e,t,n)=>{"use strict";n.d(t,{W:()=>o});var r=n(7097),i=n(9121),s=n(3740),a=n(2271);const o=(0,n(2668).op)({prod_:function(e,t=null,n=!1){let o=(0,s._1)(e,"x","prod");"bool"===o.dtype&&(o=(0,a.p)(o,"int32"));const l={x:o},c={axis:t,keepDims:n};return r.BV.runKernel(i.Dl,l,c)}})},6845:(e,t,n)=>{"use strict";n.d(t,{T9:()=>s,Yi:()=>i,wv:()=>a});var r=n(3129);class i{constructor(e,t,n,i,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=i,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const a=s||Math.random();this.random=r.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,i,s;do{r=2*this.random()-1,i=2*this.random()-1,s=r*r+i*i}while(s>=1||0===s);const a=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*a,t=this.mean+this.stdDev*i*a,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class s{constructor(e,t,n,s){this.alpha=e,this.beta=1/t,this.dtype=n;const a=s||Math.random();this.randu=r.alea(a.toString()),this.randn=new i(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,i,s;for(;;){do{r=this.randn.nextValue(),s=1+this.c*r}while(s<=0);if(s*=s*s,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),i=this.randu(),i<t||Math.log(i)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class a{constructor(e=0,t=1,n,i){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==i&&(i=Math.random()),"number"==typeof i&&(i=i.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=r.alea(i)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}},5002:(e,t,n)=>{"use strict";n.d(t,{L:()=>a});var r=n(2657),i=n(2668),s=n(6845);const a=(0,i.op)({randomUniform_:function(e,t=0,n=1,i="float32",a){const o=(0,r.f)(e,i),l=new s.wv(t,n,null,a);for(let e=0;e<o.values.length;e++)o.values[e]=l.nextValue();return o.toTensor()}})},7245:(e,t,n)=>{"use strict";n.d(t,{w:()=>s});var r=n(7097),i=n(9121);function s(e,t,n=1,s="float32"){if(0===n)throw new Error("Cannot have a step of zero");const a={start:e,stop:t,step:n,dtype:s};return r.BV.runKernel(i.e6,{},a)}},766:(e,t,n)=>{"use strict";n.d(t,{k:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({real_:function(e){const t={input:(0,s._1)(e,"input","real")};return r.BV.runKernel(i.xJ,t)}})},9036:(e,t,n)=>{"use strict";n.d(t,{M:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({reciprocal_:function(e){const t={x:(0,s._1)(e,"x","reciprocal")};return r.BV.runKernel(i.$H,t)}})},7409:(e,t,n)=>{"use strict";n.d(t,{U:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({relu_:function(e){const t={x:(0,s._1)(e,"x","relu")};return r.BV.runKernel(i.qk,t)}})},3582:(e,t,n)=>{"use strict";n.d(t,{b:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({relu6_:function(e){const t={x:(0,s._1)(e,"x","relu6")};return r.BV.runKernel(i.Sb,t)}})},4968:(e,t,n)=>{"use strict";n.d(t,{X:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({reshape_:function(e,t){const n={x:(0,s._1)(e,"x","reshape","string_or_numeric")},a={shape:t};return r.BV.runKernel(i.HZ,n,a)}})},7486:(e,t,n)=>{"use strict";n.d(t,{G:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({reverse_:function(e,t){const n={x:(0,s._1)(e,"x","reverse")},a={dims:t};return r.BV.runKernel(i.mK,n,a)}})},7809:(e,t,n)=>{"use strict";n.d(t,{N:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({round_:function(e){const t={x:(0,s._1)(e,"x","round")};return r.BV.runKernel(i.e0,t)}})},2634:(e,t,n)=>{"use strict";n.d(t,{b:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({rsqrt_:function(e){const t={x:(0,s._1)(e,"x","rsqrt","float32")};return r.BV.runKernel(i.bV,t)}})},9494:(e,t,n)=>{"use strict";n.d(t,{i:()=>s});var r=n(9115),i=n(7852);function s(e,t){if(((0,r.fU)(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&(0,r.fU)(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,i.H)(e,[],[],t)}},3100:(e,t,n)=>{"use strict";n.d(t,{s:()=>l});var r=n(7097),i=n(9121),s=n(3740),a=n(2668),o=n(3028);const l=(0,a.op)({scatterND_:function(e,t,n){const a=(0,s._1)(e,"indices","scatterND","int32"),l=(0,s._1)(t,"updates","scatterND");o.validateInput(l,a,n);const c={indices:a,updates:l},u={shape:n};return r.BV.runKernel(i.xQ,c,u)}})},3028:(e,t,n)=>{"use strict";n.r(t),n.d(t,{calculateShapes:()=>a,validateInput:()=>s,validateUpdateShape:()=>i});var r=n(9115);function i(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,i=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${i}.`;if(n.rank<i)throw new Error(s+` update.rank < ${i}. `);if(e.length<r+(n.rank-i))throw new Error(s+` Output shape length < ${r+(n.rank-i)}`);if(n.rank!==i+e.length-r)throw new Error(s+" update.rank != "+(i+e.length-r));for(let e=0;e<i;++e)if(n.shape[e]!==t.shape[e])throw new Error(s+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-i;++t)if(n.shape[t+i]!==e[t+r])throw new Error(s+` updates.shape[${t+i}] (${n.shape[t+i]}) != shape[${t+i}] (${e[t+i]})`)}function s(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}i(n,t,e)}function a(e,t,n){const i=t.shape.length,s=i>1?t.shape[i-1]:1,a=n.length;let o=1;for(let e=s;e<a;++e)o*=n[e];const l=s<1?1:s;return{sliceRank:s,numUpdates:(0,r.NA)(t.shape)/l,sliceSize:o,strides:[...(0,r.e3)(n.slice(0,s)),1],outputSize:(0,r.NA)(n)}}},3336:(e,t,n)=>{"use strict";n.d(t,{z:()=>u});var r=n(7097),i=n(9121),s=n(3740),a=n(9115),o=n(2668),l=n(4968);const c=2147483648,u=(0,o.op)({searchSorted_:function(e,t,n="left"){const o=(0,s._1)(e,"sortedSequence","searchSorted"),u=(0,s._1)(t,"values","searchSorted"),h=o.shape[o.shape.length-1],d=u.shape[u.shape.length-1],p=(0,l.X)(o,[-1,h]),f=(0,l.X)(u,[-1,d]);if(p.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(p.shape[0]!==f.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if((0,a.NA)(f.shape)>=c)throw new Error("values tensor size must less than 2147483648");if(p.shape[1]>=c)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${p.shape[1]}`);const m={sortedSequence:p,values:f},g={side:n};return r.BV.runKernel(i.nr,m,g)}})},5503:(e,t,n)=>{"use strict";n.d(t,{U:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({selu_:function(e){const t={x:(0,s._1)(e,"x","selu")};return r.BV.runKernel(i.oF,t)}})},3179:(e,t,n)=>{"use strict";n.d(t,{$:()=>i,y:()=>r});const r=1.7580993408473768,i=1.0507009873554805},8678:(e,t,n)=>{"use strict";n.d(t,{U:()=>c});var r=n(3740),i=n(9115),s=n(4794),a=n(4718),o=n(2668),l=n(4968);const c=(0,o.op)({separableConv2d_:function(e,t,n,o,c,u=[1,1],h="NHWC"){const d=(0,r._1)(e,"x","separableConv2d"),p=(0,r._1)(t,"depthwiseFilter","separableConv2d"),f=(0,r._1)(n,"pointwiseFilter","separableConv2d");let m=d,g=!1;if(3===d.rank&&(g=!0,m=(0,l.X)(d,[1,d.shape[0],d.shape[1],d.shape[2]])),"NCHW"===h)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");i.hu(4===m.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${m.rank}.`)),i.hu(4===p.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${p.rank}.`)),i.hu(4===f.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${p.rank}.`)),i.hu(1===f.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${f.shape[0]}.`)),i.hu(1===f.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${f.shape[1]}.`));const y=p.shape[2],v=p.shape[3];i.hu(f.shape[2]===y*v,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${y*v}, but got ${f.shape[2]}.`));const x=(0,a.B)(m,p,o,c,h,u),b=(0,s.T)(x,f,1,"valid",h);return g?(0,l.X)(b,[b.shape[1],b.shape[2],b.shape[3]]):b}})},6567:(e,t,n)=>{"use strict";n.d(t,{O:()=>a});var r=n(4077),i=n(3740),s=n(9115);const a=async function(e,t){const n=(0,i._1)(e,"x","setdiff1d"),a=(0,i._1)(t,"y","setdiff1d");s.hu(n.dtype===a.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${a.dtype}).`)),s.hu(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),s.hu(1===a.rank,(()=>`y should be 1D tensor, but got y (${a.shape}).`));const o=await n.data(),l=await a.data(),c=new Set(l);let u=0;for(let e=0;e<o.length;e++)c.has(o[e])||u++;const h=new r.YD([u],n.dtype),d=new r.YD([u],"int32");for(let e=0,t=0;e<o.length;e++)c.has(o[e])||(h.values[t]=o[e],d.values[t]=e,t++);return[h.toTensor(),d.toTensor()]}},625:(e,t,n)=>{"use strict";n.d(t,{X:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({sigmoid_:function(e){const t={x:(0,s._1)(e,"x","sigmoid","float32")};return r.BV.runKernel(i.a5,t)}})},4434:(e,t,n)=>{"use strict";n.d(t,{X:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({sign_:function(e){const t={x:(0,s._1)(e,"x","sign")};return r.BV.runKernel(i.i5,t)}})},9331:(e,t,n)=>{"use strict";n.d(t,{O:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({sin_:function(e){const t={x:(0,s._1)(e,"x","sin","float32")};return r.BV.runKernel(i.RQ,t)}})},3254:(e,t,n)=>{"use strict";n.d(t,{R:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({sinh_:function(e){const t={x:(0,s._1)(e,"x","sinh")};return r.BV.runKernel(i.w3,t)}})},2676:(e,t,n)=>{"use strict";n.d(t,{t:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({slice_:function(e,t,n){const a=(0,s._1)(e,"x","slice","string_or_numeric");if(0===a.rank)throw new Error("Slicing scalar is not possible");const o={x:a},l={begin:t,size:n};return r.BV.runKernel(i.p2,o,l)}})},7650:(e,t,n)=>{"use strict";n.r(t),n.d(t,{assertParamsValid:()=>i,computeFlatOffset:()=>y,computeOutShape:()=>a,getNormalizedAxes:()=>u,isSliceContinous:()=>g,maskToAxes:()=>s,parseSliceParams:()=>v,sliceInfo:()=>x,startForAxis:()=>f,startIndicesWithElidedDims:()=>h,stopForAxis:()=>m,stopIndicesWithElidedDims:()=>d,stridesForAxis:()=>p,stridesWithElidedDims:()=>o});var r=n(9115);function i(e,t,n){const i=e.shape.length;r.hu(i===t.length,(()=>`Error in slice${i}D: Length of begin ${t} must match the rank of the array (${i}).`)),r.hu(i===n.length,(()=>`Error in slice${i}D: Length of size ${n} must match the rank of the array (${i}).`));for(let s=0;s<i;++s)r.hu(t[s]+n[s]<=e.shape[s],(()=>`Error in slice${i}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`))}function s(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function a(e,t,n){const r=[];for(let i=0;i<e.length;i++)r[i]=Math.ceil((t[i]-e[i])/n[i]);return r}function o(e,t,n,r){const i=[...e];for(let e=i.length;e<r.length;e++)i.push(1);for(let e=0;e<n;e++)0===e?i[t]=1:(i.splice(t,0,1),i.pop());return i}function l(e,t,n){return n<=e?n:n-(t-1)}function c(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function u(e,t,n,r,i,s,a,l,c){const u=e.length;let g=new Array(u),y=new Array(u),v=new Array(u);if(t.length&&n>0){const c=t[0],u=n+1;g=h(a,c,u,r,e),y=d(l,c,u,i,e),v=o(s,c,u,e)}else for(let t=0;t<u;t++)g[t]=f(a,r,s,e,t,c),y[t]=m(l,i,s,e,t,c),v[t]=p(s,t,c);return{begin:g,end:y,strides:v}}function h(e,t,n,r,i){const s=[...i],a=c(n,t);for(let i=0;i<s.length;i++)if(a.indexOf(i)>-1)s[i]=0;else{const a=l(t,n,i);let o=r[a];e&1<<a&&(o=0),s[i]=o}return s}function d(e,t,n,i,s){const a=[...s],o=c(n,t);for(let r=0;r<a.length;r++)if(o.indexOf(r)>-1)a[r]=Number.MAX_SAFE_INTEGER;else{const s=l(t,n,r);let o=i[s];e&1<<s&&(o=Number.MAX_SAFE_INTEGER),a[r]=o}for(let e=0;e<a.length;e++){const t=s[e];a[e]<0&&(a[e]+=t),a[e]=r.uZ(0,a[e],s[e])}return a}function p(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function f(e,t,n,i,s,a){let o=t[s];const l=n[s]||1;(e&1<<s||a&1<<s||null==o)&&(o=l>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const c=i[s];return o<0&&(o+=c),o=r.uZ(0,o,c-1),o}function m(e,t,n,i,s,a){let o=t[s];const l=n[s]||1;(e&1<<s||a&1<<s||null==o)&&(o=l>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const c=i[s];return o<0&&(o+=c),o=l>0?r.uZ(0,o,c):r.uZ(-1,o,c-1),o}function g(e,t,n){let r=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){r=e;break}for(let i=r+1;i<n.length;i++)if(t[i]>0||n[i]!==e[i])return!1;return!0}function y(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function v(e,t,n){let i;const s=e.shape.length;let a;return i="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),i.forEach((e=>{r.hu(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(r.hu(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-i[n]))),[i,a]}function x(e,t,n,r,i,s,a,o,l){let c;if(null==r?(c=new Array(t.length),c.fill(1)):c=r,null!=a&&0!=(a&a-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:c.slice(),beginMask:i,endMask:s,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};for(let e=0;e<h.dims;e++)u&&0!=(1<<e&o)&&h.numAddAxisAfterEllipsis++,1<<e&a&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const i=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<i;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(h,d);let p=!0,f=!0,m=!0;const g=[],y=[];for(let t=0;t<e.length;++t){if(0===d.strides[t])throw Error(`strides[${t}] must be non-zero`);const n=!!(d.shrinkAxisMask&1<<t),r=e[t];if(-1===r){g.push(n?1:-1);continue}const i=[d.beginMask&1<<t,d.endMask&1<<t],s=[d.strides[t]>0?0:-1,d.strides[t]>0?r:r-1];if(n&&d.strides[t]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===d.strides[t];const a=!!(d.beginMask&1<<t&&d.endMask&1<<t);if(d.beginValid&&d.endValid){if(n){const e=d.begin[t]<0?r+d.begin[t]:d.begin[t];if(d.begin[t]=e,d.end[t]=d.begin[t]+1,e<0||e>=r)throw Error(`slice index ${d.begin[t]} of dimension ${t} out of bounds.`)}else d.begin[t]=b(d.begin[t],0,d.strides[t],r,i,s),d.end[t]=b(d.end[t],1,d.strides[t],r,i,s);const e=1===d.strides[t]&&0===d.begin[t]&&d.end[t]===r;p=p&&e,f=f&&(0===t&&1===d.strides[t]||e)}else p=p&&1===d.strides[t]&&a,f=f&&(0===t&&1===d.strides[t]||a);let o,l=!1;if(d.beginValid&&d.endValid?(o=d.end[t]-d.begin[t],l=!0):n?(o=1,l=!0):a&&r>=0&&(o=d.strides[t]<0?-r:r,l=!0),l){let e;e=0===o||o<0!=d.strides[t]<0?0:Math.trunc(o/d.strides[t])+(o%d.strides[t]!=0?1:0),g.push(e)}else g.push(-1)}for(let e=0;e<d.finalShapeGatherIndices.length;++e){const t=d.finalShapeGatherIndices[e];t>=0?y.push(g[t]):-2===t&&y.push(1)}return{finalShapeSparse:y.filter(((e,t)=>-2!==d.finalShapeGatherIndices[t])),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function b(e,t,n,r,i,s){if(i[t])return n>0?s[t]:s[t+1&1];{const t=e<0?r+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}},682:(e,t,n)=>{"use strict";n.d(t,{X:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({softmax_:function(e,t=-1){const n=(0,s._1)(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const a={logits:n},o={dim:t};return r.BV.runKernel(i.Gc,a,o)}})},3694:(e,t,n)=>{"use strict";n.d(t,{W:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({softplus_:function(e){const t={x:(0,s._1)(e,"x","softplus")};return r.BV.runKernel(i.MR,t)}})},7918:(e,t,n)=>{"use strict";n.d(t,{f:()=>o});var r=n(7097),i=n(9121),s=n(3740),a=n(9115);const o=(0,n(2668).op)({spaceToBatchND_:function(e,t,n){const o=(0,s._1)(e,"x","spaceToBatchND");a.hu(o.rank>=1+t.length,(()=>`input rank ${o.rank} should be > than [blockShape] ${t.length}`)),a.hu(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),a.hu(o.shape.reduce(((e,r,i)=>i>0&&i<=t.length?e&&(r+n[i-1][0]+n[i-1][1])%t[i-1]==0:e),!0),(()=>`input spatial dimensions ${o.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const l={x:o},c={blockShape:t,paddings:n};return r.BV.runKernel(i.TQ,l,c)}})},9758:(e,t,n)=>{"use strict";n.d(t,{e:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({sparseToDense_:function(e,t,n,a=0){const o=(0,s._1)(e,"sparseIndices","sparseToDense","int32"),l=(0,s._1)(t,"sparseValues","sparseToDense","string_or_numeric"),c=(0,s._1)(a,"defaultValue","sparseToDense",l.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const i=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);const a=t.size;if(0!==t.rank&&(1!==t.rank||a!==i))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${i}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(o,l,n,c);const u={sparseIndices:o,sparseValues:l,defaultValue:c},h={outputShape:n};return r.BV.runKernel(i.D2,u,h)}})},7020:(e,t,n)=>{"use strict";n.d(t,{k:()=>a});var r=n(7097),i=n(9121),s=n(9115);const a=(0,n(2668).op)({fft_:function(e){(0,s.hu)("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return r.BV.runKernel(i.vw,t)}})},8447:(e,t,n)=>{"use strict";n.d(t,{S:()=>a});var r=n(7097),i=n(9121),s=n(9115);const a=(0,n(2668).op)({ifft_:function(e){(0,s.hu)("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return r.BV.runKernel(i.Qg,t)}})},4415:(e,t,n)=>{"use strict";n.d(t,{w:()=>f});var r=n(1661),i=n(6884),s=n(4386),a=n(4841),o=n(2668),l=n(766),c=n(4968),u=n(7486),h=n(9494),d=n(2676),p=n(8447);const f=(0,o.op)({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let o;if(t<=2){const r=(0,c.X)(e,[n,t]);o=(0,p.S)(r)}else{const f=[n,2*(t-1)],m=(0,c.X)((0,l.k)(e),[n,t]),g=(0,c.X)((0,s.a)(e),[n,t]),y=(0,u.G)((0,d.t)(m,[0,1],[n,t-2]),1),v=(0,a.d)((0,u.G)((0,d.t)(g,[0,1],[n,t-2]),1),(0,h.i)(-1)),x=(0,i.z)([m,y],1),b=(0,i.z)([g,v],1),w=(0,c.X)((0,r.P)(x,b),[f[0],f[1]]);o=(0,p.S)(w)}if(o=(0,l.k)(o),3===e.rank&&0!==e.shape[0]){const t=o,n=e.shape[0];o=(0,c.X)(o,[n,o.shape[0]/n,o.shape[1]]),t.dispose()}return o}})},3710:(e,t,n)=>{"use strict";n.d(t,{Q:()=>m});var r=n(9115),i=n(1661),s=n(6884),a=n(4386),o=n(2668),l=n(766),c=n(4968),u=n(2676),h=n(8644),d=n(723),p=n(6577),f=n(7020);const m=(0,o.op)({rfft_:function(e,t){(0,r.hu)("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const o=e.size/n;let m;if(null!=t&&t<n){const r=e.shape.map((e=>0)),i=e.shape.map((e=>e));i[e.shape.length-1]=t,m=(0,u.t)(e,r,i),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,m=(0,s.z)([e,(0,d.l)(r)],e.shape.length-1),n=t}else m=e;const g=(0,p.P)(m),y=(0,c.X)((0,i.P)(m,g),[o,n]),v=(0,f.k)(y),x=Math.floor(n/2)+1,b=(0,l.k)(v),w=(0,a.a)(v),_=(0,h.V)(b,[x,n-x],b.shape.length-1),S=(0,h.V)(w,[x,n-x],w.shape.length-1),M=m.shape.slice();return M[m.shape.length-1]=x,(0,c.X)((0,i.P)(_[0],S[0]),M)}})},8644:(e,t,n)=>{"use strict";n.d(t,{V:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({split_:function(e,t,n=0){const a={x:(0,s._1)(e,"x","split")},o={numOrSizeSplits:t,axis:n};return r.BV.runKernel(i.L8,a,o)}})},3261:(e,t,n)=>{"use strict";n.d(t,{_:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({sqrt_:function(e){const t={x:(0,s._1)(e,"x","sqrt","float32")};return r.BV.runKernel(i.FK,t)}})},248:(e,t,n)=>{"use strict";n.d(t,{h:()=>s});var r=n(7097),i=n(3740);const s=(0,n(2668).op)({square_:function(e){const t=(0,i._1)(e,"x","square");return r.BV.runKernel("Square",{x:t},{})}})},5265:(e,t,n)=>{"use strict";n.d(t,{$:()=>l});var r=n(7097),i=n(9121),s=n(747),a=n(3740),o=n(2200);const l=(0,n(2668).op)({squaredDifference_:function(e,t){let n=(0,a._1)(e,"a","squaredDifference"),l=(0,a._1)(t,"b","squaredDifference");[n,l]=(0,s.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const c={a:n,b:l};return r.BV.runKernel(i._t,c,{})}})},9590:(e,t,n)=>{"use strict";n.d(t,{L:()=>o});var r=n(3740),i=n(9115),s=n(2668),a=n(4968);const o=(0,s.op)({squeeze_:function(e,t){const n=(0,r._1)(e,"x","squeeze");return(0,a.X)(n,(0,i.bp)(n.shape,t).newShape)}})},2991:(e,t,n)=>{"use strict";n.d(t,{k:()=>o});var r=n(7097),i=n(9121),s=n(3740),a=n(9115);const o=(0,n(2668).op)({stack_:function(e,t=0){const n=(0,s.sI)(e,"tensors","stack","string_or_numeric");a.hu(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&a.hu(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const o=n,l={axis:t};return r.BV.runKernel(i.Qi,o,l)}})},1901:(e,t,n)=>{"use strict";n.d(t,{N:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({step_:function(e,t=0){const n={x:(0,s._1)(e,"x","step")},a={alpha:t};return r.BV.runKernel(i.h8,n,a)}})},5158:(e,t,n)=>{"use strict";n.d(t,{N:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({stridedSlice_:function(e,t,n,a,o=0,l=0,c=0,u=0,h=0){const d={x:(0,s._1)(e,"x","stridedSlice","string_or_numeric")},p={begin:t,end:n,strides:a,beginMask:o,endMask:l,ellipsisMask:c,newAxisMask:u,shrinkAxisMask:h};return r.BV.runKernel(i.m2,d,p)}})},827:(e,t,n)=>{"use strict";n.d(t,{l:()=>o});var r=n(7097),i=n(9121),s=n(747),a=n(3740);const o=(0,n(2668).op)({sub_:function(e,t){let n=(0,a._1)(e,"a","sub"),o=(0,a._1)(t,"b","sub");[n,o]=(0,s.makeTypesMatch)(n,o);const l={a:n,b:o};return r.BV.runKernel(i.Tr,l)}})},5475:(e,t,n)=>{"use strict";n.d(t,{S:()=>o});var r=n(7097),i=n(9121),s=n(3740),a=n(2271);const o=(0,n(2668).op)({sum_:function(e,t=null,n=!1){let o=(0,s._1)(e,"x","sum");"bool"===o.dtype&&(o=(0,a.p)(o,"int32"));const l={x:o},c={axis:t,keepDims:n};return r.BV.runKernel(i.GB,l,c)}})},1173:(e,t,n)=>{"use strict";n.d(t,{O:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({tan_:function(e){const t={x:(0,s._1)(e,"x","tan","float32")};return r.BV.runKernel(i.sE,t)}})},1869:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({tanh_:function(e){const t={x:(0,s._1)(e,"x","tanh","float32")};return r.BV.runKernel(i.MI,t)}})},701:(e,t,n)=>{"use strict";n.d(t,{X:()=>s});var r=n(3740),i=n(7852);function s(e,t,n){const s=(0,r.C)(e,n);return(0,i.H)(e,t,s,n)}},6092:(e,t,n)=>{"use strict";n.d(t,{R:()=>a});var r=n(3740),i=n(9115),s=n(7852);function a(e,t){(0,i.Cq)(e);const n=(0,r.C)(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,s.H)(e,null,n,t)}},9906:(e,t,n)=>{"use strict";n.d(t,{w:()=>a});var r=n(3740),i=n(9115),s=n(7852);function a(e,t,n){if((0,i.Cq)(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const a=(0,r.C)(e,n);if(3!==a.length&&1!==a.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,s.H)(e,t,a,n)}},7852:(e,t,n)=>{"use strict";n.d(t,{H:()=>a});var r=n(7097),i=n(9115),s=n(9122);function a(e,t,n,a){if(null==a&&(a=(0,i.D2)(e)),"complex64"===a)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!(0,i.fU)(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){(0,i.Mu)(t);const e=(0,i.NA)(t),r=(0,i.NA)(n);(0,i.hu)(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let e=0;e<n.length;++e){const r=n[e],s=e!==n.length-1||r!==(0,i.NA)(t.slice(e));(0,i.hu)(n[e]===t[e]||!s,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return(0,i.fU)(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==a?(0,s.toTypedArray)(e,a):(0,i.xH)(e,[],!0),r.BV.makeTensor(e,t,a)}},7501:(e,t,n)=>{"use strict";n.d(t,{G:()=>o});var r=n(7097),i=n(9121),s=n(3740),a=n(9115);const o=(0,n(2668).op)({tile_:function(e,t){const n=(0,s._1)(e,"x","tile","string_or_numeric");a.hu(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const o={x:n},l={reps:t};return r.BV.runKernel(i.n9,o,l)}})},3243:(e,t,n)=>{"use strict";n.d(t,{h:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({topk_:function(e,t=1,n=!0){const a=(0,s._1)(e,"x","topk");if(0===a.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const o=a.shape[a.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${t}`);const l={x:a},c={k:t,sorted:n},[u,h]=r.BV.runKernel(i.cW,l,c);return{values:u,indices:h}}})},9065:(e,t,n)=>{"use strict";n.d(t,{p:()=>p});var r=n(7097),i=n(4368),s=n(9121),a=n(3740),o=n(9115),l=n(1661),c=n(4386),u=n(7370),h=n(2668),d=n(766);const p=(0,h.op)({transpose_:function(e,t,n){const h=(0,a._1)(e,"x","transpose");if(null==t&&(t=h.shape.map(((e,t)=>t)).reverse()),o.hu(h.rank===t.length,(()=>`Error in transpose: rank of input ${h.rank} must match length of perm ${t}.`)),t.forEach((e=>{o.hu(e>=0&&e<h.rank,(()=>"All entries in 'perm' must be between 0 and "+(h.rank-1)+` but got ${t}`))})),h.rank<=1)return h.clone();const p={x:h},f={perm:t};return"complex64"===h.dtype?(0,i.lu)((()=>{let e=(0,d.k)(h),t=(0,c.a)(h);return e=r.BV.runKernel(s.G3,{x:e},f),t=r.BV.runKernel(s.G3,{x:t},f),n&&(t=(0,u.W)(t)),(0,l.P)(e,t)})):r.BV.runKernel(s.G3,p,f)}})},3596:(e,t,n)=>{"use strict";n.d(t,{X:()=>a});var r=n(2657),i=n(2668),s=n(6845);const a=(0,i.op)({truncatedNormal_:function(e,t=0,n=1,i,a){if(null!=i&&"bool"===i)throw new Error("Unsupported data type $ { dtype }");const o=new s.Yi(t,n,i,!0,a),l=(0,r.f)(e,i);for(let e=0;e<l.values.length;e++)l.values[e]=o.nextValue();return l.toTensor()}})},9608:(e,t,n)=>{"use strict";n.d(t,{T:()=>o});var r=n(7097),i=n(9121),s=n(3740),a=n(9115);const o=(0,n(2668).op)({unique_:function(e,t=0){const n=(0,s._1)(e,"x","unique","string_or_numeric");(0,a.hu)(n.rank>0,(()=>"The input tensor must be at least 1D"));const o={x:n},l={axis:t},[c,u]=r.BV.runKernel(i.kp,o,l);return{values:c,indices:u}}})},8749:(e,t,n)=>{"use strict";n.d(t,{p:()=>o});var r=n(7097),i=n(9121),s=n(3740),a=n(9115);const o=(0,n(2668).op)({unsortedSegmentSum_:function(e,t,n){const o=(0,s._1)(e,"x","unsortedSegmentSum"),l=(0,s._1)(t,"segmentIds","unsortedSegmentSum","int32");(0,a.hu)((0,a.GN)(n),(()=>"numSegments must be of dtype int"));const c={x:o,segmentIds:l},u={numSegments:n};return r.BV.runKernel(i.Qv,c,u)}})},4136:(e,t,n)=>{"use strict";n.d(t,{H:()=>o});var r=n(7097),i=n(9121),s=n(3740),a=n(9115);const o=(0,n(2668).op)({unstack_:function(e,t=0){const n=(0,s._1)(e,"x","unstack","string_or_numeric");a.hu(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const o={value:n},l={axis:t};return r.BV.runKernel(i.To,o,l)}})},4978:(e,t,n)=>{"use strict";n.d(t,{G:()=>i});var r=n(3336);function i(e,t){return(0,r.z)(e,t,"right")}},5912:(e,t,n)=>{"use strict";n.d(t,{a:()=>l});var r=n(7097),i=n(9121),s=n(3740),a=n(8247),o=n(2200);const l=(0,n(2668).op)({where_:function(e,t,n){const l=(0,s._1)(t,"a","where"),c=(0,s._1)(n,"b","where"),u=(0,s._1)(e,"condition","where","bool"),h=(0,o.assertAndGetBroadcastShape)((0,o.assertAndGetBroadcastShape)(u.shape,l.shape),c.shape),d={condition:(0,a.U)(u,h),t:(0,a.U)(l,h),e:(0,a.U)(c,h)};return r.BV.runKernel(i.Ph,d)}})},6380:(e,t,n)=>{"use strict";n.d(t,{i:()=>s});var r=n(8333),i=n(3740);const s=async function(e){const t=(0,i._1)(e,"condition","whereAsync","bool"),n=await t.data(),s=(0,r.Z)(t.shape,n);return e!==t&&t.dispose(),s}},723:(e,t,n)=>{"use strict";n.d(t,{l:()=>a});var r=n(7097),i=n(9115),s=n(1661);function a(e,t="float32"){if("complex64"===t){const t=a(e,"float32"),n=a(e,"float32");return(0,s.P)(t,n)}const n=(0,i.wT)((0,i.NA)(e),t);return r.BV.makeTensor(n,e,t)}},6577:(e,t,n)=>{"use strict";n.d(t,{P:()=>a});var r=n(7097),i=n(9121),s=n(3740);const a=(0,n(2668).op)({zerosLike_:function(e){const t={x:(0,s._1)(e,"x","zerosLike")};return r.BV.runKernel(i.Ru,t)}})},6190:(e,t,n)=>{"use strict";var r=n(9121),i=n(2271),s=n(4841),a=n(1901);const o={kernelName:r.SY,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.d)(e,(0,a.N)((0,i.p)(n,"float32"),-1))}}};var l=n(1274),c=n(7370),u=n(9494),h=n(3261),d=n(248),p=n(827);const f={kernelName:r.VG,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=(0,d.h)((0,i.p)(n,"float32")),r=(0,h._)((0,p.l)((0,u.i)(1),t));return(0,c.W)((0,l.h)(e,r))}}}},m={kernelName:r.Sp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=(0,h._)((0,p.l)((0,d.h)((0,i.p)(n,"float32")),1));return(0,l.h)(e,t)}}}};var g=n(2200),y=n(4968),v=n(5475);const x={kernelName:r.mm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,i=g.assertAndGetBroadcastShape(n.shape,r.shape);return{a:()=>{let t=e;const r=g.getReductionAxes(n.shape,i);return r.length>0&&(t=(0,v.S)(t,r)),(0,y.X)(t,n.shape)},b:()=>{let t=e;const n=g.getReductionAxes(r.shape,i);return n.length>0&&(t=(0,v.S)(t,n)),(0,y.X)(t,r.shape)}}}},b={kernelName:r.Xz,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}};var w=n(6577);const _={kernelName:r.sJ,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,w.P)(n)}}},S={kernelName:r.aJ,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,w.P)(n)}}},M={kernelName:r.M2,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,l.h)(e,(0,h._)((0,p.l)((0,u.i)(1),(0,d.h)((0,i.p)(n,"float32")))))}}};var T=n(6407);const E={kernelName:r.qw,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=(0,h._)((0,T.I)((0,u.i)(1),(0,d.h)((0,i.p)(n,"float32"))));return(0,l.h)(e,t)}}}},A={kernelName:r.QC,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,i=(0,g.assertAndGetBroadcastShape)(n.shape,r.shape);return{a:()=>{const t=(0,T.I)((0,d.h)(n),(0,d.h)(r));let a=(0,s.d)(e,(0,l.h)(r,t));const o=(0,g.getReductionAxes)(n.shape,i);return o.length>0&&(a=(0,v.S)(a,o)),(0,y.X)(a,n.shape)},b:()=>{const t=(0,T.I)((0,d.h)(n),(0,d.h)(r));let a=(0,c.W)((0,s.d)(e,(0,l.h)(n,t)));const o=(0,g.getReductionAxes)(r.shape,i);return o.length>0&&(a=(0,v.S)(a,o)),(0,y.X)(a,r.shape)}}}},C={kernelName:r.jM,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,l.h)(e,(0,T.I)((0,d.h)((0,i.p)(n,"float32")),1))}}},I={kernelName:r.Oy,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,l.h)(e,(0,p.l)((0,u.i)(1),(0,d.h)((0,i.p)(n,"float32"))))}}};var N=n(7097),k=n(3740),R=n(9115),D=n(2582),L=n(2668);const F=(0,L.op)({avgPool3dGrad_:function(e,t,n,i,s,a){const o=(0,k._1)(e,"dy","avgPool3dGrad"),l=(0,k._1)(t,"input","avgPool3dGrad");let c=o,u=l,h=!1;4===l.rank&&(h=!0,c=(0,y.X)(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),u=(0,y.X)(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),R.hu(5===c.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),R.hu(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),(0,D.m)("avgPool3dGrad",s,a);const d={dy:c,input:u},p={filterSize:n,strides:i,pad:s,dimRoundingMode:a},f=N.BV.runKernel(r.IM,d,p);return h?(0,y.X)(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),P={kernelName:r._k,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:i,strides:s,pad:a,dimRoundingMode:o}=n;return{x:()=>F(e,r,i,s,a,o)}}},O=(0,L.op)({avgPoolGrad_:function(e,t,n,i,s){const a=(0,k._1)(e,"dy","avgPoolGrad"),o=(0,k._1)(t,"input","avgPoolGrad");R.hu(o.rank===a.rank,(()=>`Rank of input (${o.rank}) does not match rank of dy (${a.rank})`));let l=o,c=a,u=!1;3===o.rank&&(u=!0,l=(0,y.X)(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=(0,y.X)(a,[1,a.shape[0],a.shape[1],a.shape[2]])),R.hu(4===c.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${c.rank}.`)),R.hu(4===l.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${l.rank}.`));const h={dy:c,input:l},d={filterSize:n,strides:i,pad:s},p=N.BV.runKernel(r.RO,h,d);return u?(0,y.X)(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),z={kernelName:r.Jh,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:i,strides:s,pad:a}=n;return{x:()=>O(e,r,i,s,a)}}};var B=n(8687);const U={kernelName:r.XL,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,i]=t,{transposeA:s,transposeB:a}=n;return s||a?!s&&a?{a:()=>(0,B.O)(e,i,!1,!1),b:()=>(0,B.O)(e,r,!0,!1)}:s&&!a?{a:()=>(0,B.O)(i,e,!1,!0),b:()=>(0,B.O)(r,e,!1,!1)}:{a:()=>(0,B.O)(i,e,!0,!0),b:()=>(0,B.O)(e,r,!0,!0)}:{a:()=>(0,B.O)(e,i,!1,!0),b:()=>(0,B.O)(r,e,!0,!1)}}};var $=n(7918);const V={kernelName:r.zw,gradFunc:(e,t,n)=>{const{blockShape:r,crops:i}=n;return{x:()=>(0,$.f)(e,r,i)}}},W={kernelName:r.Ly,gradFunc:(e,t,n)=>{const r=n,i=r.inputShape,s=r.shape,a=Array.from(s);for(let e=i.length-1;e>=0;e--)if(i[e]===s[e])a[e]=1;else if(1!==i[e])throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${s}].`);const o=[];for(let e=0;e<a.length;e++)a[e]>1&&o.push(e);return{x:()=>(0,v.S)(e,o,!0)}}},G={kernelName:r.RF,gradFunc:e=>({x:()=>e.clone()})},H={kernelName:r.gJ,gradFunc:e=>({x:()=>(0,w.P)(e)})};var j=n(7630),q=n(624),X=n(2856),Y=n(5912);const K={kernelName:r.xn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:i,clipValueMax:s}=n;return{x:()=>(0,Y.a)((0,X.H)((0,j.b)(r,i),(0,q.z)(r,s)),e,(0,w.P)(e))}}},Z={kernelName:r.yj,inputsToSave:["x"],gradFunc:o.gradFunc};var J=n(8644);const Q={kernelName:r.Eh,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map((e=>e.shape)),{axis:i}=n,s=(0,R.EC)(i,t[0].shape)[0],a=r.map((e=>e[s]));return(0,J.V)(e,a,s).map((e=>()=>e))}};var ee=n(6013),te=n(9832);const ne={kernelName:r.mh,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,i]=t,{dilations:s,strides:a,pad:o,dataFormat:l}=n;return R.hu(D.I0(s),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`)),{x:()=>(0,te._)(r.shape,e,i,a,o,l),filter:()=>(0,ee.p)(r,e,i.shape,a,o,l)}}};var re=n(4794);const ie={kernelName:r.wm,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,i]=t,{strides:s,pad:a,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>(0,re.T)(e,i,s,a,o,1,l),filter:()=>(0,ee.p)(e,r,i.shape,s,a,o,l)}}},se=(0,L.op)({conv3DBackpropFilter_:function(e,t,n,i,s){let a=e;4===e.rank&&(a=(0,y.X)(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let o=t;4===o.rank&&(o=(0,y.X)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),R.hu(5===a.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`)),R.hu(5===o.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`)),R.hu(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),R.hu(a.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`)),R.hu(o.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${n[4]}).`));const l={x:a,dy:o},c={strides:i,pad:s,filterShape:n};return N.BV.runKernel(r.o2,l,c)}});var ae=n(7594);const oe={kernelName:r.x1,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:i,pad:s}=n;R.hu((0,D.I0)(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[a,o]=t;return{x:()=>(0,ae._)(a.shape,e,o,i,s),filter:()=>se(a,e,o.shape,i,s)}}};var le=n(9331);const ce={kernelName:r.mc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.d)((0,c.W)((0,le.O)((0,i.p)(n,"float32"))),e)}}};var ue=n(3254);const he={kernelName:r.TR,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.d)((0,ue.R)((0,i.p)(n,"float32")),e)}}};var de=n(3591),pe=n(7405),fe=n(9065);const me={kernelName:r.iH,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:i,exclusive:s,reverse:a}=n;return{x:()=>{const t=(0,de.Q3)([i],r.rank);let n=(0,pe.z)(e,i,s,!a);return null!=t&&(n=(0,fe.p)(n,t)),n}}}};var ge=n(8098),ye=n(4375);const ve={kernelName:r.ci,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:i,pad:s,dimRoundingMode:a}=n,o=null==r?[1,1]:r;R.hu(D.I0(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));const[l,c]=t;return R.hu(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),R.hu(4===c.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`)),R.hu(l.shape[3]===c.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`)),R.hu(D.jT(i,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${o}'.`)),D.m("depthwiseConv2d",s,a),{x:()=>(0,ye.v)(l.shape,e,c,i,s,o,a),filter:()=>(0,ge.z)(l,e,c.shape,i,s,o,a)}}},xe={kernelName:r.p4,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[i,s]=t,a={x:i,filter:s,dy:e},o={x:i,filter:s,dy:e};return{x:()=>N.BV.runKernel(r.ek,a,n),filter:()=>N.BV.runKernel(r.Vn,o,n)}}},be={kernelName:r.SX,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,i={dy:e,y:n};return{x:()=>N.BV.runKernel(r.HE,i)}}};var we=n(4842);const _e={kernelName:r.Om,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=(0,s.d)((0,we.Q)((0,c.W)((0,d.h)(n))),2/Math.sqrt(Math.PI));return{x:()=>(0,s.d)(e,r)}}},Se={kernelName:r.NE,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.d)(e,n)}}},Me={kernelName:r.YF,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>(0,y.X)(e,n.shape)}}},Te={kernelName:r.Y0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.d)(e,(0,we.Q)(n))}}},Ee={kernelName:r.OR,gradFunc:e=>({x:()=>(0,w.P)(e)})},Ae={kernelName:r.je,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=(0,g.assertAndGetBroadcastShape)(n.shape,r.shape);return{a:()=>{const t=(0,l.h)(e,(0,i.p)(r,"float32")),s=(0,g.getReductionAxes)(n.shape,a);return s.length>0?(0,y.X)((0,v.S)(t,s),n.shape):t},b:()=>{let t=(0,s.d)(e,(0,i.p)(n,"float32"));const o=(0,g.getReductionAxes)(r.shape,a);o.length>0&&(t=(0,y.X)((0,v.S)(t,o),r.shape));const u=(0,d.h)(r);return(0,c.W)((0,l.h)(t,(0,i.p)(u,"float32")))}}}};var Ce=n(2634),Ie=n(7501);const Ne={kernelName:r.sH,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[i,a,o,l]=t,c=null==l?(0,u.i)(1):l,h=(0,g.getReductionAxes)(a.shape,i.shape),d=[];if(1===a.rank){for(let e=0;e<i.shape.length-1;++e)d.push(i.shape[e]);d.push(1)}const f=(0,p.l)(i,a),m=(0,s.d)(e,c),x=(0,Ce.b)((0,T.I)(o,(0,u.i)(r))),b=(0,s.d)((0,s.d)((0,s.d)(x,x),x),(0,u.i)(-.5));return{x:()=>1===a.rank?(0,y.X)((0,s.d)((0,s.d)(e,(0,Ie.G)((0,y.X)(x,[1,1,1,a.shape[0]]),d)),c),i.shape):(0,y.X)((0,s.d)((0,s.d)(e,x),c),i.shape),mean:()=>{let e=(0,s.d)((0,s.d)(x,(0,u.i)(-1)),m);return 1===a.rank&&(e=(0,v.S)(e,h)),(0,y.X)(e,a.shape)},variance:()=>{let e=(0,s.d)((0,s.d)(b,f),m);return 1===a.rank&&(e=(0,v.S)(e,h)),(0,y.X)(e,a.shape)},scale:()=>{const t=(0,s.d)(f,x);let n=(0,s.d)(e,t);return 1===a.rank&&(n=(0,v.S)(n,h)),(0,y.X)(n,a.shape)},offset:()=>{let t=e;return 1===a.rank&&(t=(0,v.S)(t,h)),(0,y.X)(t,a.shape)}}}};var ke=n(8749);const Re={kernelName:r.qi,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,i]=t,{axis:s}=n,a=(0,R.EC)(s,r.shape)[0];return{x:()=>{const t=r.shape,n=i.size,o=t.slice(0,a),l=o.length,c=t.slice(s,t.length).slice(1),u=c.length,h=De(0,l),d=De(l+1,l+1+u),p=Le([o,[n],c]),f=(0,y.X)(e,p),m=(0,y.X)(i,[n]),g=Le([[l],h,d]),v=(0,fe.p)(f,g);let x=(0,ke.p)(v,m,r.shape[a]);const b=(0,de.LJ)(g);return x=(0,fe.p)(x,b),x},indices:()=>i}}};function De(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function Le(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}const Fe={kernelName:r.Ac,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>(0,w.P)(n),b:()=>(0,w.P)(r)}}},Pe={kernelName:r.iJ,gradFunc:e=>({x:()=>(0,i.p)(e,"float32")})},Oe={kernelName:r.av,gradFunc:e=>({x:()=>(0,w.P)(e)})},ze={kernelName:r.iW,gradFunc:e=>({x:()=>(0,w.P)(e)})},Be={kernelName:r.r7,gradFunc:e=>({x:()=>(0,w.P)(e)})};var Ue=n(636);const $e={kernelName:r.J$,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:i}=n,a=(0,Ue.p)(r,0);return{x:()=>(0,Y.a)(a,e,(0,s.d)(e,i))}}},Ve={kernelName:r.kU,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,l.h)(e,(0,T.I)(n,1))}}},We={kernelName:r.Zb,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,l.h)(e,(0,i.p)(n,"float32"))}}},Ge={kernelName:r.qC,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:i}=n;return{logits:()=>{const t=(0,we.Q)(r);return(0,p.l)(e,(0,s.d)((0,v.S)(e,i,!0),t))}}}},He=(0,L.op)({localResponseNormalizationBackprop_:function(e,t,n,i=5,s=1,a=1,o=.5){const l={x:e,y:t,dy:n},c={depthRadius:i,bias:s,alpha:a,beta:o};return N.BV.runKernel(r.Hh,l,c)}}),je={kernelName:r.eZ,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,i]=t,{depthRadius:s,bias:a,alpha:o,beta:l}=n;return{x:()=>He(r,i,e,s,a,o,l)}}};var qe=n(6477);function Xe(e,t,n,r){return t.rank<n.rank&&(t=(0,y.X)(t,de.rv(t.shape,r))),e.rank<n.rank&&(e=(0,y.X)(e,de.rv(e.shape,r))),{x:()=>(0,s.d)(e,(0,i.p)((0,qe.D)(n,t),e.dtype))}}const Ye={kernelName:r.Yo,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:i}=r,s=t[0],a=Xe(e,t[1],s,R.EC(i,s.shape));return{x:()=>a.x()}}};var Ke=n(6573);const Ze={kernelName:r.BM,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>(0,s.d)(e,(0,i.p)((0,j.b)(n,r),"float32")),b:()=>(0,s.d)(e,(0,i.p)((0,Ke.d)(n,r),"float32"))}}},Je=(0,L.op)({maxPool3dGrad_:function(e,t,n,i,s,a,o){const l=(0,k._1)(e,"dy","maxPool3dGrad"),c=(0,k._1)(t,"input","maxPool3dGrad"),u=(0,k._1)(n,"output","maxPool3dGrad");let h=l,d=c,p=u,f=!1;4===c.rank&&(f=!0,h=(0,y.X)(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=(0,y.X)(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),p=(0,y.X)(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),R.hu(5===h.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${h.rank}.`)),R.hu(5===d.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`)),R.hu(5===p.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`)),(0,D.m)("maxPool3dGrad",a,o);const m={dy:h,input:d,output:p},g={filterSize:i,strides:s,pad:a,dimRoundingMode:o},v=N.BV.runKernel(r.OU,m,g);return f?(0,y.X)(v,[v.shape[1],v.shape[2],v.shape[3],v.shape[4]]):v}}),Qe={kernelName:r.OA,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,i]=t,{filterSize:s,strides:a,pad:o,dimRoundingMode:l}=n;return{x:()=>Je(e,r,i,s,a,o,l)}}},et=(0,L.op)({maxPoolGrad_:function(e,t,n,i,s,a,o){const l=(0,k._1)(e,"dy","maxPoolGrad"),c=(0,k._1)(t,"input","maxPoolGrad"),u=(0,k._1)(n,"output","maxPoolGrad");R.hu(c.rank===l.rank,(()=>`Rank of input (${c.rank}) does not match rank of dy (${l.rank})`)),R.hu(4===l.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),R.hu(4===c.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${c.rank}.`)),D.m("maxPoolGrad",a,o);const h={dy:l,input:c,output:u},d={filterSize:i,strides:s,pad:a,dimRoundingMode:o};return N.BV.runKernel(r.OV,h,d)}}),tt={kernelName:r.mT,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,i]=t,{filterSize:s,strides:a,pad:o}=n;return{x:()=>et(e,r,i,s,a,o)}}};var nt=n(4917);const rt={kernelName:r.q2,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:i}=n,a=R.EC(i,r.shape),o=(0,de.kz)(r.shape,a)[1],c=R.NA(o);return{x:()=>{const t=r.shape.slice();a.forEach((e=>{t[e]=1}));const n=(0,y.X)(e,t);return(0,l.h)((0,s.d)(n,(0,nt.i)(r.shape,"float32")),c)}}}},it={kernelName:r.c1,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:i}=r,[s,a]=t,o=Xe(e,a,s,R.EC(i,s.shape));return{x:()=>o.x()}}},st={kernelName:r.q8,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>(0,s.d)(e,(0,i.p)((0,q.z)(n,r),"float32")),b:()=>(0,s.d)(e,(0,i.p)((0,Ue.p)(n,r),"float32"))}}};var at=n(2676);const ot={kernelName:r.jQ,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:i}=n,s=i.map((e=>e[0]));return{x:()=>(0,at.t)(e,s,r.shape)}}};var lt=n(6943);const ct={kernelName:r.Vb,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,i=(0,g.assertAndGetBroadcastShape)(n.shape,r.shape);return{a:()=>{const t=(0,g.getReductionAxes)(n.shape,i);return t.length>0?(0,y.X)((0,v.S)(e,t),n.shape):e},b:()=>{const t=(0,s.d)(e,(0,c.W)((0,lt.G)((0,l.h)(n,r)))),a=(0,g.getReductionAxes)(r.shape,i);return a.length>0?(0,y.X)((0,v.S)(t,a),r.shape):t}}}},ut={kernelName:r.wY,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=(0,g.assertAndGetBroadcastShape)(n.shape,r.shape);return{a:()=>{const t=(0,s.d)(e,(0,i.p)(r,"float32")),o=(0,g.getReductionAxes)(n.shape,a);return o.length>0?(0,y.X)((0,v.S)(t,o),n.shape):t},b:()=>{const t=(0,s.d)(e,(0,i.p)(n,"float32")),o=(0,g.getReductionAxes)(r.shape,a);return o.length>0?(0,y.X)((0,v.S)(t,o),r.shape):t}}}},ht={kernelName:r.ku,gradFunc:e=>({x:()=>(0,c.W)(e)})};var dt=n(723);const pt={kernelName:r.we,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>(0,dt.l)(n.shape,"float32")}}},ft={kernelName:r.qW,gradFunc:e=>({x:()=>(0,w.P)(e)})};var mt=n(4136);const gt={kernelName:r.Qi,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return(0,mt.H)(e,r).map((e=>()=>e))}},yt={kernelName:r.ly,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:i}=n,s=i.map((e=>e[0]));return{x:()=>(0,at.t)(e,s,r.shape)}}};var vt=n(2597),xt=n(3453);const bt={kernelName:r.pe,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,a]=t,o=n,l=r,c=g.assertAndGetBroadcastShape(o.shape,l.shape);return{a:()=>{const t=(0,i.p)(l,"float32");let n=(0,s.d)(e,(0,s.d)(t,(0,xt.s)(o,(0,p.l)(t,(0,u.i)(1)))));const r=g.getReductionAxes(o.shape,c);return r.length>0&&(n=(0,v.S)(n,r)),(0,y.X)(n,o.shape)},b:()=>{const t=(0,Ue.p)(o,0),n=(0,Y.a)(t,(0,vt.c)(o),(0,w.P)(o));let r=(0,s.d)(e,(0,s.d)(a,n));const i=g.getReductionAxes(l.shape,c);return i.length>0&&(r=(0,v.S)(r,i)),(0,y.X)(r,l.shape)}}}},wt={kernelName:r.o0,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,i=(0,Ue.p)(n,0);return{x:()=>(0,Y.a)(i,e,(0,s.d)(e,r)),alpha:()=>{let t=(0,Y.a)(i,(0,w.P)(e),(0,s.d)(e,n));const a=(0,g.getReductionAxes)(r.shape,e.shape);return a.length>0&&(t=(0,v.S)(t,a)),(0,y.X)(t,r.shape)}}}};var _t=n(9640);const St={kernelName:r.Dl,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:i}=n;let a=[];return a=null==i?r.shape.map(((e,t)=>t)):"number"==typeof i?[i]:i,{x:()=>function(e,t,n){const r=e.shape.length,i=r-n.length,a=de.Q3(n,r);let o=e;null!=a&&(o=(0,fe.p)(e,a));const l=o.shape.slice(),c=l.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);l.push(c);let u=function(e,t,n){const r=e.shape.slice();r[n]=1;const i=(0,y.X)(t,r),a=(0,_t.$)(e,n,!0,!1),o=(0,_t.$)(e,n,!0,!0),l=(0,s.d)(a,o);return(0,s.d)(i,l)}(o.reshape(l),t,i);if(u=u.reshape(o.shape),null!=a){const e=de.LJ(a);u=(0,fe.p)(u,e)}return u}(r,e,a)}}},Mt={kernelName:r.oH,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=g.assertAndGetBroadcastShape(n.shape,r.shape);return{a:()=>{const t=(0,l.h)(e,(0,i.p)(r,"float32")),s=g.getReductionAxes(n.shape,a);return s.length>0?(0,y.X)((0,v.S)(t,s),n.shape):t},b:()=>{let t=(0,s.d)(e,(0,i.p)(n,"float32"));const o=g.getReductionAxes(r.shape,a);o.length>0&&(t=(0,y.X)((0,v.S)(t,o),r.shape));const u=(0,d.h)(r);return(0,c.W)((0,l.h)(t,(0,i.p)(u,"float32")))}}}},Tt={kernelName:r.$H,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,l.h)(e,(0,c.W)((0,d.h)(n)))}}},Et={kernelName:r.Sb,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=(0,s.d)((0,q.z)(n,6),(0,a.N)(n));return{x:()=>(0,s.d)(e,(0,i.p)(r,"float32"))}}},At={kernelName:r.qk,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.d)(e,(0,i.p)((0,a.N)(n),"float32"))}}},Ct={kernelName:r.HZ,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,y.X)(e,n.shape)}}},It={kernelName:r._Y,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[i]=t,s={dy:e,images:i};return{images:()=>N.BV.runKernel(r.zb,s,n)}}},Nt={kernelName:r.dp,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[i]=t,s={dy:e,images:i};return{images:()=>N.BV.runKernel(r.Hm,s,n)}}};var kt=n(7486);const Rt={kernelName:r.mK,gradFunc:(e,t,n)=>{const{dims:r}=n,i=(0,R.EC)(r,e.shape);return{x:()=>(0,kt.G)(e,i)}}},Dt={kernelName:r.e0,gradFunc:e=>({x:()=>(0,w.P)(e)})},Lt={kernelName:r.bV,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,c.W)((0,l.h)(e,(0,s.d)((0,xt.s)(n,1.5),2)))}}};var Ft=n(8651);const Pt={kernelName:r.Ph,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>(0,i.p)((0,w.P)(n),"float32"),t:()=>(0,s.d)(e,(0,i.p)(n,e.dtype)),e:()=>(0,s.d)(e,(0,i.p)((0,Ft.h)(n),e.dtype))}}};var Ot=n(3179);const zt={kernelName:r.oF,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=(0,Ue.p)(n,(0,u.i)(0)),r=(0,u.i)(Ot.y),a=(0,u.i)(Ot.$),o=(0,s.d)(e,a),l=(0,s.d)((0,s.d)(e,r),(0,we.Q)((0,i.p)(n,"float32")));return(0,Y.a)(t,o,l)}}}},Bt={kernelName:r.a5,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.d)(e,(0,s.d)(n,(0,p.l)((0,u.i)(1),n)))}}},Ut={kernelName:r.i5,gradFunc:e=>({x:()=>(0,w.P)(e)})};var $t=n(173);const Vt={kernelName:r.RQ,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.d)((0,$t.m)((0,i.p)(n,"float32")),e)}}};var Wt=n(2699);const Gt={kernelName:r.w3,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.d)((0,Wt.f)((0,i.p)(n,"float32")),e)}}};var Ht=n(9682),jt=n(7650);const qt={kernelName:r.p2,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:i,size:s}=n,a=r.shape,[o,l]=(0,jt.parseSliceParams)(r,i,s),c=[];for(let t=0;t<e.rank;t++)c.push([o[t],a[t]-o[t]-l[t]]);return{x:()=>(0,Ht.v)(e,c)}}},Xt={kernelName:r.Gc,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:i}=n,a=(0,s.d)(e,r);return{logits:()=>(0,p.l)(a,(0,s.d)((0,v.S)(a,[i],!0),r))}}};var Yt=n(625);const Kt={kernelName:r.MR,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.d)(e,(0,Yt.X)(n))}}};var Zt=n(8441);const Jt={kernelName:r.TQ,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:i}=n;return{x:()=>(0,Zt.E)(e,r,i)}}};var Qt=n(6884);const en={kernelName:r.L8,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>(0,Qt.z)(e,r)}}},tn={kernelName:r.FK,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,l.h)(e,(0,s.d)((0,h._)((0,i.p)(n,"float32")),2))}}},nn={kernelName:r.bK,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.d)(e,(0,s.d)((0,i.p)(n,"float32"),2))}}},rn={kernelName:r._t,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,i=(0,u.i)(2);return{a:()=>(0,s.d)(e,(0,s.d)(i,(0,p.l)(n,r))),b:()=>(0,s.d)(e,(0,s.d)(i,(0,p.l)(r,n)))}}},sn={kernelName:r.h8,gradFunc:e=>({x:()=>(0,w.P)(e)})},an={kernelName:r.Tr,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,i=g.assertAndGetBroadcastShape(n.shape,r.shape);return{a:()=>{let t=e;const r=g.getReductionAxes(n.shape,i);return r.length>0&&(t=(0,v.S)(t,r)),(0,y.X)(t,n.shape)},b:()=>{let t=e;const n=g.getReductionAxes(r.shape,i);return n.length>0&&(t=(0,v.S)(t,n)),(0,y.X)((0,c.W)(t),r.shape)}}}},on={kernelName:r.GB,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,i=r.shape.slice(),{axis:a}=n;(0,R.EC)(a,r.shape).forEach((e=>{i[e]=1}));const o=(0,y.X)(e,i),l=(0,s.d)(o,(0,nt.i)(r.shape,"float32"));return{x:()=>l}}},ln={kernelName:r.sE,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,l.h)(e,(0,d.h)((0,$t.m)(n)))}}},cn={kernelName:r.MI,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.d)((0,p.l)((0,u.i)(1),(0,d.h)(n)),e)}}},un={kernelName:r.n9,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:i}=n;return{x:()=>{let t=(0,w.P)(r);if(1===r.rank)for(let n=0;n<i[0];++n)t=(0,T.I)(t,(0,at.t)(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<i[0];++n)for(let s=0;s<i[1];++s)t=(0,T.I)(t,(0,at.t)(e,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<i[0];++n)for(let s=0;s<i[1];++s)for(let a=0;a<i[2];++a)t=(0,T.I)(t,(0,at.t)(e,[n*r.shape[0],s*r.shape[1],a*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<i[0];++n)for(let s=0;s<i[1];++s)for(let a=0;a<i[2];++a)for(let o=0;o<i[3];++o)t=(0,T.I)(t,(0,at.t)(e,[n*r.shape[0],s*r.shape[1],a*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},hn={kernelName:r.G3,gradFunc:(e,t,n)=>{const r=n,{perm:i}=r,s=de.LJ(i);return{x:()=>(0,fe.p)(e,s)}}};var dn=n(2991);const pn={kernelName:r.To,gradFunc:(e,t,n)=>{const r=n,{axis:i}=r;return{value:()=>(0,dn.k)(e,i)}}};var fn=n(1300),mn=n(4926),gn=n(632);const yn={kernelName:r.Qv,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=(0,gn.g)(t,(0,w.P)(t)),r=(0,mn.I)(e,n);let i=(0,j.b)(t,(0,u.i)(0,"int32"));const s=r.rank-i.rank;for(let e=0;e<s;++e)i=(0,fn.d)(i,e+1);i=(0,X.H)(i,(0,nt.i)(r.shape,"bool"));const a=(0,w.P)(r);return(0,Y.a)(i,r,a)}(e,n)}}},vn={kernelName:r.Ru,gradFunc:e=>({x:()=>(0,w.P)(e)})};var xn=n(6151);const bn=[o,f,m,x,b,_,S,M,E,A,C,I,P,z,U,V,W,G,H,K,Z,Q,ie,ne,oe,ce,he,me,ve,xe,Mt,be,_e,Se,Me,Te,Ae,Ee,Ne,Re,Fe,Pe,Oe,ze,Be,$e,Ve,We,Ge,je,Ye,Ye,Ze,Qe,tt,rt,it,st,ot,ct,ut,ht,pt,ft,gt,yt,yt,bt,wt,St,Tt,Et,At,Ct,It,Nt,Rt,Dt,Lt,Pt,zt,Bt,Ut,Vt,Gt,qt,Xt,Kt,Jt,Jt,en,en,tn,rn,nn,sn,an,on,ln,cn,un,hn,pn,yn,vn];for(const e of bn)(0,xn.Li)(e)},4077:(e,t,n)=>{"use strict";n.d(t,{es:()=>v,YD:()=>h,_w:()=>b,t3:()=>x,FZ:()=>y,Vp:()=>g,Vi:()=>m});var r=n(5938),i=n(9115);function s(e,t,n,r){const s=(0,i.e3)(t),o=function(e,t,n,r){const s=(0,i.NA)(t),o=r[r.length-1],l=new Array(o).fill(0),u=t.length,h="complex64"===n?c(e):e;if(u>1)for(let e=0;e<s/o;e++){const t=e*o;for(let e=0;e<o;e++)l[e]=Math.max(l[e],a(h[t+e],0,n).length)}return l}(e,t,n,s),u=t.length,h=l(e,t,n,s,o),d=["Tensor"];return r&&(d.push(`  dtype: ${n}`),d.push(`  rank: ${u}`),d.push(`  shape: [${t}]`),d.push("  values:")),d.push(h.map((e=>"    "+e)).join("\n")),d.join("\n")}function a(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:(0,i.HD)(e)?`'${e}'`:"bool"===n?o(e):parseFloat(e.toFixed(7)).toString(),(0,i.oj)(r,t)}function o(e){return 0===e?"false":"true"}function l(e,t,n,r,i,s=!0){const u="complex64"===n?2:1,h=t[0],d=t.length;if(0===d)return"complex64"===n?[a(c(e)[0],0,n)]:"bool"===n?[o(e[0])]:[e[0].toString()];if(1===d){if(h>20){const t=3*u;let r=Array.from(e.slice(0,t)),s=Array.from(e.slice((h-3)*u,h*u));return"complex64"===n&&(r=c(r),s=c(s)),["["+r.map(((e,t)=>a(e,i[t],n))).join(", ")+", ..., "+s.map(((e,t)=>a(e,i[h-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?c(e):Array.from(e)).map(((e,t)=>a(e,i[t],n))).join(", ")+"]"]}const p=t.slice(1),f=r.slice(1),m=r[0]*u,g=[];if(h>20){for(let t=0;t<3;t++){const r=t*m,s=r+m;g.push(...l(e.slice(r,s),p,n,f,i,!1))}g.push("...");for(let t=h-3;t<h;t++){const r=t*m,s=r+m;g.push(...l(e.slice(r,s),p,n,f,i,t===h-1))}}else for(let t=0;t<h;t++){const r=t*m,s=r+m;g.push(...l(e.slice(r,s),p,n,f,i,t===h-1))}const y=2===d?",":"";g[0]="["+g[0]+y;for(let e=1;e<g.length-1;e++)g[e]=" "+g[e]+y;let v=",\n";for(let e=2;e<d;e++)v+="\n";return g[g.length-1]=" "+g[g.length-1]+"]"+(s?"":v),g}function c(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var u=n(9122);class h{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=i.NA(e),null!=n){const e=n.length;i.hu(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||i.rQ(t,this.size),this.strides=(0,i.e3)(e)}set(e,...t){0===t.length&&(t=[0]),i.hu(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const n of e){if(n<0||n>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return d().makeTensor(this.values,this.shape,this.dtype)}}let d=null,p=null,f=null;function m(e){d=e}function g(e){p=e}function y(e){f=e}class v{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=i.NA(e),this.strides=(0,i.e3)(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return p.buffer(this.shape,this.dtype,e)}bufferSync(){return p.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return(0,i.GX)(this.shape,e,"complex64"===this.dtype)}arraySync(){return(0,i.GX)(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=d().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map((e=>u.decodeString(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),d().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=d().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>u.decodeString(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await d().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(d().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return p.print(this,e)}clone(){return this.throwIfDisposed(),p.clone(this)}toString(e=!1){return s(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),p.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),d().makeVariable(this,e,t,n)}}function x(){return(0,r.R)("Tensor",(()=>v))}Object.defineProperty(v,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),x();class b extends v{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!i.cO(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);d().disposeTensor(this),this.dataId=e.dataId,d().incRef(this,null)}dispose(){d().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(b,Symbol.hasInstance,{value:e=>e instanceof v&&null!=e.assign&&e.assign instanceof Function})},747:(e,t,n)=>{"use strict";n.r(t),n.d(t,{assertTypesMatch:()=>o,getTensorsInContainer:()=>c,isTensorInList:()=>l,makeTypesMatch:()=>a});var r=n(4077),i=n(1221),s=n(9115);function a(e,t){if(e.dtype===t.dtype)return[e,t];const n=(0,i.x8)(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function o(e,t){(0,s.hu)(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function l(e,t){return t.some((t=>t.id===e.id))}function c(e){const t=[];return u(e,t,new Set),t}function u(e,t,n){if(null==e)return;if(e instanceof r.es)return void t.push(e);if(i=e,!Array.isArray(i)&&"object"!=typeof i)return;var i;const s=e;for(const e in s){const r=s[e];n.has(r)||(n.add(r),u(r,t,n))}}},3740:(e,t,n)=>{"use strict";n.d(t,{C:()=>l,_1:()=>h,sI:()=>d});var r=n(7097),i=n(2885),s=n(4077),a=n(9115),o=n(9122);function l(e,t){let n=e;if((0,a.fU)(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||(0,a.fU)(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&(0,i.OB)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&c(e,r,[]),r}function c(e,t,n){if(n=n||[],!Array.isArray(e)&&!(0,a.fU)(e))return void(0,a.hu)(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));(0,a.hu)(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),(0,a.hu)(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let t=0;t<e.length;++t)c(e[t],r,n.concat(t))}function u(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function h(e,t,n,i="numeric"){if(e instanceof s.es)return u(i,e.dtype,t,n),e;let c=(0,a.D2)(e);if("string"!==c&&["bool","int32","float32"].indexOf(i)>=0&&(c=i),u(i,c,t,n),null==e||!(0,a.fU)(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const h=l(e,c);(0,a.fU)(e)||Array.isArray(e)||(e=[e]);const d="string"!==c?(0,o.toTypedArray)(e,c):(0,a.xH)(e,[],!0);return r.BV.makeTensor(d,h,c)}function d(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,i)=>h(e,`${t}[${i}]`,n,r)))}},1221:(e,t,n)=>{"use strict";var r,i,s,a,o;n.d(t,{x8:()=>c,yw:()=>r,z4:()=>u}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(r||(r={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(i||(i={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(s||(s={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(a||(a={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(o||(o={}));const l={float32:a,int32:i,bool:s,complex64:o};function c(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return l[e][t]}function u(e){return c(e,"int32")}},9122:(e,t,n)=>{"use strict";n.r(t),n.d(t,{arraysEqual:()=>i.cO,assert:()=>i.hu,assertNonNegativeIntegerDimensions:()=>i.Mu,assertNonNull:()=>i.Cq,assertShapesMatch:()=>i.k5,bytesFromStringArray:()=>i.Ub,bytesPerElement:()=>i.bT,checkConversionForErrors:()=>i.D5,clamp:()=>i.uZ,computeStrides:()=>i.e3,createScalarValue:()=>x,createShuffledIndices:()=>i.U$,decodeString:()=>M,distSquared:()=>i.E7,encodeString:()=>S,fetch:()=>_,fingerPrint64:()=>v,flatten:()=>i.xH,getArrayFromDType:()=>i.rQ,getTypedArrayFromDType:()=>i.WP,hasEncodingLoss:()=>i.QB,hexToLong:()=>o,indexToLoc:()=>i.NE,inferDtype:()=>i.D2,inferFromImplicitShape:()=>i.JZ,isBoolean:()=>i.jn,isFunction:()=>i.mf,isInt:()=>i.GN,isNumber:()=>i.hj,isPromise:()=>i.tI,isScalarShape:()=>i.N9,isString:()=>i.HD,isTypedArray:()=>i.fU,isValidDtype:()=>i.LP,locToIndex:()=>i.qy,makeOnesTypedArray:()=>i.p8,makeZerosNestedTypedArray:()=>i.l6,makeZerosTypedArray:()=>i.wT,nearestDivisor:()=>i.jP,nearestLargerEven:()=>i.nY,now:()=>w,parseAxisParam:()=>i.EC,randUniform:()=>i.bj,repeatedTry:()=>i.WD,rightPad:()=>i.oj,shuffle:()=>i.TV,shuffleCombo:()=>i.d7,sizeFromShape:()=>i.NA,sizeToSquarishShape:()=>i.YP,squeezeShape:()=>i.bp,sum:()=>i.Sm,swap:()=>i.LF,tanh:()=>i.AE,toNestedArray:()=>i.GX,toTypedArray:()=>b});var r=n(2885),i=n(9115),s=n(3720);const a=n.n(s)()||s;function o(e){return a.fromString(e,!0,16)}const l=o("c3a5c85c97cb3127"),c=o("b492b66fbe98f273"),u=o("9ae16a3b2f90404f");function h(e){return e.xor(e.shru(47))}function d(e,t,n){const r=e.slice(t,t+n);return a.fromBytes(Array.from(r),!0,!0)}function p(e,t){return d(e,t,8)}function f(e,t){return d(e,t,4)}function m(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function g(e,t,n=o("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let i=t.xor(r).mul(n);return i=i.xor(i.shru(47)),i=i.mul(n),i}function y(e,t,n,r){return function(e,t,n,r,i,s){i=i.add(e),s=m(s.add(i).add(r),21);const a=i;return i=(i=i.add(t)).add(n),s=s.add(m(i,44)),[i.add(r),s.add(a)]}(p(e,t),p(e,t+8),p(e,t+16),p(e,t+24),n,r)}function v(e,t=e.length){const n=a.fromNumber(81,!0);if(t<=32)return t<=16?function(e,t=e.length){if(t>=8){const n=u.add(2*t),r=p(e,0).add(u),i=p(e,t-8);return g(m(i,37).mul(n).add(r),m(r,25).add(i).mul(n),n)}if(t>=4){const n=u.add(2*t);return g(f(e,0).shl(3).add(t),f(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return h(u.mul(n).xor(l.mul(r))).mul(u)}return u}(e,t):function(e,t=e.length){const n=u.add(2*t),r=p(e,0).mul(c),i=p(e,8),s=p(e,t-8).mul(n),a=p(e,t-16).mul(u);return g(m(r.add(i),43).add(m(s,30)).add(a),r.add(m(i.add(u),18)).add(s),n)}(e,t);if(t<=64)return function(e,t=e.length){const n=u.add(2*t),r=p(e,0).mul(u),i=p(e,8),s=p(e,t-8).mul(n),a=p(e,t-16).mul(u),o=m(r.add(i),43).add(m(s,30)).add(a),l=g(o,r.add(m(i.add(u),18)).add(s),n),c=p(e,16).mul(n),h=p(e,24),d=o.add(p(e,t-32)).mul(n),f=l.add(p(e,t-24)).mul(n);return g(m(c.add(h),43).add(m(d,30)).add(f),c.add(m(h.add(r),18)).add(d),n)}(e,t);let r=n,i=n.mul(c).add(113),s=h(i.mul(u).add(113)).mul(u),o=[a.UZERO,a.UZERO],d=[a.UZERO,a.UZERO];r=r.mul(u).add(p(e,0));let v=0;const x=64*(t-1>>6),b=x+(t-1&63)-63;do{r=m(r.add(i).add(o[0]).add(p(e,v+8)),37).mul(c),i=m(i.add(o[1]).add(p(e,v+48)),42).mul(c),r=r.xor(d[1]),i=i.add(o[0]).add(p(e,v+40)),s=m(s.add(d[0]),33).mul(c),o=y(e,v,o[1].mul(c),r.add(d[0])),d=y(e,v+32,s.add(d[1]),i.add(p(e,v+16))),[s,r]=[r,s],v+=64}while(v!==x);const w=c.add(s.and(255).shl(1));return v=b,d[0]=d[0].add(t-1&63),o[0]=o[0].add(d[0]),d[0]=d[0].add(o[0]),r=m(r.add(i).add(o[0]).add(p(e,v+8)),37).mul(w),i=m(i.add(o[1]).add(p(e,v+48)),42).mul(w),r=r.xor(d[1].mul(9)),i=i.add(o[0].mul(9).add(p(e,v+40))),s=m(s.add(d[0]),33).mul(w),o=y(e,v,o[1].mul(w),r.add(d[0])),d=y(e,v+32,s.add(d[1]),i.add(p(e,v+16))),[s,r]=[r,s],g(g(o[0],d[0],w).add(h(i).mul(l)).add(s),g(o[1],d[1],w).add(r),w)}function x(e,t){return"string"===t?S(e):b([e],t)}function b(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=i.xH(e)),(0,r.OB)().getBool("DEBUG")&&i.D5(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function w(){return(0,r.OB)().platform.now()}function _(e,t){return(0,r.OB)().platform.fetch(e,t)}function S(e,t="utf-8"){return t=t||"utf-8",(0,r.OB)().platform.encode(e,t)}function M(e,t="utf-8"){return t=t||"utf-8",(0,r.OB)().platform.decode(e,t)}},9115:(e,t,n)=>{"use strict";function r(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,o(e,t,n)}function i(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,o(e,n,r),o(t,n,r)}function s(e,t,n){return Math.max(e,Math.min(t,n))}function a(e){return e%2==0?e:e+1}function o(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function l(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function c(e,t){const n=Math.random();return t*n+(1-n)*e}function u(e,t){let n=0;for(let r=0;r<e.length;r++){const i=Number(e[r])-Number(t[r]);n+=i*i}return n}function h(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function d(e,t,n=""){h(y(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function p(e){h(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function f(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||R(e)&&!n)for(let r=0;r<e.length;++r)f(e[r],t,n);else t.push(e);return t}function m(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function g(e){return 0===e.length}function y(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function v(e){return e%1==0}function x(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function b(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function w(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return r(t),t}function _(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function S(e,t=(e=>0),n){return new Promise(((r,i)=>{let s=0;const a=()=>{if(e())return void r();s++;const o=t(s);null!=n&&s>=n?i():setTimeout(a,o)};a()}))}function M(e,t){let n=1,r=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${t}`);r=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const i=e.slice();return i[r]=t/n,i}function T(e,t){const n=t.length;return h((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),h(e.every((e=>v(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function E(e,t){const n=[],r=[],i=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||i?null:T(t,e).sort();let a=0;for(let t=0;t<e.length;++t){if(null!=s){if(s[a]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==s[a]||s[a]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),s[a]<=t&&a++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function A(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);n=new Uint8Array(t)}return n}function C(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function I(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function N(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function k(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function R(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function D(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function L(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function F(e){return"string"==typeof e||e instanceof String}function P(e){return"boolean"==typeof e}function O(e){return"number"==typeof e}function z(e){return Array.isArray(e)?z(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":O(e)?"float32":F(e)?"string":P(e)?"bool":"float32"}function B(e){return!!(e&&e.constructor&&e.call&&e.apply)}function U(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function $(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function V(e,t,n,r=!1){const i=new Array;if(1===t.length){const s=t[0]*(r?2:1);for(let t=0;t<s;t++)i[t]=n[e+t]}else{const s=t[0],a=t.slice(1),o=a.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<s;t++)i[t]=V(e+t*o,a,n,r)}return i}function W(e,t,n=!1){if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return V(0,e,t,n)}function G(e,t){const n=H(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function H(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function j(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return W(e,new Float32Array(n));if("int32"===t)return W(e,new Int32Array(n));if("bool"===t)return W(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function q(e){e.forEach((t=>{h(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function X(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=n[t]*e[t];return r}function Y(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let t=0;t<r.length-1;++t)r[t]=Math.floor(e/n[t]),e-=r[t]*n[t];return r[r.length-1]=e,r}function K(e){return e&&e.then&&"function"==typeof e.then}n.d(t,{AE:()=>x,Cq:()=>p,D2:()=>z,D5:()=>I,E7:()=>u,EC:()=>T,GN:()=>v,GX:()=>W,HD:()=>F,JZ:()=>M,LF:()=>o,LP:()=>N,Mu:()=>q,N9:()=>g,NA:()=>m,NE:()=>Y,QB:()=>k,Sm:()=>l,TV:()=>r,U$:()=>w,Ub:()=>L,WD:()=>S,WP:()=>A,YP:()=>b,bT:()=>D,bj:()=>c,bp:()=>E,cO:()=>y,d7:()=>i,e3:()=>$,fU:()=>R,hj:()=>O,hu:()=>h,jP:()=>U,jn:()=>P,k5:()=>d,l6:()=>j,mf:()=>B,nY:()=>a,oj:()=>_,p8:()=>G,qy:()=>X,rQ:()=>C,tI:()=>K,uZ:()=>s,wT:()=>H,xH:()=>f})},3129:(e,t,n)=>{var r=n(626),i=n(477),s=n(2868),a=n(8197),o=n(2009),l=n(2408),c=n(1662);c.alea=r,c.xor128=i,c.xorwow=s,c.xorshift7=a,c.xor4096=o,c.tychei=l,e.exports=c},626:function(e,t,n){var r;!function(e,i,s){function a(e){var t,n=this,r=(t=4022871197,function(e){e=e.toString();for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function o(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function l(e,t){var n=new a(e),r=t&&t.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,r&&("object"==typeof r&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.alea=l}(0,e=n.nmd(e),n.amdD)},2408:function(e,t,n){var r;!function(e,i,s){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,i=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^i,i=i-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^i,t.a=i-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function o(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function l(e,t){var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.tychei=l}(0,e=n.nmd(e),n.amdD)},477:function(e,t,n){var r;!function(e,i,s){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function o(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function l(e,t){var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.xor128=l}(0,e=n.nmd(e),n.amdD)},2009:function(e,t,n){var r;!function(e,i,s){function a(e){var t=this;t.next=function(){var e,n,r=t.w,i=t.X,s=t.i;return t.w=r=r+1640531527|0,n=i[s+34&127],e=i[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=i[s]=n^e,t.i=s,n+(r^r>>>16)|0},function(e,t){var n,r,i,s,a,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),i=0,s=-32;s<l;++s)t&&(r^=t.charCodeAt((s+32)%t.length)),0===s&&(a=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(a=a+1640531527|0,i=0==(n=o[127&s]^=r+a)?i+1:0);for(i>=128&&(o[127&(t&&t.length||0)]=-1),i=127,s=512;s>0;--s)r=o[i+34&127],n=o[i=i+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[i]=r^n;e.w=a,e.X=o,e.i=i}(t,e)}function o(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function l(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,r&&(r.X&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.xor4096=l}(0,e=n.nmd(e),n.amdD)},8197:function(e,t,n){var r;!function(e,i,s){function a(e){var t=this;t.next=function(){var e,n,r=t.x,i=t.i;return e=r[i],n=(e^=e>>>7)^e<<24,n^=(e=r[i+1&7])^e>>>10,n^=(e=r[i+3&7])^e>>>3,n^=(e=r[i+4&7])^e<<7,e=r[i+7&7],n^=(e^=e<<13)^e<<9,r[i]=n,t.i=i+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function o(e,t){return t.x=e.x.slice(),t.i=e.i,t}function l(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,r&&(r.x&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.xorshift7=l}(0,e=n.nmd(e),n.amdD)},2868:function(e,t,n){var r;!function(e,i,s){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function o(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function l(e,t){var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.xorwow=l}(0,e=n.nmd(e),n.amdD)},1662:(e,t,n)=>{var r;!function(i,s){var a,o=this,l=256,c=s.pow(l,6),u=s.pow(2,52),h=2*u,d=255;function p(e,t,n){var r=[],d=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,v(i)]:null==e?function(){try{var e;return a&&(e=a.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),v(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,v(i)]}}():e,3),r),p=new f(r),x=function(){for(var e=p.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=p.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|p.g(4)},x.quick=function(){return p.g(4)/4294967296},x.double=x,y(v(p.S),i),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(s.random=e,t):e})(x,d,"global"in t?t.global:this==s,t.state)}function f(e){var t,n=e.length,r=this,i=0,s=r.i=r.j=0,a=r.S=[];for(n||(e=[n++]);i<l;)a[i]=i++;for(i=0;i<l;i++)a[i]=a[s=d&s+e[i%n]+(t=a[i])],a[s]=t;(r.g=function(e){for(var t,n=0,i=r.i,s=r.j,a=r.S;e--;)t=a[i=d&i+1],n=n*l+a[d&(a[i]=a[s=d&s+t])+(a[s]=t)];return r.i=i,r.j=s,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],i=typeof e;if(t&&"object"==i)for(n in e)try{r.push(g(e[n],t-1))}catch(e){}return r.length?r:"string"==i?e:e+"\0"}function y(e,t){for(var n,r=e+"",i=0;i<r.length;)t[d&i]=d&(n^=19*t[d&i])+r.charCodeAt(i++);return v(t)}function v(e){return String.fromCharCode.apply(0,e)}if(s.seedrandom=p,y(s.random(),i),e.exports){e.exports=p;try{a=n(5778)}catch(e){}}else void 0===(r=function(){return p}.call(t,n,t,e))||(e.exports=r)}([],Math)},5934:(e,t,n)=>{"use strict";n.r(t),n.d(t,{CSVDataset:()=>j,Dataset:()=>L,FileDataSource:()=>ie,TextLineDataset:()=>B,URLDataSource:()=>se,array:()=>P,csv:()=>ae,func:()=>oe,generator:()=>le,microphone:()=>ue,version_data:()=>he,webcam:()=>ce,zip:()=>O});var r,i=n(1740),s=n(6377);function a(e,t,n=new Map,r=new Set){if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const i=t(e);if(i.recurse&&null!==i.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(i.recurse){if(h(e)){const i=Array.isArray(e)?[]:{};r.add(e);for(const s in e){const o=a(e[s],t,n,r);i[s]=o}return r.delete(e),e.__proto__&&(i.__proto__=e.__proto__),i}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,i.value),i.value}function o(e,t=c){return l(e,t)}function l(e,t,n=new Set){const r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");const i=t(e);if(i.recurse&&null!==i.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(i.recurse){if(h(r)){const i=Array.isArray(r)?[]:{};n.add(r);for(const s in r){const r=l(e.map((e=>e[s])),t,n);i[s]=r}return n.delete(r),i}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return i.value}function c(e){return null===e?null:h(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function u(e,t){const n=new Map;a(e,t,n);for(const e of Array.from(n.keys())){const t=n.get(e);if(i.D5U.isPromise(t)){const r=await t;n.set(e,r)}}return a(e,t,n)}function h(e){let t=!1;if(i.OBj().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:r}=n(4977);t=e instanceof r}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof i.esB)&&!(e instanceof Promise)&&!t)}function d(e){return e instanceof i.esB?{value:e.clone(),recurse:!1}:h(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class p{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class f extends p{constructor(){super(f.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let e=0;e<n;e++)t[e]=this.get(this.wrap(this.begin+e));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function m(e){return new v(e)}function g(e){return new x(e)}f.INITIAL_CAPACITY=32;class y{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new E(this,e)}filter(e){return new M(this,e)}map(e){return new T(this,e)}mapAsync(e){return new A(this,e)}serialMapAsync(e){return new A(this,e).serial()}flatmap(e){return new I(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e,t=!0){return new S(this,e,t)}columnMajorBatch(e,t=!0,n=c){return this.rowMajorBatch(e,t).map((e=>o(e,n)))}concatenate(e,t){return new N(m([this,e]),t)}take(e){return e<0||null==e?this:new _(this,e)}skip(e){return e<0||null==e?this:new w(this,e)}prefetch(e){return new R(this,e)}shuffle(e,t){return new D(this,e,t)}serial(){return new b(this)}}class v extends y{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:(t=e,a(t,d)),done:!1};var t}}class x extends y{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class b extends y{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class w extends y{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;i.B90(e.value)}return this.upstream.next()}}class _ extends y{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class S extends y{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class M extends y{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;i.B90(e.value)}}}class T extends y{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=i.piX.getTensorsInContainer(e.value),n=this.transform(e.value),r=i.piX.getTensorsInContainer(n);for(const e of t)i.piX.isTensorInList(e,r)||e.dispose();return{value:n,done:!1}}}class E extends y{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class A extends y{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=i.piX.getTensorsInContainer(e.value),n=await this.transform(e.value),r=i.piX.getTensorsInContainer(n);for(const e of t)i.piX.isTensorInList(e,r)||e.dispose();return{value:n,done:!1}}}class C extends y{constructor(){super(),this.outputQueue=new f,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class I extends C{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=i.piX.getTensorsInContainer(e.value),n=this.transform(e.value),r=i.piX.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(const e of t)i.piX.isTensorInList(e,r)||e.dispose();return!0}}class N extends y{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(r||(r={}));class k extends y{constructor(e,t=r.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;const i=await u(this.iterators,(function(e){return e instanceof y?{value:e.next().then((e=>(t++,e.done&&n++,e.value))),recurse:!1}:{value:null,recurse:!0}}));if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case r.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case r.SHORTEST:return{value:null,done:!0};case r.LONGEST:}return this.count++,{value:i,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class R extends y{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new p(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class D extends R{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=s.alea(n||i.D5U.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class L{constructor(){this.size=null}batch(e,t=!0){const n=this;let r;return i.D5U.assert(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),r=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),F((async()=>(await n.iterator()).columnMajorBatch(e,t,z)),r)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,F((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,F((async()=>(await t.iterator()).filter((t=>i.lub((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return F((async()=>(await t.iterator()).map((t=>i.lub((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return F((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return F((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,F((async()=>{return n=g((async()=>({value:await t.iterator(),done:!1}))).take(e),new N(n,r);var n,r}),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,F((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t,n=!0){if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,a=s.alea(t||i.D5U.now().toString());return F((async()=>{let t=a.int32();return n&&(t+=a.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,F((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function F(e,t=null){return new class extends L{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function P(e){return F((async()=>m(e)),e.length)}function O(e){if(!h(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=null==t?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(const n in e)t=null==t?e[n].size:Math.min(t,e[n].size);return F((async()=>function(e,t=r.FAIL){return new k(e,t)}(await u(e,(e=>{if(e instanceof L)return{value:e.iterator(),recurse:!1};if(h(e))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")})),r.SHORTEST)),t)}function z(e){if(null===e)return null;return null==(t=e[0])||null===(n=t)||"object"!=typeof n&&"function"!=typeof n||Array.isArray(t)||"object"==typeof t&&t instanceof i.esB||i.D5U.isTypedArray(t)?{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof i.esB?i.knu(e):i.XeE(e)}(e),recurse:!1}:{value:null,recurse:!0};var t,n}L.MAX_BUFFER_SIZE=1e4;class B extends L{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map((e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e)))}}const U='"',$=Symbol("out"),V=Symbol("field"),W=Symbol("quote"),G=Symbol("quoteafterquote"),H=Symbol("quoteinquote");class j extends L{constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new B(e),t||(t={}),this.hasHeader=!1!==t.hasHeader,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(i.D5U.assert(null==t.delimiter,(()=>"Delimiter should not be provided when delimWhitespace is true.")),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&i.D5U.assert(e.length===this.fullColumnNames.length,(()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+").")),this.fullColumnNames||(this.fullColumnNames=e);const t=this.fullColumnNames.reduce(((e,t)=>(e[t]=e[t]+1||1,e)),{}),n=Object.keys(t).filter((e=>t[e]>1));if(i.D5U.assert(0===n.length,(()=>"Duplicate column names found: "+n.toString())),this.columnConfigs)for(const e of Object.keys(this.columnConfigs))if(-1===this.fullColumnNames.indexOf(e))throw new Error('The key "'+e+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").");this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const e=await this.base.iterator(),t=await e.next();if(t.done)throw new Error("No data was found for CSV parsing.");const n=t.value;return this.parseRow(n,!1)}return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map((e=>this.makeDataElement(e)))}makeDataElement(e){const t=this.parseRow(e),n={},r={};for(let i=0;i<this.fullColumnNames.length;i++){const s=this.fullColumnNames[i],a=this.columnConfigs?this.columnConfigs[s]:null;if(!this.configuredColumnsOnly||a){const o=t[i];let l=null;if(""===o)if(a&&void 0!==a.default)l=a.default;else{if(a&&(a.required||a.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);l=void 0}else{const e=Number(o);if(isNaN(e))l=a&&"bool"===a.dtype?this.getBoolean(o):o;else if(a&&a.dtype)switch(a.dtype){case"float32":default:l=e;break;case"int32":l=Math.floor(e);break;case"bool":l=this.getBoolean(o)}else l=e}a&&a.isLabel?r[s]=l:n[s]=l}}return 0===Object.keys(r).length?n:{xs:n,ys:r}}getBoolean(e){return"1"===e||"true"===e.toLowerCase()?1:0}parseRow(e,t=!0){const n=[];let r=0;const i=e.length;let s=$;for(let t=0;t<i;t++)switch(s){case $:switch(e.charAt(t)){case U:r=t+1,s=W;break;case this.delimiter:if(r=t+1," "===this.delimiter&&this.delimWhitespace)break;n.push(""),s=$;break;default:s=V,r=t}break;case V:e.charAt(t)===this.delimiter&&(n.push(e.substring(r,t)),s=$,r=t+1);break;case W:e.charAt(t)===U&&(s=G);break;case G:switch(e.charAt(t)){case this.delimiter:n.push(e.substring(r,t-1)),s=$,r=t+1;break;case U:s=W;break;default:s=H}break;case H:e.charAt(t)===U&&(s=W)}if(s===G?n.push(e.substring(r,i-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}}class q extends y{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=!1!==e.includeSpectrogram,this.includeWaveform=!0===e.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!(0,i.OBj)().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const t=new q(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(e){throw new Error(`Error thrown while initializing video stream: ${e.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;const t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t;const n=await this.getAudioData();if(this.includeSpectrogram){const t=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const e=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],t=[];let n=0;return new Promise((r=>{const i=setInterval((()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(i),r({freqDataQueue:e,timeDataQueue:t}))}),this.fftSize/this.sampleRateHz*1e3)}))}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const t=e[0].length,n=new Float32Array(e.length*t);return e.forEach(((e,r)=>n.set(e,r*t))),n}getTensorFromAudioDataArray(e,t){const n=new Float32Array(i.D5U.sizeFromShape(t));return n.set(e,n.length-e.length),(0,i.XeE)(n,t)}}class X extends y{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=(0,i.RRF)([0],"int32"),this.webcamConfig.centerCrop){const e=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,t=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,n=(1-e)/2,r=(1-t)/2,s=n+e,a=t+r;this.cropBox=(0,i.odF)([r,n,a,s],[1,4])}else this.cropBox=(0,i.odF)([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!(0,i.OBj)().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}const n=new X(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&i.D5U.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,(()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`));try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise((e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}}))}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=i.Xhn.fromPixels(this.webcamVideoElement)}catch(e){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`)}if(!this.resize)return{value:e,done:!1};try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(e){throw new Error(`Error thrown cropping the video: ${e.message}`)}finally{e.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(e){return(0,i.lub)((()=>{const t=(0,i.dt4)((0,i.pju)(e,"float32"),0);let n;n=i.BHj.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const r=n.shape;return(0,i.XLQ)(n,r.slice(1))}))}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach((e=>e.stop()));try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}class Y{}class K extends y{split(e){return new Z(this,e)}}class Z extends K{constructor(e,t){super(),this.upstream=e,this.impl=new J(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class J extends C{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);const t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(const e of t.slice(0,-1))this.outputQueue.push(e);return this.carryover=t[t.length-1],!0}}class Q extends y{decodeUTF8(){return new ee(this)}}class ee extends K{constructor(e){super(),this.upstream=e,this.impl=new te(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class te extends C{constructor(e){if(super(),this.upstream=e,(0,i.OBj)().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:e}=n(1601);this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let t,n;return!e.done&&(t=e.value,n=(0,i.OBj)().get("IS_BROWSER")?this.decoder.decode(t,{stream:!0}):this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0)}}class ne extends Q{constructor(e,t={}){super(),this.file=e,this.options=t,i.D5U.assert(e instanceof Uint8Array||!!(0,i.OBj)().get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),(()=>"FileChunkIterator only supports File, Blob and Uint8Array right now.")),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){if(this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size))return{value:null,done:!0};const e=new Promise(((e,t)=>{const n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{const r=new FileReader;r.onload=n=>{let i=r.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(i)},r.onabort=e=>t(new Error("Aborted")),r.onerror=e=>t(new Error(e.type));const i=this.file.slice(this.offset,n);r.readAsArrayBuffer(i)}this.offset=n}));return{value:await e,done:!1}}}function re(e){return"string"==typeof e&&"file://"===e.slice(0,7)}class ie extends Y{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(re(this.input)&&(0,i.OBj)().get("IS_NODE")){const e=n(7792);this.input=e.readFileSync(this.input.slice(7))}return new ne(this.input,this.options)}}class se extends Y{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return re(this.url)?new ie(this.url,this.fileOptions).iterator():async function(e,t={},n){let r,s;var a;"string"==typeof e?r=e:(r=e.url,s={method:(a=e).method,headers:a.headers,body:a.body,mode:a.mode,credentials:a.credentials,cache:a.cache,redirect:a.redirect,referrer:a.referrer,integrity:a.integrity});const o=await(n||i.D5U.fetch)(r,s);if(o.ok){const e=new Uint8Array(await o.arrayBuffer());return new ne(e,t)}throw new Error(o.statusText)}(this.url,this.fileOptions)}}function ae(e,t={}){return new j(new se(e),t)}function oe(e){const t=g(e);return F((async()=>t))}function le(e){return F((async()=>{const t=await e();return g((()=>t.next()))}))}async function ce(e,t){return X.create(e,t)}async function ue(e){return q.create(e)}const he="3.18.0"},2001:(e,t,n)=>{"use strict";n.d(t,{AQ:()=>$a,BO:()=>qt,iT:()=>Kt,pV:()=>Ga,Ay:()=>Yt,Zg:()=>Je,fU:()=>Ye,QV:()=>Yn,$p:()=>ti,sb:()=>Jn,Iy:()=>Qe,ZC:()=>Ha,Cb:()=>r,t1:()=>i,qH:()=>nr,ug:()=>s,FB:()=>tr,qI:()=>a,o4:()=>Qn,Cq:()=>o,gl:()=>rr,zQ:()=>l,Pe:()=>er,H6:()=>kn});var r={};n.r(r),n.d(r,{maxNorm:()=>Mt,minMaxNorm:()=>At,nonNeg:()=>Et,unitNorm:()=>Tt});var i={};n.r(i),n.d(i,{constant:()=>Nt,glorotNormal:()=>Ot,glorotUniform:()=>Pt,heNormal:()=>zt,heUniform:()=>Bt,identity:()=>Lt,leCunNormal:()=>Ut,leCunUniform:()=>$t,ones:()=>It,orthogonal:()=>Vt,randomNormal:()=>Rt,randomUniform:()=>kt,truncatedNormal:()=>Dt,varianceScaling:()=>Ft,zeros:()=>Ct});var s={};n.r(s),n.d(s,{Layer:()=>rt,RNN:()=>ti,RNNCell:()=>ni,activation:()=>_s,add:()=>ks,alphaDropout:()=>wa,average:()=>Rs,averagePooling1d:()=>$s,averagePooling2d:()=>Gs,averagePooling3d:()=>qs,avgPool1d:()=>Vs,avgPool2d:()=>Hs,avgPool3d:()=>Xs,avgPooling1d:()=>Ws,avgPooling2d:()=>js,avgPooling3d:()=>Ys,batchNormalization:()=>zs,bidirectional:()=>pa,concatenate:()=>Ds,conv1d:()=>ps,conv2d:()=>fs,conv2dTranspose:()=>ms,conv3d:()=>gs,conv3dTranspose:()=>ys,convLstm2d:()=>ca,convLstm2dCell:()=>ua,cropping2D:()=>xs,dense:()=>Ss,depthwiseConv2d:()=>ws,dot:()=>Os,dropout:()=>Ms,elu:()=>os,embedding:()=>Ns,flatten:()=>Es,gaussianDropout:()=>ba,gaussianNoise:()=>xa,globalAveragePooling1d:()=>Ks,globalAveragePooling2d:()=>Zs,globalMaxPool1d:()=>ma,globalMaxPool2d:()=>ga,globalMaxPooling1d:()=>Js,globalMaxPooling2d:()=>Qs,gru:()=>ra,gruCell:()=>ia,input:()=>nr,inputLayer:()=>as,layerNormalization:()=>Bs,leakyReLU:()=>cs,lstm:()=>sa,lstmCell:()=>aa,masking:()=>_a,maxPool1d:()=>ya,maxPool2d:()=>va,maxPooling1d:()=>ea,maxPooling2d:()=>ta,maxPooling3d:()=>na,maximum:()=>Ls,minimum:()=>Fs,multiply:()=>Ps,permute:()=>Is,prelu:()=>us,reLU:()=>ls,repeatVector:()=>As,reshape:()=>Cs,rnn:()=>ha,separableConv2d:()=>vs,simpleRNN:()=>oa,simpleRNNCell:()=>la,softmax:()=>hs,spatialDropout1d:()=>Ts,stackedRNNCells:()=>da,thresholdedReLU:()=>ds,timeDistributed:()=>fa,upSampling2d:()=>bs,zeroPadding2d:()=>Us});var a={};n.r(a),n.d(a,{MAPE:()=>Da,MSE:()=>Pa,binaryAccuracy:()=>Sa,binaryCrossentropy:()=>Ma,categoricalAccuracy:()=>Ea,categoricalCrossentropy:()=>Aa,cosineProximity:()=>Na,mape:()=>La,meanAbsoluteError:()=>ka,meanAbsolutePercentageError:()=>Ra,meanSquaredError:()=>Fa,mse:()=>Oa,precision:()=>Ca,recall:()=>Ia,sparseCategoricalAccuracy:()=>Ta});var o={};n.r(o),n.d(o,{modelFromJSON:()=>Zn});var l={};n.r(l),n.d(l,{l1:()=>Ba,l1l2:()=>za,l2:()=>Ua});var c=n(1740);class u extends Error{constructor(e){super(e),Object.setPrototypeOf(this,u.prototype)}}class h extends Error{constructor(e){super(e),Object.setPrototypeOf(this,h.prototype)}}class d extends Error{constructor(e){super(e),Object.setPrototypeOf(this,d.prototype)}}class p extends Error{constructor(e){super(e),Object.setPrototypeOf(this,p.prototype)}}class f extends Error{constructor(e){super(e),Object.setPrototypeOf(this,f.prototype)}}Error;class m{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function g(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function y(e,t){if(!e)throw new f(t)}function v(e,t){let n=0;for(const r of e)r===t&&n++;return n}function x(e){return 1===e.length?e[0]:e}function b(e){return Array.isArray(e)?e:[e]}function w(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function _(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let S={};function M(e){if(null==e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function T(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach((e=>T(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?T(t):e[n]=t.value)}}}function E(e,t={},n={},r="object",i=!1){if("string"==typeof e){const i=e;let s;if(i in n)s=n[i];else if(i in S)s=S[i];else if(s=t[i],null==s)throw new d(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return s}{const s=e;if(null==s.className||null==s.config)throw new d(`${r}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);const a=s.className;let o,l;if(a in n?[o,l]=n[a]:a in S?[o,l]=S.className:a in t&&([o,l]=t[a]),null==o)throw new d(`Unknown ${r}: ${a}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const e={};for(const t of Object.keys(S))e[t]=S[t];for(const t of Object.keys(n))e[t]=n[t];s.config.customObjects=e;const t=Object.assign({},S);for(const e of Object.keys(n))S[e]=n[e];T(s.config);const r=l(o,s.config,n,i);return S=Object.assign({},t),r}{const e=Object.assign({},S);for(const e of Object.keys(n))S[e]=n[e];const t=new o(s.config);return S=Object.assign({},e),t}}}function A(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function C(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function I(e){if(null==e)throw new d(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function N(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new d(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function k(e,t,n=0,r=1/0){return y(n>=0),y(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function R(e,t){Array.isArray(e)?(c.D5U.assert(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>R(e,`element ${n+1} of ${t}`)))):c.D5U.assert(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${D(e)}.`))}function D(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>D(e))).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function L(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let F=0;function P(){return F++}const O={};function z(e=""){return e in O||(O[e]=0),O[e]+=1,e+O[e].toString()}const B=["channelsFirst","channelsLast"],U=["nearest","bilinear"],$=["valid","same","causal"],V=["max","avg"],W=["sum","mul","concat","ave"],G=new Map;function H(e){N(B,"DataFormat",e)}function j(e){N($,"PaddingMode",e)}function q(e){N(V,"PoolMode",e)}const X=[];function Y(e,t){X.push(e);try{const e=t();return X.pop(),e}catch(e){throw X.pop(),e}}function K(e){if(!Q(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===X.length?"":X.join("/")+"/")+e}function Z(e){if(!Q(e))throw new Error("Not a valid tensor name: '"+e+"'");G.has(e)||G.set(e,0);const t=G.get(e);if(G.set(e,G.get(e)+1),t>0){const n=`${e}_${t}`;return G.set(n,1),n}return e}const J=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Q(e){return!!e.match(J)}function ee(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let i=t;i<n;++i)r*=e[i];return r}function te(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function ne(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function re(e,t){if(t<e)throw new d(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}let ie;function se(){return null==ie&&(ie=(0,c.y3$)().epsilon()),ie}function ae(e,t){return c.pju(e,t)}function oe(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),c.XLQ(e,n)}function le(e,t,n){return(0,c.lub)((()=>{switch(e.rank){case 1:return c.jZU(e,t,n);case 2:return c.SmN(e,[t,0],[n,e.shape[1]]);case 3:return c.CnO(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return c.p0P(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return c.tPi(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return c.tPi(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new d(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function ce(e,t,n){return(0,c.lub)((()=>{switch(e.rank){case 1:return c.jZU(e,t,n);case 2:return c.SmN(e,[0,t],[e.shape[0],n]);case 3:return c.CnO(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return c.p0P(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new d(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function ue(e,t,n,r){return(0,c.lub)((()=>{switch(e.rank){case 1:return c.jZU(e,t,n);case 2:switch(r){case 1:return le(e,t,n);case 2:return ce(e,t,n);default:throw new d(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return le(e,t,n);case 2:return c.CnO(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return ce(e,t,n);default:throw new d(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return le(e,t,n);case 2:return c.p0P(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return c.p0P(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return ce(e,t,n);default:throw new d(`The axis is not within the rank of the tensor ${r}`)}default:throw new d(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function he(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),c.zoF(e,t)}function de(e,t){switch(e.rank){case 1:return c.gME([e,t]);case 2:return c.Izb([e,t],0);case 3:return c.MNy([e,t],0);case 4:return c.ZaL([e,t],0);default:throw new d(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function pe(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new d(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return c.Gg6(e,t)}function fe(e,t=0,n=1,r,i){return c.nGf(e,t,n,r,i)}function me(e,t,n,r){if(e.rank<2||t.rank<2)throw new p(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3&&e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new p(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`);if(2===e.rank&&2===t.rank){const i=!1,s=!1;return c.imm.matMul({a:e,b:t,transposeA:i,transposeB:s,bias:r?ve(e.rank,r,"channelsLast"):null,activation:n})}{const i=e.shape.slice(),s=i.pop();e=c.XLQ(e,[-1,s]);const a=t.shape.slice(),o=a.pop(),l=a.pop(),u=[...a,o],h=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=c.XLQ(c.p4s(t,h),[l,-1]);const d=[...i,...u],p=!1,f=!1;return c.XLQ(c.imm.matMul({a:e,b:t,transposeA:p,transposeB:f,bias:r?ve(e.rank,r,"channelsLast"):null,activation:n}),d)}}function ge(e,t,n){return(0,c.lub)((()=>(t=Array.isArray(t)?(0,c.RRF)(t,"int32"):c.pju(t,"int32"),c.Iqj(e,t,n))))}function ye(e){return c.dC7(e,e)}function ve(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new d(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?c.XLQ(t,[1,r[0],1,1,1]):c.XLQ(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?c.XLQ(t,[1,1,1,1,r[0]]):c.XLQ(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?c.XLQ(t,[1,r[0],1,1]):c.XLQ(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?c.XLQ(t,[1,1,1,r[0]]):c.XLQ(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?c.XLQ(t,[1,r[0],1]):c.XLQ(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?c.XLQ(t,[1,1,r[0]]):c.XLQ(t,[1].concat(r))}else if(e<3)return t;throw new d(`Unsupported input rank by biasAdd: ${t.rank}`)}function xe(e,t,n){return(0,c.lub)((()=>(null==n&&(n="channelsLast"),H(n),c.IHx(e,ve(e.rank,t,n)))))}function be(e,t,n,r){return(0,c.lub)((()=>c.rvX(e,t,n,r)))}function we(e,t,n=!1){return n?e():t()}const _e=["fanIn","fanOut","fanAvg"],Se=["normal","uniform","truncatedNormal"];class Me extends c.m7h.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Te extends Me{apply(e,t){return(0,c.lls)(e,t)}}Te.className="Zeros",c.m7h.registerClass(Te);class Ee extends Me{apply(e,t){return(0,c.iUs)(e,t)}}Ee.className="Ones",c.m7h.registerClass(Ee);class Ae extends Me{constructor(e){if(super(),"object"!=typeof e)throw new d(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new d(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return(0,c.lub)((()=>(0,c.dC7)((0,c.iD$)(this.value),(0,c.iUs)(e,t))))}getConfig(){return{value:this.value}}}Ae.className="Constant",c.m7h.registerClass(Ae);class Ce extends Me{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return(0,c.LGj)(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Ce.className="RandomUniform",c.m7h.registerClass(Ce);class Ie extends Me{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new p(`randomNormal does not support dType ${t}.`);return fe(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Ie.className="RandomNormal",c.m7h.registerClass(Ie);class Ne extends Me{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new p(`truncatedNormal does not support dType ${t}.`);return(0,c.Xu6)(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Ne.className="TruncatedNormal",c.m7h.registerClass(Ne);class ke extends Me{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return(0,c.lub)((()=>{if(2!==e.length||e[0]!==e[1])throw new d("Identity matrix initializer can only be used for 2D square matrices.");return(0,c.dC7)(this.gain,(0,c.iyy)(e[0]))}))}getConfig(){return{gain:this.gain}}}ke.className="Identity",c.m7h.registerClass(ke);class Re extends Me{constructor(e){if(super(),e.scale<0)throw new d(`scale must be a positive float. Got: ${e.scale}`);var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,N(_e,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){N(Se,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e,t="channelsLast"){let n,r;if(H(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){const t=ee(e,2);n=e[1]*t,r=e[0]*t}else if("channelsLast"===t){const t=ee(e,0,e.length-2);n=e[e.length-2]*t,r=e[e.length-1]*t}}else{const t=ee(e);n=Math.sqrt(t),r=Math.sqrt(t)}return[n,r]}(e),r=n[0],i=n[1];let s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,i):s/=Math.max(1,(r+i)/2),"normal"===this.distribution){const n=Math.sqrt(s);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new p(`${this.getClassName()} does not support dType ${t}.`);return(0,c.Xu6)(e,0,n,t,this.seed)}{const n=Math.sqrt(3*s);return(0,c.LGj)(e,-n,n,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Re.className="VarianceScaling",c.m7h.registerClass(Re);class De extends Re{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Re.className}}De.className="GlorotUniform",c.m7h.registerClass(De);class Le extends Re{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Re.className}}Le.className="GlorotNormal",c.m7h.registerClass(Le);class Fe extends Re{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Re.className}}Fe.className="HeNormal",c.m7h.registerClass(Fe);class Pe extends Re{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Re.className}}Pe.className="HeUniform",c.m7h.registerClass(Pe);class Oe extends Re{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Re.className}}Oe.className="LeCunNormal",c.m7h.registerClass(Oe);class ze extends Re{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Re.className}}ze.className="LeCunNormal",c.m7h.registerClass(ze);class Be extends Me{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,null!=this.seed)throw new p("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return(0,c.lub)((()=>{if(e.length<2)throw new p("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const t=fe(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32");let n=c.$r2.gramSchmidt(t);return e[0]>e[1]&&(n=(0,c.p4s)(n)),(0,c.dC7)(this.gain,n)}))}getConfig(){return{gain:this.gain,seed:this.seed}}}Be.className="Orthogonal",c.m7h.registerClass(Be);const Ue={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function $e(e,t={}){return E(e,c.m7h.SerializationMap.getMap().classNameMap,t,"initializer")}function Ve(e){return M(e)}function We(e){if("string"==typeof e){const t=e in Ue?Ue[e]:e;if("GlorotNormal"===t)return new Le;if("GlorotUniform"===t)return new De;if("HeNormal"===t)return new Fe;if("HeUniform"===t)return new Pe;if("LeCunNormal"===t)return new Oe;if("LeCunUniform"===t)return new ze;{const e={};return e.className=t,e.config={},$e(e)}}return e instanceof Me?e:$e(e)}function Ge(e){return Array.isArray(e)&&Array.isArray(e[0])}function He(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function je(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new d(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function qe(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new d(`Expected exactly 1 Shape; got ${e.length}`)}return e}function Xe(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}class Ye{constructor(e,t="float32",n="Variable",r=!0,i=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=P(),n=null==n?"Variable":n,this.originalName=K(n),this.name=Z(this.originalName),this.trainable_=r,this.constraint=i,this.val=c.VD$(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function Ke(e){return e.map((e=>e.read()))}function Ze(e){e.forEach((e=>{e[0].write(e[1])}))}class Je{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Qe{constructor(e,t,n,r,i,s,a){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=i,this.outputTensorIndex=a,this.id=P(),null!=s&&(this.originalName=K(s),this.name=Z(this.originalName)),this.rank=t.length}}let et=0;class tt{constructor(e,t){this.callArgs=t,this.id=et++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const t of e.inboundLayers)null!=t&&t.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let nt=0;class rt extends c.m7h.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=nt++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=w(e)+"_"+z(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new h(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new d(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return x(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return x(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new u(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new u(`Layer ${this.name} is not connected, no input to return.`);return x(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new u(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new u(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return x(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=b(e),null==this.inputSpec||0===this.inputSpec.length)return;const t=b(this.inputSpec);if(e.length!==t.length)throw new d(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){const r=e[n],i=t[n];if(null==i)continue;const s=r.rank;if(null!=i.ndim&&s!==i.ndim)throw new d(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${s}`);if(null!=i.maxNDim&&s>i.maxNDim)throw new d(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${s}`);if(null!=i.minNDim&&s<i.minNDim)throw new d(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${s}.`);if(null!=i.dtype&&r.dtype!==i.dtype)throw new d(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${r.dtype}.`);if(i.axes){const e=r.shape;for(const t in i.axes){const r=Number(t),s=i.axes[t],a=r>=0?e[r]:e[e.length+r];if(null!=s&&-1===[s,null].indexOf(a))throw new d(`Input ${n} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${s} but got shape ${e}.`)}}if(null!=i.shape)for(let e=0;e<i.shape.length;++e){const t=i.shape[e],s=r.shape[e];if(null!=t&&null!=s&&t!==s)throw new d(`Input ${n} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=b(e);let r=!0;for(const e of n)if(!(e instanceof Qe)){r=!1;break}let i=!0;for(const e of n)if(e instanceof Qe){i=!1;break}if(r===i)throw new d("Arguments to apply() must be all SymbolicTensors or all Tensors");return Y(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of b(e))t.push(n.shape);this.build(x(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&i&&(this._refCount=1)}if(this.assertInputCompatibility(e),i){let r=this.call(e,t);const i=b(r),s=[];for(let e of i)-1!==n.indexOf(e)&&(e=e.clone()),s.push(e);if(r=x(s),null!=this.activityRegularizer)throw new p("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(e){e=b(e);const t=[];for(const n of e)t.push(n.shape);return x(t)}(e),r=this.computeOutputShape(n);let i;const s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),i=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new Qe(s,n,this,b(e),t,this.name,r))):new Qe(s,r,this,b(e),t,this.name),this.addInboundNode(e,i,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new p("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new u(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new u(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new h(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Xe(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Ke(e?this.trainableWeights:this.weights)}setWeights(e){(0,c.lub)((()=>{const t=this.weights;if(t.length!==e.length)throw new d(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],r=Ke(t);for(let i=0;i<r.length;++i){const s=r[i],a=t[i],o=e[i];if(!c.D5U.arraysEqual(s.shape,o.shape))throw new d(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([a,o])}Ze(n)}))}addWeight(e,t,n,r,i,s,a,o){if(-1!==this._addedWeightNames.indexOf(e))throw new d(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():We("zeros"));const l=r.apply(t,n),c=new Ye(l,n,e,s,a);return l.dispose(),null!=i&&this.addLoss((()=>i.apply(c.read()))),null==s&&(s=!0),s?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=b(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}addInboundNode(e,t,n,r,i,s,a=null){const o=b(e);t=b(t),n=b(n),r=b(r),i=He(i),s=He(s);const l=[],c=[],u=[];for(const e of o)l.push(e.sourceLayer),c.push(e.nodeIndex),u.push(e.tensorIndex);new tt({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:u,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:i,outputShapes:s},a);for(let e=0;e<t.length;e++)t[e].sourceLayer=this,t[e].nodeIndex=this.inboundNodes.length-1,t[e].tensorIndex=e}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function it(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=it(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}class st extends rt{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:z("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new d("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new d("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new d("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new Qe(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new tt({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new d(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function at(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new d("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new st({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}st.className="InputLayer",c.m7h.registerClass(st);class ot{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof ot)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new d(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return(0,c.pju)(t,e.dtype)}catch(n){throw new d(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Qe){if(null==this.id2Value[e.id])throw new d(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new d(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof Qe){if(null==this.id2Value[e.id])throw new d(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new d(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&(0,c.B90)(this.id2Mask)}}const lt=new m,ct=new m;function ut(e,t,n,r){const i=null!=n&&n.training,s=Array.isArray(e),a=s?e:[e],o=a.map((e=>e.name)),l=[],u=t.names();for(const e of o)-1!==u.indexOf(e)?l.push(t.getValue(e)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const h=o.join(",")+"|"+t.names().sort().join(",");let d,p=lt.get(h);if(null==p){const e=function(e,t){c.D5U.assert(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){const i=dt(e[0],t);n=i.sorted,r=i.recipientMap}else{const i=new Set;for(const s of e){const{sorted:e,recipientMap:a}=dt(s,t);for(const t of e)i.has(t.name)||(n.push(t),i.add(t.name));for(const e in a)null==r[e]&&(r[e]=new Set),a[e].forEach((t=>r[e].add(t)))}}return{sorted:n,recipientCounts:ht(r)}}(a,t);p=e.sorted,d=e.recipientCounts,lt.put(h,p),ct.put(h,d)}d={},i||Object.assign(d,ct.get(h));const f=new ot(t);for(let e=0;e<p.length;++e){if(null!=r){const e=(0,c.sq6)().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}const s=p[e],a=s.sourceLayer;if(a instanceof st)continue;const u=[],h=[],m=[];let g=!1;for(const e of s.inputs){const n=f.getValue(e),r=f.getMask(e);u.push(n),h.push(r),null!=r&&(g=!0),i||(d[e.name]--,0!==d[e.name]||t.hasKey(e)||-1!==o.indexOf(e.name)||n.isDisposed||!0===e.sourceLayer.stateful||m.push(n))}g&&((n=n||{}).mask=h[0]);const y=b(a.apply(u,n));let v=null;a.supportsMasking&&(v=a.computeMask(u,h));const x=pt(s),w=Array.isArray(x)?x:[x];for(let e=0;e<w.length;++e){f.hasKey(w[e])||f.add(w[e],y[e],Array.isArray(v)?v[0]:v);const t=o.indexOf(w[e].name);-1!==t&&(l[t]=y[e])}i||(0,c.B90)(m)}return f.disposeMasks(),s?l:l[0]}function ht(e){const t={};for(const n in e)t[n]=e[n].size;return t}function dt(e,t){const n=new Set,r=[],i={};for(const e of t.names())n.add(e);const s=[],a=[];for(s.push(e);s.length>0;){const e=s[s.length-1];if(n.has(e.name)){s.pop();continue}const t=a[a.length-1]===s.length-1;if(0===e.inputs.length||t)s.pop(),r.push(e),n.add(e.name),t&&a.pop();else{a.push(s.length-1);for(const t of e.inputs)null==i[t.name]&&(i[t.name]=new Set),i[t.name].add(e.name),n.has(t.name)||s.push(t)}}return{sorted:r,recipientMap:i}}function pt(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function ft(e,t){return(0,c.lub)((()=>c._b3(c.Smz(c.dC7(e,e),t,!0))))}(0,c.OBj)().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=lt&&lt.setMaxEntries(e),null!=ct&&ct.setMaxEntries(e)})),n(6190);class mt extends c.m7h.Serializable{getConfig(){return{}}}class gt extends mt{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,c.lub)((()=>{const t=ft(e,this.axis),n=c.iUl(t,0,this.maxValue);return c.dC7(e,c.hiC(n,c.IHx(se(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}gt.className="MaxNorm",c.m7h.registerClass(gt);class yt extends mt{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,c.lub)((()=>c.hiC(e,c.IHx(se(),ft(e,this.axis)))))}getConfig(){return{axis:this.axis}}}yt.className="UnitNorm",c.m7h.registerClass(yt);class vt extends mt{apply(e){return c.UYe(e)}}vt.className="NonNeg",c.m7h.registerClass(vt);class xt extends mt{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,c.lub)((()=>{const t=ft(e,this.axis),n=c.IHx(c.dC7(this.rate,c.iUl(t,this.minValue,this.maxValue)),c.dC7(1-this.rate,t));return c.dC7(e,c.hiC(n,c.IHx(se(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}xt.className="MinMaxNorm",c.m7h.registerClass(xt);const bt={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function wt(e){return M(e)}function _t(e,t={}){return E(e,c.m7h.SerializationMap.getMap().classNameMap,t,"constraint")}function St(e){return null==e?null:"string"==typeof e?_t({className:e in bt?bt[e]:e,config:{}}):e instanceof mt?e:_t(e)}function Mt(e){return new gt(e)}function Tt(e){return new yt(e)}function Et(){return new vt}function At(e){return new xt(e)}function Ct(){return new Te}function It(){return new Ee}function Nt(e){return new Ae(e)}function kt(e){return new Ce(e)}function Rt(e){return new Ie(e)}function Dt(e){return new Ne(e)}function Lt(e){return new ke(e)}function Ft(e){return new Re(e)}function Pt(e){return new De(e)}function Ot(e){return new Le(e)}function zt(e){return new Fe(e)}function Bt(e){return new Pe(e)}function Ut(e){return new Oe(e)}function $t(e){return new ze(e)}function Vt(e){return new Be(e)}async function Wt(e){if(null==e)return;const t=[],n=[],r=[];for(const i in e){const s=e[i];if("number"!=typeof s){const e=s;t.push(e.data()),n.push(i),r.push(e)}}if(t.length>0){const i=await Promise.all(t);for(let t=0;t<i.length;++t)e[n[t]]=i[t][0];(0,c.B90)(r)}}function Gt(e){if(null!=e)for(const t in e){const n=e[t];"number"!=typeof n&&n.dispose()}}var Ht;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(Ht||(Ht={}));class jt{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class qt{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class Xt extends jt{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const e in t){const r=t[e];if("number"==typeof r)this.totals.hasOwnProperty(e)||(this.totals[e]=0),this.totals[e]=this.totals[e]+r*n;else{let t;e in this.totals?t=this.totals[e]:this.totals[e]=0;const i=(0,c.lub)((()=>(0,c.IHx)(this.totals[e],(0,c.dC7)(r,n))));this.totals[e]=i,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const e of this.params.metrics)null!=this.totals[e]&&("number"==typeof this.totals[e]?t[e]=this.totals[e]/this.seen:(0,c.lub)((()=>{const n=(0,c.dC7)((0,c.hiC)(1,this.seen),this.totals[e]);t[e]=n,this.totals[e].dispose(),(0,c.CnY)(t[e])})))}}class Yt extends jt{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const e in t)null==this.history[e]&&(this.history[e]=[]),this.history[e].push(t[e])}async syncData(){const e=[],t=[],n=[];for(const r in this.history){const i=this.history[r];for(let s=0;s<i.length;++s)if("number"!=typeof i[s]){const a=i[s];e.push(a.data()),t.push(r),n.push(s)}}const r=await Promise.all(e);for(let e=0;e<r.length;++e)this.history[t[e]][n[e]].dispose(),this.history[t[e]][n[e]]=r[e][0]}}class Kt extends jt{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||c.glt,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");c.D5U.isNumber(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,i=null!=n?n():c.D5U.now();return(...s)=>{const a=null!=n?n():c.D5U.now();return a-i<t||(i=a,r=e(...s)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const r=[];null!=this.yield&&(await Wt(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await Wt(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await Wt(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await Wt(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await Wt(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):c.D5U.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await Wt(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await Wt(e),await this.trainEnd(e))}}function Zt(e,t){return null==e&&(e={}),e instanceof jt?[e]:Array.isArray(e)&&e[0]instanceof jt?e:b(e).map((e=>new Kt(e,t)))}class Jt{constructor(){}static registerCallbackConstructor(e,t){c.D5U.assert(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),Jt.checkForDuplicate(t),null==Jt.constructors[e]&&(Jt.constructors[e]=[]),Jt.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Jt.constructors)Jt.constructors[+t].forEach((t=>{if(t===e)throw new d("Duplicate callback constructor.")}))}static clear(){Jt.constructors={}}static createCallbacks(e){const t=[];for(const n in Jt.constructors){const r=+n;e>=r&&t.push(...Jt.constructors[r])}return t.map((e=>new e))}}function Qt(e,t,n,r,i,s,a,o,l){const c=new Yt,u=[new Xt,...Jt.createCallbacks(t)];null!=e&&u.push(...e),u.push(c);const h=new qt(u);return h.setParams({epochs:n,initialEpoch:r,samples:i,steps:s,batchSize:a,verbose:t,doValidation:o,metrics:l}),{callbackList:h,history:c}}function en(e,t={},n=!1){return E(e,c.m7h.SerializationMap.getMap().classNameMap,t,"layer",n)}function tn(e,t){return(0,c.lub)((()=>{"float32"!==e.dtype&&(e=c.pju(e,"float32"));const n=c.Smz(ye(e),t,!0),r=c.hlL(n.shape,se()),i=c._b3(c.gWQ(n,r));return c.hiC(e,i)}))}function nn(e,t){return(0,c.lub)((()=>c.J69(ye(c.luU(t,e)),-1)))}function rn(e,t){return(0,c.lub)((()=>c.J69(c.WnP(c.luU(t,e)),-1)))}function sn(e,t){return(0,c.lub)((()=>{const n=c.luU(e,t),r=c.iUl(c.WnP(e),se(),Number.MAX_VALUE),i=c.WnP(c.hiC(n,r));return c.dC7(100,c.J69(i,-1))}))}function an(e,t,n=!1){return(0,c.lub)((()=>{if(n)t=c.XAC(t);else{const e=c.Smz(t,t.shape.length-1,!0);t=c.hiC(t,e)}return t=c.iUl(t,se(),1-se()),c.W76(c.Smz(c.dC7(c.pju(e,"float32"),c.cM7(t)),t.shape.length-1))}))}function on(e,t,n=!1){return(0,c.lub)((()=>{const r=c.pju(c.GWj(function(e){const t=[ee(e.shape)];return c.XLQ(e,t)}(e)),"int32"),i=(t=c.iUl(t,se(),1-se())).shape;return an(c.XLQ(c.lfX(r,i[i.length-1]),i),t,n)}))}function ln(e,t){return(0,c.lub)((()=>{let n;return n=c.iUl(t,se(),1-se()),n=c.cM7(c.hiC(n,c.luU(1,n))),c.J69(function(e,t){if(!c.D5U.arraysEqual(e.shape,t.shape))throw new d(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return(0,c.lub)((()=>{const n=c.UYe(t),r=c.W76(c.WnP(t));return c.IHx(c.luU(n,c.dC7(t,e)),c.Krr(c.Qqt(r)))}))}(e,n),-1)}))}function cn(e,t){return(0,c.lub)((()=>{const n=tn(e,-1),r=tn(t,-1),i=c.dC7(n,r);return c.W76(c.Smz(i,-1))}))}Jt.constructors={};const un={meanSquaredError:nn,meanAbsoluteError:rn,meanAbsolutePercentageError:sn,meanSquaredLogarithmicError:function(e,t){return(0,c.lub)((()=>{const n=c.iUl(t,se(),Number.MAX_VALUE),r=c.cM7(c.IHx(1,n)),i=c.iUl(e,se(),Number.MAX_VALUE),s=c.cM7(c.IHx(1,i));return c.J69(ye(c.luU(r,s)),-1)}))},squaredHinge:function(e,t){return(0,c.lub)((()=>{const n=c.gWQ(0,c.luU(1,c.dC7(e,t)));return c.J69(ye(n),-1)}))},hinge:function(e,t){return(0,c.lub)((()=>{const n=c.gWQ(0,c.luU(1,c.dC7(e,t)));return c.J69(n,-1)}))},categoricalHinge:function(e,t){return(0,c.lub)((()=>{const n=c.Smz(c.dC7(e,t),-1),r=c.Fp7(c.dC7(c.luU(1,e),t),-1);return c.gWQ(0,c.IHx(1,c.luU(r,n)))}))},logcosh:function(e,t){return(0,c.lub)((()=>{const n=Math.log(2),r=c.luU(t,e),i=c.luU(c.IHx(r,c.Wvh(c.dC7(-2,r))),n);return c.J69(i,-1)}))},categoricalCrossentropy:an,sparseCategoricalCrossentropy:on,binaryCrossentropy:ln,kullbackLeiblerDivergence:function(e,t){return(0,c.lub)((()=>{const n=c.iUl(e,se(),1),r=c.iUl(t,se(),1);return c.Smz(c.dC7(e,c.cM7(c.hiC(n,r))),-1)}))},poisson:function(e,t){return(0,c.lub)((()=>{const n=c.cM7(c.IHx(se(),t));return c.J69(c.luU(t,c.dC7(e,n)),-1)}))},cosineProximity:cn};function hn(e){if("string"==typeof e){if(e in un)return un[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new d(t)}return e}function dn(e,t){return(0,c.lub)((()=>{const n=c.dC7(.5,c.JpU(t)),r=ae(c.pjt(t,n),e.dtype);return c.J69(c.DgJ(e,r),-1)}))}function pn(e,t){return(0,c.lub)((()=>ae(c.DgJ(c.NqF(e,-1),c.NqF(t,-1)),"float32")))}function fn(e,t){return(0,c.lub)((()=>c.pju(c.Smz(c.HvI(c.DgJ(e,1),c.DgJ(t,1))),"float32")))}function mn(e,t){return(0,c.lub)((()=>{const n=fn(e,t),r=function(e,t){return(0,c.lub)((()=>c.pju(c.Smz(c.HvI(c.DgJ(e,0),c.DgJ(t,1))),"float32")))}(e,t),i=c.IHx(n,r);return c.pju(c.arb(c.pjt(i,0),c.hiC(n,i),0),"float32")}))}function gn(e,t){return ln(e,t)}function yn(e,t){return e.rank===t.rank&&(e=c.L9e(e,[e.rank-1])),(t=c.NqF(t,-1)).dtype!==e.dtype&&(t=c.pju(t,e.dtype)),c.pju(c.DgJ(e,t),"float32")}const vn=an,xn=on,bn={binaryAccuracy:dn,categoricalAccuracy:pn,precision:mn,categoricalCrossentropy:vn,sparseCategoricalCrossentropy:xn,mse:nn,MSE:nn,mae:rn,MAE:rn,mape:sn,MAPE:sn,cosine:cn};function wn(e){if("string"==typeof e&&e in bn)return bn[e];if("string"!=typeof e&&null!=e)return e;throw new d(`Unknown metric ${e}`)}function _n(e){if(y(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(const n of Object.keys(un))if(un[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(bn))if(bn[n]===e){t=n;break}return void 0!==t?t:e.name}}function Sn(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!Mn(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function Mn(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!=typeof n)return!1;if(!Mn(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!Mn(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function Tn(e,t,n=console.log){let r="";for(let n=0;n<e.length;++n)n>0&&(r=r.slice(0,r.length-1)+" "),r+=e[n],r=r.slice(0,t[n]),r+=" ".repeat(t[n]-r.length);n(r)}function En(e,t,n){let r,i;try{i=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(e){i="multiple"}try{r=JSON.stringify(e.outputShape)}catch(e){r="multiple"}Tn([`${e.name} (${e.getClassName()})`,i,r,e.countParams().toString()],t,n)}function An(e,t,n,r){let i,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(e){s="multiple"}try{i=JSON.stringify(e.outputShape)}catch(e){i="multiple"}const a=[];for(const t of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(t)))for(let e=0;e<t.inboundLayers.length;++e){const n=t.inboundLayers[e].name,r=t.nodeIndices[e],i=t.tensorIndices[e];a.push(`${n}[${r}][${i}]`)}const o=e.name,l=e.getClassName(),c=0===a.length?"":a[0];Tn([`${o} (${l})`,s,i,e.countParams().toString(),c],t,r);for(let e=1;e<a.length;++e)Tn(["","","","",a[e]],t,r)}function Cn(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function In(e,t){if(null===e)return null;if("string"==typeof e)return _(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let i=0;i<r;++i){const r=e[i];Cn(t,i,r)?n.push(r):n.push(In(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{const e=_(n);t[e]=In(r,e)}}return t}}function Nn(e,t){if(null==e)return null;if("string"==typeof e)return w(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let i=0;i<r;++i){const r=e[i];Cn(t,i,r)?n.push(r):n.push(Nn(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];t[w(n)]="name"!==n&&"className"!==n||"string"!=typeof r?Nn(r,n):r}return t}}const kn="3.18.0";class Rn extends rt{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=z(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],C(this.inputs).length!==this.inputs.length)throw new d(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);C(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const e of this.outputs){const t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(n),this.outputLayersTensorIndices.push(r)}for(const e of this.inputs){const t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;y(0===n,"input layer has >1 nodes"),y(0===r,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(n),this.inputLayersTensorIndices.push(r)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let t=0;t<this.inputLayers.length;t++){const n=this.inputLayers[t];if(!(n instanceof st))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${t} (0-based) originates from layer type ${n.getClassName()}.`);this.inputNames.push(n.name),this.feedInputShapes.push(n.batchInputShape),this.feedInputNames.push(n.name)}for(const e of this.outputLayers)this.outputNames.push(e.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},r={},i={},s={},a=[],o=(e,t,n,r,i,l)=>{null!=r&&null!=i&&null!=l||(r=e.sourceLayer,i=e.nodeIndex,l=e.tensorIndex);const c=r.inboundNodes[i];if(-1!==n.indexOf(c))throw new h(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(c))return;this.containerNodes.add(Rn.nodeKey(r,i)),r.id in s||(s[r.id]=Object.keys(s).length),-1===n.indexOf(c)&&n.push(c);const u=c.inboundLayers.length;for(let e=0;e<u;e++){const r=c.inputTensors[e],i=c.inboundLayers[e],s=c.nodeIndices[e],a=c.tensorIndices[e];o(r,t,n,i,s,a)}for(t.push(c);n.indexOf(c)>=0;)n.splice(n.indexOf(c),1);a.push(c)},l=[],c=[];for(const e of this.outputs)o(e,l,c);const u=a.slice().reverse();for(const e of u){n[e.id]=e,e.id in t||(t[e.id]=0);let s=t[e.id];const a=null==r[e.outboundLayer.id]?0:r[e.outboundLayer.id];s=Math.max(s,a),r[e.outboundLayer.id]=s,i[e.outboundLayer.id]=e.outboundLayer,t[e.id]=s;for(let r=0;r<e.inboundLayers.length;r++){const i=e.inboundLayers[r],a=e.nodeIndices[r],o=i.inboundNodes[a],l=null==t[o.id]?0:t[o.id];t[o.id]=Math.max(s+1,l),n[o.id]=o}}const p={};for(const e in t){const r=t[e];r in p||(p[r]=[]),p[r].push(n[e])}const f={};for(const e in r){const t=r[e];t in f||(f[t]=[]),f[t].push(i[e])}let m=Object.keys(f).map((e=>parseInt(e,10))).sort(A);this.layers=[];for(const e of m){const t=f[e];t.sort(((e,t)=>{const n=s[e.id],r=s[t.id];return n<r?-1:n>r?1:0}));for(const e of t)e instanceof Rn&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=f,m=Object.keys(p).map((e=>parseInt(e,10))).sort(A);const g=this.inputs.slice(),v=[];for(const e of m)for(const t of p[e]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===g.indexOf(n))throw new h(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${v}`);for(const e of t.outputTensors)g.push(e);v.push(e.name)}}this.nodesByDepth=p;const x=this.layers.map((e=>e.name));for(const e of x){const t=x.filter((t=>t===e)).length;if(1!==t)throw new h(`The name "${e}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(x))}this.outboundNodes=[],this.inboundNodes=[],new tt({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new d("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const n={};let r=0;for(const e of this.layers)for(const t of e.weights){if(null!=n[t.originalName])throw new d(`Duplicate weight name: ${t.originalName}`);n[t.originalName]=t,r++}const i=[];for(const r in e){let s=r;if(null==n[r]){const e=r.split("/");s=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[s])i.push([n[s],e[r]]);else if(t)throw new d(`Provided weight data has no target variable: ${r}`);delete n[s]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new d(`${e.length} of ${r} weights are not set: ${e}`)}Ze(i)}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${kn}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const n=Nn(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return(0,c.lub)((()=>{e=b(e);const n=new ot;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return ut(this.outputs,n,t)}))}computeMask(e,t){return(0,c.lub)((()=>{let n;return e=b(e),n=null==t?g(null,e.length):b(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=He(e);if(t.length!==this.inputLayers.length)throw new d(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let e=0;e<t.length;e++){const r=this.inputLayers[e],i=t[e];n[r.name+"_0_0"]=i}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(A);if(r.length>1)for(const e of r){const t=this.nodesByDepth[e];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(t.id))continue;const r=[];for(let t=0;t<e.inboundLayers.length;t++){const i=e.inboundLayers[t],s=e.nodeIndices[t],a=e.tensorIndices[t],o=n[`${i.name}_${s}_${a}`];r.push(o)}const i=He(t.computeOutputShape(x(r))),s=t.inboundNodes.indexOf(e);for(let e=0;e<i.length;e++)n[`${t.name}_${s}_${e}`]=i[e]}}const i=[],s=[];for(let e=0;e<this.outputLayers.length;e++){const t=this.outputLayers[e],n=this.outputLayersNodeIndices[e],r=this.outputLayersTensorIndices[e],i=`${t.name}_${n}_${r}`;s.push(i)}for(let e=0;e<s.length;e++){const t=s[e];y(t in n),i.push(n[t])}return x(i)}runInternalGraph(e,t){null==t&&(t=g(null,e.length));const n={};for(let r=0;r<this.inputs.length;++r){const i=this.inputs[r],s=e[r],a=t[r];n[i.id]=[s,a]}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(A);for(const e of r){const t=this.nodesByDepth[e];for(const e of t){const t=e.outboundLayer,r=e.inputTensors,i=e.outputTensors,s=new Array;for(const e of r)e.id in n&&s.push(n[e.id]);if(s.length===r.length){let r,a,o,l,c={};if(null!=e.callArgs&&(c=e.callArgs),1===s.length){const[e,n]=s[0];null==c.mask&&(c.mask=n),o=b(t.call(e,c)),l=b(t.computeMask(e,n)),r=[e],a=[n]}else r=s.map((e=>e[0])),a=s.map((e=>e[1])),null==c.mask&&(c.mask=a),o=b(t.call(r,c)),l=b(t.computeMask(r,a));if(t.activityRegularizer)throw new p("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<i.length;++e){const t=i[e],r=o[e],s=l[e];n[t.id]=[r,s]}}}}const i=[],s=[],a=[];for(const e of this.outputs){y(e.id in n,`Could not compute output ${e.name} : ${e.id}`);const[t,r]=n[e.id];a.push(t.shape),i.push(t),s.push(r)}return[i,s,a]}buildNodeConversionMap(e){const t={};let n;for(const e of this.layers){n=e instanceof Rn?1:0;for(let r=0;r<e.inboundNodes.length;r++){const i=Rn.nodeKey(e,r);this.containerNodes.has(i)&&(t[i]=n,n+=1)}}return t}getLayer(e,t){if(null!=t){if(this.layers.length<=t)throw new d(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}if(null==e)throw new d("Provide either a layer name or layer index");for(const t of this.layers)if(t.name===e)return t;throw new d(`No such layer: ${e}`)}calculateLosses(){return(0,c.lub)((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=Rn.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const e of this.layers){const r=e.getClassName(),i=e.getConfig(),s=[];for(let n=0;n<e.inboundNodes.length;n++){const r=e.inboundNodes[n],i=Rn.nodeKey(e,n);let a={};if(this.containerNodes.has(i)){if(r.callArgs)try{JSON.stringify(r.callArgs),a=r.callArgs}catch(t){console.warn(`Layer ${e.name} was passed non-serializable keyword arguments: ${r.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),a={}}if(r.inboundLayers.length>0){const e=[];for(let n=0;n<r.inboundLayers.length;n++){const i=r.inboundLayers[n],s=r.nodeIndices[n],o=r.tensorIndices[n];let l=t[Rn.nodeKey(i,s)];null==l&&(l=0),e.push([i.name,l,o,a])}s.push(e)}}}const a={};a.name=e.name,a.className=r,a.config=i,a.inboundNodes=s,n.push(a)}e.layers=n;const r=[];for(let e=0;e<this.inputLayers.length;e++){const n=this.inputLayers[e],i=this.inputLayersNodeIndices[e],s=Rn.nodeKey(n,i);if(!this.containerNodes.has(s))continue;let a=t[s];null==a&&(a=0);const o=this.inputLayersTensorIndices[e];r.push([n.name,a,o])}e.inputLayers=r;const i=[];for(let e=0;e<this.outputLayers.length;e++){const n=this.outputLayers[e],r=this.outputLayersNodeIndices[e],s=Rn.nodeKey(n,r);if(!this.containerNodes.has(s))continue;let a=t[s];null==a&&(a=0);const o=this.outputLayersTensorIndices[e];i.push([n.name,a,o])}return e.outputLayers=i,e}static fromConfig(e,t,n={},r=!1){const i={},s={};function a(e,t){e.name in s?s[e.name].push(t):s[e.name]=[t]}function o(e,t){const n=[];let r;for(const s of t){const o=s[0],l=s[1],c=s[2];if(r=null==s[3]?{}:s[3],!(o in i))return void a(e,t);const u=i[o];if(u.inboundNodes.length<=l)return void a(e,t);const h=u.inboundNodes[l];n.push(h.outputTensors[c])}n.length>0&&e.apply(x(n),r)}function l(e){const n=e.name,s=en(e,null!=t.customObjects?t.customObjects:{});s.setFastWeightInitDuringBuild(r),i[n]=s,e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new d(`Corrupted configuration, expected array for nodeData: ${e}`);a(s,e)}))}const c=t.name,u=t.layers;for(const e of u)l(e);for(;!I(s);)for(const e of u){const t=i[e.name];if(t.name in s){const e=s[t.name];delete s[t.name];for(const n of e)o(t,n)}}const h=[],p=[],f=t.inputLayers;for(const e of f){const t=e[0],n=e[1],r=e[2];y(t in i);const s=i[t].inboundNodes[n].outputTensors;h.push(s[r])}const m=t.outputLayers;for(const e of m){const t=e[0],n=e[1],r=e[2];y(t in i);const s=i[t].inboundNodes[n].outputTensors;p.push(s[r])}return new e({inputs:h,outputs:p,name:c})}get stateful(){if(this._stateful)throw new d("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){(0,c.lub)((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function Dn(e,t){return function(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}(e,t,"classWeight")}async function Ln(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=(0,c.lub)((()=>{if(1===e.shape.length)return(0,c.d9v)(e);if(2===e.shape.length){if(e.shape[1]>1){const t=1;return(0,c.NqF)(e,t)}if(1===e.shape[1])return(0,c.XLQ)(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());(0,c.B90)(t);const i=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);i.push(n[e])})),(0,c.RRF)(i,"float32")}return null}function Fn(e,t){return(0,c.dC7)(e,t)}function Pn(e,t){let n,r;const i=t;n=i.xs,r=i.ys,c.D5U.assert(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));const s=On("input",e.inputNames,n),a=On("output",e.outputNames,r),o=s[0].shape[0];c.D5U.assert(s.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),c.D5U.assert(a.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let t=0;t<s.length;t++)c.D5U.assert(s[t].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[t]} has ${s[t].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let t=0;t<a.length;t++)c.D5U.assert(a[t].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[t]} has ${a[t].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:s,ys:a}}function On(e,t,n){if(n instanceof c.esB)return[n];if(Array.isArray(n))return c.D5U.assert(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{const r=[];for(const i of t){if(null==n[i])throw new d(`The feature data generated by the dataset lacks the required ${e} key '${i}'.`);r.push(n[i])}return r}}function zn(e){return"function"==typeof e.iterator}function Bn(e){c.D5U.assert(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function Un(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>le(e,t,n-t))):le(e,t,n-t)}function $n(e,t){return c.lub((()=>null==e?null:Array.isArray(e)?e.map((e=>$n(e,t))):ge(e,"int32"===t.dtype?t:c.pju(t,"int32"))))}function Vn(e,t){const n=[];let r=0,i=null;for(;r<e;)i=r+t,i>=e&&(i=e),n.push([r,i]),r=i;return n}function Wn(e){const t=[];e instanceof c.esB&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(oe(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Gn(e,t){if(null==e)return;const n=[];if(t instanceof c.esB)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const e in t){const r=t[e];n.push(r.id)}const r=[];if(e instanceof c.esB)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(const t in e){const i=e[t];-1===n.indexOf(i.id)&&r.push(i)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function Hn(e){return Array.isArray(e)}function jn(e){return!function(e){return e instanceof c.esB}(e)&&!Hn(e)}function qn(e,t,n,r=!0,i=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(Hn(e)&&e.length>0)t=!0;else if(jn(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new d(`Error when checking model ${i} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));let s;if(jn(e)){s=[];for(const n of t){if(null==e[n])throw new d(`No data provided for "${n}". Need data for each key in: ${t}`);s.push(e[n])}}else if(Hn(e)){if(e.length!==t.length)throw new d(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(t.length>1)throw new d(`The model ${i} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=Wn(s),null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;const a=s[e];if(a.shape.length!==n[e].length)throw new d(`Error when checking ${i}: expected ${t[e]} to have ${n[e].length} dimension(s). but got array with shape ${a.shape}`);for(let t=0;t<n[e].length;++t){if(0===t&&!r)continue;const s=a.shape[t],o=n[e][t];if(null!=o&&o>=0&&s!==o)throw new d(`${i} expected a batch of elements where each example has shape [${n[e].slice(1,n[e].length)}] (i.e.,tensor shape [*,${n[e].slice(1,n[e].length)}]) but the ${i} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return s}function Xn(e,t,n,r=!0,i=""){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new d(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new d(`The model expects ${t.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;const a=s[e];if(a.shape.length!==n[e].length)throw new d(`Error when checking ${i}: expected ${t[e]} to have ${n[e].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let s=0;s<n[e].length;++s){if(0===s&&!r)continue;const o=a.shape[s],l=n[e][s];if(null!=l&&l!==o)throw new d(`Error when checking ${i}: expected ${t[e]} to have shape ${JSON.stringify(n[e])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}class Yn extends Rn{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new d("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(e,t,n,r=console.log){const i=function(e){let t=!0;const n=[],r=[];for(const t in e.nodesByDepth)n.push(e.nodesByDepth[t]);for(const e of n){if(e.length>1||1===e.length&&e[0].inboundLayers.length>1){t=!1;break}r.push(...e)}if(t)for(const n of e.layers){let e=!1;for(const i of n.inboundNodes)if(-1!==r.indexOf(i)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),s=["Layer (type)","Input Shape","Output shape","Param #"];let a;if(i?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!i){s.push("Receives inputs"),a=[];for(const t in e.nodesByDepth)a.push(...e.nodesByDepth[t])}r("_".repeat(t)),Tn(s,n,r),r("=".repeat(t));const o=e.layers;for(let e=0;e<o.length;++e)i?En(o[e],n,r):An(o[e],n,a,r),r((e===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=function(e){let t;return t=null!=e.collectedTrainableWeights?Xe(e.collectedTrainableWeights):Xe(e.trainableWeights),t}(e),c=Xe(e.nonTrainableWeights);r(`Total params: ${l+c}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${c}`),r("_".repeat(t))}(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>c.p_j.adagrad(.01),Adadelta:()=>c.p_j.adadelta(1,.95,se()),Adam:()=>c.p_j.adam(.001,.9,.999,se()),Adamax:()=>c.p_j.adamax(.002,.9,.999,se(),0),RMSProp:()=>c.p_j.rmsprop(.001,.9,0,se()),SGD:()=>c.p_j.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new d(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof c.gaJ))throw new d("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new d(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);const n=e.loss;t=n.map((e=>hn(e)))}else{const n=hn(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new d(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(hn(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let e=0;e<this.outputs.length;++e){const t=this.internalOutputShapes[e],n=this.outputNames[e];this.feedOutputNames.push(n),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[e])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Y("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),i=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};Y("metric",(()=>{for(let e=0;e<this.outputs.length;++e)-1===n.indexOf(e)&&(t=>{let n,r,s;for(const a of t){if("string"==typeof a&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(a)){const t=this.internalOutputShapes[e];let i;1===t[t.length-1]||this.lossFunctions[e]===ln?-1!==["accuracy","acc"].indexOf(a)?r=dn:-1!==["crossentropy","ce"].indexOf(a)&&(r=gn):this.lossFunctions[e]===on?-1!==["accuracy","acc"].indexOf(a)?r=yn:-1!==["crossentropy","ce"].indexOf(a)&&(r=xn):-1!==["accuracy","acc"].indexOf(a)?r=pn:-1!==["crossentropy","ce"].indexOf(a)&&(r=vn),-1!==["accuracy","acc"].indexOf(a)?i="acc":-1!==["crossentropy","ce"].indexOf(a)&&(i="ce"),s=r,n=""+i}else{const e=wn(a);s=e,n=""+_n(a)}let t;Y(n,(()=>{t=s})),i(e,n,t)}})(r[e])})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){const r=null==n.batchSize?32:n.batchSize;Bn(r);const i=this.standardizeUserDataXY(e,t,!0,r);try{const s=i[0].concat(i[1]);this.makeTestFunction();const a=this.testFunction;return x(this.testLoop(a,s,r,n.verbose,n.steps))}finally{Gn(i[0],e),Gn(i[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const r=null!=(n=n||{}).batches,i=e.testFunction;let s=[];if(n.verbose>0)throw new p("Verbose mode is not implemented yet.");c.D5U.assert(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const a="function"==typeof t.next?t:await t.iterator();let o=0,l=0;for(;!r||l<n.batches;){const t=await a.next();if(s=c.lub((()=>{if(t.value){const{xs:n,ys:r}=Pn(e,t.value),a=n.concat(r),u=c.lub((()=>i(a)));if(c.B90(a),0===l)for(let e=0;e<u.length;++e)s.push((0,c.iD$)(0));const h=a[0].shape[0];for(let e=0;e<u.length;++e){const t=u[e],n=s[e];s[e]=c.lub((()=>c.IHx(s[e],c.dC7(h,t)))),l>0&&c.B90(n)}c.B90(u),o+=h,++l}return s})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let e=0;e<s.length;++e){const t=s[e];s[e]=c.hiC(s[e],o),c.B90(t)}return x(s)}(this,e,t)}checkNumSamples(e,t,n,r="steps"){let i;if(null!=n){if(i=null,null!=t)throw new d(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new d(`Either the input data should have a defined shape, or ${r} shoud be specified.`);i=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return i}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new d("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=n?t:[t],i=this.retrieveSymbolicTensors(r),s=new ot;if(e instanceof c.esB&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new d(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(const t of this.inputs){const n=e[t.name];if(null==n)throw new d(`No value is provided for the model's input ${t.name}`);s.add(t,n)}const a=ut(i,s);return n?a:a[0]}retrieveSymbolicTensors(e){const t=g(null,e.length);let n=e.length;for(const r of this.layers){const i=Array.isArray(r.output)?r.output:[r.output],s=i.map((e=>e.name));for(let r=0;r<e.length;++r){const a=s.indexOf(e[r]);if(-1!==a&&(t[r]=i[a],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new d(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return c.lub((()=>{const r=this.checkNumSamples(e);if(n)throw new p("Verbose predictLoop() is not implemented yet.");const i=Vn(r,t),s=this.outputs.map((e=>[]));for(let t=0;t<i.length;++t)c.lub((()=>{const n=i[t][0],r=i[t][1],s=Un(e,n,r),a=[];if(Array.isArray(s))for(let e=0;e<s.length;++e)a.push({key:this.inputs[e],value:s[e]});else a.push({key:this.inputs[0],value:s});const o=new ot(a);return ut(this.outputs,o)})).forEach(((e,t)=>s[t].push(e)));return x(s.map((e=>c.zoF(e,0))))}))}predict(e,t={}){const n=Wn(e);Xn(n,this.inputNames,this.feedInputShapes,!1);try{const r=null==t.batchSize?32:t.batchSize;return Bn(r),this.predictLoop(n,r)}finally{Gn(n,e)}}predictOnBatch(e){Xn(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(null==this.optimizer_)throw new h("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let e=0;e<this.feedOutputShapes.length;++e){const t=this.feedOutputShapes[e];this.feedLossFns[e]===on?i.push(t.slice(0,t.length-1).concat([1])):i.push(t)}if(function(e,t,n){const r=C(e.map((e=>e.shape[0])));r.sort();const i=C(t.map((e=>e.shape[0])));if(i.sort(),r.length>1)throw new d(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(i.length>1)throw new d(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(r.length>0&&i.length>0&&!c.D5U.arraysEqual(r,i))throw new d(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${i[0]} target sample(s).`)}(e=qn(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=qn(t,this.feedOutputNames,i,!1,"target")),function(e,t,n){const r=[nn,ln,an];for(let i=0;i<e.length;++i){const s=e[i],a=t[i],o=n[i];if(null!=a){if(a===an&&1===s.shape[s.shape.length-1])throw new d(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(a)){const e=s.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const r=e[n],i=t[n];if(null!=i&&r!==i)throw new d(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!=0)throw new d(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,i=!0,s){const[a,o]=this.standardizeUserDataXY(e,t,i,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const e=Dn(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await Ln(o[t],null,e[t]))}return[a,o,l]}testLoop(e,t,n,r=0,i){return c.lub((()=>{const s=this.checkNumSamples(t,n,i,"steps"),a=[];if(r>0)throw new p("Verbose mode is not implemented yet.");if(null!=i)throw new p("steps mode in testLoop() is not implemented yet");{const r=Vn(s,n),i=(0,c.RRF)(re(0,s));for(let n=0;n<r.length;++n){const s=r[n][0],o=r[n][1],l=le(i,s,o-s),u=$n(t,l),h=e(u);if(0===n)for(let e=0;e<h.length;++e)a.push((0,c.iD$)(0));for(let e=0;e<h.length;++e){const t=h[e];a[e]=c.IHx(a[e],c.dC7(o-s,t))}}for(let e=0;e<a.length;++e)a[e]=c.hiC(a[e],s)}return a}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let i=r;v(e,r)>1&&(i+=`_${v(e.slice(0,n),r)}`),t.push(i)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],a=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const a=new ot(e),o=ut(this.outputs,a,{training:!0});let l;for(let e=0;e<this.lossFunctions.length;++e){let n=(0,this.lossFunctions[e])(r[e],o[e]);null!=i[e]&&(n=Fn(n,i[e]));const s=c.J69(n);t.push(s),l=0===e?n:c.IHx(l,n)}for(let e=0;e<this.metricsTensors.length;++e){let n;if(this.outputs.length>1&&e<this.outputs.length)n=t[e];else{const t=this.metricsTensors[e][0],i=this.metricsTensors[e][1];n=c.J69(t(r[i],o[i]))}c.CnY(n),s.push(n)}return l=c.J69(l),this.calculateLosses().forEach((e=>{l=c.IHx(l,e)})),l}),!0,a)].concat(s)}}makeTestFunction(){this.testFunction=e=>c.lub((()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let e=0;e<this.inputs.length;++e)s.push({key:this.inputs[e],value:r[e]});const a=new ot(s),o=ut(this.outputs,a);for(let e=0;e<this.lossFunctions.length;++e){const r=this.lossFunctions[e],s=c.J69(r(i[e],o[e]));n=0===e?s:c.IHx(n,s),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],r=this.metricsTensors[e][1],s=c.J69(n(i[r],o[r]));t.push(s)}return t}))}async fit(e,t,n={}){return async function(e,t,n,r={}){if(e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let i,s,a,o,l,u,h,f,m;e.isTraining=!0;try{const g=null==r.batchSize?32:r.batchSize;Bn(g);const y=!1,v=await e.standardizeUserData(t,n,r.sampleWeight,r.classWeight,y,g);i=v[0],s=v[1],m=v[2];let x,b=!1;if(null!=r.validationData&&r.validationData.length>0){if(b=!0,2!==r.validationData.length)throw 3===r.validationData.length?new p("validationData including sample weights is not supported yet."):new d(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);l=r.validationData[0],u=r.validationData[1];const t=!0,n=await e.standardizeUserData(l,u,null,null,t,g);h=n[0],f=n[1],x=h.concat(f)}else if(null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1){b=!0;const e=Math.floor(i[0].shape[0]*(1-r.validationSplit)),t=i[0].shape[0];h=Un(i,e,t),a=i,i=Un(i,0,e),f=Un(s,e,t),o=s,s=Un(s,0,e),x=h.concat(f)}else null!=r.validationSteps&&(b=!0);const w=i.concat(s).concat(m);e.checkTrainableWeightsConsistency();const _=e.makeTrainFunction(),S=e.getDedupedMetricsNames();let M,T;b?(e.makeTestFunction(),M=e.testFunction,T=S.slice().concat(S.map((e=>"val_"+e)))):(M=null,x=[],T=S.slice());const E=Zt(r.callbacks,r.yieldEvery),A=await async function(e,t,n,r,i,s,a,o,l,u,h,d,f,m,g){null==i&&(i=32),null==s&&(s=1),null==h&&(h=!0),null==f&&(f=0);let y=!1;null!=l&&null!=u&&(y=!0);const v=e.checkNumSamples(n,i,m,"steps_per_epoch");let x;null!=v&&(x=re(0,v)),null==a&&(a=1);const{callbackList:b,history:w}=Qt(o,a,s,f,v,m,i,y,d);b.setModel(e),e.history=w,await b.onTrainBegin(),e.stopTraining_=!1;for(let a=f;a<s;++a){await b.onEpochBegin(a);const s={};{if("batch"===h)throw new p("batch shuffling is not implemneted yet");h&&c.D5U.shuffle(x);const a=(0,c.RRF)(x),o=Vn(v,i);for(let h=0;h<o.length;++h){const d={};if(await b.onBatchBegin(h,d),c.lub((()=>{const p=o[h][0],f=o[h][1],m=le(a,p,f-p);d.batch=h,d.size=f-p;const g=$n(n,m),v=t(g);for(let e=0;e<r.length;++e){const t=r[e],n=v[e];d[t]=n,c.CnY(n)}if(h===o.length-1&&y){const t=e.testLoop(l,u,i);for(let e=0;e<r.length;++e){const n=r[e],i=t[e];c.CnY(i),s["val_"+n]=i}}})),await b.onBatchEnd(h,d),Gt(d),e.stopTraining_)break}a.dispose()}if(await b.onEpochEnd(a,s),e.stopTraining_)break}return await b.onTrainEnd(),await e.history.syncData(),e.history}(e,_,w,S,g,r.epochs,r.verbose,E,M,x,r.shuffle,T,r.initialEpoch,null);return A}finally{e.isTraining=!1,Gn(i,t),Gn(s,n),Gn(a,t),Gn(o,n),Gn(h,l),Gn(f,u),null!=m&&c.B90(m)}}(this,e,t,n)}async fitDataset(e,t){return async function(e,t,n){const r=null!=n.batchesPerEpoch;if(c.D5U.assert(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),c.D5U.assert(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),c.D5U.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),c.D5U.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),c.D5U.assert(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const i=null!=n.validationData;let s,a;if(i)if(zn(n.validationData))c.D5U.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const e=function(e){if(3===e.length)throw new p("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);s=e.xs,a=e.ys}const o=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;u=i?l.slice().concat(l.map((e=>"val_"+e))):l.slice();const h=Zt(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:f,history:m}=Qt(h,d,n.epochs,null,null,function(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}(t,n),null,i,u);f.setModel(e),e.history=m,await f.onTrainBegin(),e.stopTraining_=!1;let g=null==n.initialEpoch?0:n.initialEpoch,y=await t.iterator();for(;g<n.epochs;){const u={};await f.onEpochBegin(g);let h=0,d=0;for(r||(y=await t.iterator());!r||h<n.batchesPerEpoch;){const t=await y.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${h} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:r,ys:i}=Pn(e,t.value),s={};s.batch=d,s.size=r[0].shape[0],await f.onBatchBegin(d,s);const a=[];if(null!=n.classWeight){const t=Dn(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)a.push(await Ln(i[e],null,t[e]))}const u=r.concat(i).concat(a),p=o(u);c.B90(u);for(let e=0;e<l.length;++e){const t=l[e],n=p[e];s[t]=n,c.CnY(n)}await f.onBatchEnd(d,s),Gt(s),d++,h++}if(r?h>=n.batchesPerEpoch:t.done){if(i){let t;t=zn(n.validationData)?b(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):b(e.evaluate(s,a,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)u[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await f.onEpochEnd(g,u),g++,e.stopTraining_)break}return await f.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),r=n[0],i=n[1],s=this.makeTrainFunction()(r.concat(i)),a=[];for(const e of s){const t=await e.data();a.push(t[0])}return c.B90(s),Gn(n[0],e),Gn(n[1],t),x(a)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,i=this.getWeights(n);for(let e=0;e<r.length;++e)n&&!r[e].trainable||t.push({name:r[e].originalName,tensor:i[e]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=c.sq6().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-c.sq6().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=w(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>w(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=w(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[w(_n(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>w(_n(e))));{const e={};for(const t in this.metrics)e[t]=w(_n(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=en(In(e.optimizer_config));let n,r;if("string"==typeof e.loss)n=_(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>_(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=_(e.loss[t])}if(Array.isArray(e.metrics))r=e.metrics.map((e=>_(e)));else if(null!=e.metrics){r={};for(const t in e.metrics)r[t]=_(e.metrics[t])}this.compile({loss:n,metrics:r,optimizer:t})}async save(e,t){if("string"==typeof e){const t=c.io.getSaveHandlers(e);if(0===t.length)throw new d(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new d(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new d("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await c.io.encodeWeights(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${kn}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:i}=await c.io.encodeWeights(await this.optimizer.getWeights(),e);n.specs.push(...i),n.data=c.io.concatenateArrayBuffers([n.data,t])}if(null!=this.userDefinedMetadata){const e=!0;Sn(this.userDefinedMetadata,this.name,e),r.userDefinedMetadata=this.userDefinedMetadata}return r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){Sn(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Yn.className="Model",c.m7h.registerClass(Yn);class Kn extends Yn{}async function Zn(e,t){"modelTopology"in e||(e={modelTopology:e});let n=e.modelTopology;null!=n.model_config&&(n=n.model_config);const r=en(In(n),t);if(null!=e.weightsManifest){const t=await c.io.loadWeights(e.weightsManifest,e.pathPrefix,r.weights.map((e=>e.originalName))),n={};for(const e of r.weights)n[e.originalName]=t[e.originalName];r.loadWeights(n),(0,c.B90)(t)}return r}Kn.className="Functional",c.m7h.registerClass(Kn);class Jn extends Yn{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:z("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new d(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof Jn||e instanceof Yn;let n;if(t){if(n=e,1!==n.outputs.length)throw new d("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new d("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new d("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=at({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new d(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new d("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=it(this.outputs[0])}this.inboundNodes=[],new tt({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:g(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(qe(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Yn({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new h("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new h("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new h("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new h("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let i,s={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new d("Legacy serialization format not supported yet.");i=t}else c.D5U.assert(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),i=t.layers,delete t.layers,s=t;const a=new e(s);if(!(a instanceof Jn))throw new p(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const e of i){const t=en(e,void 0,r);r&&t.setFastWeightInitDuringBuild(!0),a.add(t)}return a}set stopTraining(e){if(null==this.model)throw new d("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new d("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}function Qn(e){return new Yn(e)}function er(e){return new Jn(e)}function tr(e,t){return null==t&&(t={}),async function(e,t){if(null==t&&(t={}),"string"==typeof e){const n=c.io.getLoadHandlers(e,t);if(0===n.length)n.push(c.io.browserHTTPRequest(e,t));else if(n.length>1)throw new d(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return async function(e,t,n){if(null==n&&(n={}),null==e.load)throw new d("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await e.load();let i=r.modelTopology;null!=i.model_config&&(i=i.model_config);const s=null==n.strict||n.strict,a=null!=r.weightData&&null!=r.weightSpecs&&s,o=en(In(i),void 0,a),l=r.trainingConfig;if(null!=l&&o.loadTrainingConfig(l),null!=r.userDefinedMetadata&&o.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new d("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:e,optimizerWeights:t}=function(e,t){const n=c.io.decodeWeights(e,t),r={},i=[];return t.forEach((e=>{"optimizer"===e.group?i.push({name:e.name,tensor:n[e.name]}):r[e.name]=n[e.name]})),{modelWeights:r,optimizerWeights:i}}(r.weightData,r.weightSpecs);o.loadWeights(e,s),null!=o.optimizer&&t.length>0&&await o.optimizer.setWeights(t),(0,c.B90)(e),(0,c.B90)(t.map((e=>e.tensor)))}return o}(e,0,t)}(e,t)}function nr(e){return at(e)}function rr(e,t){Jt.registerCallbackConstructor(e,t)}Jn.className="Sequential",c.m7h.registerClass(Jn);class ir extends c.m7h.Serializable{getConfig(){return{}}}class sr extends ir{apply(e,t=1){return function(e,t=1){if(1!==t)throw new p(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return c.pyx(e)}(e,t)}}sr.className="elu",c.m7h.registerClass(sr);class ar extends ir{apply(e){return c.U8D(e)}}ar.className="selu",c.m7h.registerClass(ar);class or extends ir{apply(e){return c.UYe(e)}}or.className="relu",c.m7h.registerClass(or);class lr extends ir{apply(e){return(0,c.lub)((()=>c.LTh(6,c.UYe(e))))}}lr.className="relu6",c.m7h.registerClass(lr);class cr extends ir{apply(e){return e}}cr.className="linear",c.m7h.registerClass(cr);class ur extends ir{apply(e){return c.XD2(e)}}ur.className="sigmoid",c.m7h.registerClass(ur);class hr extends ir{apply(e){return function(e){return(0,c.lub)((()=>{const t=c.IHx(.5,c.dC7(.2,e));return c.iUl(t,0,1)}))}(e)}}hr.className="hardSigmoid",c.m7h.registerClass(hr);class dr extends ir{apply(e){return c.Wvh(e)}}dr.className="softplus",c.m7h.registerClass(dr);class pr extends ir{apply(e){return function(e){return(0,c.lub)((()=>c.hiC(e,c.IHx(c.WnP(e),1))))}(e)}}pr.className="softsign",c.m7h.registerClass(pr);class fr extends ir{apply(e){return c.AEp(e)}}fr.className="tanh",c.m7h.registerClass(fr);class mr extends ir{apply(e,t=-1){return c.XAC(e,t)}}mr.className="softmax",c.m7h.registerClass(mr);class gr extends ir{apply(e,t=-1){return c.CmS(e,t)}}gr.className="logSoftmax",c.m7h.registerClass(gr);class yr extends ir{apply(e,t=1){return(0,c.lub)((()=>c.dC7(c.XD2(c.dC7(e,t)),e)))}}yr.className="swish",c.m7h.registerClass(yr);class vr extends ir{apply(e){return(0,c.lub)((()=>c.dC7(e,c.AEp(c.Wvh(e)))))}}function xr(e){return e.getClassName()}function br(e,t={}){return E(e,c.m7h.SerializationMap.getMap().classNameMap,t,"activation")}function wr(e){if(null==e){return br({className:"linear",config:{}})}if("string"==typeof e){const t={};return t.className=e,t.config={},br(t)}return e instanceof ir?e:br(e)}function _r(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}vr.className="mish",c.m7h.registerClass(vr);class Sr extends c.m7h.Serializable{}class Mr extends Sr{constructor(e){super(),_r(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return(0,c.lub)((()=>{let t=(0,c.lls)([1]);return this.hasL1&&(t=(0,c.IHx)(t,(0,c.Smz)(c.dC7(this.l1,(0,c.WnP)(e))))),this.hasL2&&(t=(0,c.IHx)(t,(0,c.Smz)(c.dC7(this.l2,ye(e))))),c.XLQ(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}Mr.className="L1L2",c.m7h.registerClass(Mr);const Tr={l1l2:"L1L2"};function Er(e){return M(e)}function Ar(e,t={}){return E(e,c.m7h.SerializationMap.getMap().classNameMap,t,"regularizer")}function Cr(e){return null==e?null:"string"==typeof e?Ar({className:e in Tr?Tr[e]:e,config:{}}):e instanceof Sr?e:Ar(e)}class Ir extends rt{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=je(e);let n=(0,c.UYe)(e);return null!=this.maxValue&&(n=(0,c.iUl)(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}Ir.className="ReLU",c.m7h.registerClass(Ir);class Nr extends rt{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=je(e);return(0,c.hi7)(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}Nr.className="LeakyReLU",c.m7h.registerClass(Nr);class kr extends rt{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=We(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Cr(e.alphaRegularizer),this.alphaConstraint=St(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new d(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=qe(e)).slice(1);if(null!=this.sharedAxes)for(const e of this.sharedAxes)t[e-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let t=1;t<e.length;++t)n[t]=e[t];this.inputSpec=[new Je({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=je(e),(0,c.AL3)(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Ve(this.alphaInitializer),alphaRegularizer:Er(this.alphaRegularizer),alphaConstraint:wt(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}kr.className="PReLU",c.m7h.registerClass(kr);class Rr extends rt{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new p(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=je(e);return(0,c.pyx)(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}Rr.className="ELU",c.m7h.registerClass(Rr);class Dr extends rt{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=je(e);return(0,c.dC7)(n,(0,c.pju)((0,c.pjt)(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}Dr.className="ThresholdedReLU",c.m7h.registerClass(Dr);class Lr extends rt{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new mr).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){const n=je(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function Fr(e,t,n){if("number"==typeof e)return g(e,t);if(e.length!==t)throw new d(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let i=0;i<t;++i){const s=e[i];if((r=s)!==parseInt(r.toString(),10))throw new d(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e;var r}function Pr(e,t,n,r,i=1){if(null==e)return e;let s;return s="same"===n?e:e-(t+(t-1)*(i-1))+1,Math.floor((s+r-1)/r)}function Or(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+ne([n-t,0]);else{if("same"!==r)throw new d(`Unsupport padding mode: ${r}.`);e*=t}return e}function zr(e,t){return(0,c.lub)((()=>(H(t),"channelsFirst"===t?c.p4s(e,[0,2,3,1]):e)))}function Br(e,t){return(0,c.lub)((()=>(H(t),"channelsFirst"===t?c.p4s(e,[0,2,3,4,1]):e)))}function Ur(e,t,n,r=[1,1],i="valid",s,a,o=null){return(0,c.lub)((()=>{if(null==s&&(s="channelsLast"),H(s),3!==e.rank&&4!==e.rank)throw new d(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new d(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=zr(e,s);if("causal"===i)throw new p("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=c.imm.conv2d({x:l,filter:t,strides:r,pad:"same"===i?"same":"valid",dilations:a,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===s&&(l=c.p4s(l,[0,3,1,2])),l}))}Lr.className="Softmax",c.m7h.registerClass(Lr);class $r extends rt{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",$r.verifyArgs(t),this.rank=e,R(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new p(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Fr(t.kernelSize,e,"kernelSize"),this.strides=Fr(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,j(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,H(this.dataFormat),this.activation=wr(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=We(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=St(t.biasConstraint),this.biasRegularizer=Cr(t.biasRegularizer),this.activityRegularizer=Cr(t.activityRegularizer),this.dilationRate=Fr(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new d(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new d(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new d(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(y("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!k(e.kernelSize,"number",1,3))throw new d(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:xr(this.activation),useBias:this.useBias,biasInitializer:Ve(this.biasInitializer),biasRegularizer:Er(this.biasRegularizer),activityRegularizer:Er(this.activityRegularizer),biasConstraint:wt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class Vr extends $r{constructor(e,t){super(e,t),this.kernel=null,Vr.verifyArgs(t),this.filters=t.filters,R(this.filters,"filters"),this.kernelInitializer=We(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=St(t.kernelConstraint),this.kernelRegularizer=Cr(t.kernelRegularizer)}build(e){e=qe(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new d(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return(0,c.lub)((()=>{let t;e=je(e);const n=null==this.bias?null:this.bias.read(),r=L(this.activation.getClassName());if(null!=r&&2===this.rank)t=Ur(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=function(e,t,n,r=1,i="valid",s,a=1){return(0,c.lub)((()=>{if(null==s&&(s="channelsLast"),H(s),3!==e.shape.length)throw new d(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new d(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new d(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===s&&(e=c.p4s(e,[0,2,1])),"causal"===i)throw new p("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=c.PAt(e,t,r,"same"===i?"same":"valid","NWC",a);return null!=n&&(o=xe(o,n)),o}))}(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=Ur(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new p("convolutions greater than 3D are not implemented yet.");t=function(e,t,n,r=[1,1,1],i="valid",s,a){return(0,c.lub)((()=>{if(null==s&&(s="channelsLast"),H(s),4!==e.rank&&5!==e.rank)throw new d(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new d(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=Br(e,s);if("causal"===i)throw new p("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=c.pdZ(o,t,r,"same"===i?"same":"valid","NDHWC",a),null!=n&&(o=xe(o,n)),"channelsFirst"===s&&(o=c.p4s(o,[0,4,1,2,3])),o}))}(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=qe(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let e=0;e<n.length;++e){const r=Pr(n[e],this.kernelSize[e],this.padding,this.strides[e],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[e]);t.push(r)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:Ve(this.kernelInitializer),kernelRegularizer:Er(this.kernelRegularizer),kernelConstraint:wt(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new d(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class Wr extends Vr{constructor(e){super(2,e),Wr.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!k(e.kernelSize,"number",1,2))throw new d(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}Wr.className="Conv2D",c.m7h.registerClass(Wr);class Gr extends Vr{constructor(e){super(3,e),Gr.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new d(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}Gr.className="Conv3D",c.m7h.registerClass(Gr);class Hr extends Wr{constructor(e){if(super(e),this.inputSpec=[new Je({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new d(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=qe(e)).length)throw new d("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new d("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Je({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return c.lub((()=>{let t=je(e);if(4!==t.shape.length)throw new d(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let i,s;"channelsFirst"===this.dataFormat?(i=2,s=3):(i=1,s=2);const a=n[i],o=n[s],l=this.kernelSize[0],u=this.kernelSize[1],h=this.strides[0],p=this.strides[1],f=[r,Or(a,h,l,this.padding),Or(o,p,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=c.p4s(t,[0,2,3,1]));let m=c.bc(t,this.kernel.read(),f,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(m=c.p4s(m,[0,3,1,2])),null!=this.bias&&(m=xe(m,this.bias.read(),this.dataFormat)),null!=this.activation&&(m=this.activation.apply(m)),m}))}computeOutputShape(e){const t=(e=qe(e)).slice();let n,r,i;"channelsFirst"===this.dataFormat?(n=1,r=2,i=3):(n=3,r=1,i=2);const s=this.kernelSize[0],a=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=Or(t[r],o,s,this.padding),t[i]=Or(t[i],l,a,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Hr.className="Conv2DTranspose",c.m7h.registerClass(Hr);class jr extends Gr{constructor(e){if(super(e),this.inputSpec=[new Je({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new d(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=qe(e)).length)throw new d("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new d("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Je({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return c.lub((()=>{let t=je(e);if(5!==t.shape.length)throw new d(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let i,s,a;"channelsFirst"===this.dataFormat?(a=2,i=3,s=4):(a=1,i=2,s=3);const o=n[a],l=n[i],u=n[s],h=this.kernelSize[0],p=this.kernelSize[1],f=this.kernelSize[2],m=this.strides[0],g=this.strides[1],y=this.strides[2],v=[r,Or(o,m,h,this.padding),Or(l,g,p,this.padding),Or(u,y,f,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=c.p4s(t,[0,2,3,4,1]));let x=c.$QV(t,this.kernel.read(),v,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(x=c.p4s(x,[0,4,1,2,3])),null!==this.bias&&(x=xe(x,this.bias.read(),this.dataFormat)),null!==this.activation&&(x=this.activation.apply(x)),x}))}computeOutputShape(e){const t=(e=qe(e)).slice();let n,r,i,s;"channelsFirst"===this.dataFormat?(n=1,r=2,i=3,s=4):(n=4,r=1,i=2,s=3);const a=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],u=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[r]=Or(t[r],c,a,this.padding),t[i]=Or(t[i],u,o,this.padding),t[s]=Or(t[s],h,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}jr.className="Conv3DTranspose",c.m7h.registerClass(jr);class qr extends Vr{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new d("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new d("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new d(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=We(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Cr(t.depthwiseRegularizer),this.depthwiseConstraint=St(t.depthwiseConstraint),this.pointwiseInitializer=We(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Cr(t.pointwiseRegularizer),this.pointwiseConstraint=St(t.pointwiseConstraint)}build(e){if((e=qe(e)).length<this.rank+2)throw new d(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new d(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),i=[];for(let e=0;e<this.rank;++e)i.push(1);i.push(n*this.depthMultiplier,this.filters);const s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new Je({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return(0,c.lub)((()=>{let t;if(e=je(e),1===this.rank)throw new p("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=c.p4s(e,[0,2,3,1])),t=c.U_I(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=xe(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=c.p4s(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Ve(this.depthwiseInitializer),e.pointwiseInitializer=Ve(this.pointwiseInitializer),e.depthwiseRegularizer=Er(this.depthwiseRegularizer),e.pointwiseRegularizer=Er(this.pointwiseRegularizer),e.depthwiseConstraint=wt(this.depthwiseConstraint),e.pointwiseConstraint=wt(this.pointwiseConstraint),e}}qr.className="SeparableConv";class Xr extends qr{constructor(e){super(2,e)}}Xr.className="SeparableConv2D",c.m7h.registerClass(Xr);class Yr extends Vr{constructor(e){super(1,e),Yr.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!k(e.kernelSize,"number",1,1))throw new d(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}Yr.className="Conv1D",c.m7h.registerClass(Yr);class Kr extends rt{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return(0,c.lub)((()=>{if(e=je(e),"channelsLast"===this.dataFormat){const t=ue(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return ue(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=ue(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return ue(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}Kr.className="Cropping2D",c.m7h.registerClass(Kr);class Zr extends rt{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,H(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,N(U,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return c.lub((()=>{let t=je(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=c.p4s(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],i="nearest"===this.interpolation?c.BHj.resizeNearestNeighbor(t,[e,r]):c.BHj.resizeBilinear(t,[e,r]);return c.p4s(i,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?c.BHj.resizeNearestNeighbor(t,[e,r]):c.BHj.resizeBilinear(t,[e,r])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}Zr.className="UpSampling2D",c.m7h.registerClass(Zr);class Jr extends $r{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=We(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=St(e.depthwiseConstraint),this.depthwiseRegularizer=Cr(e.depthwiseRegularizer)}build(e){if((e=qe(e)).length<4)throw new d(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new d(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return(0,c.lub)((()=>{let t=function(e,t,n=[1,1],r="valid",i,s){return(0,c.lub)((()=>{null==i&&(i="channelsLast"),H(i);let a=zr(e,i);if(4!==e.rank)throw new d(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new d(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return a=c.B10(a,t,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===i&&(a=c.p4s(a,[0,3,1,2])),a}))}(e=je(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=xe(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=qe(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=Pr(t,this.kernelSize[0],this.padding,this.strides[0]),s=Pr(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,i,s]:[e[0],i,s,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Ve(this.depthwiseInitializer),e.depthwiseRegularizer=Er(this.depthwiseRegularizer),e.depthwiseConstraint=wt(this.depthwiseRegularizer),e}}function Qr(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new d("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function i(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=i(t),constants:n=i(n)}}function ei(e,t,n,r=!1,i,s,a=!1,o=!1){return c.lub((()=>{const l=t.shape.length;if(l<3)throw new d(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(re(2,l));if(t=c.p4s(t,u),null!=s)throw new p("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=i&&((i=c.pju(c.pju(i,"bool"),"float32")).rank===l-1&&(i=c.dt4(i,-1)),i=c.p4s(i,u)),r&&(t=c.GYS(t,0),null!=i&&(i=c.GYS(i,0)));const h=[];let f,m=n;const g=t.shape[0],y=c.HHK(t);let v,x;null!=i&&(v=c.HHK(i));for(let t=0;t<g;++t){const n=y[t],r=c.lub((()=>e(n,m)));if(null==i)f=r[0],m=r[1];else{const e=c.lub((()=>{const e=v[t],n=c.luU(c.JpU(e),e);return{output:c.IHx(c.dC7(r[0],e),c.dC7(m[0],n)),newStates:m.map(((t,i)=>c.IHx(c.dC7(r[1][i],e),c.dC7(t,n))))}}));f=e.output,m=e.newStates}o&&h.push(f)}if(o){const e=1;x=c.knu(h,e)}return[f,x,m]}))}Jr.className="DepthwiseConv2D",c.m7h.registerClass(Jr);class ti extends rt{constructor(e){let t;if(super(e),null==e.cell)throw new d("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new ci({cells:e.cell}):e.cell,null==t.stateSize)throw new d("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new Je({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?re(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null)):this.states_}setStates(e){this.states_=e}computeOutputShape(e){Ge(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return c.lub((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new p("Constants support is not implemented in RNN yet.");Ge(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new Je({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));let i;if(this.cell.build(r),i=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!c.D5U.arraysEqual(this.stateSpec.map((e=>e.shape[e.shape.length-1])),i))throw new d(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map((e=>new Je({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e,t=!1){(0,c.lub)((()=>{if(!this.stateful)throw new u("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new d("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>c.lls([n,e]))):this.states_=[c.lls([n,this.cell.stateSize])];else if(null==e)c.B90(this.states_),null!=this.keptStates&&(c.B90(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>c.lls([n,e]))):this.states_[0]=c.lls([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new d(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):c.B90(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,s=[n,i];if(!c.D5U.arraysEqual(r.shape,s))throw new d(`State ${t} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>c.CnY(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const i=Qr(e,n,r,this.numConstants);e=i.inputs,n=i.initialState,r=i.constants;let s=[],a=[];if(null!=n){t.initialState=n,s=s.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new Je({shape:e.shape}));a=a.concat(this.stateSpec)}if(null!=r&&(t.constants=r,s=s.concat(r),this.numConstants=r.length),s[0]instanceof Qe){const n=[e].concat(s),r=this.inputSpec.concat(a),i=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=i,o}return super.apply(e,t)}call(e,t){return(0,c.lub)((()=>{const n=null==t?null:t.mask,r=null==t?null:t.training;let i=null==t?null:t.initialState;e=je(e),null==i&&(i=this.stateful?this.states_:this.getInitialState(e));const s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==s)throw new d(`RNN Layer has ${s} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:r},o=ei(((e,t)=>{const n=this.cell.call([e].concat(t),a);return[n[0],n.slice(1)]}),e,i,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],c=o[1],u=o[2];this.stateful&&this.resetStates(u,r);const h=this.returnSequences?c:l;return this.returnState?[h].concat(u):h}))}getInitialState(e){return(0,c.lub)((()=>{let t=c.lls(e.shape);return t=c.Smz(t,[1,2]),t=oe(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?pe(t,[1,e]):t)):this.cell.stateSize>1?[pe(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===ti.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,e,t)}static fromConfig(e,t,n={}){const r=en(t.cell,n);return new e(Object.assign(t,{cell:r}))}}ti.className="RNN",c.m7h.registerClass(ti);class ni extends rt{}class ri extends ni{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,R(this.units,"units"),this.activation=wr(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=We(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=We(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=We(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Cr(e.kernelRegularizer),this.recurrentRegularizer=Cr(e.recurrentRegularizer),this.biasRegularizer=Cr(e.biasRegularizer),this.kernelConstraint=St(e.kernelConstraint),this.recurrentConstraint=St(e.recurrentConstraint),this.biasConstraint=St(e.biasConstraint),this.dropout=te([1,ne([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=te([1,ne([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=qe(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return(0,c.lub)((()=>{if(2!==e.length)throw new d(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const r=null!=t.training&&t.training;let i;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ui({ones:()=>c.JpU(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ui({ones:()=>c.JpU(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,a=this.recurrentDropoutMask;i=me(null!=s?c.dC7(e,s):e,this.kernel.read()),null!=this.bias&&(i=xe(i,this.bias.read())),null!=a&&(n=c.dC7(n,a));let o=c.IHx(i,me(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:xr(this.activation),useBias:this.useBias,kernelInitializer:Ve(this.kernelInitializer),recurrentInitializer:Ve(this.recurrentInitializer),biasInitializer:Ve(this.biasInitializer),kernelRegularizer:Er(this.kernelRegularizer),recurrentRegularizer:Er(this.recurrentRegularizer),biasRegularizer:Er(this.biasRegularizer),activityRegularizer:Er(this.activityRegularizer),kernelConstraint:wt(this.kernelConstraint),recurrentConstraint:wt(this.recurrentConstraint),biasConstraint:wt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},e,t)}}ri.className="SimpleRNNCell",c.m7h.registerClass(ri);class ii extends ti{constructor(e){e.cell=new ri(e),super(e)}call(e,t){return(0,c.lub)((()=>{null!=this.cell.dropoutMask&&(c.B90(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(c.B90(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,i=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:i})}))}static fromConfig(e,t){return new e(t)}}ii.className="SimpleRNN",c.m7h.registerClass(ii);class si extends ni{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new d("GRUCell does not support reset_after parameter set to true.");this.units=e.units,R(this.units,"units"),this.activation=wr(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=wr(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=We(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=We(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=We(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Cr(e.kernelRegularizer),this.recurrentRegularizer=Cr(e.recurrentRegularizer),this.biasRegularizer=Cr(e.biasRegularizer),this.kernelConstraint=St(e.kernelConstraint),this.recurrentConstraint=St(e.recurrentConstraint),this.biasConstraint=St(e.biasConstraint),this.dropout=te([1,ne([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=te([1,ne([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=qe(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return(0,c.lub)((()=>{if(2!==e.length)throw new d(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ui({ones:()=>c.JpU(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ui({ones:()=>c.JpU(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,s=this.recurrentDropoutMask;let a,o,l;0<this.dropout&&this.dropout<1&&(e=c.dC7(e,i[0]));let u=me(e,this.kernel.read());this.useBias&&(u=xe(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=c.dC7(r,s[0]));const h=this.recurrentKernel.read(),[p,f]=c.Vl2(h,[2*this.units,this.units],h.rank-1),m=me(r,p),[g,y,v]=c.Vl2(u,3,u.rank-1),[x,b]=c.Vl2(m,2,m.rank-1);a=this.recurrentActivation.apply(c.IHx(g,x)),o=this.recurrentActivation.apply(c.IHx(y,b));const w=me(c.dC7(o,r),f);l=this.activation.apply(c.IHx(v,w));const _=c.IHx(c.dC7(a,r),c.dC7(c.IHx(1,c.W76(a)),l));return[_,_]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:xr(this.activation),recurrentActivation:xr(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ve(this.kernelInitializer),recurrentInitializer:Ve(this.recurrentInitializer),biasInitializer:Ve(this.biasInitializer),kernelRegularizer:Er(this.kernelRegularizer),recurrentRegularizer:Er(this.recurrentRegularizer),biasRegularizer:Er(this.biasRegularizer),activityRegularizer:Er(this.activityRegularizer),kernelConstraint:wt(this.kernelConstraint),recurrentConstraint:wt(this.recurrentConstraint),biasConstraint:wt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},e,t)}}si.className="GRUCell",c.m7h.registerClass(si);class ai extends ti{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new si(e),super(e)}call(e,t){return(0,c.lub)((()=>{null!=this.cell.dropoutMask&&(c.B90(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(c.B90(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,i=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:i})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}ai.className="GRU",c.m7h.registerClass(ai);class oi extends ni{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,R(this.units,"units"),this.activation=wr(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=wr(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=We(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=We(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=We(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Cr(e.kernelRegularizer),this.recurrentRegularizer=Cr(e.recurrentRegularizer),this.biasRegularizer=Cr(e.biasRegularizer),this.kernelConstraint=St(e.kernelConstraint),this.recurrentConstraint=St(e.recurrentConstraint),this.biasConstraint=St(e.biasConstraint),this.dropout=te([1,ne([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=te([1,ne([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=qe(e))[e.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;r=new((t=class extends Me{apply(t,r){const i=e.apply([n]),s=(new Ee).apply([n]),a=e.apply([2*n]);return de(de(i,s),a)}}).className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return(0,c.lub)((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new d(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ui({ones:()=>c.JpU(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ui({ones:()=>c.JpU(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,a=this.recurrentDropoutMask;let o,l,u,h;0<this.dropout&&this.dropout<1&&(e=c.dC7(e,s[0]));let p=me(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=c.dC7(r,a[0])),p=c.IHx(p,me(r,this.recurrentKernel.read())),this.useBias&&(p=xe(p,this.bias.read()));const[f,m,g,y]=c.Vl2(p,4,p.rank-1);o=this.recurrentActivation.apply(f),l=this.recurrentActivation.apply(m),u=c.IHx(c.dC7(l,i),c.dC7(o,this.activation.apply(g))),h=this.recurrentActivation.apply(y);const v=c.dC7(h,this.activation.apply(u));return[v,v,u]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:xr(this.activation),recurrentActivation:xr(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ve(this.kernelInitializer),recurrentInitializer:Ve(this.recurrentInitializer),biasInitializer:Ve(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Er(this.kernelRegularizer),recurrentRegularizer:Er(this.recurrentRegularizer),biasRegularizer:Er(this.biasRegularizer),activityRegularizer:Er(this.activityRegularizer),kernelConstraint:wt(this.kernelConstraint),recurrentConstraint:wt(this.recurrentConstraint),biasConstraint:wt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},e,t)}}oi.className="LSTMCell",c.m7h.registerClass(oi);class li extends ti{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new oi(e),super(e)}call(e,t){return(0,c.lub)((()=>{null!=this.cell.dropoutMask&&(c.B90(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(c.B90(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,i=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:i})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}li.className="LSTM",c.m7h.registerClass(li);class ci extends ni{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return(0,c.lub)((()=>{let n=e.slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const i=[];let s;for(let a=0;a<this.cells.length;++a){const o=this.cells[a];n=r[a],s=0===a?[e[0]].concat(n):[s[0]].concat(n),s=o.call(s,t),i.push(s.slice(1))}n=[];for(const e of i.slice().reverse())n.push(...e);return[s[0]].concat(n)}))}build(e){let t;Ge(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{Y(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign({},e,t)}static fromConfig(e,t,n={}){const r=[];for(const e of t.cells)r.push(en(e,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return Ke(e)}setWeights(e){const t=[];for(const n of this.cells){const r=n.weights.length,i=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],i[e]])}Ze(t)}}function ui(e){const{ones:t,rate:n,training:r=!1,count:i=1,dropoutFunc:s}=e,a=()=>null!=s?s(t(),n):be(t(),n),o=()=>we(a,t,r);return!i||i<=1?c.CnY(o().clone()):Array(i).fill(void 0).map(o).map((e=>c.CnY(e.clone())))}ci.className="StackedRNNCells",c.m7h.registerClass(ci);class hi extends ti{constructor(e){if(e.unroll)throw new p("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new p("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Je({ndim:5})]}call(e,t){return c.lub((()=>{if(null!=this.cell.dropoutMask&&(c.B90(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(c.B90(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new d("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,r=null==t?null:t.training,i=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:i})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return c.lub((()=>{const{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),i=[r[0],...r.slice(2)],s=c.lls(i);return Array.isArray(t)?Array(t.length).fill(s):[s]}))}resetStates(e,t=!1){c.lub((()=>{if(!this.stateful)throw new u("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),i=[r[0],...r.slice(2)];if(null==n[0])throw new d("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>c.lls(i))):this.states_=[c.lls(i)];else if(null==e)c.B90(this.states_),null!=this.keptStates&&(c.B90(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>c.lls(i))):this.states_[0]=c.lls(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new d(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):c.B90(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=i;if(!c.D5U.arraysEqual(n.shape,r))throw new d(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>c.CnY(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:i,strides:s,dilationRate:a}=this.cell,o="channelsFirst"===t,l=e[o?3:2],c=e[o?4:3],u=Pr(l,r[0],i,s[0],a[0]),h=Pr(c,r[1],i,s[1],a[1]);return[...e.slice(0,2),...o?[n,u,h]:[u,h,n]]}}hi.className="ConvRNN2D";class di extends oi{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:i,dataFormat:s,dilationRate:a}=e;super(Object.assign({},e,{units:t})),this.filters=t,R(this.filters,"filters"),this.kernelSize=Fr(n,2,"kernelSize"),this.kernelSize.forEach((e=>R(e,"kernelSize"))),this.strides=Fr(r||1,2,"strides"),this.strides.forEach((e=>R(e,"strides"))),this.padding=i||"valid",j(this.padding),this.dataFormat=s||"channelsLast",H(this.dataFormat),this.dilationRate=Fr(a||1,2,"dilationRate"),this.dilationRate.forEach((e=>R(e,"dilationRate")))}build(e){var t;e=qe(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new d(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=e[n],i=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new((t=class extends Me{apply(e,t){return he([n.apply([r]),c.iUs([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return c.lub((()=>{if(3!==e.length)throw new d(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,r=e[0],i=e[1],s=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=ui({ones:()=>c.JpU(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,o=(e,t,n)=>t&&t[n]?c.dC7(t[n],e):e;let l=o(r,a,0),u=o(r,a,1),h=o(r,a,2),p=o(r,a,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=ui({ones:()=>c.JpU(i),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const f=this.recurrentDropoutMask;let m=o(i,f,0),g=o(i,f,1),y=o(i,f,2),v=o(i,f,3);const[x,b,w,_]=c.Vl2(this.kernel.read(),4,3),[S,M,T,E]=this.useBias?c.Vl2(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,x,S,this.padding),u=this.inputConv(u,b,M,this.padding),h=this.inputConv(h,w,T,this.padding),p=this.inputConv(p,_,E,this.padding);const[A,C,I,N]=c.Vl2(this.recurrentKernel.read(),4,3);m=this.recurrentConv(m,A),g=this.recurrentConv(g,C),y=this.recurrentConv(y,I),v=this.recurrentConv(v,N);const k=this.recurrentActivation.apply(c.IHx(l,m)),R=this.recurrentActivation.apply(c.IHx(u,g)),D=c.IHx(c.dC7(R,s),c.dC7(k,this.activation.apply(c.IHx(h,y)))),L=c.dC7(this.recurrentActivation.apply(c.IHx(p,v)),this.activation.apply(D));return[L,L,D]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(r=Object.getOwnPropertySymbols(e);i<r.length;i++)t.indexOf(r[i])<0&&Object.prototype.propertyIsEnumerable.call(e,r[i])&&(n[r[i]]=e[r[i]])}return n}(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},n,r)}inputConv(e,t,n,r){const i=c.Tek(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?xe(i,n,this.dataFormat):i}recurrentConv(e,t){return c.Tek(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}di.className="ConvLSTM2DCell",c.m7h.registerClass(di);class pi extends hi{constructor(e){const t=new di(e);super(Object.assign({},e,{cell:t}))}static fromConfig(e,t){return new e(t)}}pi.className="ConvLSTM2D",c.m7h.registerClass(pi);class fi extends rt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let e=0;e<this.noiseShape.length;++e)n.push(null==this.noiseShape[e]?t[e]:this.noiseShape[e]);return n}call(e,t){return(0,c.lub)((()=>{this.invokeCallHook(e,t);const n=je(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,r=this.getNoiseShape(n);return we((()=>be(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}fi.className="Dropout",c.m7h.registerClass(fi);class mi extends fi{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}mi.className="SpatialDropout1D",c.m7h.registerClass(mi);class gi extends rt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,R(this.units,"units"),this.activation=wr(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=We(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=We(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=St(e.kernelConstraint),this.biasConstraint=St(e.biasConstraint),this.kernelRegularizer=Cr(e.kernelRegularizer),this.biasRegularizer=Cr(e.biasRegularizer),this.activityRegularizer=Cr(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=qe(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=qe(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return(0,c.lub)((()=>{this.invokeCallHook(e,t);const n=je(e),r=L(this.activation.getClassName());let i;return null!=r?i=me(n,this.kernel.read(),r,this.bias?this.bias.read():null):(i=me(n,this.kernel.read()),null!=this.bias&&(i=xe(i,this.bias.read())),null!=this.activation&&(i=this.activation.apply(i))),i}))}getConfig(){const e={units:this.units,activation:xr(this.activation),useBias:this.useBias,kernelInitializer:Ve(this.kernelInitializer),biasInitializer:Ve(this.biasInitializer),kernelRegularizer:Er(this.kernelRegularizer),biasRegularizer:Er(this.biasRegularizer),activityRegularizer:Er(this.activityRegularizer),kernelConstraint:wt(this.kernelConstraint),biasConstraint:wt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}gi.className="Dense",c.m7h.registerClass(gi);class yi extends rt{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=qe(e);for(const t of e.slice(1))if(null==t)throw new d(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],ee(e,1)]}call(e,t){return(0,c.lub)((()=>{this.invokeCallHook(e,t);let n=je(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=(0,c.p4s)(n,e)}return function(e){if(e.rank<=1)throw new d(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],ee(e.shape,1)];return c.XLQ(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}yi.className="Flatten",c.m7h.registerClass(yi);class vi extends rt{constructor(e){super(e),this.supportsMasking=!0,this.activation=wr(e.activation)}call(e,t){return(0,c.lub)((()=>{this.invokeCallHook(e,t);const n=je(e);return this.activation.apply(n)}))}getConfig(){const e={activation:xr(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}vi.className="Activation",c.m7h.registerClass(vi);class xi extends rt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return(0,c.lub)((()=>{return e=je(e),t=e,n=this.n,(0,c.lub)((()=>{if(2!==t.shape.length)throw new d(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return pe(oe(t,1),[1,n,1])}));var t,n}))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}xi.className="RepeatVector",c.m7h.registerClass(xi);class bi extends rt{constructor(e){super(e),this.targetShape=e.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let i=1,s=null;for(let e=0;e<r.length;++e){const t=r[e];if(this.isUnknown(t)){if(null!==s)throw new d("Can only specifiy one unknown dimension.");s=e}else i*=t}const a=ee(e);if(null!==s){if(0===i||a%i!=0)throw new d(n);r[s]=a/i}else if(a!==i)throw new d(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return(0,c.lub)((()=>{this.invokeCallHook(e,t);const n=je(e),r=n.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return(0,c.XLQ)(n,i)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}bi.className="Reshape",c.m7h.registerClass(bi);class wi extends rt{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=re(1,e.dims.length+1);if(!c.D5U.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Je({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=qe(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return(0,c.p4s)(je(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}wi.className="Permute",c.m7h.registerClass(wi);class _i extends rt{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=je(e);return(0,c.YjB)((0,c.Quu)(n,this.maskValue),-1)}call(e,t){return(0,c.lub)((()=>{this.invokeCallHook(e,t);const n=je(e),r=(0,c.YjB)((0,c.Quu)(n,this.maskValue),-1,!0);return(0,c.dC7)(n,(0,c.pju)(r,n.dtype))}))}}_i.className="Masking",c.m7h.registerClass(_i);class Si extends rt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(b(e.inputLength))}this.inputDim=e.inputDim,R(this.inputDim,"inputDim"),this.outputDim=e.outputDim,R(this.outputDim,"outputDim"),this.embeddingsInitializer=We(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Cr(e.embeddingsRegularizer),this.activityRegularizer=Cr(e.activityRegularizer),this.embeddingsConstraint=St(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return(0,c.lub)((()=>this.maskZero?(e=je(e),(0,c.Quu)(e,(0,c.P84)(e))):null))}computeOutputShape(e){if(e=qe(e),null==this.inputLength)return[...e,this.outputDim];const t=b(this.inputLength);if(t.length!==e.length-1)throw new d(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){const i=t[r],s=e[r+1];if(null!=i&&null!=s&&i!==s)throw new d(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==i&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return(0,c.lub)((()=>{this.invokeCallHook(e,t);let n=je(e);"int32"!==n.dtype&&(n=ae(n,"int32"));const r=ge(this.embeddings.read(),(0,c.XLQ)(n,[n.size]));return(0,c.XLQ)(r,qe(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Ve(this.embeddingsInitializer),embeddingsRegularizer:Er(this.embeddingsRegularizer),activityRegularizer:Er(this.activityRegularizer),embeddingsConstraint:wt(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}Si.className="Embedding",c.m7h.registerClass(Si);class Mi extends rt{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new p}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const i=e[e.length-t.length+r],s=t[r];if(null==i||null==s||i<0||s<0)n.push(null);else if(1===i)n.push(s);else if(1===s)n.push(i);else{if(i!==s)throw new d("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(i)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[qe(e)]),e.length<2)throw new d(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const n of e)null!=n&&null!==n[0]&&t.push(n[0]);if(t=C(t),t.length>1)throw new d(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let t=1;t<e.length;++t){const r=null==e[t]?null:e[t].slice(1);n=this.computeElementwiseOpOutputShape(n,r)}const r=e.map((e=>e.length));-1===e.indexOf(null)&&1===C(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return(0,c.lub)((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const r=ne(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=oe(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const r of e){const e=r.rank;if(null==e){const e=r.shape,i=e[0],s=e.slice(1).concat([i]);let a=c.XLQ(r,[i].concat(ee(e.slice(1))));a=c.p4s(a,[1,0]),a=c.XLQ(a,s),t.push(a),n=!0}else if(e>1){const i=re(1,e).concat([0]);t.push(c.p4s(r,i)),n=!0}else t.push(r)}let r=this.mergeFunction(t);const i=r.rank;if(n)if(null==i){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=c.XLQ(c.p4s(c.XLQ(r,[-1,t]),[1,0]),n)}else if(i>1){const e=[i-1].concat(re(0,i-1));r=c.p4s(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let n=1;n<e.length;++n){const r=null==e[n]?null:e[n].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let n=[];for(const t of e)null!=t&&null!==t[0]&&n.push(t[0]);return n=C(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return c.lub((()=>{if(null==t)return null;if(!Array.isArray(t))throw new d("`mask` should be an Array");if(!Array.isArray(e))throw new d("`inputs` should be an Array");if(t.length!==e.length)throw new d(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:c.dt4(e,0))))[0];for(let e=1;e<t.length-1;++e)n=c.HvI(n,t[e]);return n}))}}class Ti extends Mi{constructor(e){super(e)}mergeFunction(e){return(0,c.lub)((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=c.IHx(t,e[n]);return t}))}}Ti.className="Add",c.m7h.registerClass(Ti);class Ei extends Mi{constructor(e){super(e)}mergeFunction(e){return(0,c.lub)((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=c.dC7(t,e[n]);return t}))}}Ei.className="Multiply",c.m7h.registerClass(Ei);class Ai extends Mi{constructor(e){super(e)}mergeFunction(e){return(0,c.lub)((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=c.IHx(t,e[n]);return c.dC7(1/e.length,t)}))}}Ai.className="Average",c.m7h.registerClass(Ai);class Ci extends Mi{constructor(e){super(e)}mergeFunction(e){return(0,c.lub)((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=c.gWQ(t,e[n]);return t}))}}Ci.className="Maximum",c.m7h.registerClass(Ci);class Ii extends Mi{constructor(e){super(e)}mergeFunction(e){return(0,c.lub)((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=c.LTh(t,e[n]);return t}))}}Ii.className="Minimum",c.m7h.registerClass(Ii);class Ni extends Mi{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new d("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const n of e)if(null!=n){t=!1;break}if(t)return;const n=[];for(let t=0;t<e.length;++t){const r=e[t].slice();r.splice(this.axis,1);let i=!1;for(const e of n)if(c.D5U.arraysEqual(e,r)){i=!0;break}i||n.push(r)}if(n.length>1)throw new d("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return(0,c.lub)((()=>he(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new d("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const e of t.slice(1)){if(null==n[r]||null==e[r]){n[r]=null;break}n[r]+=e[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new d("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new d("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new d(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return c.lub((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const r=[];for(let n=0;n<e.length;++n)null==t[n]?r.push(c.pju(c.JpU(e[n]),"bool")):t[n].rank<e[n].rank?r.push(c.dt4(t[n],-1)):r.push(t[n]);const i=c.zoF(r,this.axis);return c.$6P(i,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function ki(e,t){for(;e<0;)e+=t;return e}Ni.className="Concatenate",c.m7h.registerClass(Ni);class Ri extends Mi{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){c.D5U.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new p("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new d(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new d(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>ki(t,e[n].shape.length))):[ki(this.axes,n.shape.length),ki(this.axes,r.shape.length)],this.normalize&&(n=tn(n,t[0]),r=tn(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new p("batchDot is not implemented for tensors of 4D or higher rank yet");if(c.D5U.assert(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),c.D5U.assert(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new p("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,i=t.shape.length;null==n&&(n=[r-1,i-2]);const s=n;return c.lub((()=>{let n,a;if(r>i){n=r-i;const e=[];for(let t=0;t<n;++t)e.push(1);t=c.XLQ(t,t.shape.concat(e))}else if(i>r){n=i-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=c.XLQ(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)a=s[0]===s[1]?c.Smz(c.dC7(e,t),s[0]):c.Smz(c.dC7(c.p4s(e,[1,0]),t),s[1]);else{const n=s[0]!==e.shape.length-1,r=s[1]===t.shape.length-1;a=c.OI3(e,t,n,r)}if(n>0){let e;e=r>i?r+i-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);a=c.L9e(a,t)}return 1===a.shape.length&&(a=c.dt4(a,1)),a}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[ki(this.axes,e.length),ki(this.axes,t.length)],n}computeOutputShape(e){c.D5U.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new p("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const i=t.concat(n);return 1===i.length&&i.push(1),i}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}Ri.className="Dot",c.m7h.registerClass(Ri);class Di extends rt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return(0,c.lub)((()=>{this.invokeCallHook(e,t);const n=je(e);return we((()=>(0,c.IHx)(fe(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}Di.className="GaussianNoise",c.m7h.registerClass(Di);class Li extends rt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return(0,c.lub)((()=>{this.invokeCallHook(e,t);const n=je(e);return this.rate>0&&this.rate<1?we((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return(0,c.dC7)(n,fe(n.shape,1,e))}),(()=>n),t.training||!1):n}))}}Li.className="GaussianDropout",c.m7h.registerClass(Li);class Fi extends rt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||je(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return(0,c.lub)((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),r=()=>{const t=je(e),r=-1.7580993408473766;let i=(0,c.brS)((0,c.LGj)(n),this.rate);i=ae(i,"float32");const s=((1-this.rate)*(1+this.rate*r**2))**-.5,a=-s*r*this.rate,o=(0,c.IHx)((0,c.dC7)(t,i),(0,c.dC7)((0,c.IHx)(i,-1),r));return(0,c.IHx)((0,c.dC7)(o,s),a)};return we(r,(()=>je(e)),t.training||!1)}return e}))}}function Pi(e,t,n,r,i,s=.001){let a;if(2===e.rank)a=c.Dxk(e,t,n,r,i,s);else if(3===e.rank)a=c.JY5(e,t,n,r,i,s);else{if(4!==e.rank)throw new p(`batchNormalization is not implemented for array of rank ${e.rank} yet`);a=c.p3b(e,t,n,r,i,s)}return a}Fi.className="AlphaDropout",c.m7h.registerClass(Fi);class Oi extends rt{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=We(e.betaInitializer||"zeros"),this.gammaInitializer=We(e.gammaInitializer||"ones"),this.movingMeanInitializer=We(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=We(e.movingVarianceInitializer||"ones"),this.betaConstraint=St(e.betaConstraint),this.gammaConstraint=St(e.gammaConstraint),this.betaRegularizer=Cr(e.betaRegularizer),this.gammaRegularizer=Cr(e.gammaRegularizer)}build(e){e=qe(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new d(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Je({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return(0,c.lub)((()=>{const n=null!=t.training&&t.training,r=je(e),i=r.shape,s=i.length,a=re(0,s),o=this.axis>=0?this.axis:this.axis+s;a.splice(o,1);const l=g(1,s);l[o]=i[o];const u=a.slice();u.sort();const h=!c.D5U.arraysEqual(u,re(0,s).slice(0,s-1));if(!n)return(()=>{if(h){const e=(0,c.XLQ)(this.movingMean.read(),l),t=(0,c.XLQ)(this.movingVariance.read(),l),n=this.center?(0,c.XLQ)(this.beta.read(),l):null,i=this.scale?(0,c.XLQ)(this.gamma.read(),l):null;return Pi(r,e,t,n,i,this.epsilon)}return Pi(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,p,f]=function(e,t,n,r,i=.001){return c.D5U.arraysEqual(r.slice().sort(),re(0,e.rank-1))?function(e,t,n,r,i=.001){return(0,c.lub)((()=>{const s=c.Gi7(e,r),a=s.mean,o=s.variance;return[Pi(e,a,o,n,t,i),a,o]}))}(e,t,n,r,i):function(e,t,n,r,i=.001){return(0,c.lub)((()=>{const s=c.Gi7(e,r),a=s.mean,o=s.variance,l=[];for(const t of re(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);const u=(0,c.XLQ)(a,l),h=(0,c.XLQ)(o,l),d=null==t?null:(0,c.XLQ)(t,l),p=null==n?null:(0,c.XLQ)(n,l);return[Pi(e,u,h,p,d,i),a,o]}))}(e,t,n,r,i)}(r,this.gamma.read(),this.beta.read(),a,this.epsilon),m=(e,t,n)=>{c.lub((()=>{const r=1-n,i=e.read(),s=c.dC7(c.luU(i,t),r);e.write(c.luU(i,s))}))};return(()=>{m(this.movingMean,p,this.momentum),m(this.movingVariance,f,this.momentum)})(),d}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ve(this.betaInitializer),gammaInitializer:Ve(this.gammaInitializer),movingMeanInitializer:Ve(this.movingMeanInitializer),movingVarianceInitializer:Ve(this.movingVarianceInitializer),betaRegularizer:Er(this.betaRegularizer),gammaRegularizer:Er(this.gammaRegularizer),betaConstraint:wt(this.betaConstraint),gammaConstraint:wt(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}Oi.className="BatchNormalization",c.m7h.registerClass(Oi);class zi extends rt{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=We(e.betaInitializer||"zeros"),this.gammaInitializer=We(e.gammaInitializer||"ones"),this.betaRegularizer=Cr(e.betaRegularizer),this.gammaRegularizer=Cr(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=qe(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let e=0;e<this.axis.length;++e)this.axis[e]<0&&(this.axis[e]+=t);for(const e of this.axis)if(e<0||e>=t)throw new Error(`Invalid axis: ${e}`);if(this.axis.length!==C(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((t=>e[t]));this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,!0):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,!0):this.beta=null,this.built=!0}call(e,t){const n=je(e),r=n.shape,i=r.length;return(0,c.lub)((()=>{let{mean:e,variance:t}=(0,c.Gi7)(n,this.axis,!0);const s=g(1,i);for(const e of this.axis)s[e]=r[e];const a=e=>null!=e&&e.shape.length!==i?c.XLQ(e,s):e;let o=this.scale?a(this.gamma.read()):null,l=this.center?a(this.beta.read()):null;const u=[],h=[];for(let e=0;e<i;++e)-1!==this.axis.indexOf(e)?(u.push(r[e]),h.push(1)):(u.push(1),h.push(r[e]));return e=c.Gg6(e,u),t=c.Gg6(t,u),null!=o&&(o=c.Gg6(o,h)),null!=l&&(l=c.Gg6(l,h)),Pi(n,e,t,l,o,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ve(this.betaInitializer),gammaInitializer:Ve(this.gammaInitializer),betaRegularizer:Er(this.betaRegularizer),gammaRegularizer:Er(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}zi.className="LayerNormalization",c.m7h.registerClass(zi);class Bi extends rt{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new d(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new d(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new d(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Je({ndim:4})]}computeOutputShape(e){let t,n;return e=qe(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return(0,c.lub)((()=>{return t=je(e),n=this.padding,r=this.dataFormat,(0,c.lub)((()=>{if(4!==t.rank)throw new d(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new d("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new d(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let e;return e="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],c.vku(t,e)}));var t,n,r}))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function Ui(e,t,n,r,i,s){return(0,c.lub)((()=>{let a;H(i),q(s),j(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==i&&(i="channelsLast"),null==s&&(s="max"),e=zr(e,i);const o="same"===r?"same":"valid";return a="max"===s?c._sB(e,t,n,o):c.wS1(e,t,n,o),"channelsFirst"===i&&(a=c.p4s(a,[0,3,1,2])),a}))}function $i(e,t,n,r,i,s){return(0,c.lub)((()=>{let a;H(i),q(s),j(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==i&&(i="channelsLast"),null==s&&(s="max"),e=Br(e,i);const o="same"===r?"same":"valid";return a="max"===s?c.YQQ(e,t,n,o):c.uR5(e,t,n,o),"channelsFirst"===i&&(a=c.p4s(a,[0,4,1,2,3])),a}))}Bi.className="ZeroPadding2D",c.m7h.registerClass(Bi);class Vi extends rt{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new d(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(R(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new d(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}R(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,j(this.padding),this.inputSpec=[new Je({ndim:3})]}computeOutputShape(e){const t=Pr((e=qe(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return(0,c.lub)((()=>{this.invokeCallHook(e,t),e=oe(je(e),2);const n=this.poolingFunction(je(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return c.L9e(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class Wi extends Vi{constructor(e){super(e)}poolingFunction(e,t,n,r,i){return H(i),j(r),Ui(e,t,n,r,i,"max")}}Wi.className="MaxPooling1D",c.m7h.registerClass(Wi);class Gi extends Vi{constructor(e){super(e)}poolingFunction(e,t,n,r,i){return H(i),j(r),Ui(e,t,n,r,i,"avg")}}Gi.className="AveragePooling1D",c.m7h.registerClass(Gi);class Hi extends rt{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new d(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];R(this.poolSize,"poolSize"),R(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,H(this.dataFormat),j(this.padding),this.inputSpec=[new Je({ndim:4})]}computeOutputShape(e){e=qe(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=Pr(t,this.poolSize[0],this.padding,this.strides[0]),n=Pr(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return(0,c.lub)((()=>(this.invokeCallHook(e,t),this.poolingFunction(je(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class ji extends Hi{constructor(e){super(e)}poolingFunction(e,t,n,r,i){return H(i),j(r),Ui(e,t,n,r,i,"max")}}ji.className="MaxPooling2D",c.m7h.registerClass(ji);class qi extends Hi{constructor(e){super(e)}poolingFunction(e,t,n,r,i){return H(i),j(r),Ui(e,t,n,r,i,"avg")}}qi.className="AveragePooling2D",c.m7h.registerClass(qi);class Xi extends rt{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new d(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];R(this.poolSize,"poolSize"),R(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,H(this.dataFormat),j(this.padding),this.inputSpec=[new Je({ndim:5})]}computeOutputShape(e){e=qe(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=Pr(t,this.poolSize[0],this.padding,this.strides[0]),n=Pr(n,this.poolSize[1],this.padding,this.strides[1]),r=Pr(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return(0,c.lub)((()=>(this.invokeCallHook(e,t),this.poolingFunction(je(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Yi extends Xi{constructor(e){super(e)}poolingFunction(e,t,n,r,i){return H(i),j(r),$i(e,t,n,r,i,"max")}}Yi.className="MaxPooling3D",c.m7h.registerClass(Yi);class Ki extends Xi{constructor(e){super(e)}poolingFunction(e,t,n,r,i){return H(i),j(r),$i(e,t,n,r,i,"avg")}}Ki.className="AveragePooling3D",c.m7h.registerClass(Ki);class Zi extends rt{constructor(e){super(e),this.inputSpec=[new Je({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new p}}class Ji extends Zi{constructor(e){super(e||{})}call(e,t){return(0,c.lub)((()=>{const t=je(e);return c.J69(t,1)}))}}Ji.className="GlobalAveragePooling1D",c.m7h.registerClass(Ji);class Qi extends Zi{constructor(e){super(e||{})}call(e,t){return(0,c.lub)((()=>{const t=je(e);return c.Fp7(t,1)}))}}Qi.className="GlobalMaxPooling1D",c.m7h.registerClass(Qi);class es extends rt{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,H(this.dataFormat),this.inputSpec=[new Je({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new p}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class ts extends es{call(e,t){return(0,c.lub)((()=>{const t=je(e);return"channelsLast"===this.dataFormat?c.J69(t,[1,2]):c.J69(t,[2,3])}))}}ts.className="GlobalAveragePooling2D",c.m7h.registerClass(ts);class ns extends es{call(e,t){return(0,c.lub)((()=>{const t=je(e);return"channelsLast"===this.dataFormat?c.Fp7(t,[1,2]):c.Fp7(t,[2,3])}))}}ns.className="GlobalMaxPooling2D",c.m7h.registerClass(ns);class rs extends rt{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){const r=en(t.layer,n);delete t.layer;const i={layer:r};return Object.assign(i,t),new e(i)}}class is extends rs{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=qe(e)).length<3)throw new d(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=qe(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return(0,c.lub)((()=>ei(((e,n)=>[je(this.layer.call(e,t)),[]]),e=je(e),[],!1,null,null,!1,!0)[1]))}}is.className="TimeDistributed",c.m7h.registerClass(is);class ss extends rs{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=en(n),t.goBackwards=!0!==t.goBackwards;const r={};var i;if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=en(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,i=this.mergeMode,N(W,"BidirectionalMergeMode",i),e.weights)throw new p("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,i=this.forwardLayer.computeOutputShape(e);return Array.isArray(i)&&Array.isArray(i[0])||(i=[i]),this.returnState?(r=i.slice(1),t=i[0]):t=i[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):x(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const i=Qr(e,n,r,this.numConstants);if(e=i.inputs,n=i.initialState,r=i.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const s=[],a=[];if(null!=n){const e=n.length;if(e%2>0)throw new d("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);const r=n.map((e=>new Je({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),a.push(...r)}if(null!=r)throw new p("Support for constants in Bidirectional layers is not implemented yet.");const o=s[0]instanceof Qe;for(const e of s)if(e instanceof Qe!==o)throw new d("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(s),r=this.inputSpec.concat(a),i=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=i,o}return super.apply(e,t)}call(e,t){return(0,c.lub)((()=>{const n=t.initialState;let r,i,s,a;if(null==n)r=this.forwardLayer.call(e,t),i=this.backwardLayer.call(e,t);else{const s=n.slice(0,n.length/2),a=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:s})),i=this.backwardLayer.call(e,Object.assign(t,{initialState:a}))}return this.returnState&&(Array.isArray(r)&&(s=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=c.GYS(i,1)),"concat"===this.mergeMode?a=he([r,i]):"sum"===this.mergeMode?a=c.IHx(r,i):"ave"===this.mergeMode?a=c.dC7(.5,c.IHx(r,i)):"mul"===this.mergeMode?a=c.dC7(r,i):null==this.mergeMode&&(a=[r,i]),this.returnState?null==this.mergeMode?a.concat(s):[a].concat(s):a}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Y(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),Y(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=en(t.layer);if(delete t.layer,null!=t.numConstants)throw new p("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}}function as(e){return new st(e)}function os(e){return new Rr(e)}function ls(e){return new Ir(e)}function cs(e){return new Nr(e)}function us(e){return new kr(e)}function hs(e){return new Lr(e)}function ds(e){return new Dr(e)}function ps(e){return new Yr(e)}function fs(e){return new Wr(e)}function ms(e){return new Hr(e)}function gs(e){return new Gr(e)}function ys(e){return new jr(e)}function vs(e){return new Xr(e)}function xs(e){return new Kr(e)}function bs(e){return new Zr(e)}function ws(e){return new Jr(e)}function _s(e){return new vi(e)}function Ss(e){return new gi(e)}function Ms(e){return new fi(e)}function Ts(e){return new mi(e)}function Es(e){return new yi(e)}function As(e){return new xi(e)}function Cs(e){return new bi(e)}function Is(e){return new wi(e)}function Ns(e){return new Si(e)}function ks(e){return new Ti(e)}function Rs(e){return new Ai(e)}function Ds(e){return new Ni(e)}function Ls(e){return new Ci(e)}function Fs(e){return new Ii(e)}function Ps(e){return new Ei(e)}function Os(e){return new Ri(e)}function zs(e){return new Oi(e)}function Bs(e){return new zi(e)}function Us(e){return new Bi(e)}function $s(e){return new Gi(e)}function Vs(e){return $s(e)}function Ws(e){return $s(e)}function Gs(e){return new qi(e)}function Hs(e){return Gs(e)}function js(e){return Gs(e)}function qs(e){return new Ki(e)}function Xs(e){return qs(e)}function Ys(e){return qs(e)}function Ks(e){return new Ji(e)}function Zs(e){return new ts(e)}function Js(e){return new Qi(e)}function Qs(e){return new ns(e)}function ea(e){return new Wi(e)}function ta(e){return new ji(e)}function na(e){return new Yi(e)}function ra(e){return new ai(e)}function ia(e){return new si(e)}function sa(e){return new li(e)}function aa(e){return new oi(e)}function oa(e){return new ii(e)}function la(e){return new ri(e)}function ca(e){return new pi(e)}function ua(e){return new di(e)}function ha(e){return new ti(e)}function da(e){return new ci(e)}function pa(e){return new ss(e)}function fa(e){return new is(e)}ss.className="Bidirectional",c.m7h.registerClass(ss);const ma=Js,ga=Qs,ya=ea,va=ta;function xa(e){return new Di(e)}function ba(e){return new Li(e)}function wa(e){return new Fi(e)}function _a(e){return new _i(e)}function Sa(e,t){return dn(e,t)}function Ma(e,t){return gn(e,t)}function Ta(e,t){return yn(e,t)}function Ea(e,t){return pn(e,t)}function Aa(e,t){return vn(e,t)}function Ca(e,t){return mn(e,t)}function Ia(e,t){return function(e,t){return(0,c.lub)((()=>{const n=fn(e,t),r=function(e,t){return(0,c.lub)((()=>c.pju(c.Smz(c.HvI(c.DgJ(e,1),c.DgJ(t,0))),"float32")))}(e,t),i=c.IHx(n,r);return c.pju(c.arb(c.pjt(i,0),c.hiC(n,i),0),"float32")}))}(e,t)}function Na(e,t){return cn(e,t)}function ka(e,t){return rn(e,t)}function Ra(e,t){return sn(e,t)}function Da(e,t){return sn(e,t)}function La(e,t){return sn(e,t)}function Fa(e,t){return nn(e,t)}function Pa(e,t){return nn(e,t)}function Oa(e,t){return nn(e,t)}function za(e){return new Mr(e)}function Ba(e){return _r(t=e),new Mr({l1:null!=t?t.l1:null,l2:0});var t}function Ua(e){return _r(t=e),new Mr({l2:null!=t?t.l2:null,l1:0});var t}class $a extends jt{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof Yn))throw new Error("model must be a LayersModel, not some other Container");this.model=e}}function Va(e,t){return e<t}function Wa(e,t){return e>t}class Ga extends $a{constructor(e){if(super(),null==e&&(e={}),e.restoreBestWeights)throw new p("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),"min"===this.mode?this.monitorFunc=Va:"max"===this.mode||-1!==this.monitor.indexOf("acc")?this.monitorFunc=Wa:this.monitorFunc=Va,this.monitorFunc===Va&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===Va?1/0:-1/0}async onEpochEnd(e,t){await Wt(t);const n=this.getMonitorValue(t);null!=n&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){null==e&&(e={});const t=e[this.monitor];return null==t&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}}const Ha={earlyStopping:function(e){return new Ga(e)}}},6452:(e,t,n)=>{"use strict";n.r(t),n.d(t,{Abs:()=>S.SYM,Acos:()=>S.VGw,Acosh:()=>S.SpW,AdadeltaOptimizer:()=>S.zJI,AdagradOptimizer:()=>S.HeW,AdamOptimizer:()=>S.a4z,AdamaxOptimizer:()=>S.DBS,Add:()=>S.mm_,AddN:()=>S.Xze,All:()=>S.oT6,Any:()=>S.IKK,ArgMax:()=>S.sJF,ArgMin:()=>S.aJk,Asin:()=>S.M2y,Asinh:()=>S.qw7,Atan:()=>S.jMg,Atan2:()=>S.QCc,Atanh:()=>S.Oyi,AvgPool:()=>S.JhU,AvgPool3D:()=>S._k9,AvgPool3DGrad:()=>S.IMb,AvgPoolGrad:()=>S.ROF,BatchMatMul:()=>S.XLW,BatchToSpaceND:()=>S.zws,Bincount:()=>S.zvY,BroadcastArgs:()=>S.eEB,BroadcastTo:()=>S.Ly9,Callback:()=>Ht.AQ,CallbackList:()=>Ht.BO,Cast:()=>S.RFZ,Ceil:()=>S.gJX,ClipByValue:()=>S.xnO,Complex:()=>S.Zz9,ComplexAbs:()=>S.yj2,Concat:()=>S.Eh3,Conv2D:()=>S.mhS,Conv2DBackpropFilter:()=>S.wUP,Conv2DBackpropInput:()=>S.wm,Conv3D:()=>S.x12,Conv3DBackpropFilterV2:()=>S.o2y,Conv3DBackpropInputV2:()=>S.ik2,Cos:()=>S.mc4,Cosh:()=>S.TR1,CropAndResize:()=>S.VcC,Cumprod:()=>S.Byc,Cumsum:()=>S.iHb,CustomCallback:()=>Ht.iT,DataStorage:()=>S.JLz,DenseBincount:()=>S.QRR,DepthToSpace:()=>S.T0n,DepthwiseConv2dNative:()=>S.cie,DepthwiseConv2dNativeBackpropFilter:()=>S.sL$,DepthwiseConv2dNativeBackpropInput:()=>S.y7R,Diag:()=>S.$w,Dilation2D:()=>S.p4S,Dilation2DBackpropFilter:()=>S.Vn9,Dilation2DBackpropInput:()=>S.ekb,ENV:()=>S.ViN,EarlyStopping:()=>Ht.pV,Einsum:()=>S.$g6,Elu:()=>S.SX0,EluGrad:()=>S.HEU,Environment:()=>S.qAh,Equal:()=>S.hdR,Erf:()=>S.Omj,Exp:()=>S.NEP,ExpandDims:()=>S.YFo,Expm1:()=>S.Y0y,FFT:()=>S.vwp,Fill:()=>S.deh,FlipLeftRight:()=>S.Uyb,Floor:()=>S.OR,FloorDiv:()=>S.jeX,FromPixels:()=>S.eBW,FusedBatchNorm:()=>S.sHE,FusedConv2D:()=>S._V0,FusedDepthwiseConv2D:()=>S.luS,GatherNd:()=>S.q1x,GatherV2:()=>S.qi_,GraphModel:()=>Pr,Greater:()=>S.iZT,GreaterEqual:()=>S.Acj,History:()=>Ht.Ay,IFFT:()=>S.Qg5,Identity:()=>S.iJz,Imag:()=>S.J_u,InputSpec:()=>Ht.Zg,IsFinite:()=>S.avt,IsInf:()=>S.iWB,IsNan:()=>S.r7n,KernelBackend:()=>S.Zuw,LRN:()=>S.eZ0,LRNGrad:()=>S.Hhh,LayerVariable:()=>Ht.fU,LayersModel:()=>Ht.QV,LeakyRelu:()=>S.J$2,Less:()=>S.vtC,LessEqual:()=>S.CAk,LinSpace:()=>S.e7N,Log:()=>S.ZbH,Log1p:()=>S.kU,LogSoftmax:()=>S.qCd,LogicalAnd:()=>S.PYm,LogicalNot:()=>S.VfG,LogicalOr:()=>S.MZg,LowerBound:()=>S.qIC,Max:()=>S.YoZ,MaxPool:()=>S.mTV,MaxPool3D:()=>S.OAf,MaxPool3DGrad:()=>S.OU7,MaxPoolGrad:()=>S.OV7,MaxPoolWithArgmax:()=>S.vFR,Maximum:()=>S.BMI,Mean:()=>S.q2K,Min:()=>S.c17,Minimum:()=>S.q8u,MirrorPad:()=>S.jQs,Mod:()=>S.Vbg,MomentumOptimizer:()=>S.rIn,Multinomial:()=>S.NZg,Multiply:()=>S.wYn,Neg:()=>S.kuV,NonMaxSuppressionV3:()=>S.uv1,NonMaxSuppressionV4:()=>S.cye,NonMaxSuppressionV5:()=>S.W0H,NotEqual:()=>S.yQU,OP_SCOPE_SUFFIX:()=>S.zvA,OneHot:()=>S.we_,OnesLike:()=>S.qWM,Optimizer:()=>S.gaJ,OptimizerConstructors:()=>S.eEe,Pack:()=>S.QiL,PadV2:()=>S.lyA,Pool:()=>S.Kgp,Pow:()=>S.pe_,Prelu:()=>S.o0g,Prod:()=>S.DlI,RMSPropOptimizer:()=>S.gVI,RNN:()=>Ht.$p,Range:()=>S.e6w,Rank:()=>S.yw1,Real:()=>S.xJR,RealDiv:()=>S.oHH,Reciprocal:()=>S.$HU,Reduction:()=>S.IH3,Relu:()=>S.qkr,Relu6:()=>S.SbG,Reshape:()=>S.HZH,ResizeBilinear:()=>S._Yw,ResizeBilinearGrad:()=>S.zbQ,ResizeNearestNeighbor:()=>S.dpD,ResizeNearestNeighborGrad:()=>S.Hmb,Reverse:()=>S.mKl,RotateWithOffset:()=>S.b9H,Round:()=>S.e07,Rsqrt:()=>S.bV0,SGDOptimizer:()=>S.DYp,ScatterNd:()=>S.xQA,SearchSorted:()=>S.nr8,Select:()=>S.PhF,Selu:()=>S.oFR,Sequential:()=>Ht.sb,Sigmoid:()=>S.a5O,Sign:()=>S.i5y,Sin:()=>S.RQH,Sinh:()=>S.wYB,Slice:()=>S.p2w,Softmax:()=>S.Gcp,Softplus:()=>S.MRv,SpaceToBatchND:()=>S.TQc,SparseFillEmptyRows:()=>S.O3z,SparseReshape:()=>S.nhH,SparseSegmentMean:()=>S.w3H,SparseSegmentSum:()=>S.ZjV,SparseToDense:()=>S.D2d,SplitV:()=>S.L8s,Sqrt:()=>S.FKq,Square:()=>S.bK0,SquaredDifference:()=>S._tC,Step:()=>S.h8e,StridedSlice:()=>S.jQk,StringNGrams:()=>S._JP,StringSplit:()=>S.s1s,StringToHashBucketFast:()=>S.XkS,Sub:()=>S.Tr8,Sum:()=>S.GBy,SymbolicTensor:()=>Ht.Iy,Tan:()=>S.sEM,Tanh:()=>S.MIZ,Tensor:()=>S.esB,TensorBuffer:()=>S.YDk,Tile:()=>S.n9L,TopK:()=>S.cWu,Transform:()=>S.wx7,Transpose:()=>S.G3Y,Unique:()=>S.kpP,Unpack:()=>S.ToN,UnsortedSegmentSum:()=>S.Qvg,UpperBound:()=>S.XDQ,Variable:()=>S._wD,ZerosLike:()=>S.RuY,_FusedMatMul:()=>S.usg,abs:()=>S.WnP,acos:()=>S.Khb,acosh:()=>S.__u,add:()=>S.IHx,addN:()=>S.QBD,all:()=>S.$6P,any:()=>S.YjB,argMax:()=>S.NqF,argMin:()=>S.vHJ,asin:()=>S.ZRM,asinh:()=>S.VfV,atan:()=>S.z4N,atan2:()=>S.fvJ,atanh:()=>S.C80,avgPool:()=>S.wS1,avgPool3d:()=>S.uR5,backend:()=>S.y3$,backend_util:()=>S.Wap,basicLSTMCell:()=>S.zEQ,batchNorm:()=>S.tgs,batchNorm2d:()=>S.Dxk,batchNorm3d:()=>S.JY5,batchNorm4d:()=>S.p3b,batchToSpaceND:()=>S.E4h,bincount:()=>S.yE8,booleanMaskAsync:()=>S.anm,broadcastArgs:()=>S.XsQ,broadcastTo:()=>S.UFq,broadcast_util:()=>S.Jyw,browser:()=>S.Xhn,buffer:()=>S.f3b,callbacks:()=>Ht.ZC,cast:()=>S.pju,ceil:()=>S.mDi,clipByValue:()=>S.iUl,clone:()=>S.d9v,complex:()=>S.PYB,concat:()=>S.zoF,concat1d:()=>S.gME,concat2d:()=>S.Izb,concat3d:()=>S.MNy,concat4d:()=>S.ZaL,constraints:()=>Ht.Cb,conv1d:()=>S.PAt,conv2d:()=>S.Tek,conv2dTranspose:()=>S.bc,conv3d:()=>S.pdZ,conv3dTranspose:()=>S.$QV,copyRegisteredKernels:()=>S.T3b,cos:()=>S.mCk,cosh:()=>S.f9Y,cosineWindow:()=>S.mew,cumprod:()=>S.$Gn,cumsum:()=>S.zbp,customGrad:()=>S.cbc,data:()=>Ur,denseBincount:()=>S.ppE,deprecationWarn:()=>S.MXe,depthToSpace:()=>S.nTT,depthwiseConv2d:()=>S.B10,deregisterOp:()=>Yt,device_util:()=>S.C2$,diag:()=>S.Ka3,dilation2d:()=>S.WmZ,disableDeprecationWarnings:()=>S.cFr,dispose:()=>S.B90,disposeVariables:()=>S.N8o,div:()=>S.hiC,divNoNan:()=>S.NTj,dot:()=>S.AKD,dropout:()=>S.rvX,einsum:()=>S.WYO,elu:()=>S.pyx,enableDebugMode:()=>S.Ra$,enableProdMode:()=>S.G48,enclosingPowerOfTwo:()=>S.GRh,engine:()=>S.SRH,env:()=>S.OBj,equal:()=>S.DgJ,erf:()=>S.qNN,euclideanNorm:()=>S.d2q,exp:()=>S.Qqt,expandDims:()=>S.dt4,expm1:()=>S.t$B,eye:()=>S.iyy,fft:()=>S.kp_,fill:()=>S.hlL,findBackend:()=>S.x3e,findBackendFactory:()=>S.zel,floor:()=>S.GWj,floorDiv:()=>S.qPi,fused:()=>S.imm,gather:()=>S.Iqj,gatherND:()=>S.dbB,gather_util:()=>S.DaI,getBackend:()=>S.N_N,getGradient:()=>S.ukX,getKernel:()=>S.pIF,getKernelsForBackend:()=>S.trD,grad:()=>S.UQy,grads:()=>S.tiA,greater:()=>S.pjt,greaterEqual:()=>S.brS,ifft:()=>S.Sxn,imag:()=>S.asL,image:()=>S.BHj,inTopKAsync:()=>S.V3u,initializers:()=>Ht.t1,input:()=>Ht.qH,io:()=>S.io,irfft:()=>S.wx0,isFinite:()=>S.xVT,isInf:()=>S.UWc,isNaN:()=>S.i2d,keep:()=>S.CnY,kernel_impls:()=>S.GDt,layers:()=>Ht.ug,leakyRelu:()=>S.hi7,less:()=>S.d9m,lessEqual:()=>S.zN1,linalg:()=>S.$r2,linspace:()=>S.SX3,loadGraphModel:()=>Or,loadGraphModelSync:()=>zr,loadLayersModel:()=>Ht.FB,localResponseNormalization:()=>S.G9k,log:()=>S.cM7,log1p:()=>S.Krr,logSigmoid:()=>S.e_t,logSoftmax:()=>S.CmS,logSumExp:()=>S.l_t,logicalAnd:()=>S.HvI,logicalNot:()=>S.hJK,logicalOr:()=>S.K5V,logicalXor:()=>S.egP,losses:()=>S.MB5,lowerBound:()=>S.eab,matMul:()=>S.OI3,math:()=>S.mAU,max:()=>S.Fp7,maxPool:()=>S._sB,maxPool3d:()=>S.YQQ,maxPoolWithArgmax:()=>S.Ip$,maximum:()=>S.gWQ,mean:()=>S.J69,memory:()=>S.sq6,meshgrid:()=>S.ry_,metrics:()=>Ht.qI,min:()=>S.VV$,minimum:()=>S.LTh,mirrorPad:()=>S.VdP,mod:()=>S.wQq,model:()=>Ht.o4,models:()=>Ht.Cq,moments:()=>S.Gi7,movingAverage:()=>S.p_,mul:()=>S.dC7,multiRNNCell:()=>S.rq4,multinomial:()=>S.SJ_,neg:()=>S.W76,nextFrame:()=>S.glt,norm:()=>S.KOy,notEqual:()=>S.Quu,oneHot:()=>S.lfX,ones:()=>S.iUs,onesLike:()=>S.JpU,op:()=>S.op,outerProduct:()=>S.N2O,pad:()=>S.vku,pad1d:()=>S.pNR,pad2d:()=>S.koy,pad3d:()=>S.t1L,pad4d:()=>S.lGY,pool:()=>S.d_R,pow:()=>S.sQ3,prelu:()=>S.AL3,print:()=>S.S0v,prod:()=>S.WVs,profile:()=>S.N5s,rand:()=>S.TN_,randomGamma:()=>S.wzB,randomNormal:()=>S.nGf,randomUniform:()=>S.LGj,range:()=>S.w6H,ready:()=>S.Cd_,real:()=>S.kwC,reciprocal:()=>S.M25,registerBackend:()=>S.jqO,registerCallbackConstructor:()=>Ht.gl,registerGradient:()=>S.LiG,registerKernel:()=>S.wCN,registerOp:()=>qt,regularizers:()=>Ht.zQ,relu:()=>S.UYe,relu6:()=>S.btT,removeBackend:()=>S.cjG,reshape:()=>S.XLQ,reverse:()=>S.GYS,reverse1d:()=>S.SDf,reverse2d:()=>S.diP,reverse3d:()=>S.sx7,reverse4d:()=>S.mG2,rfft:()=>S.QEs,round:()=>S.NMM,rsqrt:()=>S.bp0,scalar:()=>S.iD$,scatterND:()=>S.snQ,scatter_util:()=>S.yV1,searchSorted:()=>S.zcT,selu:()=>S.U8D,separableConv2d:()=>S.U_I,sequential:()=>Ht.Pe,serialization:()=>S.m7h,setBackend:()=>S.CQI,setPlatform:()=>S.VYu,setdiff1dAsync:()=>S.ODp,sigmoid:()=>S.XD2,sign:()=>S.Xxe,signal:()=>S.tdS,sin:()=>S.O$l,sinh:()=>S.R_K,slice:()=>S.tPi,slice1d:()=>S.jZU,slice2d:()=>S.SmN,slice3d:()=>S.CnO,slice4d:()=>S.p0P,slice_util:()=>S.kuN,softmax:()=>S.XAC,softplus:()=>S.Wvh,spaceToBatchND:()=>S.fBT,sparse:()=>S.rVs,sparseToDense:()=>S.ers,spectral:()=>S.uN7,split:()=>S.Vl2,sqrt:()=>S._b3,square:()=>S.h62,squaredDifference:()=>S.$i,squeeze:()=>S.L9e,stack:()=>S.knu,step:()=>S.Nbs,stridedSlice:()=>S.NXj,string:()=>S.Z_8,sub:()=>S.luU,sum:()=>S.Smz,sumOutType:()=>S.z4k,tan:()=>S.ORZ,tanh:()=>S.AEp,tensor:()=>S.XeE,tensor1d:()=>S.RRF,tensor2d:()=>S.odF,tensor3d:()=>S.wOQ,tensor4d:()=>S.yXz,tensor5d:()=>S.Bfx,tensor6d:()=>S.xZs,tensor_util:()=>S.piX,test_util:()=>S.p3L,tidy:()=>S.lub,tile:()=>S.Gg6,time:()=>S.XVJ,topk:()=>S.hg7,train:()=>S.p_j,transpose:()=>S.p4s,truncatedNormal:()=>S.Xu6,unique:()=>S.Two,unregisterGradient:()=>S.bt3,unregisterKernel:()=>S.nEe,unsortedSegmentSum:()=>S.pUJ,unstack:()=>S.HHK,upcastType:()=>S.x8V,upperBound:()=>S.GaM,util:()=>S.D5U,valueAndGrad:()=>S.h76,valueAndGrads:()=>S.fNQ,variable:()=>S.VD$,variableGrads:()=>S.pnJ,version:()=>Zv,version_converter:()=>Br,version_core:()=>S.jTM,version_layers:()=>Ht.H6,where:()=>S.arb,whereAsync:()=>S.itS,zeros:()=>S.lls,zerosLike:()=>S.P84});var r={};n.r(r),n.d(r,{json:()=>rn});var i={};n.r(i),n.d(i,{json:()=>sn});var s={};n.r(s),n.d(s,{json:()=>an});var a={};n.r(a),n.d(a,{json:()=>on});var o={};n.r(o),n.d(o,{json:()=>ln});var l={};n.r(l),n.d(l,{json:()=>cn});var c={};n.r(c),n.d(c,{json:()=>un});var u={};n.r(u),n.d(u,{json:()=>hn});var h={};n.r(h),n.d(h,{json:()=>dn});var d={};n.r(d),n.d(d,{json:()=>pn});var p={};n.r(p),n.d(p,{json:()=>fn});var f={};n.r(f),n.d(f,{json:()=>mn});var m={};n.r(m),n.d(m,{json:()=>gn});var g={};n.r(g),n.d(g,{json:()=>yn});var y={};n.r(y),n.d(y,{json:()=>vn});var v={};n.r(v),n.d(v,{json:()=>xn});var x={};n.r(x),n.d(x,{json:()=>bn});var b={};n.r(b),n.d(b,{json:()=>wn});var w={};n.r(w),n.d(w,{json:()=>_n});var _={};n.r(_),n.d(_,{addImpl:()=>bi,bincountImpl:()=>ds,bincountReduceImpl:()=>ps,ceilImpl:()=>gs,concatImpl:()=>_s,equalImpl:()=>sa,expImpl:()=>ga,expm1Impl:()=>wa,floorImpl:()=>za,gatherNdImpl:()=>ja,gatherV2Impl:()=>Xa,greaterEqualImpl:()=>Qa,greaterImpl:()=>Ka,lessEqualImpl:()=>po,lessImpl:()=>co,linSpaceImpl:()=>go,logImpl:()=>vo,maxImpl:()=>Do,maximumImpl:()=>Po,minimumImpl:()=>jo,multiplyImpl:()=>Zs,negImpl:()=>rl,notEqualImpl:()=>hl,prodImpl:()=>Ml,rangeImpl:()=>El,rsqrtImpl:()=>zl,scatterImpl:()=>$l,sigmoidImpl:()=>oi,simpleAbsImpl:()=>Ii,sliceImpl:()=>ls,sparseFillEmptyRowsImpl:()=>oc,sparseReshapeImpl:()=>cc,sparseSegmentReductionImpl:()=>hc,sqrtImpl:()=>gc,squaredDifferenceImpl:()=>bc,stridedSliceImpl:()=>Tc,stringNGramsImpl:()=>Cc,stringSplitImpl:()=>kc,stringToHashBucketFastImpl:()=>Dc,subImpl:()=>Aa,tileImpl:()=>Bc,topKImpl:()=>Wc,transposeImpl:()=>Pi,uniqueImpl:()=>Kc});var S=n(1740),M=(n(6190),n(6235)),T=n(4077);(0,T.t3)().prototype.abs=function(){return this.throwIfDisposed(),(0,M.W)(this)};var E=n(7839);(0,T.t3)().prototype.acos=function(){return this.throwIfDisposed(),(0,E.K)(this)};var A=n(1470);(0,T.t3)().prototype.acosh=function(){return this.throwIfDisposed(),(0,A._)(this)};var C=n(6407);(0,T.t3)().prototype.add=function(e){return this.throwIfDisposed(),(0,C.I)(this,e)};var I=n(781);(0,T.t3)().prototype.all=function(e,t){return this.throwIfDisposed(),(0,I.$)(this,e,t)};var N=n(2998);(0,T.t3)().prototype.any=function(e,t){return this.throwIfDisposed(),(0,N.Y)(this,e,t)};var k=n(47);(0,T.t3)().prototype.argMax=function(e){return this.throwIfDisposed(),(0,k.N)(this,e)};var R=n(7394);(0,T.t3)().prototype.argMin=function(e){return this.throwIfDisposed(),(0,R.v)(this,e)};var D=n(4968),L=n(9115);(0,T.t3)().prototype.asScalar=function(){return this.throwIfDisposed(),(0,L.hu)(1===this.size,(()=>"The array must have only 1 element.")),(0,D.X)(this,[])};var F=n(2271);(0,T.t3)().prototype.asType=function(e){return this.throwIfDisposed(),(0,F.p)(this,e)},(0,T.t3)().prototype.as1D=function(){return this.throwIfDisposed(),(0,D.X)(this,[this.size])},(0,T.t3)().prototype.as2D=function(e,t){return this.throwIfDisposed(),(0,D.X)(this,[e,t])},(0,T.t3)().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),(0,D.X)(this,[e,t,n])},(0,T.t3)().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),(0,D.X)(this,[e,t,n,r])},(0,T.t3)().prototype.as5D=function(e,t,n,r,i){return this.throwIfDisposed(),(0,D.X)(this,[e,t,n,r,i])};var P=n(2421);(0,T.t3)().prototype.asin=function(){return this.throwIfDisposed(),(0,P.Z)(this)};var O=n(1891);(0,T.t3)().prototype.asinh=function(){return this.throwIfDisposed(),(0,O.V)(this)};var z=n(7037);(0,T.t3)().prototype.atan=function(){return this.throwIfDisposed(),(0,z.z)(this)};var B=n(9812);(0,T.t3)().prototype.atan2=function(e){return this.throwIfDisposed(),(0,B.f)(this,e)};var U=n(369);(0,T.t3)().prototype.atanh=function(){return this.throwIfDisposed(),(0,U.C)(this)};var $=n(5176);(0,T.t3)().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),(0,$.w)(this,e,t,n,r)};var V=n(8441);(0,T.t3)().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),(0,V.E)(this,e,t)};var W=n(7505);(0,T.t3)().prototype.batchNorm=function(e,t,n,r,i){return this.throwIfDisposed(),(0,W.t)(this,e,t,n,r,i)};var G=n(8247);(0,T.t3)().prototype.broadcastTo=function(e){return this.throwIfDisposed(),(0,G.U)(this,e)},(0,T.t3)().prototype.cast=function(e){return this.throwIfDisposed(),(0,F.p)(this,e)};var H=n(6825);(0,T.t3)().prototype.ceil=function(){return this.throwIfDisposed(),(0,H.m)(this)};var j=n(2279);(0,T.t3)().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),(0,j.i)(this,e,t)};var q=n(6884);(0,T.t3)().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof T.es&&(e=[e]),(0,q.z)([this,...e],t)};var X=n(1355);(0,T.t3)().prototype.conv1d=function(e,t,n,r,i,s){return this.throwIfDisposed(),(0,X.P)(this,e,t,n,r,i,s)};var Y=n(1405);(0,T.t3)().prototype.conv2dTranspose=function(e,t,n,r,i){return this.throwIfDisposed(),(0,Y.b)(this,e,t,n,r,i)};var K=n(4794);(0,T.t3)().prototype.conv2d=function(e,t,n,r,i,s){return this.throwIfDisposed(),(0,K.T)(this,e,t,n,r,i,s)};var Z=n(173);(0,T.t3)().prototype.cos=function(){return this.throwIfDisposed(),(0,Z.m)(this)};var J=n(2699);(0,T.t3)().prototype.cosh=function(){return this.throwIfDisposed(),(0,J.f)(this)};var Q=n(9640);(0,T.t3)().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),(0,Q.$)(this,e,t,n)};var ee=n(7405);(0,T.t3)().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),(0,ee.z)(this,e,t,n)};var te=n(9112);(0,T.t3)().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),(0,te.n)(this,e,t)};var ne=n(4718);(0,T.t3)().prototype.depthwiseConv2d=function(e,t,n,r,i,s){return this.throwIfDisposed(),(0,ne.B)(this,e,t,n,r,i,s)};var re=n(557);(0,T.t3)().prototype.dilation2d=function(e,t,n,r,i){return this.throwIfDisposed(),(0,re.W)(this,e,t,n,r,i)};var ie=n(9322);(0,T.t3)().prototype.divNoNan=function(e){return this.throwIfDisposed(),(0,ie.N)(this,e)};var se=n(1274);(0,T.t3)().prototype.div=function(e){return this.throwIfDisposed(),(0,se.h)(this,e)};var ae=n(548);(0,T.t3)().prototype.dot=function(e){return this.throwIfDisposed(),(0,ae.A)(this,e)};var oe=n(3233);(0,T.t3)().prototype.elu=function(){return this.throwIfDisposed(),(0,oe.p)(this)};var le=n(6477);(0,T.t3)().prototype.equal=function(e){return this.throwIfDisposed(),(0,le.D)(this,e)};var ce=n(4650);(0,T.t3)().prototype.erf=function(){return this.throwIfDisposed(),(0,ce.q)(this)};var ue=n(1954);(0,T.t3)().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),(0,ue.d)(this,e,t)};var he=n(4842);(0,T.t3)().prototype.exp=function(){return this.throwIfDisposed(),(0,he.Q)(this)};var de=n(1300);(0,T.t3)().prototype.expandDims=function(e){return this.throwIfDisposed(),(0,de.d)(this,e)};var pe=n(3426);(0,T.t3)().prototype.expm1=function(){return this.throwIfDisposed(),(0,pe.t)(this)};var fe=n(7020);(0,T.t3)().prototype.fft=function(){return this.throwIfDisposed(),(0,fe.k)(this)},(0,T.t3)().prototype.flatten=function(){return this.throwIfDisposed(),(0,D.X)(this,[this.size])};var me=n(6943);(0,T.t3)().prototype.floor=function(){return this.throwIfDisposed(),(0,me.G)(this)};var ge=n(9165);(0,T.t3)().prototype.floorDiv=function(e){return this.throwIfDisposed(),(0,ge.q)(this,e)};var ye=n(4926);(0,T.t3)().prototype.gather=function(e,t){return this.throwIfDisposed(),(0,ye.I)(this,e,t)};var ve=n(7630);(0,T.t3)().prototype.greaterEqual=function(e){return this.throwIfDisposed(),(0,ve.b)(this,e)};var xe=n(636);(0,T.t3)().prototype.greater=function(e){return this.throwIfDisposed(),(0,xe.p)(this,e)};var be=n(8447);(0,T.t3)().prototype.ifft=function(){return this.throwIfDisposed(),(0,be.S)(this)};var we=n(4415);(0,T.t3)().prototype.irfft=function(){return this.throwIfDisposed(),(0,we.w)(this)};var _e=n(3963);(0,T.t3)().prototype.isFinite=function(){return this.throwIfDisposed(),(0,_e.x)(this)};var Se=n(4365);(0,T.t3)().prototype.isInf=function(){return this.throwIfDisposed(),(0,Se.U)(this)};var Me=n(6230);(0,T.t3)().prototype.isNaN=function(){return this.throwIfDisposed(),(0,Me.i)(this)};var Te=n(9133);(0,T.t3)().prototype.leakyRelu=function(e){return this.throwIfDisposed(),(0,Te.h)(this,e)};var Ee=n(624);(0,T.t3)().prototype.lessEqual=function(e){return this.throwIfDisposed(),(0,Ee.z)(this,e)};var Ae=n(6573);(0,T.t3)().prototype.less=function(e){return this.throwIfDisposed(),(0,Ae.d)(this,e)};var Ce=n(9648);(0,T.t3)().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),(0,Ce.G)(this,e,t,n,r)};var Ie=n(3888);(0,T.t3)().prototype.logSigmoid=function(){return this.throwIfDisposed(),(0,Ie.e)(this)};var Ne=n(1510);(0,T.t3)().prototype.logSoftmax=function(e){return this.throwIfDisposed(),(0,Ne.C)(this,e)};var ke=n(1391);(0,T.t3)().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),(0,ke.l)(this,e,t)};var Re=n(2597);(0,T.t3)().prototype.log=function(){return this.throwIfDisposed(),(0,Re.c)(this)};var De=n(7474);(0,T.t3)().prototype.log1p=function(){return this.throwIfDisposed(),(0,De.K)(this)};var Le=n(2856);(0,T.t3)().prototype.logicalAnd=function(e){return this.throwIfDisposed(),(0,Le.H)(this,e)};var Fe=n(8651);(0,T.t3)().prototype.logicalNot=function(){return this.throwIfDisposed(),(0,Fe.h)(this)};var Pe=n(5750);(0,T.t3)().prototype.logicalOr=function(e){return this.throwIfDisposed(),(0,Pe.K)(this,e)};var Oe=n(596);(0,T.t3)().prototype.logicalXor=function(e){return this.throwIfDisposed(),(0,Oe.e)(this,e)};var ze=n(8687);(0,T.t3)().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),(0,ze.O)(this,e,t,n)};var Be=n(1174);(0,T.t3)().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),(0,Be._)(this,e,t,n,r)};var Ue=n(3307);(0,T.t3)().prototype.max=function(e,t){return this.throwIfDisposed(),(0,Ue.F)(this,e,t)};var $e=n(632);(0,T.t3)().prototype.maximum=function(e){return this.throwIfDisposed(),(0,$e.g)(this,e)};var Ve=n(5130);(0,T.t3)().prototype.mean=function(e,t){return this.throwIfDisposed(),(0,Ve.J)(this,e,t)};var We=n(5735);(0,T.t3)().prototype.min=function(e,t){return this.throwIfDisposed(),(0,We.V)(this,e,t)};var Ge=n(4513);(0,T.t3)().prototype.minimum=function(e){return this.throwIfDisposed(),(0,Ge.L)(this,e)};var He=n(1483);(0,T.t3)().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),(0,He.V)(this,e,t)};var je=n(5228);(0,T.t3)().prototype.mod=function(e){return this.throwIfDisposed(),(0,je.w)(this,e)};var qe=n(4841);(0,T.t3)().prototype.mul=function(e){return this.throwIfDisposed(),(0,qe.d)(this,e)};var Xe=n(7370);(0,T.t3)().prototype.neg=function(){return this.throwIfDisposed(),(0,Xe.W)(this)};var Ye=n(3561);(0,T.t3)().prototype.norm=function(e,t,n){return this.throwIfDisposed(),(0,Ye.K)(this,e,t,n)};var Ke=n(6500);(0,T.t3)().prototype.notEqual=function(e){return this.throwIfDisposed(),(0,Ke.Q)(this,e)};var Ze=n(6708);(0,T.t3)().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),(0,Ze.l)(this,e,t,n)};var Je=n(7846);(0,T.t3)().prototype.onesLike=function(){return this.throwIfDisposed(),(0,Je.J)(this)};var Qe=n(9682);(0,T.t3)().prototype.pad=function(e,t){return this.throwIfDisposed(),(0,Qe.v)(this,e,t)};var et=n(5860);(0,T.t3)().prototype.pool=function(e,t,n,r,i,s){return this.throwIfDisposed(),(0,et.d)(this,e,t,n,r,i,s)};var tt=n(3453);(0,T.t3)().prototype.pow=function(e){return this.throwIfDisposed(),(0,tt.s)(this,e)};var nt=n(8151);(0,T.t3)().prototype.prelu=function(e){return this.throwIfDisposed(),(0,nt.A)(this,e)};var rt=n(9451);(0,T.t3)().prototype.prod=function(e,t){return this.throwIfDisposed(),(0,rt.W)(this,e,t)};var it=n(9036);(0,T.t3)().prototype.reciprocal=function(){return this.throwIfDisposed(),(0,it.M)(this)};var st=n(7409);(0,T.t3)().prototype.relu=function(){return this.throwIfDisposed(),(0,st.U)(this)};var at=n(3582);(0,T.t3)().prototype.relu6=function(){return this.throwIfDisposed(),(0,at.b)(this)},(0,T.t3)().prototype.reshapeAs=function(e){return this.throwIfDisposed(),(0,D.X)(this,e.shape)},(0,T.t3)().prototype.reshape=function(e){return this.throwIfDisposed(),(0,D.X)(this,e)};var ot=n(3305);(0,T.t3)().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),(0,ot.I)(this,e,t,n)};var lt=n(5098);(0,T.t3)().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),(0,lt.j)(this,e,t,n)};var ct=n(7486);(0,T.t3)().prototype.reverse=function(e){return this.throwIfDisposed(),(0,ct.G)(this,e)};var ut=n(3710);(0,T.t3)().prototype.rfft=function(){return this.throwIfDisposed(),(0,ut.Q)(this)};var ht=n(7809);(0,T.t3)().prototype.round=function(){return this.throwIfDisposed(),(0,ht.N)(this)};var dt=n(2634);(0,T.t3)().prototype.rsqrt=function(){return this.throwIfDisposed(),(0,dt.b)(this)};var pt=n(5503);(0,T.t3)().prototype.selu=function(){return this.throwIfDisposed(),(0,pt.U)(this)};var ft=n(8678);(0,T.t3)().prototype.separableConv2d=function(e,t,n,r,i,s){return this.throwIfDisposed(),(0,ft.U)(this,e,t,n,r,i,s)};var mt=n(625);(0,T.t3)().prototype.sigmoid=function(){return this.throwIfDisposed(),(0,mt.X)(this)};var gt=n(4434);(0,T.t3)().prototype.sign=function(){return this.throwIfDisposed(),(0,gt.X)(this)};var yt=n(9331);(0,T.t3)().prototype.sin=function(){return this.throwIfDisposed(),(0,yt.O)(this)};var vt=n(3254);(0,T.t3)().prototype.sinh=function(){return this.throwIfDisposed(),(0,vt.R)(this)};var xt=n(2676);(0,T.t3)().prototype.slice=function(e,t){return this.throwIfDisposed(),(0,xt.t)(this,e,t)};var bt=n(682);(0,T.t3)().prototype.softmax=function(e){return this.throwIfDisposed(),(0,bt.X)(this,e)};var wt=n(3694);(0,T.t3)().prototype.softplus=function(){return this.throwIfDisposed(),(0,wt.W)(this)};var _t=n(7918);(0,T.t3)().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),(0,_t.f)(this,e,t)};var St=n(8644);(0,T.t3)().prototype.split=function(e,t){return this.throwIfDisposed(),(0,St.V)(this,e,t)};var Mt=n(3261);(0,T.t3)().prototype.sqrt=function(){return this.throwIfDisposed(),(0,Mt._)(this)};var Tt=n(248);(0,T.t3)().prototype.square=function(){return this.throwIfDisposed(),(0,Tt.h)(this)};var Et=n(5265);(0,T.t3)().prototype.squaredDifference=function(e){return this.throwIfDisposed(),(0,Et.$)(this,e)};var At=n(9590);(0,T.t3)().prototype.squeeze=function(e){return this.throwIfDisposed(),(0,At.L)(this,e)};var Ct=n(2991);(0,T.t3)().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof T.es?[this,e]:[this,...e];return(0,Ct.k)(n,t)};var It=n(1901);(0,T.t3)().prototype.step=function(e){return this.throwIfDisposed(),(0,It.N)(this,e)};var Nt=n(5158);(0,T.t3)().prototype.stridedSlice=function(e,t,n,r,i,s,a,o){return this.throwIfDisposed(),(0,Nt.N)(this,e,t,n,r,i,s,a,o)};var kt=n(827);(0,T.t3)().prototype.sub=function(e){return this.throwIfDisposed(),(0,kt.l)(this,e)};var Rt=n(5475);(0,T.t3)().prototype.sum=function(e,t){return this.throwIfDisposed(),(0,Rt.S)(this,e,t)};var Dt=n(1173);(0,T.t3)().prototype.tan=function(){return this.throwIfDisposed(),(0,Dt.O)(this)};var Lt=n(1869);(0,T.t3)().prototype.tanh=function(){return this.throwIfDisposed(),(0,Lt.A)(this)};var Ft=n(7501);(0,T.t3)().prototype.tile=function(e){return this.throwIfDisposed(),(0,Ft.G)(this,e)},(0,T.t3)().prototype.toBool=function(){return this.throwIfDisposed(),(0,F.p)(this,"bool")},(0,T.t3)().prototype.toFloat=function(){return this.throwIfDisposed(),(0,F.p)(this,"float32")},(0,T.t3)().prototype.toInt=function(){return this.throwIfDisposed(),(0,F.p)(this,"int32")};var Pt=n(3243);(0,T.t3)().prototype.topk=function(e,t){return this.throwIfDisposed(),(0,Pt.h)(this,e,t)};var Ot=n(9065);(0,T.t3)().prototype.transpose=function(e){return this.throwIfDisposed(),(0,Ot.p)(this,e)};var zt=n(9608);(0,T.t3)().prototype.unique=function(e){return this.throwIfDisposed(),(0,zt.T)(this,e)};var Bt=n(8749);(0,T.t3)().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),(0,Bt.p)(this,e,t)};var Ut=n(4136);(0,T.t3)().prototype.unstack=function(e){return this.throwIfDisposed(),(0,Ut.H)(this,e)};var $t=n(5912);(0,T.t3)().prototype.where=function(e,t){return this.throwIfDisposed(),(0,$t.a)(e,this,t)};var Vt=n(6577);(0,T.t3)().prototype.zerosLike=function(){return this.throwIfDisposed(),(0,Vt.P)(this)};var Wt,Gt,Ht=n(2001);(0,S.OBj)().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(Wt||(Wt={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(Gt||(Gt={}));const jt={};function qt(e,t){const n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};jt[e]=n}function Xt(e){return jt[e]}function Yt(e){delete jt[e]}function Kt(e,t,n,r,i){const s=t.inputParams[e];if(s&&void 0!==s.inputIndexStart){const e=s.inputIndexStart,a=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?e+1:s.inputIndexEnd;if("tensor"===s.type)return Zt(t.inputNames[s.inputIndexStart],n,r,i);if("tensors"===s.type)return t.inputNames.slice(e,a).map((e=>Zt(e,n,r,i)));const o=Zt(t.inputNames.slice(e)[0],n,r,i),l=o.dataSync();return"number"===s.type?l[0]:S.D5U.toNestedArray(o.shape,l)}const a=t.attrParams[e];return a&&a.value}function Zt(e,t,n,r){const[i,s]=en(e);if(null!=r){const e=r.getHashTableHandleByName(i);if(null!=e)return e}const a=n.currentContextIds.find((e=>!!t[Qt(i,e)]));return void 0!==a?t[Qt(i,a)][s]:void 0}function Jt(e,t){const[n,r,i]=en(e);return[Qt(n,t&&t.currentContextId),r,i]}function Qt(e,t){return t?`${e}-${t}`:e}function en(e){const t=e.split(":");if(1===t.length)return[e,0,void 0];const n=t[0],r=3===t.length?t[1]:void 0;return[n,Number(t[t.length-1]),r]}function tn(e,t,n){let r=Kt("pad",e,t,n);if("explicit"===r){r=Kt("explicitPaddings",e,t,n);const i=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)i[e][0]=r[2*e],i[e][1]=r[2*e+1];return i}return r}function nn(e){return e.kept?e:(0,S.d9v)(e)}const rn=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],sn=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],an=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],on=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],ln=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],cn=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],un=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],hn=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],dn=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],pn=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],fn=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],mn=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],gn=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],yn=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],vn=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],xn=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],bn=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],wn=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],_n=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class Sn{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[r,i,s,a,o,l,c,u,h,d,p,f,m,g,y,v,x,b,w].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e,t={}){const n=e.node,r=[],i=[],s=[],a=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?i.push(e[t.name]):null!=t.input&&0!==t.input.length||s.push(e[t.name]),e)),{});let o=[];const l=[];let c={},u={};null!=t&&(c=this.mapSignatureEntries(t.inputs),u=this.mapSignatureEntries(t.outputs));const h=Object.keys(a);h.forEach((e=>{const t=a[e];t.inputNames.forEach(((e,n)=>{const[r,,i]=Jt(e),s=a[r];if(null!=s.outputs){const e=s.outputs.indexOf(i);if(-1!==e){const i=`${r}:${e}`;t.inputNames[n]=i}}t.inputs.push(s),s.children.push(t)}))})),0===Object.keys(u).length?h.forEach((e=>{const t=a[e];0===t.children.length&&l.push(t)})):Object.keys(u).forEach((e=>{const[t]=Jt(e),n=a[t];null!=n&&(n.signatureKey=u[e],l.push(n))})),Object.keys(c).length>0?Object.keys(c).forEach((e=>{const[t]=Jt(e),n=a[t];n&&(n.signatureKey=c[e],o.push(n))})):o=r;let d={};null!=e.library&&null!=e.library.function&&(d=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const p={nodes:a,inputs:o,outputs:l,weights:i,placeholders:r,signature:t,functions:d};return s.length>0&&(p.initNodes=s),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=Xt(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{const r=n.type;let i;switch(n.type){case"string":i=Tn(e.attr,n.tfName,n.defaultValue),void 0===i&&n.tfDeprecatedName&&(i=Tn(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":i=Fn(e.attr,n.tfName,n.defaultValue),void 0===i&&n.tfDeprecatedName&&(i=Fn(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":i=An(e.attr,n.tfName,n.defaultValue||0),void 0===i&&n.tfDeprecatedName&&(i=An(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":i=Ln(e.attr,n.tfName,n.defaultValue),void 0===i&&n.tfDeprecatedName&&(i=Ln(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":i=En(e.attr,n.tfName,n.defaultValue),void 0===i&&n.tfDeprecatedName&&(i=En(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":i=On(e.attr,n.tfName,n.defaultValue),void 0===i&&n.tfDeprecatedName&&(i=On(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":i=Dn(e.attr,n.tfName,n.defaultValue),void 0===i&&n.tfDeprecatedName&&(i=Dn(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":i=Pn(e.attr,n.tfName,n.defaultValue),void 0===i&&n.tfDeprecatedName&&(i=Pn(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":i=Nn(e.attr,n.tfName,n.defaultValue),void 0===i&&n.tfDeprecatedName&&(i=Nn(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":i=kn(e.attr,n.tfName,n.defaultValue),void 0===i&&n.tfDeprecatedName&&(i=kn(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":i=In(e.attr,n.tfName,n.defaultValue),void 0===i&&n.tfDeprecatedName&&(i=In(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:i,type:r},t}),{})),n}mapFunction(e){const t=e.nodeDef,n=[];let r={};null!=t&&(r=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));const i=[],s=[];e.signature.inputArg.forEach((e=>{const[t]=Jt(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Cn(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,i.push(n),r[t]=n})),Object.keys(r).forEach((e=>{const t=r[e];t.inputNames.forEach(((e,n)=>{const[i,,s]=Jt(e),a=r[i];if(null!=a.outputs){const e=a.outputs.indexOf(s);if(-1!==e){const r=`${i}:${e}`;t.inputNames[n]=r}}t.inputs.push(a),a.children.push(t)}))}));const a=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=Jt(a[e.name]),i=r[t];null!=i&&(i.defaultOutput=n,s.push(i))}));const o=this.mapArgsToSignature(e);return{nodes:r,inputs:i,outputs:s,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function Mn(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=(0,S.OBj)().global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function Tn(e,t,n,r=!1){const i=e[t];return null!=i?Mn(i.s,r):n}function En(e,t,n){const r=e[t];return r?r.b:n}function An(e,t,n){const r=e[t]||{},i=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof i?i:parseInt(i,10)}function Cn(e){switch("string"==typeof e&&(e=Wt[e]),e){case Wt.DT_FLOAT:case Wt.DT_HALF:return"float32";case Wt.DT_INT32:case Wt.DT_INT64:case Wt.DT_INT8:case Wt.DT_UINT8:return"int32";case Wt.DT_BOOL:return"bool";case Wt.DT_DOUBLE:return"float32";case Wt.DT_STRING:return"string";default:return null}}function In(e,t,n){const r=e[t];return r&&r.func?r.func.name:n}function Nn(e,t,n){const r=e[t];return r&&r.type?Cn(r.type):n}function kn(e,t,n){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>Cn(e))):n}function Rn(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function Dn(e,t,n){const r=e[t];return r&&r.shape?Rn(r.shape):n}function Ln(e,t,n){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):n}function Fn(e,t,n,r=!1){const i=e[t];return i&&i.list&&i.list.s?i.list.s.map((e=>Mn(e,r))):n}function Pn(e,t,n){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>Rn(e))):n}function On(e,t,n){const r=e[t];return r&&r.list&&r.list.b?r.list.b:n}class zn{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return Zt(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return Zt(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return An(this.node.rawAttrs,e,t);if(null!=n.s)return Tn(this.node.rawAttrs,e,t);if(null!=n.b)return En(this.node.rawAttrs,e,t);if(null!=n.shape)return Dn(this.node.rawAttrs,e,t);if(null!=n.type)return Nn(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return Ln(this.node.rawAttrs,e,t);if(null!=n.list.s)return Fn(this.node.rawAttrs,e,t);if(null!=n.list.shape)return Pn(this.node.rawAttrs,e,t);if(null!=n.list.b)return On(this.node.rawAttrs,e,t);if(null!=n.list.type)return kn(this.node.rawAttrs,e,t)}return t}}var Bn=n(3135),Un=n(1661),$n=n(4386),Vn=n(766);function Wn(e,t,n=""){if("number"!=typeof e&&"number"!=typeof t){S.D5U.assert(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){const i=e[r],s=t[r];S.D5U.assert(i<0||s<0||i===s,(()=>n+` Shapes ${e} and ${t} must match`))}}}function Gn(e){return"number"!=typeof e&&!e.some((e=>e<0))}function Hn(e,t,n){let r=jn(e,n);const i=!Gn(r);if(i&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(i&&t.forEach((e=>{r=jn(e.shape,r)})),!Gn(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function jn(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let r=0;r<e.length;++r){const i=e[r],s=t[r];if(i>=0&&s>=0&&i!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=i>=0?i:s}return n}class qn{constructor(e,t,n,r,i,s,a){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=i,this.dynamicSize=s,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=(0,S.iD$)(0),(0,S.CnY)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),Wn(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,(0,S.CnY)(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return(0,S.XeE)([],[0].concat(this.elementShape));const n=this.readMany(e);return Wn(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),(0,S.knu)(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return(0,S.XeE)([],[0].concat(this.elementShape));const t=[];for(let e=0;e<this.size();e++)t.push(e);const n=this.readMany(t);return Wn(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),(0,S.zoF)(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,(0,S.HHK)(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const i=0===n?0:t.size/n,s=[];(0,S.lub)((()=>{t=(0,S.XLQ)(t,[1,n,i]);for(let n=0;n<e.length;++n){const a=[0,0===n?0:r[n-1],0],o=[1,e[n],i];s[n]=(0,S.XLQ)((0,S.tPi)(t,a,o),this.elementShape)}return s}));const a=[];for(let t=0;t<e.length;t++)a[t]=t;this.writeMany(a,s)}}class Xn{constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);Wn(t,e.shape,"TensorList shape mismatch: "),(0,S.CnY)(e)})),this.idTensor=(0,S.iD$)(0),this.maxNumElements=r,(0,S.CnY)(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Xn([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Wn(e,this.elementShape,"TensorList shape mismatch: ");const r=Hn(this.elementShape,this.tensors,e);return(0,S.lub)((()=>{const e=this.tensors.map((e=>(0,S.XLQ)(e,r)));return(0,S.knu)(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=Hn(this.elementShape,this.tensors,e),r=this.tensors.pop();return Wn(r.shape,e,"TensorList shape mismatch: "),(0,S.XLQ)(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Wn(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");(0,S.CnY)(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new Xn([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);Wn(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=Hn(this.elementShape,this.tensors,t);return(0,S.XLQ)(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Wn(this.elementShape,t.shape,"TensorList shape mismatch: "),(0,S.CnY)(t),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Wn(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=Hn(this.elementShape,this.tensors,n);return 0===e.length?(0,S.XeE)([],[0].concat(r)):(0,S.lub)((()=>{const t=e.map((e=>(0,S.XLQ)(this.tensors[e],r)));return(0,S.knu)(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Wn(this.elementShape,t,"TensorList shape mismatch: ");const n=Hn(this.elementShape,this.tensors,t);return 0===this.size()?(0,S.XeE)([],[0].concat(n)):(0,S.lub)((()=>{const e=this.tensors.map((e=>(0,S.XLQ)(e,n)));return(0,S.zoF)(e,0)}))}}var Yn=n(4624),Kn=n(473),Zn=n(6877),Jn=n(1749),Qn=n(5020);function er(e,t,n){const[r,i]=Kt("fusedOps",e,t,n),s="biasadd"===r,a=!s,o="prelu"===i,l="fusedbatchnorm"===r,c=Kt("numArgs",e,t,n);if(s){if(o&&2!==c)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&1!==c)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=Kt("strides",e,t,n),h=tn(e,t,n),d=Kt("dataFormat",e,t,n).toUpperCase(),p=Kt("dilations",e,t,n);let[f,m]=Kt("args",e,t,n);return a&&(m=f,f=void 0),{stride:u,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:i,leakyreluAlpha:Kt("leakyreluAlpha",e,t,n)}}var tr=n(4006),nr=n(4135),rr=n(686),ir=n(4917),sr=n(5002),ar=n(7245),or=n(3596),lr=n(723),cr=n(4376),ur=n(6380),hr=n(6567);function dr(e,t,n){return{boxes:Kt("boxes",e,t,n),scores:Kt("scores",e,t,n),maxOutputSize:Kt("maxOutputSize",e,t,n),iouThreshold:Kt("iouThreshold",e,t,n),scoreThreshold:Kt("scoreThreshold",e,t,n),softNmsSigma:Kt("softNmsSigma",e,t,n)}}var pr=n(4608),fr=n(4978),mr=n(6092),gr=n(9494);class yr{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=(0,S.iD$)(0),this.tensorMap=new Map,(0,S.CnY)(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return gr.i(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),(0,S.lub)((()=>{const e=(0,S.HHK)(t),r=n.length,i=e.length;S.D5U.assert(r===i,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${i} elements.`));for(let t=0;t<r;t++){const r=n[t],i=e[t];(0,S.CnY)(i),this.tensorMap.set(r,i)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return(0,S.lub)((()=>{const e=[];for(let r=0;r<n.length;r++){const i=n[r],s=this.findWithDefault(i,t);e.push(s)}return(0,S.knu)(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}var vr=n(4653),xr=n(9758),br=n(3865),wr=n(5746),_r=n(3100),Sr=n(7494),Mr=n(8194);function Tr(e,t,n,r){const i=((e,t,n)=>{switch(e.category){case"arithmetic":return S.lub((()=>((e,t,n)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[C.I(Kt("a",e,t,n),Kt("b",e,t,n))];case"AddN":return[Bn.Q(Kt("tensors",e,t,n))];case"FloorMod":case"Mod":return[je.w(Kt("a",e,t,n),Kt("b",e,t,n))];case"Mul":return[qe.d(Kt("a",e,t,n),Kt("b",e,t,n))];case"RealDiv":case"Div":return[se.h(Kt("a",e,t,n),Kt("b",e,t,n))];case"DivNoNan":return[ie.N(Kt("a",e,t,n),Kt("b",e,t,n))];case"FloorDiv":return[ge.q(Kt("a",e,t,n),Kt("b",e,t,n))];case"Sub":return[kt.l(Kt("a",e,t,n),Kt("b",e,t,n))];case"Minimum":return[Ge.L(Kt("a",e,t,n),Kt("b",e,t,n))];case"Maximum":return[$e.g(Kt("a",e,t,n),Kt("b",e,t,n))];case"Pow":return[tt.s(Kt("a",e,t,n),Kt("b",e,t,n))];case"SquaredDifference":return[Et.$(Kt("a",e,t,n),Kt("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"basic_math":return S.lub((()=>((e,t,n)=>{switch(e.op){case"Abs":case"ComplexAbs":return[M.W(Kt("x",e,t,n))];case"Acos":return[E.K(Kt("x",e,t,n))];case"Acosh":return[A._(Kt("x",e,t,n))];case"Asin":return[P.Z(Kt("x",e,t,n))];case"Asinh":return[O.V(Kt("x",e,t,n))];case"Atan":return[z.z(Kt("x",e,t,n))];case"Atan2":return[B.f(Kt("x",e,t,n),Kt("y",e,t,n))];case"Atanh":return[U.C(Kt("x",e,t,n))];case"Ceil":return[H.m(Kt("x",e,t,n))];case"Complex":return[Un.P(Kt("real",e,t,n),Kt("imag",e,t,n))];case"Cos":return[Z.m(Kt("x",e,t,n))];case"Cosh":return[J.f(Kt("x",e,t,n))];case"Elu":return[oe.p(Kt("x",e,t,n))];case"Erf":return[ce.q(Kt("x",e,t,n))];case"Exp":return[he.Q(Kt("x",e,t,n))];case"Expm1":return[pe.t(Kt("x",e,t,n))];case"Floor":return[me.G(Kt("x",e,t,n))];case"Log":return[Re.c(Kt("x",e,t,n))];case"Log1p":return[De.K(Kt("x",e,t,n))];case"Imag":return[$n.a(Kt("x",e,t,n))];case"Neg":return[Xe.W(Kt("x",e,t,n))];case"Reciprocal":return[it.M(Kt("x",e,t,n))];case"Real":return[Vn.k(Kt("x",e,t,n))];case"Relu":return[st.U(Kt("x",e,t,n))];case"Round":return[ht.N(Kt("x",e,t,n))];case"Selu":return[pt.U(Kt("x",e,t,n))];case"Sigmoid":return[mt.X(Kt("x",e,t,n))];case"Sin":return[yt.O(Kt("x",e,t,n))];case"Sign":return[gt.X(Kt("x",e,t,n))];case"Sinh":return[vt.R(Kt("x",e,t,n))];case"Softplus":return[wt.W(Kt("x",e,t,n))];case"Sqrt":return[Mt._(Kt("x",e,t,n))];case"Square":return[Tt.h(Kt("x",e,t,n))];case"Tanh":return[Lt.A(Kt("x",e,t,n))];case"Tan":return[Dt.O(Kt("x",e,t,n))];case"ClipByValue":return[j.i(Kt("x",e,t,n),Kt("clipValueMin",e,t,n),Kt("clipValueMax",e,t,n))];case"Relu6":return[at.b(Kt("x",e,t,n))];case"Rsqrt":return[dt.b(Zt(e.inputNames[0],t,n))];case"Prod":return[rt.W(Kt("x",e,t,n),Kt("axes",e,t,n))];case"LeakyRelu":return[Te.h(Kt("x",e,t,n),Kt("alpha",e,t,n))];case"Prelu":return[nt.A(Kt("x",e,t,n),Kt("alpha",e,t,n))];case"IsNan":return[Me.i(Zt(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"control":return(async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const r=Kt("thenBranch",e,t,n),i=Kt("elseBranch",e,t,n),s=Kt("cond",e,t,n),a=Kt("args",e,t,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap):n.functionMap[i].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=Kt("body",e,t,n),i=Kt("cond",e,t,n),s=Kt("args",e,t,n),a=await n.functionMap[i].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map((e=>e.id));let l=await a[0].data();a.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()}));let c=s;for(;l[0];){const e=c;c=await n.functionMap[r].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);const t=c.map((e=>e.id));e.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const s=await n.functionMap[i].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);l=await s[0].data(),s.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return c}case"LoopCond":return[nn(Kt("pred",e,t,n))];case"Switch":{const r=Kt("pred",e,t,n);let i=Kt("data",e,t,n);return i.kept||(i=nn(i)),(await r.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const r=e.inputNames.find((e=>void 0!==Zt(e,t,n)));return r?[nn(Zt(r,t,n))]:void 0}case"Enter":{const r=Kt("frameName",e,t,n),i=Kt("tensor",e,t,n);return n.enterFrame(r),[nn(i)]}case"Exit":{const r=Kt("tensor",e,t,n);return n.exitFrame(),[nn(r)]}case"NextIteration":{const r=Kt("tensor",e,t,n);return n.nextIteration(),[nn(r)]}case"TensorArrayV3":{const r=Kt("size",e,t,n),i=Kt("dtype",e,t,n),s=Kt("elementShape",e,t,n),a=Kt("dynamicSize",e,t,n),o=Kt("clearAfterRead",e,t,n),l=Kt("identicalElementShapes",e,t,n),c=Kt("name",e,t,n),u=new qn(c,i,r,s,l,a,o);return n.addTensorArray(u),[u.idTensor,(0,S.iD$)(1)]}case"TensorArrayWriteV3":{const r=Kt("tensorArrayId",e,t,n),i=Kt("index",e,t,n),s=Kt("tensor",e,t,n),a=n.getTensorArray(r.id);return a.write(i,s),[a.idTensor]}case"TensorArrayReadV3":{const r=Kt("tensorArrayId",e,t,n),i=Kt("index",e,t,n);return[n.getTensorArray(r.id).read(i)]}case"TensorArrayGatherV3":{const r=Kt("tensorArrayId",e,t,n),i=Kt("indices",e,t,n),s=Kt("dtype",e,t,n);return[n.getTensorArray(r.id).gather(i,s)]}case"TensorArrayScatterV3":{const r=Kt("tensorArrayId",e,t,n),i=Kt("indices",e,t,n),s=Kt("tensor",e,t,n),a=n.getTensorArray(r.id);return a.scatter(i,s),[a.idTensor]}case"TensorArrayConcatV3":{const r=Kt("tensorArrayId",e,t,n),i=n.getTensorArray(r.id),s=Kt("dtype",e,t,n);return[i.concat(s)]}case"TensorArraySplitV3":{const r=Kt("tensorArrayId",e,t,n),i=Kt("tensor",e,t,n),s=Kt("lengths",e,t,n),a=n.getTensorArray(r.id);return a.split(s,i),[a.idTensor]}case"TensorArraySizeV3":{const r=Kt("tensorArrayId",e,t,n),i=n.getTensorArray(r.id);return[(0,S.iD$)(i.size(),"int32")]}case"TensorArrayCloseV3":{const r=Kt("tensorArrayId",e,t,n),i=n.getTensorArray(r.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const r=Kt("tensorListId",e,t,n),i=Kt("index",e,t,n),s=Kt("tensor",e,t,n),a=n.getTensorList(r.id);return a.setItem(i,s),[a.idTensor]}case"TensorListGetItem":{const r=Kt("tensorListId",e,t,n),i=Kt("index",e,t,n),s=Kt("elementShape",e,t,n),a=Kt("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(i,s,a)]}case"TensorListScatterV2":case"TensorListScatter":{const r=Kt("indices",e,t,n),i=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const i=Math.max(...t);if(null!=r&&-1!==r&&i>=r)throw new Error(`Max index must be < array size (${i}  vs. ${r})`);const s=new Xn([],n,e.dtype,r),a=(0,S.HHK)(e,0);return t.forEach(((e,t)=>{s.setItem(e,a[t])})),s}(Kt("tensor",e,t,n),r,Kt("elementShape",e,t,n),Kt("numElements",e,t,n));return n.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=Kt("elementShape",e,t,n),i=Kt("elementDType",e,t,n);let s;s="TensorListReserve"===e.op?"numElements":"maxNumElements";const a=function(e,t,n){return new Xn([],e,t,n)}(r,i,Kt(s,e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListGather":{const r=Kt("tensorListId",e,t,n),i=Kt("indices",e,t,n),s=Kt("elementShape",e,t,n),a=Kt("elementDType",e,t,n);return[n.getTensorList(r.id).gather(i,a,s)]}case"TensorListStack":{const r=Kt("tensorListId",e,t,n),i=Kt("elementShape",e,t,n),s=Kt("elementDType",e,t,n),a=Kt("numElements",e,t,n);return[n.getTensorList(r.id).stack(i,s,a)]}case"TensorListFromTensor":{const r=function(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);Wn(e.shape.slice(1),t,"TensorList shape mismatch: ");const i=(0,S.HHK)(e);return new Xn(i,t,r)}(Kt("tensor",e,t,n),Kt("elementShape",e,t,n),Kt("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=Kt("tensorListId",e,t,n),i=n.getTensorList(r.id),s=Kt("dtype",e,t,n),a=Kt("elementShape",e,t,n);return[i.concat(s,a)]}case"TensorListPushBack":{const r=Kt("tensorListId",e,t,n),i=Kt("tensor",e,t,n),s=n.getTensorList(r.id);return s.pushBack(i),[s.idTensor]}case"TensorListPopBack":{const r=Kt("tensorListId",e,t,n),i=Kt("elementShape",e,t,n),s=Kt("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(i,s)]}case"TensorListSplit":{const r=Kt("tensor",e,t,n),i=Kt("elementShape",e,t,n),s=function(e,t,n){let r=0;const i=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const s=jn(e.shape.slice(1),n),a=0===r?0:e.size/r,o=(0,S.lub)((()=>{const n=[];e=(0,S.XLQ)(e,[1,r,a]);for(let r=0;r<t.length;++r){const o=[0,0===r?0:i[r-1],0],l=[1,t[r],a];n[r]=(0,S.XLQ)((0,S.tPi)(e,o,l),s)}return e.dispose(),n})),l=new Xn([],n,e.dtype,t.length);for(let e=0;e<o.length;e++)l.setItem(e,o[e]);return l}(r,Kt("lengths",e,t,n),i);return n.addTensorList(s),[s.idTensor]}case"TensorListLength":{const r=Kt("tensorListId",e,t,n),i=n.getTensorList(r.id);return[(0,S.iD$)(i.size(),"int32")]}case"TensorListResize":{const r=Kt("tensorListId",e,t,n),i=Kt("size",e,t,n),s=n.getTensorList(r.id).resize(i);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n);case"convolution":return S.lub((()=>((e,t,n)=>{switch(e.op){case"Conv1D":{const r=Kt("stride",e,t,n),i=Kt("pad",e,t,n),s=Kt("dataFormat",e,t,n).toUpperCase(),a=Kt("dilation",e,t,n);return[X.P(Kt("x",e,t,n),Kt("filter",e,t,n),r,i,s,a)]}case"Conv2D":{const r=Kt("strides",e,t,n),i=tn(e,t,n),s=Kt("dataFormat",e,t,n).toUpperCase(),a=Kt("dilations",e,t,n);return[K.T(Kt("x",e,t,n),Kt("filter",e,t,n),[r[1],r[2]],i,s,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:r,pad:i,dataFormat:s,dilations:a,biasArg:o,preluArg:l,activationFunc:c,leakyreluAlpha:u}=er(e,t,n);return[Yn.conv2d({x:Kt("x",e,t,n),filter:Kt("filter",e,t,n),strides:[r[1],r[2]],pad:i,dataFormat:s,dilations:[a[1],a[2]],bias:o,activation:c,preluActivationWeights:l,leakyreluAlpha:u})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:i,dataFormat:s,dilations:a,biasArg:o,preluArg:l,activationFunc:c,leakyreluAlpha:u}=er(e,t,n);return[Yn.depthwiseConv2d({x:Kt("x",e,t,n),filter:Kt("filter",e,t,n),strides:[r[1],r[2]],pad:i,dataFormat:s,dilations:[a[1],a[2]],bias:o,activation:c,preluActivationWeights:l,leakyreluAlpha:u})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=Kt("outputShape",e,t,n),i=Kt("strides",e,t,n),s=tn(e,t,n);return[Y.b(Kt("x",e,t,n),Kt("filter",e,t,n),r,[i[1],i[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=Kt("strides",e,t,n),i=tn(e,t,n),s=Kt("dilations",e,t,n),a=Kt("dataFormat",e,t,n).toUpperCase();return[ne.B(Kt("input",e,t,n),Kt("filter",e,t,n),[r[1],r[2]],i,a,[s[1],s[2]])]}case"Conv3D":{const r=Kt("strides",e,t,n),i=Kt("pad",e,t,n),s=Kt("dataFormat",e,t,n).toUpperCase(),a=Kt("dilations",e,t,n);return[Kn.p(Kt("x",e,t,n),Kt("filter",e,t,n),[r[1],r[2],r[3]],i,s,[a[1],a[2],a[3]])]}case"AvgPool":{const r=Kt("strides",e,t,n),i=Kt("pad",e,t,n),s=Kt("kernelSize",e,t,n);return[$.w(Kt("x",e,t,n),[s[1],s[2]],[r[1],r[2]],i)]}case"MaxPool":{const r=Kt("strides",e,t,n),i=Kt("pad",e,t,n),s=Kt("kernelSize",e,t,n);return[Be._(Kt("x",e,t,n),[s[1],s[2]],[r[1],r[2]],i)]}case"MaxPoolWithArgmax":{const r=Kt("strides",e,t,n),i=Kt("pad",e,t,n),s=Kt("kernelSize",e,t,n),a=Kt("includeBatchInIndex",e,t,n),{result:o,indexes:l}=Zn.I(Kt("x",e,t,n),[s[1],s[2]],[r[1],r[2]],i,a);return[o,l]}case"AvgPool3D":{const r=Kt("strides",e,t,n),i=Kt("pad",e,t,n),s=Kt("kernelSize",e,t,n);return[Jn.u(Kt("x",e,t,n),[s[1],s[2],s[3]],[r[1],r[2],r[3]],i)]}case"MaxPool3D":{const r=Kt("strides",e,t,n),i=Kt("pad",e,t,n),s=Kt("kernelSize",e,t,n);return[Qn.Y(Kt("x",e,t,n),[s[1],s[2],s[3]],[r[1],r[2],r[3]],i)]}case"Dilation2D":{const r=Kt("strides",e,t,n),i=Kt("pad",e,t,n),s=Kt("dilations",e,t,n),a=r[1],o=r[2],l=s[1],c=s[2];return[re.W(Kt("x",e,t,n),Kt("filter",e,t,n),[a,o],i,[l,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"creation":return S.lub((()=>((e,t,n)=>{switch(e.op){case"Fill":{const r=Kt("shape",e,t,n),i=Kt("dtype",e,t,n),s=Kt("value",e,t,n);return[tr.h(r,s,i)]}case"LinSpace":{const r=Kt("start",e,t,n),i=Kt("stop",e,t,n),s=Kt("num",e,t,n);return[nr.S(r,i,s)]}case"Multinomial":{const r=Kt("logits",e,t,n),i=Kt("numSamples",e,t,n),s=Kt("seed",e,t,n);return[rr.S(r,i,s)]}case"OneHot":{const r=Kt("indices",e,t,n),i=Kt("depth",e,t,n),s=Kt("onValue",e,t,n),a=Kt("offValue",e,t,n);return[Ze.l(r,i,s,a)]}case"Ones":return[ir.i(Kt("shape",e,t,n),Kt("dtype",e,t,n))];case"OnesLike":return[Je.J(Kt("x",e,t,n))];case"RandomUniform":return[sr.L(Kt("shape",e,t,n),Kt("minval",e,t,n),Kt("maxval",e,t,n),Kt("dtype",e,t,n))];case"Range":{const r=Kt("start",e,t,n),i=Kt("stop",e,t,n),s=Kt("step",e,t,n);return[ar.w(r,i,s,Kt("dtype",e,t,n))]}case"TruncatedNormal":{const r=Kt("shape",e,t,n),i=Kt("mean",e,t,n),s=Kt("stdDev",e,t,n),a=Kt("seed",e,t,n);return[or.X(r,i,s,Kt("dtype",e,t,n),a)]}case"Zeros":return[lr.l(Kt("shape",e,t,n),Kt("dtype",e,t,n))];case"ZerosLike":return[Vt.P(Kt("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"dynamic":return(async(e,t,n)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:i,maxOutputSize:s,iouThreshold:a,scoreThreshold:o,softNmsSigma:l}=dr(e,t,n),c=await cr.BHj.nonMaxSuppressionWithScoreAsync(r,i,s,a,o,l);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:i,maxOutputSize:s,iouThreshold:a,scoreThreshold:o}=dr(e,t,n),l=Kt("padToMaxOutputSize",e,t,n),c=await cr.BHj.nonMaxSuppressionPaddedAsync(r,i,s,a,o,l);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:i,maxOutputSize:s,iouThreshold:a,scoreThreshold:o}=dr(e,t,n);return[await cr.BHj.nonMaxSuppressionAsync(r,i,s,a,o)]}case"Where":{const r=F.p(Kt("condition",e,t,n),"bool"),i=[await ur.i(r)];return r.dispose(),i}case"ListDiff":return hr.O(Kt("x",e,t,n),Kt("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n);case"evaluation":return S.lub((()=>((e,t,n)=>{switch(e.op){case"LowerBound":{const r=Kt("sortedSequence",e,t,n),i=Kt("values",e,t,n);return[pr.e(r,i)]}case"TopKV2":{const r=Kt("x",e,t,n),i=Kt("k",e,t,n),s=Kt("sorted",e,t,n),a=Pt.h(r,i,s);return[a.values,a.indices]}case"UpperBound":{const r=Kt("sortedSequence",e,t,n),i=Kt("values",e,t,n);return[fr.G(r,i)]}case"Unique":{const r=Kt("x",e,t,n),i=zt.T(r);return[i.values,i.indices]}case"UniqueV2":{const r=Kt("x",e,t,n),i=Kt("axis",e,t,n),s=zt.T(r,i);return[s.values,s.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"image":return S.lub((()=>((e,t,n)=>{switch(e.op){case"ResizeBilinear":{const r=Kt("images",e,t,n),i=Kt("size",e,t,n),s=Kt("alignCorners",e,t,n),a=Kt("halfPixelCenters",e,t,n);return[cr.BHj.resizeBilinear(r,[i[0],i[1]],s,a)]}case"ResizeNearestNeighbor":{const r=Kt("images",e,t,n),i=Kt("size",e,t,n),s=Kt("alignCorners",e,t,n),a=Kt("halfPixelCenters",e,t,n);return[cr.BHj.resizeNearestNeighbor(r,[i[0],i[1]],s,a)]}case"CropAndResize":{const r=Kt("image",e,t,n),i=Kt("boxes",e,t,n),s=Kt("boxInd",e,t,n),a=Kt("cropSize",e,t,n),o=Kt("method",e,t,n),l=Kt("extrapolationValue",e,t,n);return[cr.BHj.cropAndResize(r,i,s,a,o,l)]}case"ImageProjectiveTransformV3":{const r=Kt("images",e,t,n),i=Kt("transforms",e,t,n),s=Kt("outputShape",e,t,n),a=Kt("fillValue",e,t,n),o=Kt("interpolation",e,t,n),l=Kt("fillMode",e,t,n);return[cr.BHj.transform(r,i,o.toLowerCase(),l.toLowerCase(),a,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"graph":return S.lub((()=>((e,t,n)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const r=Kt("default",e,t,n);return[Zt(e.name,t,n)||r];case"Placeholder":return[Zt(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[nn(Kt("x",e,t,n))];case"IdentityN":return Kt("x",e,t,n).map((e=>nn(e)));case"Shape":return[mr.R(Kt("x",e,t,n).shape,"int32")];case"ShapeN":return Kt("x",e,t,n).map((e=>mr.R(e.shape)));case"Size":return[gr.i(Kt("x",e,t,n).size,"int32")];case"Rank":return[gr.i(Kt("x",e,t,n).rank,"int32")];case"NoOp":return[gr.i(1)];case"Print":const i=Kt("x",e,t,n),s=Kt("data",e,t,n),a=Kt("message",e,t,n),o=Kt("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(a);for(let e=0;e<s.length;e++)console.log(Array.prototype.slice.call(s[e].dataSync()).slice(0,o));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"logical":return S.lub((()=>((e,t,n)=>{switch(e.op){case"Equal":return[le.D(Kt("a",e,t,n),Kt("b",e,t,n))];case"NotEqual":return[Ke.Q(Kt("a",e,t,n),Kt("b",e,t,n))];case"Greater":return[xe.p(Kt("a",e,t,n),Kt("b",e,t,n))];case"GreaterEqual":return[ve.b(Kt("a",e,t,n),Kt("b",e,t,n))];case"Less":return[Ae.d(Kt("a",e,t,n),Kt("b",e,t,n))];case"LessEqual":return[Ee.z(Kt("a",e,t,n),Kt("b",e,t,n))];case"LogicalAnd":return[Le.H(Kt("a",e,t,n),Kt("b",e,t,n))];case"LogicalNot":return[Fe.h(Kt("a",e,t,n))];case"LogicalOr":return[Pe.K(Kt("a",e,t,n),Kt("b",e,t,n))];case"Select":case"SelectV2":return[$t.a(Kt("condition",e,t,n),Kt("a",e,t,n),Kt("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"matrices":return S.lub((()=>((e,t,n)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[ze.O(Kt("a",e,t,n),Kt("b",e,t,n),Kt("transposeA",e,t,n),Kt("transposeB",e,t,n))];case"Einsum":return[vr.W(Kt("equation",e,t,n),...Kt("tensors",e,t,n))];case"Transpose":return[Ot.p(Kt("x",e,t,n),Kt("perm",e,t,n))];case"_FusedMatMul":const[r,i]=Kt("fusedOps",e,t,n),s="biasadd"===r,a="prelu"===i,o=Kt("numArgs",e,t,n),l=Kt("leakyreluAlpha",e,t,n);if(s){if(a&&2!==o)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&1!==o)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,u]=Kt("args",e,t,n);return[Yn.matMul({a:Kt("a",e,t,n),b:Kt("b",e,t,n),transposeA:Kt("transposeA",e,t,n),transposeB:Kt("transposeB",e,t,n),bias:c,activation:i,preluActivationWeights:u,leakyreluAlpha:l})];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"normalization":return S.lub((()=>((e,t,n)=>{switch(e.op){case"EuclideanNorm":return[ue.d(Kt("x",e,t,n),Kt("axis",e,t,n),Kt("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[W.t(Kt("x",e,t,n),Kt("mean",e,t,n),Kt("variance",e,t,n),Kt("offset",e,t,n),Kt("scale",e,t,n),Kt("epsilon",e,t,n))];case"LRN":return[Ce.G(Kt("x",e,t,n),Kt("radius",e,t,n),Kt("bias",e,t,n),Kt("alpha",e,t,n),Kt("beta",e,t,n))];case"Softmax":return[bt.X(Kt("x",e,t,n))];case"LogSoftmax":return[Ne.C(Kt("x",e,t,n))];case"SparseToDense":return[xr.e(Kt("sparseIndices",e,t,n),Kt("outputShape",e,t,n),Kt("sparseValues",e,t,n),Kt("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"reduction":return S.lub((()=>((e,t,n)=>{switch(e.op){case"Max":{const r=Kt("axis",e,t,n),i=Kt("keepDims",e,t,n);return[Ue.F(Kt("x",e,t,n),r,i)]}case"Mean":{const r=Kt("axis",e,t,n),i=Kt("keepDims",e,t,n);return[Ve.J(Kt("x",e,t,n),r,i)]}case"Min":{const r=Kt("axis",e,t,n),i=Kt("keepDims",e,t,n);return[We.V(Kt("x",e,t,n),r,i)]}case"Sum":{const r=Kt("axis",e,t,n),i=Kt("keepDims",e,t,n);return[Rt.S(Kt("x",e,t,n),r,i)]}case"All":{const r=Kt("axis",e,t,n),i=Kt("keepDims",e,t,n);return[I.$(Kt("x",e,t,n),r,i)]}case"Any":{const r=Kt("axis",e,t,n),i=Kt("keepDims",e,t,n);return[N.Y(Kt("x",e,t,n),r,i)]}case"ArgMax":{const r=Kt("axis",e,t,n);return[k.N(Kt("x",e,t,n),r)]}case"ArgMin":{const r=Kt("axis",e,t,n);return[R.v(Kt("x",e,t,n),r)]}case"Prod":{const r=Kt("axis",e,t,n),i=Kt("keepDims",e,t,n);return[rt.W(Kt("x",e,t,n),r,i)]}case"Cumprod":{const r=Kt("axis",e,t,n),i=Kt("exclusive",e,t,n),s=Kt("reverse",e,t,n);return[Q.$(Kt("x",e,t,n),r,i,s)]}case"Cumsum":{const r=Kt("axis",e,t,n),i=Kt("exclusive",e,t,n),s=Kt("reverse",e,t,n);return[ee.z(Kt("x",e,t,n),r,i,s)]}case"Bincount":const r=Kt("x",e,t,n),i=Kt("weights",e,t,n),s=Kt("size",e,t,n);return[br.y(r,i,s)];case"DenseBincount":{const r=Kt("x",e,t,n),i=Kt("weights",e,t,n),s=Kt("size",e,t,n),a=Kt("binaryOutput",e,t,n);return[wr.p(r,i,s,a)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"slice_join":return S.lub((()=>((e,t,n)=>{switch(e.op){case"ConcatV2":case"Concat":{const r=Kt("n",e,t,n),i=Kt("axis",e,t,n);let s=Kt("tensors",e,t,n);return s=s.slice(0,r),[q.z(s,i)]}case"Gather":{const r=Kt("x",e,t,n),i=Kt("indices",e,t,n);return[ye.I(r,F.p(i,"int32"),0)]}case"GatherV2":{const r=Kt("axis",e,t,n),i=Kt("batchDims",e,t,n),s=Kt("x",e,t,n),a=Kt("indices",e,t,n);return[ye.I(s,F.p(a,"int32"),r,i)]}case"Reverse":{const r=Kt("dims",e,t,n),i=[];for(let e=0;e<r.length;e++)r[e]&&i.push(e);const s=Kt("x",e,t,n);return[ct.G(s,i)]}case"ReverseV2":{const r=Kt("axis",e,t,n),i=Kt("x",e,t,n);return[ct.G(i,r)]}case"Slice":{const r=Kt("begin",e,t,n),i=Kt("size",e,t,n);return[xt.t(Kt("x",e,t,n),r,i)]}case"StridedSlice":{const r=Kt("begin",e,t,n),i=Kt("end",e,t,n),s=Kt("strides",e,t,n),a=Kt("beginMask",e,t,n),o=Kt("endMask",e,t,n),l=Kt("ellipsisMask",e,t,n),c=Kt("newAxisMask",e,t,n),u=Kt("shrinkAxisMask",e,t,n),h=Kt("x",e,t,n);return[Nt.N(h,r,i,s,a,o,l,c,u)]}case"Pack":return(0,S.lub)((()=>{const r=Kt("axis",e,t,n),i=Kt("tensors",e,t,n),s=i[0].shape,a=At.L(i[0]).shape,o=i.map((e=>{const t=S.D5U.arraysEqual(e.shape,s);if(!t&&!S.D5U.arraysEqual(At.L(e).shape,a))throw new Error("the input tensors shape does not match");return t?e:D.X(e,s)}));return[Ct.k(o,r)]}));case"Unpack":{const r=Kt("axis",e,t,n),i=Kt("tensor",e,t,n);return Ut.H(i,r)}case"Tile":{const r=Kt("reps",e,t,n);return[Ft.G(Kt("x",e,t,n),r)]}case"Split":case"SplitV":{const r=Kt("axis",e,t,n),i=Kt("numOrSizeSplits",e,t,n),s=Kt("x",e,t,n);return St.V(s,i,r)}case"ScatterNd":{const r=Kt("indices",e,t,n),i=Kt("values",e,t,n),s=Kt("shape",e,t,n);return[_r.s(r,i,s)]}case"GatherNd":{const r=Kt("x",e,t,n),i=Kt("indices",e,t,n);return[Sr.d(r,i)]}case"SparseToDense":{const r=Kt("sparseIndices",e,t,n),i=Kt("outputShape",e,t,n),s=Kt("sparseValues",e,t,n),a=Kt("defaultValue",e,t,n);return[xr.e(r,s,i,s.dtype===a.dtype?a:F.p(a,s.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"sparse":return S.lub((()=>((e,t,n)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:i,emptyRowIndicator:s,reverseIndexMap:a}=cr.rVs.sparseFillEmptyRows(Kt("indices",e,t,n),Kt("values",e,t,n),Kt("denseShape",e,t,n),Kt("defaultValue",e,t,n));return[r,i,s,a]}case"SparseReshape":{const{outputIndices:r,outputShape:i}=cr.rVs.sparseReshape(Kt("inputIndices",e,t,n),Kt("inputShape",e,t,n),Kt("newShape",e,t,n));return[r,i]}case"SparseSegmentMean":return[cr.rVs.sparseSegmentMean(Kt("data",e,t,n),Kt("indices",e,t,n),Kt("segmentIds",e,t,n))];case"SparseSegmentSum":return[cr.rVs.sparseSegmentSum(Kt("data",e,t,n),Kt("indices",e,t,n),Kt("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"spectral":return S.lub((()=>((e,t,n)=>{switch(e.op){case"FFT":return[fe.k(Kt("x",e,t,n))];case"IFFT":return[be.S(Kt("x",e,t,n))];case"RFFT":return[ut.Q(Kt("x",e,t,n))];case"IRFFT":return[we.w(Kt("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"string":return S.lub((()=>((e,t,n)=>{switch(e.op){case"StringNGrams":{const{nGrams:r,nGramsSplits:i}=cr.Z_8.stringNGrams(Kt("data",e,t,n),Kt("dataSplits",e,t,n),Kt("separator",e,t,n),Kt("nGramWidths",e,t,n),Kt("leftPad",e,t,n),Kt("rightPad",e,t,n),Kt("padWidth",e,t,n),Kt("preserveShortSequences",e,t,n));return[r,i]}case"StringSplit":{const{indices:r,values:i,shape:s}=cr.Z_8.stringSplit(Kt("input",e,t,n),Kt("delimiter",e,t,n),Kt("skipEmpty",e,t,n));return[r,i,s]}case"StringToHashBucketFast":return[cr.Z_8.stringToHashBucketFast(Kt("input",e,t,n),Kt("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"transformation":return S.lub((()=>((e,t,n)=>{switch(e.op){case"Cast":return[F.p(Kt("x",e,t,n),Kt("dtype",e,t,n))];case"ExpandDims":{const r=Kt("axis",e,t,n);return[de.d(Kt("x",e,t,n),r)]}case"Squeeze":{const r=Kt("axis",e,t,n);return[At.L(Kt("x",e,t,n),r)]}case"Reshape":return[D.X(Kt("x",e,t,n),Kt("shape",e,t,n))];case"MirrorPad":return[He.V(Kt("x",e,t,n),Kt("padding",e,t,n),Kt("mode",e,t,n))];case"PadV2":case"Pad":return[Qe.v(Kt("x",e,t,n),Kt("padding",e,t,n),Kt("constantValue",e,t,n))];case"SpaceToBatchND":{const r=Kt("blockShape",e,t,n),i=Kt("paddings",e,t,n);return[_t.f(Kt("x",e,t,n),r,i)]}case"BatchToSpaceND":{const r=Kt("blockShape",e,t,n),i=Kt("crops",e,t,n);return[V.E(Kt("x",e,t,n),r,i)]}case"DepthToSpace":{const r=Kt("blockSize",e,t,n),i=Kt("dataFormat",e,t,n).toUpperCase();return[te.n(Kt("x",e,t,n),r,i)]}case"BroadcastTo":return[G.U(Kt("x",e,t,n),Kt("shape",e,t,n))];case"BroadcastArgs":return[Mr.X(Kt("s0",e,t,n),Kt("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"hash_table":return(async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{const i=Kt("keyDType",e,t,n),s=Kt("valueDType",e,t,n),a=new yr(i,s);return r.addHashTable(e.name,a),[a.handle]}case"LookupTableImport":case"LookupTableImportV2":{const i=Kt("tableHandle",e,t,n,r),s=Kt("keys",e,t,n),a=Kt("values",e,t,n),o=r.getHashTableById(i.id);return[await o.import(s,a)]}case"LookupTableFind":case"LookupTableFindV2":{const i=Kt("tableHandle",e,t,n,r),s=Kt("keys",e,t,n),a=Kt("defaultValue",e,t,n),o=r.getHashTableById(i.id);return[await o.find(s,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=Kt("tableHandle",e,t,n,r);return[r.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,r);case"custom":const i=Xt(e.op);if(i&&i.customExecutor)return i.customExecutor(new zn(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return S.D5U.isPromise(i)?i.then((e=>[].concat(e))):[].concat(i)}class Er{constructor(e={},t={},n={},r={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function Ar(e,t,n,r){const i=new Set,s=[];let a=null,o=null;const l=new Set,c=Object.keys(e).map((e=>en(e)[0]));let u=[];null!=r&&(u=r.map((e=>en(e.name)[0])));const h=[...t];for(;h.length>0;){const e=h.pop();(kr(e)||Rr(e)||Dr(e))&&null==a&&(a=e,o=a.children.map((e=>e.name)).filter((e=>i.has(e)))),i.add(e.name),null==n[e.name]&&-1===c.indexOf(e.name)&&-1===u.indexOf(e.name)&&(0!==e.inputs.length?e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),h.push(e))})):s.push(e.name))}return{inputs:e,outputs:t,usedNodes:i,missingInputs:s,dynamicNode:a,syncInputs:o}}const Cr=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Ir=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],Nr=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function kr(e){return Cr.indexOf(e.op)>=0}function Rr(e){return Ir.indexOf(e.op)>=0}function Dr(e){return Nr.indexOf(e.op)>=0}class Lr{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new Lr(e.functions[t],this)}))}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,t){const n=Ar(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:i,syncInputs:s}=n;if(null!=i)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(r.length>0){const n=t.map((e=>e.name)),i=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${i}]. Missing the following inputs: [${r}]`)}return function(e,t,n){const{usedNodes:r,inputs:i}=n,s=[],a=Object.keys(i).map((e=>en(e)[0])).map((t=>e.nodes[t])),o=e.initNodes;a.forEach((e=>{r.has(e.name)&&s.push(e)})),e.weights.forEach((e=>{r.has(e.name)&&s.push(e)})),null!=o&&o.forEach((e=>{r.has(e.name)&&s.push(e)}));const l=new Set,c=[];for(;s.length>0;){const e=s.pop();l.add(e.name),t[e.name]||c.push(e),e.children.forEach((e=>{!l.has(e.name)&&r.has(e.name)&&e.inputs.every((e=>l.has(e.name)))&&s.push(e)}))}return c}(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map((e=>this.graph.nodes[en(e)[0]])),i=t.map((e=>en(e)[0]));let s=i.map((e=>this.graph.nodes[e]));this.resetIntermediateTensors(),0===s.length&&(s=this._outputs);const a=this.getCompilationKey(r,s);let o=this.compiledMap.get(a);null==o&&(o=this.compile(e,s),this.compiledMap.set(a,o));const l={},c={};return(0,S.lub)((()=>{const n=new Er(this.weightMap,l,c,this.functionExecutorMap),r=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,i]=en(t),s=[];s[i]=e[t],r[n]=s}));const s=this.getFrozenTensorIds(r),a={};for(let e=0;e<o.length;e++){const t=o[e];if(!r[t.name]){const e=Tr(t,r,n,this._resourceManager);if(S.D5U.isPromise(e))throw new Error(`The execution of the op '${t.op}' returned a promise. Please use model.executeAsync() instead.`);r[t.name]=e,this.checkTensorForDisposal(t.name,t,r,n,s,i,a)}}return null==this.parent&&n.dispose(s),t.map((e=>Zt(e,r,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,i,s,a){"control"!==t.category&&-1===s.indexOf(e)&&(n[e].forEach((e=>{null!=e&&(a[e.id]=(a[e.id]||0)+t.children.length)})),t.inputs.forEach((e=>{if("control"!==e.category){const s=function(e,t,n){return t[Qt(e,n.currentContextId)]}(e.name,n,r);null!=s&&s.forEach((e=>{if(e&&!e.kept&&!i.has(e.id)){const n=a[e.id];if(1===n){if(this.keepTensorForDebug){const[n,i]=Jt(t.name,r);this.intermediateTensors[n]||(this.intermediateTensors[n]=[]),this.intermediateTensors[n][i]=e}else e.dispose();delete a[e.id]}else null!=n&&a[e.id]--}}))}})))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.intermediateTensors&&(Object.keys(this.intermediateTensors).forEach((e=>this.intermediateTensors[e].forEach((e=>e.dispose())))),this.disposeTensorsMap())}disposeTensorsMap(){this.tensorsMap&&Object.keys(this.tensorsMap).forEach((e=>{this.tensorsMap[e].forEach((e=>{!e||e.kept||e.isDisposed||this.keepIds.has(e.id)||e.dispose()}))}))}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors)this.intermediateTensors[e].forEach((e=>e.dispose())),delete this.intermediateTensors[e]}async _executeAsync(e,t,n=!1,r={},i={}){n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepTensorForDebug=(0,S.OBj)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){console.warn(e.message)}this.resetIntermediateTensors();const s=new Er(this.weightMap,r,i,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,s,t,n);const a=t.map((e=>Zt(e,this.tensorsMap,s))),o=a.map((e=>e.id)),l=Object.keys(e).map((t=>e[t].id));return this.keepIds=new Set([...o,...l,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),null==this.parent&&s.dispose(this.keepIds),a}async executeFunctionAsync(e,t,n){const r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){const i=Object.keys(e),s=i.map((e=>this.graph.nodes[en(e)[0]])),a=n.map((e=>en(e)[0]));let o=a.map((e=>this.graph.nodes[e]));0===o.length&&(o=this._outputs);const{usedNodes:l,missingInputs:c,dynamicNode:u,syncInputs:h}=Ar(e,o,this.weightMap,this._initNodes),d=[...s,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),p=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,r]=en(t),i=[];i[r]=e[t],p[n]=i}));const f={},m=this.getFrozenTensorIds(p),g={};for(;d.length>0;){const e=this.processStack(s,d,t,p,g,m,a,f,l);await Promise.all(e)}null!=u||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const y=o.filter((e=>!kr(e)&&!Zt(e.name,p,t))).map((e=>e.name));if(y.length>0){let e="";throw null!=u&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${y}] from the provided inputs [${i}]. Consider providing the following inputs: [${c}]. ${e}`)}return p}processStack(e,t,n,r,i,s,a,o,l){const c=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let u="";if("Enter"===e.node.op&&Kt("isConstant",e.node,r,n)&&([u]=Jt(e.node.name,n)),null==r[e.node.name]){const h=Tr(e.node,r,n,this._resourceManager);u||([u]=Jt(e.node.name,n));const d=n.currentContext;S.D5U.isPromise(h)?c.push(h.then((c=>(r[u]=c,n.currentContext=d,this.checkTensorForDisposal(u,e.node,r,n,s,a,o),this.processChildNodes(e.node,t,n,r,i,l),c)))):(r[u]=h,this.checkTensorForDisposal(u,e.node,r,n,s,a,o),this.processChildNodes(e.node,t,n,r,i,l))}else this.processChildNodes(e.node,t,n,r,i,l)}return c}processChildNodes(e,t,n,r,i,s){e.children.forEach((e=>{const[a]=Jt(e.name,n);!i[a]&&s.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!Zt(e,r,n)))&&(i[a]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!Zt(e,r,n)))&&(i[a]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t],[r]=en(t),i=this.graph.nodes[r];if(i.attrParams.shape&&i.attrParams.shape.value){const e=i.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t));S.D5U.assert(t,(()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}i.attrParams.dtype&&i.attrParams.dtype.value&&S.D5U.assert(n.dtype===i.attrParams.dtype.value,(()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){const t={};for(const n in e)null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[n]?t[this._signature.inputs[n].name]=e[n]:t[n]=e[n];return t}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=en(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]?this._signature.outputs[e].name:e),{})}checkOutputs(e){e.forEach((e=>{const[t]=en(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}}class Fr{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}class Pr{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",null==t&&(this.loadOptions={}),this.resourceManager=new Fr}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=S.io.browserHTTPRequest(e,this.loadOptions);else{const t=S.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(S.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return S.D5U.isPromise(e)?e.then((e=>this.loadSync(e))):this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let n;n=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const r=S.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Lr(Sn.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=Sn.Instance.transformGraph(e.modelInitializer);this.initializer=new Lr(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if("string"==typeof e){const t=S.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof S.esB||Array.isArray(e)))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce(((t,n,r)=>(t[n]=e[r],t)),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function Or(e,t={}){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof e&&(e=function(e){return e.endsWith("/")||(e+="/"),`${e}model.json?tfjs-format=file`}(e));const n=new Pr(e,t);return await n.load(),n}function zr(e){if(null==e)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide a url or an IOHandler that loads the model");if(!e.load)throw new Error(`modelUrl IO Handler ${e} has no load function`);const t=new Pr(e);return t.load(),t}const Br="3.18.0";var Ur=n(5934);function $r(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&S.D5U.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}const Vr=S.GDt.whereImpl;class Wr extends S.Zuw{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new S.JLz(this,(0,S.SRH)())}nextDataId(){return Wr.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,(0,S.OBj)().get("IS_NODE")&&S.Wap.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&S.D5U.isString(n[0])){const i=n.map((e=>S.D5U.encodeString(e)));r=this.write(i,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,t,n,r,i){this.data.set(e,{values:t,dtype:r,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){const e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return S.Wap.mergeRealAndImagArrays(e,t)}return this.data.get(e).values}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>S.D5U.decodeString(e)));return(0,S.f3b)(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,S.f3b)(e.shape,e.dtype,t)}makeOutput(e,t,n){return(0,S.SRH)().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=S.D5U.now();return e(),{kernelMs:S.D5U.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){$r([e],"where");const t=this.readSync(e.dataId);return Vr(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function Gr(e,t,n){return({inputs:r,attrs:i,backend:s})=>{const{x:a}=r;if($r(a,e),"string"===a.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const o=s,l=o.data.get(a.dataId).values,c=S.D5U.sizeFromShape(a.shape),u=n||a.dtype,h=S.D5U.getArrayFromDType(u,c);for(let e=0;e<c;++e)h[e]=t(l[e],i);return o.makeTensorInfo(a.shape,u,h)}}function Hr(e,t,n){return({inputs:r,attrs:i,backend:s})=>{const{x:a}=r;if($r(a,e),"string"===a.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const o=s,l=o.data.get(a.dataId).values,c=n||a.dtype,u=t(l,c,i);return o.makeTensorInfo(a.shape,c,u)}}Wr.nextDataId=0,(0,S.jqO)("cpu",(()=>new Wr),1);const jr=Gr(S.SX0,(e=>e>=0?e:Math.exp(e)-1)),qr={kernelName:S.SX0,backendName:"cpu",kernelFunc:jr};function Xr(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Yr={kernelName:S.iJz,backendName:"cpu",kernelFunc:Xr};function Kr(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{alpha:s}=r;$r([i],"leakyRelu");const a=S.D5U.sizeFromShape(i.shape),o=n.data.get(i.dataId).values,l=S.D5U.getTypedArrayFromDType("float32",a);for(let e=0;e<o.length;e++)l[e]=o[e]<0?s*o[e]:o[e];return n.makeTensorInfo(i.shape,"float32",l)}const Zr={kernelName:S.J$2,backendName:"cpu",kernelFunc:Kr};function Jr(e){return(t,n,r,i,s)=>{const a=S.Wap.assertAndGetBroadcastShape(t,n),o=a.length,l=S.D5U.computeStrides(a),c=S.D5U.sizeFromShape(a),u=S.D5U.getTypedArrayFromDType(s,c),h=t.length,d=n.length,p=S.D5U.computeStrides(t),f=S.D5U.computeStrides(n),m=S.Wap.getBroadcastDims(t,a),g=S.Wap.getBroadcastDims(n,a);if(m.length+g.length===0)for(let t=0;t<u.length;++t)u[t]=e(r[t%r.length],i[t%i.length]);else for(let t=0;t<u.length;++t){const n=S.D5U.indexToLoc(t,o,l),s=n.slice(-h);m.forEach((e=>s[e]=0));const a=S.D5U.locToIndex(s,h,p),c=n.slice(-d);g.forEach((e=>c[e]=0));const y=S.D5U.locToIndex(c,d,f);u[t]=e(r[a],i[y])}return[u,a]}}const Qr=Jr(((e,t)=>e<0?t*e:e));function ei(e){const{inputs:t,backend:n}=e,{x:r,alpha:i}=t;$r([r,i],"prelu");const s=n.data.get(r.dataId).values,a=n.data.get(i.dataId).values,[o,l]=Qr(r.shape,i.shape,s,a,"float32");return n.makeTensorInfo(l,"float32",o)}const ti={kernelName:S.o0g,backendName:"cpu",kernelFunc:ei},ni=Gr(S.qkr,(e=>Math.max(0,e))),ri={kernelName:S.qkr,backendName:"cpu",kernelFunc:ni},ii=Gr(S.SbG,(e=>Math.min(Math.max(0,e),6))),si={kernelName:S.SbG,backendName:"cpu",kernelFunc:ii};function ai(e){return(t,n,r)=>{const i=S.D5U.getTypedArrayFromDType(n,t.length);for(let n=0;n<t.length;++n)i[n]=e(t[n],r);return i}}const oi=ai((e=>1/(1+Math.exp(-e)))),li=Gr(S.a5O,(e=>1/(1+Math.exp(-e)))),ci={kernelName:S.a5O,backendName:"cpu",kernelFunc:li};function ui(e,t,n,r,i){if("linear"===n)return Xr({inputs:{x:t},backend:e});if("relu"===n)return ni({inputs:{x:t},backend:e});if("elu"===n)return jr({inputs:{x:t},backend:e});if("relu6"===n)return ii({inputs:{x:t},backend:e});if("prelu"===n)return ei({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return Kr({inputs:{x:t},backend:e,attrs:{alpha:i}});if("sigmoid"===n)return li({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function hi(e){const{inputs:t,backend:n}=e,{real:r,imag:i}=t,s=n.data.get(r.dataId).values,a=n.data.get(i.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(i.shape,"float32",a)},o}const di={kernelName:S.Zz9,backendName:"cpu",kernelFunc:hi};function pi(e,t,n="float32"){if("complex64"===n)return hi({inputs:{real:pi(e,t,"float32"),imag:pi(e,t,"float32")},backend:e});const r=S.D5U.makeZerosTypedArray(S.D5U.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function fi(e){const{inputs:t,backend:n}=e,{input:r}=t,i=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(i.dataId).values;return n.makeTensorInfo(i.shape,i.dtype,s)}const mi={kernelName:S.xJR,backendName:"cpu",kernelFunc:fi};function gi(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===i.dtype)return Xr({inputs:{x:i},backend:n});const e=pi(n,i.shape,i.dtype),t=gi({inputs:{x:i},backend:n,attrs:{dtype:"float32"}}),r=hi({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===i.dtype){const e=fi({inputs:{input:i},backend:n}),t=gi({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!S.D5U.hasEncodingLoss(i.dtype,s)){const e=Xr({inputs:{x:i},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}if("int32"===s){const e=n.data.get(i.dataId).values,t=Int32Array.from(e);return n.makeTensorInfo(i.shape,"int32",t)}if("bool"===s){const e=n.data.get(i.dataId).values,t=S.D5U.toTypedArray([0],i.dtype),[r,s]=Jr(((e,t)=>e!==t?1:0))(i.shape,[],e,t,"bool");return n.makeTensorInfo(s,"bool",r)}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${s}`)}const yi={kernelName:S.RFZ,backendName:"cpu",kernelFunc:gi};function vi(e,t,n,r){return null==n?({inputs:n,backend:i})=>{const{a:s,b:a}=n,o=i;$r([s,a],e);const l=o.data.get(s.dataId).values,c=o.data.get(a.dataId).values,u="string"===s.dtype?S.Wap.fromUint8ToStringArray(l):l,h="string"===s.dtype?S.Wap.fromUint8ToStringArray(c):c,d=r||s.dtype,[p,f]=t(s.shape,a.shape,u,h,d);return o.makeTensorInfo(f,d,p)}:({inputs:e,backend:i})=>{const{a:s,b:a}=e,o=i;if("complex64"===s.dtype||"complex64"===a.dtype){const e=gi({inputs:{x:s},backend:o,attrs:{dtype:"complex64"}}),t=o.data.get(e.dataId),r=t.complexTensorInfos.real,i=t.complexTensorInfos.imag,l=o.data.get(r.dataId).values,c=o.data.get(i.dataId).values,u=gi({inputs:{x:a},backend:o,attrs:{dtype:"complex64"}}),h=o.data.get(u.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,f=o.data.get(d.dataId).values,m=o.data.get(p.dataId).values,[g,y,v]=n(s.shape,a.shape,l,c,f,m),x=o.makeTensorInfo(v,"float32",g),b=o.makeTensorInfo(v,"float32",y),w=hi({inputs:{real:x,imag:b},backend:o});return o.disposeIntermediateTensorInfo(e),o.disposeIntermediateTensorInfo(u),o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo(b),w}{const e=o.data.get(s.dataId).values,n=o.data.get(a.dataId).values,i=r||s.dtype,[l,c]=t(s.shape,a.shape,e,n,i);return o.makeTensorInfo(c,i,l)}}}function xi(e){return(t,n,r,i,s,a)=>{const o=S.Wap.assertAndGetBroadcastShape(t,n),l=S.D5U.sizeFromShape(o),c=o.length,u=S.D5U.computeStrides(o),h=S.D5U.getTypedArrayFromDType("float32",l),d=S.D5U.getTypedArrayFromDType("float32",l),p=S.Wap.getBroadcastDims(t,o),f=S.Wap.getBroadcastDims(n,o),m=S.Wap.mergeRealAndImagArrays(r,i),g=S.Wap.mergeRealAndImagArrays(s,a),y=t.length,v=S.D5U.computeStrides(t),x=n.length,b=S.D5U.computeStrides(n);if(p.length+f.length===0)for(let t=0;t<h.length;t++){const n=t%m.length,r=t%g.length,i=e(m[2*n],m[2*n+1],g[2*r],g[2*r+1]);h[t]=i.real,d[t]=i.imag}else for(let t=0;t<h.length;t++){const n=S.D5U.indexToLoc(t,c,u),r=n.slice(-y);p.forEach((e=>r[e]=0));const i=S.D5U.locToIndex(r,y,v),s=n.slice(-x);f.forEach((e=>s[e]=0));const a=S.D5U.locToIndex(s,x,b),o=e(m[2*i],m[2*i+1],g[2*a],g[2*a+1]);h[t]=o.real,d[t]=o.imag}return[h,d,o]}}const bi=Jr(((e,t)=>e+t)),wi=xi(((e,t,n,r)=>({real:e+n,imag:t+r}))),_i=vi(S.mm_,bi,wi),Si={kernelName:S.mm_,backendName:"cpu",kernelFunc:_i};function Mi(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{shape:s}=r,a=S.D5U.sizeFromShape(i.shape),o=S.D5U.inferFromImplicitShape(s,a),l=S.D5U.sizeFromShape(o);S.D5U.assert(a===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${i.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(i.dataId);const c=n.data.get(i.dataId);if(null!=c.complexTensorInfos){const e=c.complexTensorInfos.real,t=c.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:i.dataId,shape:o,dtype:i.dtype}}const Ti={kernelName:S.HZH,backendName:"cpu",kernelFunc:Mi};function Ei(e){const{inputs:t,backend:n,attrs:r}=e,{a:i,b:s}=t,{transposeA:a,transposeB:o}=r;$r([i,s],"matMul");const l=i.shape.length,c=s.shape.length,u=a?i.shape[l-2]:i.shape[l-1],h=o?s.shape[c-1]:s.shape[c-2],d=a?i.shape[l-1]:i.shape[l-2],p=o?s.shape[c-2]:s.shape[c-1],f=i.shape.slice(0,-2),m=s.shape.slice(0,-2),g=S.D5U.sizeFromShape(f),y=S.D5U.sizeFromShape(m),v=S.Jyw.assertAndGetBroadcastShape(i.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,p]);S.D5U.assert(u===h,(()=>`Error in matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${i.shape} and ${s.shape} and transposeA=${a} and transposeB=${o} must match.`));const x=o?[y,p,h]:[y,h,p],b=Mi({inputs:{x:i},backend:n,attrs:{shape:a?[g,u,d]:[g,d,u]}}),w=Mi({inputs:{x:s},backend:n,attrs:{shape:x}}),_=a?b.shape[1]:b.shape[2],M=a?b.shape[2]:b.shape[1],T=o?w.shape[1]:w.shape[2],E=Math.max(g,y),A=n.data.get(b.dataId).values,C=n.data.get(w.dataId).values,I=S.D5U.computeStrides(b.shape),N=S.D5U.computeStrides(w.shape),[k,R,D]=a?[I[0],1,I[1]]:[I[0],I[1],1],[L,F,P]=o?[1,N[1],N[0]]:[N[1],1,N[0]],O=M*T,z=(0,S.f3b)([E,M,T],b.dtype),B=z.values,U=n.blockSize;for(let e=0;e<E;e++)for(let t=0;t<M;t+=U)for(let n=0;n<T;n+=U)for(let r=0;r<_;r+=U){const i=Math.min(t+U,M),s=Math.min(n+U,T),a=Math.min(r+U,_);for(let o=t;o<i;o++)for(let t=n;t<s;t++){let n=0;for(let i=r;i<a;i++){const r=Math.min(e,g-1)*k,s=Math.min(e,y-1)*P;n+=A[r+o*R+i*D]*C[i*L+t*F+s]}B[e*O+(o*T+t)]+=n}}return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(v,z.dtype,z.values)}const Ai={kernelName:S.XLW,backendName:"cpu",kernelFunc:Ei},Ci={kernelName:S.usg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:i,b:s,bias:a,preluActivationWeights:o}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;let d,p,f;const m=[];d=Ei({inputs:{a:i,b:s},attrs:{transposeA:l,transposeB:c},backend:n}),a&&(p=_i({inputs:{a:d,b:a},backend:n}),m.push(d),d=p),u&&(f=ui(n,d,u,o,h),m.push(d),d=f);for(const e of m)n.disposeIntermediateTensorInfo(e);return d}};function Ii(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const Ni={kernelName:S.SYM,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;$r(t,"abs");let r=new Float32Array(S.D5U.sizeFromShape(t.shape));return r=Ii(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}},ki=Gr(S.VGw,(e=>Math.acos(e))),Ri={kernelName:S.VGw,backendName:"cpu",kernelFunc:ki},Di=Gr(S.SpW,(e=>Math.acosh(e))),Li={kernelName:S.SpW,backendName:"cpu",kernelFunc:Di},Fi={kernelName:S.Xze,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;$r(t,"addN");const i=r.map((e=>n.data.get(e.dataId).values)),s=(0,S.f3b)(r[0].shape,r[0].dtype),a=s.values;for(let e=0;e<r.length;e++){const t=i[e];for(let e=0;e<a.length;e++)a[e]+=t[e]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}};function Pi(e,t,n,r,i){const s=t.length,a=S.D5U.sizeFromShape(t),o=S.D5U.computeStrides(t),l=S.D5U.computeStrides(i),c=S.D5U.getTypedArrayFromDType(n,S.D5U.sizeFromShape(i));for(let t=0;t<a;++t){const n=S.D5U.indexToLoc(t,s,o),i=new Array(n.length);for(let e=0;e<i.length;e++)i[e]=n[r[e]];c[S.D5U.locToIndex(i,s,l)]=e[t]}return c}function Oi(e){const{inputs:t,attrs:n,backend:r}=e,{x:i}=t,{perm:s}=n;$r(i,"transpose");const a=i.shape.length,o=new Array(a);for(let e=0;e<o.length;e++)o[e]=i.shape[s[e]];const l=Pi(r.data.get(i.dataId).values,i.shape,i.dtype,s,o);return{dataId:r.write(l,o,i.dtype),shape:o,dtype:i.dtype}}const zi={kernelName:S.G3Y,backendName:"cpu",kernelFunc:Oi},Bi={kernelName:S.oT6,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,keepDims:a}=r;$r(i,"all");const o=S.D5U.parseAxisParam(s,i.shape);let l=o;const c=S.Wap.getAxesPermutation(l,i.shape.length);let u=i;null!=c&&(u=Oi({inputs:{x:i},backend:n,attrs:{perm:c}}),l=S.Wap.getInnerMostAxes(l.length,i.shape.length)),S.Wap.assertAxesAreInnerMostDims("all",l,u.shape.length);const[h,d]=S.Wap.computeOutAndReduceShapes(u.shape,l),p=S.D5U.sizeFromShape(d),f=S.D5U.makeZerosTypedArray(S.D5U.sizeFromShape(h),u.dtype),m=n.data.get(u.dataId).values;for(let e=0;e<f.length;++e){const t=e*p;let n=m[t];for(let e=0;e<p;++e){const r=m[t+e];n=n&&r}f[e]=n}null!=c&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(h,u.dtype,f);if(a){const e=Mi({inputs:{x:g},backend:n,attrs:{shape:S.Wap.expandShapeToKeepDim(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},Ui={kernelName:S.IKK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,keepDims:a}=r;$r(i,"any");const o=S.D5U.parseAxisParam(s,i.shape);let l=o;const c=S.Wap.getAxesPermutation(l,i.shape.length);let u=i;null!=c&&(u=Oi({inputs:{x:i},backend:n,attrs:{perm:c}}),l=S.Wap.getInnerMostAxes(l.length,i.shape.length)),S.Wap.assertAxesAreInnerMostDims("any",l,u.shape.length);const[h,d]=S.Wap.computeOutAndReduceShapes(u.shape,l),p=S.D5U.sizeFromShape(d),f=S.D5U.makeZerosTypedArray(S.D5U.sizeFromShape(h),u.dtype),m=n.data.get(u.dataId).values;for(let e=0;e<f.length;++e){const t=e*p;let n=m[t];for(let e=0;e<p;++e){const r=m[t+e];n=n||r}f[e]=n}null!=c&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(h,u.dtype,f);if(a){const e=Mi({inputs:{x:g},backend:n,attrs:{shape:S.Wap.expandShapeToKeepDim(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},$i={kernelName:S.sJF,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s}=r;$r(i,"argMax");let a=S.D5U.parseAxisParam(s,i.shape);const o=S.Wap.getAxesPermutation(a,i.shape.length);let l=i;const c=[];null!=o&&(l=Oi({inputs:{x:i},backend:n,attrs:{perm:o}}),c.push(l),a=S.Wap.getInnerMostAxes(a.length,l.shape.length)),a=[a[0]],S.Wap.assertAxesAreInnerMostDims("argMax",a,l.shape.length);const[u,h]=S.Wap.computeOutAndReduceShapes(l.shape,a),d=S.D5U.sizeFromShape(u),p=S.D5U.makeZerosTypedArray(d,"int32"),f=S.D5U.sizeFromShape(h),m=n.data.get(l.dataId).values;for(let e=0;e<p.length;++e){const t=e*f;let n=m[t],r=0;for(let e=0;e<f;++e){const i=m[t+e];i>n&&(n=i,r=e)}p[e]=r}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u,"int32",p)}},Vi={kernelName:S.aJk,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s}=r;$r(i,"argMin");let a=S.D5U.parseAxisParam(s,i.shape);const o=S.Wap.getAxesPermutation(a,i.shape.length);let l=i;const c=[];null!=o&&(l=Oi({inputs:{x:i},backend:n,attrs:{perm:o}}),c.push(l),a=S.Wap.getInnerMostAxes(a.length,l.shape.length)),a=[a[0]],S.Wap.assertAxesAreInnerMostDims("argMin",a,l.shape.length);const[u,h]=S.Wap.computeOutAndReduceShapes(l.shape,a),d=S.D5U.sizeFromShape(u),p=S.D5U.makeZerosTypedArray(d,"int32"),f=S.D5U.sizeFromShape(h),m=n.data.get(l.dataId).values;for(let e=0;e<p.length;++e){const t=e*f;let n=m[t],r=0;for(let e=0;e<f;++e){const i=m[t+e];i<n&&(n=i,r=e)}p[e]=r}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u,"int32",p)}},Wi=Gr(S.M2y,(e=>Math.asin(e))),Gi={kernelName:S.M2y,backendName:"cpu",kernelFunc:Wi},Hi=Gr(S.qw7,(e=>Math.asinh(e))),ji={kernelName:S.qw7,backendName:"cpu",kernelFunc:Hi},qi=Gr(S.jMg,(e=>Math.atan(e))),Xi={kernelName:S.jMg,backendName:"cpu",kernelFunc:qi},Yi=Jr(((e,t)=>Math.atan2(e,t))),Ki=vi(S.QCc,Yi),Zi={kernelName:S.QCc,backendName:"cpu",kernelFunc:Ki},Ji=Gr(S.Oyi,(e=>Math.atanh(e))),Qi={kernelName:S.Oyi,backendName:"cpu",kernelFunc:Ji};function es(e,t,n,r,i,s){const a=i.strideHeight,o=i.strideWidth,l=i.dilationHeight,c=i.dilationWidth,u=i.effectiveFilterHeight,h=i.effectiveFilterWidth,d=i.padInfo.top,p=i.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=(0,S.f3b)(i.outShape,n),g=m.values,y=i.outShape[1]*i.outShape[2]*i.outShape[3],v=i.outShape[2]*i.outShape[3],x=i.outShape[3];for(let t=0;t<i.batchSize;++t){const n=t*y,m=t*r[0];for(let t=0;t<i.inChannels;++t)for(let y=0;y<i.outHeight;++y){const b=y*a-d,w=Math.max(0,b),_=Math.min(i.inHeight,u+b),S=n+y*v;for(let n=0;n<i.outWidth;++n){const a=n*o-p,u=Math.max(0,a),d=Math.min(i.inWidth,h+a);let y=f,v=0,b=0;for(let n=w;n<_;n+=l){const i=m+n*r[1];for(let n=u;n<d;n+=c){const a=e[i+n*r[2]+t];"max"===s&&a>y?y=a:"avg"===s&&(v+=a,b++)}if(isNaN(y))break}g[S+n*x+t]="avg"===s?v/b:y}}}return m}function ts(e,t,n,r,i=!1,s=!1){const a=(0,S.f3b)(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,u=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=(0,S.f3b)(t,n,e);for(let e=0;e<r.batchSize;++e)for(let t=0;t<r.inChannels;++t)for(let n=0;n<r.outHeight;++n){const g=n*o-p;let y=g;for(;y<0;)y+=c;const v=Math.min(r.inHeight,h+g);for(let o=0;o<r.outWidth;++o){const h=o*l-f;let p=h;for(;p<0;)p+=u;const x=Math.min(r.inWidth,d+h);let b=Number.NEGATIVE_INFINITY,w=-1;for(let n=y;n<v;n+=c){const a=n-g;for(let o=p;o<x;o+=u){const l=o-h,c=m.get(e,n,o,t);c>b&&(b=c,w=i?s?((e*r.inHeight+n)*r.inWidth+o)*r.inChannels+t:(n*r.inWidth+o)*r.inChannels+t:a*d+l)}}a.set(w,e,n,o,t)}}return a}function ns(e,t,n,r,i,s){const a=i.strideDepth,o=i.strideHeight,l=i.strideWidth,c=i.dilationDepth,u=i.dilationHeight,h=i.dilationWidth,d=i.effectiveFilterDepth,p=i.effectiveFilterHeight,f=i.effectiveFilterWidth,m=i.padInfo.front,g=i.padInfo.top,y=i.padInfo.left,v="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=(0,S.f3b)(i.outShape,n),b=x.values,w=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],_=i.outShape[2]*i.outShape[3]*i.outShape[4],M=i.outShape[3]*i.outShape[4],T=i.outShape[4];for(let t=0;t<i.batchSize;++t){const n=t*w,x=t*r[0];for(let t=0;t<i.inChannels;++t)for(let w=0;w<i.outDepth;++w){const S=w*a-m;let E=S;for(;E<0;)E+=c;const A=Math.min(i.inDepth,d+S),C=n+w*_;for(let n=0;n<i.outHeight;++n){const a=n*o-g;let d=a;for(;d<0;)d+=u;const m=Math.min(i.inHeight,p+a),w=C+n*M;for(let n=0;n<i.outWidth;++n){const a=n*l-y;let o=a;for(;o<0;)o+=h;const p=Math.min(i.inWidth,f+a),g=w+n*T;let _=v,S=0,M=0;for(let n=E;n<A;n+=c){const i=x+n*r[1];for(let n=d;n<m;n+=u){const a=i+n*r[2];for(let n=o;n<p;n+=h){const i=e[a+n*r[3]+t];if("max"===s&&i>_?_=i:"avg"===s&&(S+=i,M++),isNaN(_))break}if(isNaN(_))break}if(isNaN(_))break}b[g+t]="avg"===s?S/M:_}}}}return x}const rs={kernelName:S.JhU,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t;$r(i,"avgPool");const{filterSize:s,strides:a,pad:o,dimRoundingMode:l}=r;S.D5U.assert(S.Wap.eitherStridesOrDilationsAreOne(a,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`));const c=S.Wap.computePool2DInfo(i.shape,s,a,1,o,l);let u;if(1===c.filterWidth&&1===c.filterHeight&&S.D5U.arraysEqual(c.inShape,c.outShape))u=Xr({inputs:{x:i},backend:n});else{const e=n.data.get(i.dataId).values,t=S.D5U.computeStrides(i.shape),r=es(e,i.shape,i.dtype,t,c,"avg");u=n.makeTensorInfo(c.outShape,i.dtype,r.values)}return u}},is={kernelName:S._k9,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{filterSize:s,strides:a,pad:o,dimRoundingMode:l,dataFormat:c}=r;$r(i,"avgPool3d");const u=S.Wap.computePool3DInfo(i.shape,s,a,1,o,l,c),h=ns(n.data.get(i.dataId).values,i.shape,i.dtype,S.D5U.computeStrides(i.shape),u,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}},ss={kernelName:S.IMb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:i,input:s}=t,{filterSize:a,strides:o,pad:l,dimRoundingMode:c}=r;$r([i,s],"avgPool3DGrad");const u=S.Wap.computePool3DInfo(s.shape,a,o,1,l,c),h=u.strideDepth,d=u.strideHeight,p=u.strideWidth,f=u.filterDepth,m=u.filterHeight,g=u.filterWidth,y=u.dilationDepth,v=u.dilationHeight,x=u.dilationWidth,b=u.effectiveFilterDepth,w=u.effectiveFilterHeight,_=u.effectiveFilterWidth,M=b-1-u.padInfo.front,T=_-1-u.padInfo.left,E=w-1-u.padInfo.top,A=(0,S.f3b)(s.shape,"float32"),C=1/(f*m*g),I=n.bufferSync(i);for(let e=0;e<u.batchSize;++e)for(let t=0;t<u.inChannels;++t)for(let n=0;n<u.inDepth;++n)for(let r=0;r<u.inHeight;++r)for(let i=0;i<u.inWidth;++i){const s=n-M,a=r-E,o=i-T;let l=0;for(let n=0;n<b;n+=y){const r=(s+n)/h;if(!(r<0||r>=u.outDepth||Math.floor(r)!==r))for(let n=0;n<w;n+=v){const i=(a+n)/d;if(!(i<0||i>=u.outHeight||Math.floor(i)!==i))for(let n=0;n<_;n+=x){const s=(o+n)/p;s<0||s>=u.outWidth||Math.floor(s)!==s||(l+=I.get(e,r,i,s,t))}}}A.set(l*C,e,n,r,i,t)}return n.makeTensorInfo(A.shape,A.dtype,A.values)}},as={kernelName:S.ROF,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:i,input:s}=t,a=s;$r([i,s],"avgPoolGrad");const{filterSize:o,strides:l,pad:c}=r,u=S.Wap.computePool2DInfo(a.shape,o,l,1,c),h=u.strideHeight,d=u.strideWidth,p=u.filterHeight,f=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,y=u.effectiveFilterHeight,v=u.effectiveFilterWidth,x=v-1-u.padInfo.left,b=y-1-u.padInfo.top,w=(0,S.f3b)(a.shape,"float32"),_=1/(p*f),M=n.data.get(i.dataId).values,T=(0,S.f3b)(i.shape,"float32",M);for(let e=0;e<u.batchSize;++e)for(let t=0;t<u.inChannels;++t)for(let n=0;n<u.inHeight;++n)for(let r=0;r<u.inWidth;++r){const i=n-b,s=r-x;let a=0;for(let n=0;n<y;n+=m){const r=(i+n)/h;if(!(r<0||r>=u.outHeight||Math.floor(r)!==r))for(let n=0;n<v;n+=g){const i=(s+n)/d;i<0||i>=u.outWidth||Math.floor(i)!==i||(a+=T.get(e,r,i,t))}}w.set(a*_,e,n,r,t)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}},os={kernelName:S.sHE,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,scale:s,offset:a,mean:o,variance:l}=t;S.D5U.assert(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),S.D5U.assert(null==a||o.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),S.D5U.assert(null==s||o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),$r([i,o,l,s,a],"batchNorm");let{varianceEpsilon:c}=r;null==c&&(c=.001);const u=n.data.get(i.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(l.dataId).values,p=s?n.data.get(s.dataId).values:new Float32Array([1]),f=a?n.data.get(a.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=f.length,y=p.length,v=d.length,x=h.length;let b=0,w=0,_=0,M=0;for(let e=0;e<u.length;++e)m[e]=f[b++]+(u[e]-h[w++])*p[_++]/Math.sqrt(d[M++]+c),b>=g&&(b=0),w>=x&&(w=0),_>=y&&(_=0),M>=v&&(M=0);return n.makeTensorInfo(i.shape,i.dtype,m)}};function ls(e,t,n,r,i){const s=S.kuN.isSliceContinous(r,t,n),a=S.D5U.sizeFromShape(n),o=S.D5U.computeStrides(r);if(s){const n=S.kuN.computeFlatOffset(t,o);return"string"===i?e.slice(n,n+a):e.subarray(n,n+a)}const l="string"===i?S.Wap.fromUint8ToStringArray(e):e,c=(0,S.f3b)(r,i,l),u=(0,S.f3b)(n,i);for(let e=0;e<u.size;++e){const n=u.indexToLoc(e),r=n.map(((e,n)=>e+t[n]));u.set(c.get(...r),...n)}return"string"===i?S.Wap.fromStringArrayToUint8(u.values):u.values}function cs(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{begin:s,size:a}=r;$r(i,"slice");const[o,l]=S.kuN.parseSliceParams(i,s,a);S.kuN.assertParamsValid(i,o,l);const c=ls(n.data.get(i.dataId).values,o,l,i.shape,i.dtype);return n.makeTensorInfo(l,i.dtype,c)}const us={kernelName:S.p2w,backendName:"cpu",kernelFunc:cs},hs={kernelName:S.zws,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{blockShape:s,crops:a}=r;$r([i],"batchToSpaceND");const o=s.reduce(((e,t)=>e*t)),l=S.Wap.getReshaped(i.shape,s,o),c=S.Wap.getPermuted(l.length,s.length),u=S.Wap.getReshapedPermuted(i.shape,s,o),h=S.Wap.getSliceBeginCoords(a,s.length),d=S.Wap.getSliceSize(u,a,s.length),p=Mi({inputs:{x:i},backend:n,attrs:{shape:l}}),f=Oi({inputs:{x:p},backend:n,attrs:{perm:c}}),m=Mi({inputs:{x:f},backend:n,attrs:{shape:u}}),g=cs({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function ds(e,t,n,r,i){const s=S.D5U.sizeFromShape(r),a=S.D5U.makeZerosTypedArray(i,n);for(let n=0;n<e.length;n++){const r=e[n];if(r<0)throw new Error("Input x must be non-negative!");r>=i||(a[r]+=s>0?t[n]:1)}return a}function ps(e,t,n,r=!1){const i=e.shape[0],s=e.shape[1],a=(0,S.f3b)([i,n],t.dtype);for(let o=0;o<i;o++)for(let i=0;i<s;i++){const s=e.get(o,i);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?a.set(1,o,s):t.size>0?a.set(a.get(o,s)+t.get(o,i),o,s):a.set(a.get(o,s)+1,o,s))}return a}const fs={kernelName:S.zvY,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,weights:s}=t,{size:a}=r,o=ds(n.data.get(i.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,a);return n.makeTensorInfo([a],s.dtype,o)}},ms={kernelName:S.eEB,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:i}=t,s=n.data.get(r.dataId).values,a=n.data.get(i.dataId).values,o=S.Wap.assertAndGetBroadcastShape(Array.from(s),Array.from(a));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},gs=ai((e=>Math.ceil(e))),ys=Hr(S.gJX,gs),vs={kernelName:S.gJX,backendName:"cpu",kernelFunc:ys},xs=Gr(S.xnO,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),bs={kernelName:S.xnO,backendName:"cpu",kernelFunc:xs},ws={kernelName:S.yj2,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(S.D5U.sizeFromShape(t.shape)),i=n.data.get(t.dataId),s=i.complexTensorInfos.real,a=i.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values;for(let e=0;e<o.length;e++){const t=o[e],n=l[e];r[e]=Math.hypot(t,n)}return n.makeOutput(r,t.shape,"float32")}};function _s(e,t,n,r){const i=S.D5U.getArrayFromDType(n,S.D5U.sizeFromShape(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=S.D5U.sizeFromShape(e.shape);i.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const s="string"===n?S.Wap.fromUint8ToStringArray(e.vals):e.vals;let a=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)i[o+t]=s[a++]}r+=e.shape[1]}))}return i}function Ss(e){const{inputs:t,backend:n}=e,{input:r}=t,i=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(i.dataId).values;return n.makeTensorInfo(i.shape,i.dtype,s)}const Ms={kernelName:S.J_u,backendName:"cpu",kernelFunc:Ss};function Ts(e){const{inputs:t,backend:n,attrs:r}=e,{axis:i}=r,s=S.D5U.parseAxisParam(i,t[0].shape)[0];let a=S.Wap.computeOutShape(t.map((e=>e.shape)),s);if(0===S.D5U.sizeFromShape(a))return n.makeTensorInfo(a,t[0].dtype,[]);const o=t.filter((e=>S.D5U.sizeFromShape(e.shape)>0));if(1===o.length)return Xr({inputs:{x:o[0]},backend:n});const l=o.map((e=>e.shape));if(S.Wap.assertParamsConsistent(l,s),"complex64"===o[0].dtype){const e=o.map((e=>fi({inputs:{input:e},backend:n}))),t=o.map((e=>Ss({inputs:{input:e},backend:n}))),r=Ts({inputs:e,backend:n,attrs:{axis:s}}),i=Ts({inputs:t,backend:n,attrs:{axis:s}}),a=hi({inputs:{real:r,imag:i},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),a}const c=o.map((e=>{const t=S.D5U.sizeFromShape(e.shape.slice(s));return Mi({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),u=c.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));a=S.Wap.computeOutShape(c.map((e=>e.shape)),1);const h=1===c[0].shape[0],d=_s(u,a,t[0].dtype,h),p=S.Wap.computeOutShape(o.map((e=>e.shape)),s),f=n.makeTensorInfo(p,t[0].dtype,d);return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}const Es={kernelName:S.Eh3,backendName:"cpu",kernelFunc:Ts};function As(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:s}=t,{strides:a,pad:o,dataFormat:l,dilations:c,dimRoundingMode:u}=r;$r([i,s],"conv2d");const h=S.Wap.convertConv2DDataFormat(l),d=S.Wap.computeConv2DInfo(i.shape,s.shape,a,c,o,u,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,v=d.padInfo.top,x="channelsLast"===d.dataFormat,b=new S.YDk(d.outShape,i.dtype),w=S.D5U.computeStrides(i.shape),_=S.D5U.computeStrides(s.shape),M=w[0],T=x?w[1]:w[2],E=x?w[2]:1,A=x?1:w[1],C=b.strides[0],I=x?b.strides[1]:b.strides[2],N=x?b.strides[2]:1,k=x?1:b.strides[1],R=n.data.get(i.dataId).values,D=n.data.get(s.dataId).values,L=b.values;for(let e=0;e<d.batchSize;++e){const t=e*M,n=e*C;for(let e=0;e<d.outHeight;++e){const r=n+e*I,i=e*d.strideHeight-v;for(let e=0;e<p;++e){const n=i+e*m;if(n<0||n>=d.inHeight)continue;const s=e*_[0],a=t+n*T;for(let e=0;e<d.outWidth;++e){const t=r+e*N,n=e*d.strideWidth-y;for(let e=0;e<f;++e){const r=n+e*g;if(r<0||r>=d.inWidth)continue;const i=a+r*E;let o=s+e*_[1];for(let e=0;e<d.inChannels;++e){const n=R[i+e*A];for(let e=0;e<d.outChannels;++e)L[t+e*k]+=n*D[o+e];o+=d.outChannels}}}}}}return n.makeTensorInfo(b.shape,b.dtype,L)}const Cs={kernelName:S.mhS,backendName:"cpu",kernelFunc:As},Is={kernelName:S.wUP,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,dy:s}=t,{strides:a,pad:o,dataFormat:l,dimRoundingMode:c,filterShape:u}=r;$r([i,s],"conv2dBackpropFilter");const h=S.Wap.convertConv2DDataFormat(l),d=S.Wap.computeConv2DInfo(i.shape,u,a,1,o,c,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,y="channelsLast"===d.dataFormat,v=new S.YDk(d.filterShape,"float32"),x=d.padInfo.left,b=d.padInfo.top,w=n.data.get(i.dataId).values,_=n.data.get(s.dataId).values,M=new S.YDk(i.shape,i.dtype,w),T=new S.YDk(s.shape,s.dtype,_);for(let e=0;e<m;++e){const t=Math.max(0,Math.ceil((b-e)/p)),n=Math.min(d.outHeight,(d.inHeight+b-e)/p);for(let r=0;r<g;++r){const i=Math.max(0,Math.ceil((x-r)/f)),s=Math.min(d.outWidth,(d.inWidth+x-r)/f);for(let a=0;a<d.inChannels;++a)for(let o=0;o<d.outChannels;++o){let l=0;for(let c=0;c<d.batchSize;++c)for(let u=t;u<n;++u){const t=e+u*p-b;for(let e=i;e<s;++e){const n=r+e*f-x;l+=y?M.get(c,t,n,a)*T.get(c,u,e,o):M.get(c,a,t,n)*T.get(c,o,u,e)}}v.set(l,e,r,a,o)}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}},Ns={kernelName:S.wm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:i,filter:s}=t,{inputShape:a,strides:o,pad:l,dataFormat:c,dimRoundingMode:u}=r;$r([i,s],"conv2dBackpropInput");const h=S.D5U.computeStrides(s.shape),d=S.D5U.computeStrides(i.shape);let p=S.Wap.convertConv2DDataFormat(c);const f=S.Wap.computeConv2DInfo(a,s.shape,o,1,l,u,!1,p),m=new S.YDk(f.inShape,"float32"),g=m.values,y=n.data.get(i.dataId).values,v=n.data.get(s.dataId).values,[x,b,w]=h,{batchSize:_,filterHeight:M,filterWidth:T,inChannels:E,inHeight:A,inWidth:C,outChannels:I,outHeight:N,outWidth:k,strideHeight:R,strideWidth:D}=f;p=f.dataFormat;const L=M-1-f.padInfo.top,F=T-1-f.padInfo.left,P="channelsLast"===p,O=m.strides[0],z=P?m.strides[1]:m.strides[2],B=P?m.strides[2]:1,U=P?1:m.strides[1],$=d[0],V=P?d[1]:d[2],W=P?d[2]:1,G=P?1:d[1];for(let e=0;e<_;++e)for(let t=0;t<E;++t)for(let n=0;n<A;++n){const r=n-L,i=Math.max(0,Math.ceil(r/R)),s=Math.min(N,(M+r)/R);for(let a=0;a<C;++a){const o=a-F,l=Math.max(0,Math.ceil(o/D)),c=Math.min(k,(T+o)/D);let u=0;for(let n=i;n<s;++n){const i=n*R-r;for(let r=l;r<c;++r){const s=$*e+V*n+W*r,a=x*(M-1-i)+b*(T-1-(r*D-o))+w*t;for(let e=0;e<I;++e)u+=y[s+G*e]*v[a+e]}}g[O*e+z*n+B*a+U*t]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}},ks={kernelName:S.x12,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:s}=t,{strides:a,pad:o,dilations:l}=r;$r([i,s],"conv3d");const c=S.Wap.computeConv3DInfo(i.shape,s.shape,a,l,o),{filterDepth:u,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=c,y=g.front,v=g.left,x=g.top,b=new S.YDk(c.outShape,i.dtype),w=n.data.get(i.dataId).values,_=n.data.get(s.dataId).values,M=b.values,T=S.D5U.computeStrides(i.shape),E=S.D5U.computeStrides(s.shape);for(let e=0;e<c.batchSize;++e){const t=e*T[0],n=e*b.strides[0];for(let e=0;e<c.outDepth;++e){const r=n+e*b.strides[1],i=e*c.strideDepth-y;for(let e=0;e<u;++e){const n=i+e*p;if(n<0||n>=c.inDepth)continue;const s=e*E[0],a=t+n*T[1];for(let e=0;e<c.outHeight;++e){const t=r+e*b.strides[2],n=e*c.strideHeight-x;for(let e=0;e<h;++e){const r=n+e*f;if(r<0||r>=c.inHeight)continue;const i=s+e*E[1],o=a+r*T[2];for(let e=0;e<c.outWidth;++e){const n=t+e*c.outChannels,r=e*c.strideWidth-v;for(let e=0;e<d;++e){const t=r+e*m;if(t<0||t>=c.inWidth)continue;const s=i+e*E[2],a=o+t*c.inChannels;let l=s;for(let e=0;e<c.inChannels;++e){const t=w[a+e];for(let e=0;e<c.outChannels;++e)M[n+e]+=t*_[l+e];l+=c.outChannels}}}}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},Rs={kernelName:S.o2y,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,dy:s}=t,{strides:a,pad:o,filterShape:l}=r;$r([i,s],"conv3dBackpropFilterV2");const c=S.D5U.computeStrides(i.shape),u=S.D5U.computeStrides(s.shape),h=S.Wap.computeConv3DInfo(i.shape,l,a,1,o),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,v=new S.YDk(h.filterShape,"float32"),x=v.values,[b,w,_,M]=v.strides,T=n.data.get(s.dataId).values,[E,A,C,I]=u,N=n.data.get(i.dataId).values,[k,R,D,L]=c,F=h.padInfo.front,P=h.padInfo.left,O=h.padInfo.top;for(let e=0;e<m;++e){const t=Math.max(0,Math.ceil((F-e)/d)),n=Math.min(h.outDepth,(h.inDepth+F-e)/d),r=e*b;for(let i=0;i<g;++i){const s=Math.max(0,Math.ceil((O-i)/p)),a=Math.min(h.outHeight,(h.inHeight+O-i)/p),o=i*w+r;for(let r=0;r<y;++r){const l=Math.max(0,Math.ceil((P-r)/f)),c=Math.min(h.outWidth,(h.inWidth+P-r)/f),u=r*_+o;for(let o=0;o<h.inChannels;++o){const m=o*M+u;for(let u=0;u<h.outChannels;++u){let g=0;for(let m=0;m<h.batchSize;++m){const h=m*k,y=m*E;for(let m=t;m<n;++m){const t=(e+m*d-F)*R+h,n=m*A+y;for(let e=s;e<a;++e){const s=(i+e*p-O)*D+t,a=e*C+n;for(let e=l;e<c;++e){const t=e*I+a;g+=N[(r+e*f-P)*L+s+o]*T[t+u]}}}}x[m+u]=g}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}},Ds={kernelName:S.ik2,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:i,filter:s}=t,{pad:a,strides:o,inputShape:l}=r;$r([i],"conv3dBackpropInputV2");const c=S.D5U.computeStrides(i.shape),u=S.D5U.computeStrides(s.shape),h=S.Wap.computeConv3DInfo(l,s.shape,o,1,a),d=new S.YDk(h.inShape,"float32"),p=d.values,[f,m,g,y]=d.strides,v=n.data.get(i.dataId).values,[x,b,w,_]=c,M=n.data.get(s.dataId).values,[T,E,A,C]=u,{batchSize:I,filterDepth:N,filterHeight:k,filterWidth:R,inChannels:D,inDepth:L,inHeight:F,inWidth:P,outChannels:O,outDepth:z,outHeight:B,outWidth:U,strideDepth:$,strideHeight:V,strideWidth:W}=h,G=N-1-h.padInfo.front,H=k-1-h.padInfo.top,j=R-1-h.padInfo.left;for(let e=0;e<I;++e)for(let t=0;t<D;++t)for(let n=0;n<L;++n){const r=n-G,i=Math.max(0,Math.ceil(r/$)),s=Math.min(z,(N+r)/$);for(let a=0;a<F;++a){const o=a-H,l=Math.max(0,Math.ceil(o/V)),c=Math.min(B,(k+o)/V);for(let u=0;u<P;++u){const h=u-j,d=Math.max(0,Math.ceil(h/W)),S=Math.min(U,(R+h)/W);let I=0;for(let n=i;n<s;++n){const i=n*$-r;for(let r=l;r<c;++r){const s=r*V-o;for(let a=d;a<S;++a){const o=x*e+b*n+w*r+_*a,l=T*(N-1-i)+E*(k-1-s)+A*(R-1-(a*W-h))+C*t;for(let e=0;e<O;++e)I+=v[o+e]*M[l+e]}}}p[f*e+m*n+g*a+y*u+t]=I}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},Ls=Gr(S.mc4,(e=>Math.cos(e))),Fs={kernelName:S.mc4,backendName:"cpu",kernelFunc:Ls},Ps=Gr(S.TR1,(e=>Math.cosh(e))),Os={kernelName:S.TR1,backendName:"cpu",kernelFunc:Ps},zs={kernelName:S.VcC,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:i,boxes:s,boxInd:a}=t,{cropSize:o,method:l,extrapolationValue:c}=r,[u,h,d,p]=i.shape,f=s.shape[0],[m,g]=o,y=(0,S.f3b)([f,m,g,p],"float32"),v=n.data.get(s.dataId).values,x=n.data.get(a.dataId).values,b=n.data.get(i.dataId).values,w=S.D5U.computeStrides(i.shape),_=S.D5U.computeStrides(y.shape);for(let e=0;e<f;e++){const t=4*e,n=v[t],r=v[t+1],i=v[t+2],s=v[t+3],a=x[e];if(a>=u)continue;const o=m>1?(i-n)*(h-1)/(m-1):0,f=g>1?(s-r)*(d-1)/(g-1):0;for(let t=0;t<m;t++){const u=m>1?n*(h-1)+t*o:.5*(n+i)*(h-1);if(u<0||u>h-1)for(let n=0;n<g;n++)for(let r=0;r<p;r++){const i=r+n*_[2]+t*_[1]+e*_[0];y.values[i]=c}else if("bilinear"===l){const n=Math.floor(u),i=Math.ceil(u),o=u-n;for(let l=0;l<g;l++){const u=g>1?r*(d-1)+l*f:.5*(r+s)*(d-1);if(u<0||u>d-1){for(let n=0;n<p;n++){const r=n+l*_[2]+t*_[1]+e*_[0];y.values[r]=c}continue}const h=Math.floor(u),m=Math.ceil(u),v=u-h;for(let r=0;r<p;r++){let s=r+h*w[2]+n*w[1]+a*w[0];const c=b[s];s=r+m*w[2]+n*w[1]+a*w[0];const u=b[s];s=r+h*w[2]+i*w[1]+a*w[0];const d=b[s];s=r+m*w[2]+i*w[1]+a*w[0];const p=c+(u-c)*v,f=d+(b[s]-d)*v;s=r+l*_[2]+t*_[1]+e*_[0],y.values[s]=p+(f-p)*o}}}else for(let n=0;n<g;++n){const i=g>1?r*(d-1)+n*f:.5*(r+s)*(d-1);if(i<0||i>d-1){for(let r=0;r<p;r++){const i=r+n*_[2]+t*_[1]+e*_[0];y.values[i]=c}continue}const o=Math.round(i),l=Math.round(u);for(let r=0;r<p;r++){const i=r+o*w[2]+l*w[1]+a*w[0],s=r+n*_[2]+t*_[1]+e*_[0];y.values[s]=b[i]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},Bs={kernelName:S.Byc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,exclusive:a,reverse:o}=r;$r(i,"cumprod");const l=S.Wap.getAxesPermutation([s],i.shape.length);let c=i;null!=l&&(c=Oi({inputs:{x:i},backend:n,attrs:{perm:l}}));const u=S.Wap.getInnerMostAxes(1,i.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const h=(0,S.x8V)(c.dtype,"int32"),d=S.D5U.makeOnesTypedArray(S.D5U.sizeFromShape(c.shape),h),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let e=0;e<p.length;e+=f)for(let t=0;t<f;t++){const n=m(e,t);if(0===t)d[n]=a?1:p[n];else{const r=m(e,t-1);d[n]=a?p[r]*d[r]:p[n]*d[r]}}const g=n.makeTensorInfo(c.shape,h,d);if(null!=l){const e=Oi({inputs:{x:g},backend:n,attrs:{perm:S.Wap.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(c),e}return g}},Us={kernelName:S.iHb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,exclusive:a,reverse:o}=r;$r(i,"cumsum");const l=S.Wap.getAxesPermutation([s],i.shape.length);let c=i;null!=l&&(c=Oi({inputs:{x:i},backend:n,attrs:{perm:l}}));const u=S.Wap.getInnerMostAxes(1,i.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const h=(0,S.x8V)(c.dtype,"int32"),d=S.D5U.makeZerosTypedArray(S.D5U.sizeFromShape(c.shape),h),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let e=0;e<p.length;e+=f)for(let t=0;t<f;t++){const n=m(e,t);if(0===t)d[n]=a?0:p[n];else{const r=m(e,t-1);d[n]=a?p[r]+d[r]:p[n]+d[r]}}const g=n.makeTensorInfo(c.shape,h,d);if(null!=l){const e=Oi({inputs:{x:g},backend:n,attrs:{perm:S.Wap.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(c),e}return g}},$s={kernelName:S.QRR,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,weights:s}=t,{size:a,binaryOutput:o}=r;if(1===i.shape.length){const e=ds(n.data.get(i.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,a);return n.makeTensorInfo([a],s.dtype,e)}if(2===i.shape.length){const e=ps(n.bufferSync(i),n.bufferSync(s),a,o);return n.makeTensorInfo(e.shape,s.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}},Vs={kernelName:S.T0n,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{blockSize:s,dataFormat:a}=r;S.D5U.assert("NHWC"===a,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`));const o=i.shape[0],l=i.shape[1],c=i.shape[2],u=i.shape[3],h=l*s,d=c*s,p=u/(s*s),f=n.data.get(i.dataId).values,m=new Float32Array(o*h*d*p);let g=0;for(let e=0;e<o;++e)for(let t=0;t<h;++t){const n=Math.floor(t/s),r=t%s;for(let t=0;t<d;++t){const i=Math.floor(t/s),a=(r*s+t%s)*p;for(let t=0;t<p;++t){const r=t+a+u*(i+c*(n+l*e));m[g++]=f[r]}}}return n.makeTensorInfo([o,h,d,p],i.dtype,m)}};function Ws(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:s}=t,{strides:a,pad:o,dilations:l,dimRoundingMode:c}=r;$r([i,s],"depthwiseConv2DNative");const u=S.D5U.computeStrides(i.shape),h=S.D5U.computeStrides(s.shape);let d=l;null==d&&(d=[1,1]),S.D5U.assert(S.Wap.eitherStridesOrDilationsAreOne(a,d),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`));const p=S.Wap.computeConv2DInfo(i.shape,s.shape,a,d,o,c,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:v}=p,x=v.left,b=v.top,w=p.outChannels/p.inChannels,_=new S.YDk(p.outShape,i.dtype),M=n.data.get(i.dataId).values,T=n.data.get(s.dataId).values,E=_.values;for(let e=0;e<p.batchSize;++e){const t=e*u[0],n=e*_.strides[0];for(let e=0;e<p.outHeight;++e){const r=n+e*_.strides[1],i=e*p.strideHeight-b;for(let e=0;e<f;++e){const n=i+e*g;if(n<0||n>=p.inHeight)continue;const s=e*h[0],a=t+n*u[1];for(let e=0;e<p.outWidth;++e){const t=r+e*_.strides[2],n=e*p.strideWidth-x;for(let e=0;e<m;++e){const r=n+e*y;if(r<0||r>=p.inWidth)continue;const i=s+e*h[1],o=a+r*p.inChannels;let l=t,c=i;for(let e=0;e<p.inChannels;++e){const t=M[o+e];for(let e=0;e<w;++e)E[l+e]+=t*T[c+e];l+=w,c+=w}}}}}}return n.makeTensorInfo(_.shape,_.dtype,_.values)}const Gs={kernelName:S.cie,backendName:"cpu",kernelFunc:Ws},Hs={kernelName:S.sL$,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,dy:s}=t,{strides:a,dilations:o,pad:l,dimRoundingMode:c,filterShape:u}=r;$r([i,s],"depthwiseConv2dNativeBackpropFilter");const h=S.Wap.computeConv2DInfo(i.shape,u,a,o,l,c,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new S.YDk(h.filterShape,"float32"),y=h.padInfo.left,v=h.padInfo.top,x=h.outChannels/h.inChannels,b=n.data.get(i.dataId).values,w=new S.YDk(i.shape,i.dtype,b),_=n.data.get(s.dataId).values,M=new S.YDk(s.shape,s.dtype,_);for(let e=0;e<f;++e){const t=Math.max(0,Math.ceil((v-e)/d)),n=Math.min(h.outHeight,(h.inHeight+v-e)/d);for(let r=0;r<m;++r){const i=Math.max(0,Math.ceil((y-r)/p)),s=Math.min(h.outWidth,(h.inWidth+y-r)/p);for(let a=0;a<h.outChannels;++a){const o=Math.trunc(a/x),l=a%x;let c=0;for(let l=0;l<h.batchSize;++l)for(let u=t;u<n;++u){const t=e+u*d-v;for(let e=i;e<s;++e){const n=r+e*p-y;c+=w.get(l,t,n,o)*M.get(l,u,e,a)}}g.set(c,e,r,o,l)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}},js={kernelName:S.y7R,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:i,filter:s}=t,{strides:a,dilations:o,pad:l,dimRoundingMode:c,inputShape:u}=r;$r([i,s],"depthwiseConv2DNativeBackpropInput");const h=S.D5U.computeStrides(i.shape),d=S.D5U.computeStrides(s.shape),p=S.Wap.computeConv2DInfo(u,s.shape,a,o,l,c,!0),f=new S.YDk(p.inShape,"float32"),m=f.values,[g,y,v]=f.strides,x=n.data.get(i.dataId).values,[b,w,_]=h,M=n.data.get(s.dataId).values,[T,E,A]=d,{batchSize:C,filterHeight:I,filterWidth:N,inChannels:k,inHeight:R,inWidth:D,outChannels:L,outHeight:F,outWidth:P,strideHeight:O,strideWidth:z}=p,B=I-1-p.padInfo.top,U=N-1-p.padInfo.left,$=L/k;for(let e=0;e<C;++e)for(let t=0;t<k;++t)for(let n=0;n<R;++n){const r=n-B,i=Math.max(0,Math.ceil(r/O)),s=Math.min(F,(I+r)/O);for(let a=0;a<D;++a){const o=a-U,l=Math.max(0,Math.ceil(o/z)),c=Math.min(P,(N+o)/z);let u=0;for(let n=i;n<s;++n){const i=n*O-r;for(let r=l;r<c;++r){const s=b*e+w*n+_*r,a=T*(I-1-i)+E*(N-1-(r*z-o))+A*t;for(let e=0;e<$;++e)u+=x[s+(t*$+e)]*M[a+e]}}m[g*e+y*n+v*a+t]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},qs={kernelName:S.$w,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,i=S.D5U.sizeFromShape(r.shape),s=n.data.get(r.dataId).values,a=(0,S.f3b)([i,i],r.dtype),o=a.values;for(let e=0;e<s.length;e++)o[e*i+e]=s[e];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,a.dtype,a.values)}},Xs={kernelName:S.p4S,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:i}=e,{strides:s,pad:a,dilations:o}=n,l=t,c=l.data.get(r.dataId).values,u=r.shape.length,h=l.data.get(i.dataId).values,d=i.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:v,padInfo:x,strideHeight:b,strideWidth:w,filterHeight:_,filterWidth:M,dilationHeight:T,dilationWidth:E,outShape:A}=S.Wap.computeDilation2DInfo(r.shape,i.shape,s,a,"NHWC",o),C=S.D5U.sizeFromShape(A),I=A.length,N=S.D5U.getArrayFromDType(r.dtype,C);for(let e=0;e<p;++e)for(let t=0;t<y;++t){const n=t*b-x.top;for(let s=0;s<v;++s){const a=s*w-x.left;for(let o=0;o<g;++o){let l=Number.MIN_SAFE_INTEGER;for(let t=0;t<_;++t){const s=n+t*T;if(s>=0&&s<f)for(let n=0;n<M;++n){const p=a+n*E;if(p>=0&&p<m){const a=S.D5U.locToIndex([e,s,p,o],u,S.D5U.computeStrides(r.shape)),f=S.D5U.locToIndex([t,n,o],d,S.D5U.computeStrides(i.shape)),m=c[a]+h[f];m>l&&(l=m)}}}N[S.D5U.locToIndex([e,t,s,o],I,S.D5U.computeStrides(A))]=l}}}return{dataId:l.write(S.D5U.toTypedArray(N,r.dtype),A,r.dtype),shape:A,dtype:r.dtype}}},Ys={kernelName:S.Vn9,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:i,dy:s}=e,{strides:a,pad:o,dilations:l}=n,c=t,u=S.D5U.toNestedArray(r.shape,c.data.get(r.dataId).values),h=S.D5U.toNestedArray(i.shape,c.data.get(i.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:v,strideHeight:x,strideWidth:b,filterHeight:w,filterWidth:_,dilationHeight:M,dilationWidth:T,outShape:E}=S.Wap.computeDilation2DInfo(r.shape,i.shape,a,o,"NHWC",l);S.D5U.assert(s.rank===E.length,(()=>`Error in ${S.Vn9}, dy must have the same rank as output ${E.length}, but got ${s.rank}`));const A=S.D5U.toNestedArray(E,c.data.get(s.dataId).values),C=S.D5U.makeZerosNestedTypedArray(i.shape,i.dtype);for(let e=0;e<d;++e)for(let t=0;t<g;++t){const n=t*x-v.top;for(let r=0;r<y;++r){const i=r*b-v.left;for(let s=0;s<m;++s){let a=Number.MIN_SAFE_INTEGER,o=0,l=0;for(let t=0;t<w;++t){const r=n+t*M;if(r>=0&&r<p)for(let n=0;n<_;++n){const c=i+n*T;if(c>=0&&c<f){const i=u[e][r][c][s]+h[t][n][s];i>a&&(a=i,o=t,l=n)}}}C[o][l][s]+=A[e][t][r][s]}}}return{dataId:c.write(S.D5U.toTypedArray(C,r.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},Ks={kernelName:S.ekb,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:i,dy:s}=e,{strides:a,pad:o,dilations:l}=n,c=t,u=S.D5U.toNestedArray(r.shape,c.data.get(r.dataId).values),h=S.D5U.toNestedArray(i.shape,c.data.get(i.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:v,strideHeight:x,strideWidth:b,filterHeight:w,filterWidth:_,dilationHeight:M,dilationWidth:T,outShape:E}=S.Wap.computeDilation2DInfo(r.shape,i.shape,a,o,"NHWC",l);S.D5U.assert(s.rank===E.length,(()=>`Error in ${S.ekb}, dy must have the same rank as output ${E.length}, but got ${s.rank}`));const A=S.D5U.toNestedArray(E,c.data.get(s.dataId).values),C=S.D5U.makeZerosNestedTypedArray(r.shape,r.dtype);for(let e=0;e<d;++e)for(let t=0;t<g;++t){const n=t*x-v.top;for(let r=0;r<y;++r){const i=r*b-v.left;for(let s=0;s<m;++s){let a=Number.MIN_SAFE_INTEGER,o=n<0?0:n,l=i<0?0:i;for(let t=0;t<w;++t){const r=n+t*M;if(r>=0&&r<p)for(let n=0;n<_;++n){const c=i+n*T;if(c>=0&&c<f){const i=u[e][r][c][s]+h[t][n][s];i>a&&(a=i,o=r,l=c)}}}C[e][o][l][s]+=A[e][t][r][s]}}}return{dataId:c.write(S.D5U.toTypedArray(C,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Zs=Jr(((e,t)=>e*t)),Js=xi(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),Qs=vi(S.wYn,Zs,Js),ea={kernelName:S.wYn,backendName:"cpu",kernelFunc:Qs};function ta(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,keepDims:a}=r;let o;$r(i,"sum"),o="bool"===i.dtype?gi({inputs:{x:i},backend:n,attrs:{dtype:"int32"}}):Xr({inputs:{x:i},backend:n});const l=o.shape.length,c=S.D5U.parseAxisParam(s,o.shape),u=S.Wap.getAxesPermutation(c,l);let h=c,d=o;null!=u&&(d=Oi({inputs:{x:o},backend:n,attrs:{perm:u}}),h=S.Wap.getInnerMostAxes(h.length,l)),S.Wap.assertAxesAreInnerMostDims("sum",h,d.shape.length);const[p,f]=S.Wap.computeOutAndReduceShapes(d.shape,h);let m=pi(n,p,S.Wap.upcastType(d.dtype,"int32"));const g=S.D5U.sizeFromShape(f),y=n.data.get(m.dataId).values,v=n.data.get(d.dataId).values;for(let e=0;e<y.length;++e){const t=e*g;let n=0;for(let e=0;e<g;++e)n+=v[t+e];y[e]=n}if(a){const e=m;m=Mi({inputs:{x:m},backend:n,attrs:{shape:S.Wap.expandShapeToKeepDim(m.shape,c)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(o),null!=u&&n.disposeIntermediateTensorInfo(d),m}const na={kernelName:S.GBy,backendName:"cpu",kernelFunc:ta},ra={kernelName:S.$g6,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:i}=r,s=t,{allDims:a,summedDims:o,idDims:l}=S.Wap.decodeEinsumEquation(i,s.length);S.Wap.checkEinsumDimSizes(a.length,l,s);const{path:c,steps:u}=S.Wap.getEinsumComputePath(o,l),h=u.length;let d=null,p=a.length;const f=[];for(let e=0;e<h;++e){for(const t of u[e]){const{permutationIndices:e,expandDims:r}=S.Wap.getEinsumPermutation(p,l[t]);let i;S.Wap.isIdentityPermutation(e)?i=s[t]:(i=Oi({inputs:{x:s[t]},backend:n,attrs:{perm:e}}),f.push(i));const a=i.shape.slice();for(let e=0;e<r.length;++e)a.splice(r[e],0,1);S.D5U.arraysEqual(i.shape,a)||(i=Mi({inputs:{x:i},backend:n,attrs:{shape:a}}),f.push(i)),null===d?d=i:(d=Qs({inputs:{a:i,b:d},backend:n}),f.push(d))}e<h-1&&(c[e]>=0&&(d=ta({inputs:{x:d},backend:n,attrs:{axis:c[e]-(a.length-p),keepDims:!1}}),f.push(d)),p--)}for(const e of f)e!==d&&n.disposeIntermediateTensorInfo(e);return d}},ia={kernelName:S.HEU,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:r,y:i}=t;$r([r,i],"eluGrad");const s=new Float32Array(S.D5U.sizeFromShape(i.shape)),a=n.data.get(i.dataId).values,o=n.data.get(r.dataId).values;for(let e=0;e<a.length;++e){const t=a[e];s[e]=t>=1?o[e]:o[e]*(t+1)}return n.makeTensorInfo(i.shape,"float32",s)}},sa=Jr(((e,t)=>e===t?1:0)),aa=vi(S.hdR,sa,null,"bool"),oa={kernelName:S.hdR,backendName:"cpu",kernelFunc:aa},la=S.Wap.ERF_P,ca=S.Wap.ERF_A1,ua=S.Wap.ERF_A2,ha=S.Wap.ERF_A3,da=S.Wap.ERF_A4,pa=S.Wap.ERF_A5,fa=Gr(S.Omj,(e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+la*n);return t*(1-((((pa*r+da)*r+ha)*r+ua)*r+ca)*r*Math.exp(-n*n))})),ma={kernelName:S.Omj,backendName:"cpu",kernelFunc:fa},ga=ai((e=>Math.exp(e))),ya=Hr(S.NEP,ga,"float32"),va={kernelName:S.NEP,backendName:"cpu",kernelFunc:ya};function xa(e){const{inputs:t,backend:n,attrs:r}=e,{input:i}=t,{dim:s}=r,a=i.shape.length,o=i.shape.slice();let l=s;return s<0&&(S.D5U.assert(-(a+1)<=s,(()=>`Axis must be in the interval [${-(a+1)}, ${a}]`)),l=a+s+1),o.splice(l,0,1),Mi({inputs:{x:i},backend:n,attrs:{shape:o}})}const ba={kernelName:S.YFo,backendName:"cpu",kernelFunc:xa},wa=ai((e=>Math.expm1(e))),_a=Hr(S.Y0y,wa),Sa={kernelName:S.Y0y,backendName:"cpu",kernelFunc:_a},Ma=Jr(((e,t)=>e/t)),Ta=vi(S.oHH,Ma),Ea={kernelName:S.oHH,backendName:"cpu",kernelFunc:Ta},Aa=Jr(((e,t)=>e-t)),Ca=xi(((e,t,n,r)=>({real:e-n,imag:t-r}))),Ia=vi(S.Tr8,Aa,Ca),Na={kernelName:S.Tr8,backendName:"cpu",kernelFunc:Ia};function ka(e,t,n){const r=e.shape,i=r[0],s=r[1],a=n.data.get(e.dataId),o=a.complexTensorInfos.real,l=a.complexTensorInfos.imag,c=[i,s],u=S.D5U.sizeFromShape(c),h=S.D5U.getTypedArrayFromDType("float32",u),d=S.D5U.getTypedArrayFromDType("float32",u);for(let e=0;e<i;e++){const r=cs({inputs:{x:o},backend:n,attrs:{begin:[e,0],size:[1,s]}}),i=cs({inputs:{x:l},backend:n,attrs:{begin:[e,0],size:[1,s]}}),a=hi({inputs:{real:r,imag:i},backend:n}),{real:c,imag:u}=Ra(a,t,n),p=S.Wap.mergeRealAndImagArrays(c,u);for(let t=0;t<s;t++){const n=S.Wap.getComplexWithIndex(p,t);h[e*s+t]=n.real,d[e*s+t]=n.imag}n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a)}const p=n.makeTensorInfo(c,"float32",h),f=n.makeTensorInfo(c,"float32",d),m=hi({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function Ra(e,t,n){const r=S.D5U.sizeFromShape(e.shape),i=n.data.get(e.dataId),s=n.data.get(i.complexTensorInfos.real.dataId).values,a=n.data.get(i.complexTensorInfos.imag.dataId).values;if(0==((o=r)&o-1)){const i=Da(s,a,r,t,n),o=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(o,"float32",i.real),t=n.makeTensorInfo(o,"float32",i.imag),s=n.makeTensorInfo([],"float32",S.D5U.createScalarValue(r,"float32")),a=Xr({inputs:{x:s},backend:n}),l=Ea.kernelFunc({inputs:{a:e,b:s},backend:n}),c=Ea.kernelFunc({inputs:{a:t,b:a},backend:n}),u=n.data.get(l.dataId).values,h=n.data.get(c.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),{real:u,imag:h}}return i}{const e=function(e,t,n){const r=new Float32Array(2*t);for(let i=0;i<t;i++){let s=0,a=0;for(let r=0;r<t;r++){const o=S.Wap.exponent(i*r,t,n),l=S.Wap.getComplexWithIndex(e,r);s+=l.real*o.real-l.imag*o.imag,a+=l.real*o.imag+l.imag*o.real}n&&(s/=t,a/=t),S.Wap.assignToTypedArray(r,s,a,i)}return r}(S.Wap.mergeRealAndImagArrays(s,a),r,t);return S.Wap.splitRealAndImagArrays(e)}var o}function Da(e,t,n,r,i){if(1===n)return{real:e,imag:t};const s=S.Wap.mergeRealAndImagArrays(e,t),a=n/2,o=S.Wap.complexWithEvenIndex(s),l=o.real,c=o.imag,u=[l.length],h=i.makeTensorInfo(u,"float32",l),d=i.makeTensorInfo(u,"float32",c),p=hi({inputs:{real:h,imag:d},backend:i}),f=S.Wap.complexWithOddIndex(s),m=f.real,g=f.imag,y=[m.length],v=i.makeTensorInfo(y,"float32",m),x=i.makeTensorInfo(y,"float32",g),b=hi({inputs:{real:v,imag:x},backend:i}),w=Da(l,c,a,r,i),_=w.real,M=w.imag,T=[_.length],E=i.makeTensorInfo(T,"float32",_),A=i.makeTensorInfo(T,"float32",M),C=hi({inputs:{real:E,imag:A},backend:i}),I=Da(m,g,a,r,i),N=I.real,k=I.imag,R=[N.length],D=i.makeTensorInfo(R,"float32",N),L=i.makeTensorInfo(R,"float32",k),F=hi({inputs:{real:D,imag:L},backend:i}),P=S.Wap.exponents(n,r),O=[P.real.length],z=i.makeTensorInfo(O,"float32",P.real),B=i.makeTensorInfo(O,"float32",P.imag),U=hi({inputs:{real:z,imag:B},backend:i}),$=Qs({inputs:{a:U,b:F},backend:i}),V=_i({inputs:{a:C,b:$},backend:i}),W=Ia({inputs:{a:C,b:$},backend:i}),G=fi({inputs:{input:V},backend:i}),H=fi({inputs:{input:W},backend:i}),j=Ss({inputs:{input:V},backend:i}),q=Ss({inputs:{input:W},backend:i}),X=Ts({inputs:[G,H],backend:i,attrs:{axis:0}}),Y=Ts({inputs:[j,q],backend:i,attrs:{axis:0}}),K=i.data.get(X.dataId).values,Z=i.data.get(Y.dataId).values;return i.disposeIntermediateTensorInfo(h),i.disposeIntermediateTensorInfo(d),i.disposeIntermediateTensorInfo(p),i.disposeIntermediateTensorInfo(v),i.disposeIntermediateTensorInfo(x),i.disposeIntermediateTensorInfo(b),i.disposeIntermediateTensorInfo(E),i.disposeIntermediateTensorInfo(A),i.disposeIntermediateTensorInfo(C),i.disposeIntermediateTensorInfo(D),i.disposeIntermediateTensorInfo(L),i.disposeIntermediateTensorInfo(F),i.disposeIntermediateTensorInfo(z),i.disposeIntermediateTensorInfo(B),i.disposeIntermediateTensorInfo(U),i.disposeIntermediateTensorInfo($),i.disposeIntermediateTensorInfo(V),i.disposeIntermediateTensorInfo(W),i.disposeIntermediateTensorInfo(G),i.disposeIntermediateTensorInfo(j),i.disposeIntermediateTensorInfo(H),i.disposeIntermediateTensorInfo(q),i.disposeIntermediateTensorInfo(X),i.disposeIntermediateTensorInfo(Y),{real:K,imag:Z}}const La={kernelName:S.vwp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,i=S.D5U.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],a=Mi({inputs:{x:r},backend:n,attrs:{shape:[i/s,s]}}),o=ka(a,!1,n),l=Mi({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),l}};function Fa(e){const{backend:t,attrs:n}=e,{shape:r,value:i,dtype:s}=n,a=s||S.D5U.inferDtype(i),o=S.D5U.getArrayFromDType(a,S.D5U.sizeFromShape(r));return function(e,t,n){e.fill(t)}(o,i),t.makeTensorInfo(r,a,o)}const Pa={kernelName:S.deh,backendName:"cpu",kernelFunc:Fa},Oa={kernelName:S.Uyb,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,i=n,s=S.D5U.getTypedArrayFromDType(r.dtype,S.D5U.sizeFromShape(r.shape)),[a,o,l,c]=r.shape,u=i.data.get(r.dataId).values;for(let e=0;e<a;e++){const t=e*l*o*c;for(let e=0;e<o;e++){const n=e*(l*c);for(let e=0;e<l;e++){const r=e*c;for(let i=0;i<c;i++){const a=Math.round(l-e-1),o=t+n+r+i;let h=u[o];a>=0&&a<l&&(h=u[t+n+a*c+i]),s[o]=h}}}}return{dataId:i.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},za=ai((e=>Math.floor(e))),Ba=Hr(S.OR,za),Ua={kernelName:S.OR,backendName:"cpu",kernelFunc:Ba},$a=Jr(((e,t)=>Math.floor(e/t))),Va=vi(S.jeX,$a,null,"int32"),Wa={kernelName:S.jeX,backendName:"cpu",kernelFunc:Va},Ga={kernelName:S._V0,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:s,bias:a,preluActivationWeights:o}=t,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let m=As({inputs:{x:i,filter:s},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(a){const e=m;if("NCHW"===u&&1===a.shape.length&&1!==a.shape[0]){const e=Mi({inputs:{x:a},backend:n,attrs:{shape:[a.shape[0],1,1]}});m=_i({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=_i({inputs:{a:m,b:a},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===u&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){const e=Mi({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=ui(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=ui(n,m,p,o,f);n.disposeIntermediateTensorInfo(e)}return m}},Ha={kernelName:S.luS,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:s,bias:a,preluActivationWeights:o}=t,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let m=Ws({inputs:{x:i,filter:s},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(a){const e=m;m=_i({inputs:{a:m,b:a},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=ui(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}};function ja(e,t,n,r,i,s,a,o,l){const c=(0,S.f3b)([r,s],n);for(let n=0;n<r;n++){const r=[];let u=0;for(let t=0;t<i;t++){const s=e[n*i+t];u+=s*a[t],r.push(s)}if(u<0||u>=l/s)throw new Error(`Invalid indices: ${r} does not index into ${o}`);for(let e=0;e<s;e++)c.values[n*s+e]=t.get(...t.indexToLoc(u*s+e))}return c}const qa={kernelName:S.q1x,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:i}=t,s=S.D5U.sizeFromShape(r.shape),a=i.shape,o=a[a.length-1],[l,c,u,h]=S.Wap.prepareAndValidate(r,i);if(0===c)return n.makeTensorInfo(l,r.dtype,[]);const d=ja(n.data.get(i.dataId).values,n.bufferSync(r),r.dtype,c,o,u,h,r.shape,s);return n.makeTensorInfo(l,r.dtype,d.values)}};function Xa(e,t,n){const r=(0,S.f3b)(n,e.dtype);for(let n=0;n<r.size;++n){const i=r.indexToLoc(n).slice(),s=i[0],a=i[2],o=t.locToIndex([s,a]);i[2]=t.values[o];const l=e.locToIndex(i);0<=l&&l<e.values.length&&(r.values[n]=e.values[l])}return r}const Ya={kernelName:S.qi_,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,indices:s}=t,{axis:a,batchDims:o}=r;$r([i,s],"gatherV2");const l=S.D5U.parseAxisParam(a,i.shape)[0],c=n.data.get(s.dataId).values,u=i.shape[l];for(let e=0;e<c.length;++e){const t=c[e];S.D5U.assert(t<=u-1&&t>=0,(()=>`GatherV2: the index value ${t} is not in [0, ${u-1}]`))}let h=o;null==o&&(h=0);const d=S.D5U.sizeFromShape(s.shape),p=S.Wap.segment_util.collectGatherOpShapeInfo(i,s,l,h),f=Mi({inputs:{x:i},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=Mi({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),g=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],y=n.bufferSync(m),v=Xa(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,v.dtype,v.values)}},Ka=Jr(((e,t)=>e>t?1:0)),Za=vi(S.iZT,Ka,null,"bool"),Ja={kernelName:S.iZT,backendName:"cpu",kernelFunc:Za},Qa=Jr(((e,t)=>e>=t?1:0)),eo=vi(S.Acj,Qa,null,"bool"),to={kernelName:S.Acj,backendName:"cpu",kernelFunc:eo},no={kernelName:S.Qg5,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,i=S.D5U.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],a=Mi({inputs:{x:r},backend:n,attrs:{shape:[i/s,s]}}),o=ka(a,!0,n),l=Mi({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),l}},ro=Gr(S.avt,(e=>Number.isFinite(e)?1:0),"bool"),io={kernelName:S.avt,backendName:"cpu",kernelFunc:ro},so=Gr(S.iWB,(e=>Math.abs(e)===1/0?1:0),"bool"),ao={kernelName:S.iWB,backendName:"cpu",kernelFunc:so},oo=Gr(S.r7n,(e=>Number.isNaN(e)?1:0),"bool"),lo={kernelName:S.r7n,backendName:"cpu",kernelFunc:oo},co=Jr(((e,t)=>e<t?1:0)),uo=vi(S.vtC,co,null,"bool"),ho={kernelName:S.vtC,backendName:"cpu",kernelFunc:uo},po=Jr(((e,t)=>e<=t?1:0)),fo=vi(S.CAk,po,null,"bool"),mo={kernelName:S.CAk,backendName:"cpu",kernelFunc:fo};function go(e,t,n){const r=(t-e)/(n-1),i=S.D5U.makeZerosTypedArray(n,"float32");i[0]=e;for(let e=1;e<i.length;e++)i[e]=i[e-1]+r;return i}const yo={kernelName:S.e7N,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:i,num:s}=n,a=go(r,i,s);return t.makeTensorInfo([a.length],"float32",a)}},vo=ai((e=>Math.log(e))),xo=Hr(S.ZbH,vo),bo={kernelName:S.ZbH,backendName:"cpu",kernelFunc:xo},wo=Gr(S.kU,(e=>Math.log1p(e))),_o={kernelName:S.kU,backendName:"cpu",kernelFunc:wo},So=Jr(((e,t)=>e&&t)),Mo=vi(S.PYm,So,null,"bool"),To={kernelName:S.PYm,backendName:"cpu",kernelFunc:Mo},Eo=Gr(S.VfG,(e=>e?0:1),"bool"),Ao={kernelName:S.VfG,backendName:"cpu",kernelFunc:Eo},Co=Jr(((e,t)=>e||t)),Io=vi(S.MZg,Co,null,"bool"),No={kernelName:S.MZg,backendName:"cpu",kernelFunc:Io},ko={kernelName:S.eZ0,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{depthRadius:s,bias:a,alpha:o,beta:l}=r;$r(i,"LRN");const c=i.shape[3],u=c-1,h=n.data.get(i.dataId).values,d=S.D5U.sizeFromShape(i.shape),p=new Float32Array(d);function f(e){const t=e%c;let n=e-t+Math.max(0,t-s);const r=e-t+Math.min(t+s,u);let i=0;for(;n<=r;n++){const e=h[n];i+=e*e}return i}for(let e=0;e<d;e++){const t=f(e),n=h[e]*Math.pow(a+o*t,-l);p[e]=n}return n.makeTensorInfo(i.shape,i.dtype,p)}},Ro={kernelName:S.Hhh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,y:s,dy:a}=t,{depthRadius:o,bias:l,alpha:c,beta:u}=r;$r(a,"LRNGrad");const h=S.D5U.sizeFromShape(a.shape),d=a.shape[3],p=n.data.get(a.dataId).values,f=n.data.get(i.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(h),y=h;for(let e=0;e<y;e++){const t=e%d,n=e-t+Math.max(0,t-o),r=e-t+Math.min(d,t+o+1);let i=0;for(let e=n;e<r;e++)i+=Math.pow(f[e],2);i=c*i+l;for(let t=n;t<r;t++){let n=-2*c*u*f[t]*m[e]/i;e===t&&(n+=Math.pow(i,-u)),n*=p[e],g[t]+=n}}return n.makeTensorInfo(a.shape,i.dtype,g)}};function Do(e,t,n,r){const i=S.D5U.getTypedArrayFromDType(r,S.D5U.sizeFromShape(n));for(let n=0;n<i.length;++n){const r=n*t;let s=e[r];for(let n=0;n<t;++n){const t=e[r+n];(Number.isNaN(t)||t>s)&&(s=t)}i[n]=s}return i}function Lo(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{reductionIndices:s,keepDims:a}=r,o=n;let l=i.shape;const c=l.length,u=S.D5U.parseAxisParam(s,l);let h=u;const d=S.Wap.getAxesPermutation(h,c);let p=o.data.get(i.dataId).values;if(null!=d){const e=new Array(c);for(let t=0;t<e.length;t++)e[t]=l[d[t]];p=Pi(p,l,i.dtype,d,e),h=S.Wap.getInnerMostAxes(h.length,c),l=e}$r(i,"max"),S.Wap.assertAxesAreInnerMostDims("max",h,c);const[f,m]=S.Wap.computeOutAndReduceShapes(l,h),g=Do(p,S.D5U.sizeFromShape(m),f,i.dtype),y=o.write(g,f,i.dtype);let v=f;return a&&(v=S.Wap.expandShapeToKeepDim(f,u)),{dataId:y,shape:v,dtype:i.dtype}}const Fo={kernelName:S.YoZ,backendName:"cpu",kernelFunc:Lo},Po=Jr(((e,t)=>Math.max(e,t))),Oo=vi(S.BMI,Po),zo={kernelName:S.BMI,backendName:"cpu",kernelFunc:Oo},Bo={kernelName:S.mTV,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t;$r(i,"maxPool");const{filterSize:s,strides:a,pad:o,dimRoundingMode:l}=r;S.D5U.assert(S.Wap.eitherStridesOrDilationsAreOne(a,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`));const c=S.Wap.computePool2DInfo(i.shape,s,a,1,o,l);let u;if(1===c.filterWidth&&1===c.filterHeight&&S.D5U.arraysEqual(c.inShape,c.outShape))u=Xr({inputs:{x:i},backend:n});else{const e=n.data.get(i.dataId).values,t=S.D5U.computeStrides(i.shape),r=es(e,i.shape,i.dtype,t,c,"max");u=n.makeTensorInfo(c.outShape,i.dtype,r.values)}return u}},Uo={kernelName:S.OAf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{filterSize:s,strides:a,pad:o,dimRoundingMode:l,dataFormat:c}=r;$r(i,"maxPool3d");const u=S.Wap.computePool3DInfo(i.shape,s,a,1,o,l,c),h=ns(n.data.get(i.dataId).values,i.shape,i.dtype,S.D5U.computeStrides(i.shape),u,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}},$o={kernelName:S.OU7,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:i,input:s}=t,{filterSize:a,strides:o,pad:l,dimRoundingMode:c}=r;$r([i,s],"maxPool3DGrad");const u=S.Wap.computePool3DInfo(s.shape,a,o,1,l,c),h=function(e,t){const n=(0,S.f3b)(t.outShape,"int32"),r=t.strideDepth,i=t.strideHeight,s=t.strideWidth,a=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterDepth,u=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const v=y*r-d;let x=v;for(;x<0;)x+=a;const b=Math.min(t.inDepth,c+v);for(let r=0;r<t.outHeight;++r){const c=r*i-p;let d=c;for(;d<0;)d+=o;const w=Math.min(t.inHeight,u+c);for(let i=0;i<t.outWidth;++i){const p=i*s-f;let _=p;for(;_<0;)_+=l;const S=Math.min(t.inWidth,h+p);let M=Number.NEGATIVE_INFINITY,T=-1;for(let t=x;t<b;t+=a){const n=t-v;for(let r=d;r<w;r+=o){const i=r-c;for(let s=_;s<S;s+=l){const a=s-p,o=e.get(m,t,r,s,g);o>=M&&(M=o,T=n*u*h+i*u+a)}}}n.set(T,m,y,r,i,g)}}}return n}(n.bufferSync(s),u),d=u.strideDepth,p=u.strideHeight,f=u.strideWidth,m=u.dilationDepth,g=u.dilationHeight,y=u.dilationWidth,v=u.effectiveFilterDepth,x=u.effectiveFilterHeight,b=u.effectiveFilterWidth,w=v-1-u.padInfo.front,_=b-1-u.padInfo.left,M=x-1-u.padInfo.top,T=(0,S.f3b)(s.shape,"float32"),E=n.bufferSync(i);for(let e=0;e<u.batchSize;++e)for(let t=0;t<u.inChannels;++t)for(let n=0;n<u.inDepth;++n)for(let r=0;r<u.inHeight;++r)for(let i=0;i<u.inWidth;++i){const s=n-w,a=r-M,o=i-_;let l=0;for(let n=0;n<v;n+=m){const r=(s+n)/d;if(!(r<0||r>=u.outDepth||Math.floor(r)!==r))for(let i=0;i<x;i+=g){const s=(a+i)/p;if(!(s<0||s>=u.outHeight||Math.floor(s)!==s))for(let a=0;a<b;a+=y){const c=(o+a)/f;if(c<0||c>=u.outWidth||Math.floor(c)!==c)continue;const d=v*x*b-1-h.get(e,r,s,c,t)===n*x*b+i*b+a?1:0;0!==d&&(l+=E.get(e,r,s,c,t)*d)}}}T.set(l,e,n,r,i,t)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}},Vo={kernelName:S.OV7,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:i,input:s,output:a}=t,o=s;$r([s,a],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,d=S.Wap.computePool2DInfo(o.shape,l,c,1,u,h),p=n.data.get(o.dataId).values,f=(0,S.f3b)(d.outShape,o.dtype,ts(p,o.shape,o.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,v=d.dilationWidth,x=d.effectiveFilterHeight,b=d.effectiveFilterWidth,w=b-1-d.padInfo.left,_=x-1-d.padInfo.top,M=(0,S.f3b)(o.shape,"float32"),T=n.data.get(i.dataId).values,E=(0,S.f3b)(i.shape,"float32",T);for(let e=0;e<d.batchSize;++e)for(let t=0;t<d.inChannels;++t)for(let n=0;n<d.inHeight;++n)for(let r=0;r<d.inWidth;++r){const i=n-_,s=r-w;let a=0;for(let n=0;n<x;n+=y){const r=(i+n)/m;if(!(r<0||r>=d.outHeight||Math.floor(r)!==r))for(let i=0;i<b;i+=v){const o=(s+i)/g;if(o<0||o>=d.outWidth||Math.floor(o)!==o)continue;const l=x*b-1-f.get(e,r,o,t)===n*b+i?1:0;0!==l&&(a+=E.get(e,r,o,t)*l)}}M.set(a,e,n,r,t)}return n.makeTensorInfo(M.shape,M.dtype,M.values)}},Wo={kernelName:S.vFR,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:i,strides:s,pad:a,includeBatchInIndex:o}=t,l=n;$r(r,"MaxPoolWithArgmax");const c=l.data.get(r.dataId).values,u=S.Wap.computePool2DInfo(r.shape,i,s,[1,1],a),[h,d]=function(e,t,n,r,i){const s=es(e,0,n,S.D5U.computeStrides(t),i,"max"),a=ts(e,t,n,i,!0,r);return[s.values,a.values]}(c,r.shape,r.dtype,o,u),p=l.write(h,u.outShape,r.dtype),f=l.write(d,u.outShape,r.dtype);return[{dataId:p,shape:u.outShape,dtype:r.dtype},{dataId:f,shape:u.outShape,dtype:"int32"}]}},Go={kernelName:S.q2K,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,keepDims:a}=r,o=S.D5U.parseAxisParam(s,i.shape),l=S.Wap.computeOutAndReduceShapes(i.shape,o)[1],c=S.D5U.sizeFromShape(l),u=[],h=n.makeTensorInfo([],"float32",new Float32Array([c]));u.push(h);const d=gi({inputs:{x:i},backend:n,attrs:{dtype:"float32"}});u.push(d);const p=Ta({inputs:{a:d,b:h},backend:n});u.push(p);const f=ta({inputs:{x:p},backend:n,attrs:{axis:s,keepDims:a}});return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}},Ho={kernelName:S.c17,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,keepDims:a}=r;$r(i,"min");const o=S.D5U.parseAxisParam(s,i.shape);let l=o;const c=S.Wap.getAxesPermutation(l,i.shape.length);let u=i;null!=c&&(u=Oi({inputs:{x:i},backend:n,attrs:{perm:c}}),l=S.Wap.getInnerMostAxes(l.length,i.shape.length)),S.Wap.assertAxesAreInnerMostDims("min",l,u.shape.length);const[h,d]=S.Wap.computeOutAndReduceShapes(u.shape,l),p=S.D5U.sizeFromShape(d),f=S.D5U.makeZerosTypedArray(S.D5U.sizeFromShape(h),u.dtype),m=n.data.get(u.dataId).values;for(let e=0;e<f.length;++e){const t=e*p;let n=m[t];for(let e=0;e<p;++e){const r=m[t+e];(Number.isNaN(r)||r<n)&&(n=r)}f[e]=n}null!=c&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(h,u.dtype,f);if(a){const e=Mi({inputs:{x:g},backend:n,attrs:{shape:S.Wap.expandShapeToKeepDim(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},jo=Jr(((e,t)=>Math.min(e,t))),qo=vi(S.q8u,jo),Xo={kernelName:S.q8u,backendName:"cpu",kernelFunc:qo},Yo={kernelName:S.jQs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{paddings:s,mode:a}=r;$r(i,"mirrorPad");const o=s.map(((e,t)=>e[0]+i.shape[t]+e[1])),l=s.map((e=>e[0])),c=s.map(((e,t)=>e[0]+i.shape[t])),u="reflect"===a?0:1,h=n.data.get(i.dataId).values,d=i.shape.length,p=S.D5U.computeStrides(i.shape),f=S.D5U.sizeFromShape(o),m=o.length,g=S.D5U.computeStrides(o),y=S.D5U.getTypedArrayFromDType(i.dtype,f);for(let e=0;e<f;e++){let t=S.D5U.indexToLoc(e,m,g);for(let e=0;e<m;e++)t[e]<l[e]?t[e]=2*l[e]-t[e]-u:t[e]>=c[e]&&(t[e]=2*(c[e]-1)-t[e]+u);t=t.map(((e,t)=>e-l[t]));const n=S.D5U.locToIndex(t,d,p);y[e]=h[n]}return{dataId:n.write(y,o,i.dtype),shape:o,dtype:i.dtype}}},Ko=Jr(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),Zo=vi(S.Vbg,Ko),Jo={kernelName:S.Vbg,backendName:"cpu",kernelFunc:Zo};var Qo=n(2948);function el(e){const{inputs:t,backend:n,attrs:r}=e,{logits:i}=t,{dim:s}=r,a=i.shape.length;let o=s;if(-1===o&&(o=a-1),o!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${o}`);const l=S.D5U.parseAxisParam([o],i.shape),c=Lo({inputs:{x:i},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),u=S.Wap.expandShapeToKeepDim(c.shape,l),h=Mi({inputs:{x:c},backend:n,attrs:{shape:u}}),d=Ia({inputs:{a:i,b:h},backend:n}),p=ya({inputs:{x:d},backend:n}),f=ta({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=Mi({inputs:{x:f},backend:n,attrs:{shape:u}}),g=Ta({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const tl={kernelName:S.Gcp,backendName:"cpu",kernelFunc:el},nl={kernelName:S.NZg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:i}=t,{numSamples:s,seed:a,normalized:o}=r;$r(i,"multinomial");const l=o?i:el({inputs:{logits:i},backend:n,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],h=n.data.get(l.dataId).values,d=[c,s],p=S.D5U.makeZerosTypedArray(S.D5U.sizeFromShape(d),"int32");for(let e=0;e<c;++e){const t=e*u,n=new Float32Array(u-1);n[0]=h[t];for(let e=1;e<n.length;++e)n[e]=n[e-1]+h[t+e];const r=Qo.alea(a.toString()),i=e*s;for(let e=0;e<s;++e){const t=r();p[i+e]=n.length;for(let r=0;r<n.length;r++)if(t<n[r]){p[i+e]=r;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",p)}};function rl(e,t,n){const r=S.D5U.createScalarValue(-1,n);return Zs([],t,r,e,n)}const il={kernelName:S.kuV,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;$r(r,"neg");const i=n.data.get(r.dataId).values,[s,a]=rl(i,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,s)}},sl=S.GDt.nonMaxSuppressionV3Impl,al={kernelName:S.uv1,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:i,scores:s}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=r;$r(i,"NonMaxSuppression");const c=n.data.get(i.dataId).values,u=n.data.get(s.dataId).values,{selectedIndices:h}=sl(c,u,a,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},ol=S.GDt.nonMaxSuppressionV4Impl,ll={kernelName:S.cye,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:i,scores:s}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:c}=r;$r(i,"NonMaxSuppressionPadded");const u=n.data.get(i.dataId).values,h=n.data.get(s.dataId).values,{selectedIndices:d,validOutputs:p}=ol(u,h,a,o,l,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},cl=S.GDt.nonMaxSuppressionV5Impl,ul={kernelName:S.W0H,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:i,scores:s}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:c}=r;$r(i,"NonMaxSuppressionWithScore");const u=n.data.get(i.dataId).values,h=n.data.get(s.dataId).values,d=a,p=o,f=l,m=c,{selectedIndices:g,selectedScores:y}=cl(u,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},hl=Jr(((e,t)=>e!==t?1:0)),dl=vi(S.yQU,hl,null,"bool"),pl={kernelName:S.yQU,backendName:"cpu",kernelFunc:dl},fl={kernelName:S.we_,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:i}=t,{depth:s,onValue:a,offValue:o}=r;$r(i,"oneHot");const l=S.D5U.sizeFromShape(i.shape),c=new Float32Array(l*s);c.fill(o);const u=n.data.get(i.dataId).values;for(let e=0;e<l;++e)u[e]>=0&&u[e]<s&&(c[e*s+u[e]]=a);return n.makeTensorInfo([...i.shape,s],"int32",c)}};function ml(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=fi({inputs:{input:r},backend:n}),t=ml({inputs:{x:e},backend:n}),i=Ss({inputs:{input:r},backend:n}),s=ml({inputs:{x:i},backend:n}),a=hi({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),a}return Fa({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const gl={kernelName:S.RuY,backendName:"cpu",kernelFunc:ml},yl={kernelName:S.qWM,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:i}=n;if("string"===i.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===i.dtype){const t=fi({inputs:{input:i},backend:r}),n=e({inputs:{x:t},backend:r}),s=Ss({inputs:{input:i},backend:r}),a=ml({inputs:{x:s},backend:r}),o=hi({inputs:{real:n,imag:a},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(a),o}return Fa({backend:r,attrs:{shape:i.shape,value:1,dtype:i.dtype}})}};function vl(e){const{inputs:t,backend:n,attrs:r}=e,{axis:i}=r;if(1===t.length)return xa({inputs:{input:t[0]},backend:n,attrs:{dim:i}});const s=t[0].shape,a=t[0].dtype;t.forEach((e=>{S.D5U.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),S.D5U.assert(a===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=Ts({inputs:t.map((e=>{const t=xa({inputs:{input:e},backend:n,attrs:{dim:i}});return o.push(t),t})),backend:n,attrs:{axis:i}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}const xl={kernelName:S.QiL,backendName:"cpu",kernelFunc:vl},bl={kernelName:S.lyA,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{paddings:s,constantValue:a}=r;$r(i,"pad");const o=s.map(((e,t)=>e[0]+i.shape[t]+e[1])),l=s.map((e=>e[0])),c=n.data.get(i.dataId).values,u=S.D5U.sizeFromShape(i.shape),h=i.shape.length,d=S.D5U.computeStrides(i.shape),p=S.D5U.sizeFromShape(o),f=o.length,m=S.D5U.computeStrides(o),g=S.D5U.getTypedArrayFromDType(i.dtype,p);0!==a&&g.fill(a);for(let e=0;e<u;e++){const t=S.D5U.indexToLoc(e,h,d).map(((e,t)=>e+l[t]));g[S.D5U.locToIndex(t,f,m)]=c[e]}return{dataId:n.write(g,o,i.dtype),shape:o,dtype:i.dtype}}},wl=Jr(((e,t)=>Math.pow(e,t))),_l=vi(S.pe_,wl),Sl={kernelName:S.pe_,backendName:"cpu",kernelFunc:_l};function Ml(e,t,n,r){const[i,s]=S.Wap.computeOutAndReduceShapes(e,r),a=(0,S.x8V)(t,"int32"),o=S.D5U.makeZerosTypedArray(S.D5U.sizeFromShape(i),a),l=S.D5U.sizeFromShape(s);for(let e=0;e<o.length;++e){const t=e*l;let r=1;for(let e=0;e<l;++e)r*=n[t+e];o[e]=r}return{outVals:o,outShape:i,outDtype:a}}const Tl={kernelName:S.DlI,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,keepDims:a}=r;$r(i,"prod");const o=i.shape.length,l=S.D5U.parseAxisParam(s,i.shape),c=S.Wap.getAxesPermutation(l,o);let u=l,h=i;const d=[];null!=c&&(h=Oi({inputs:{x:i},backend:n,attrs:{perm:c}}),d.push(h),u=S.Wap.getInnerMostAxes(u.length,o));const p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=Ml(h.shape,h.dtype,p,u);let y=m;return a&&(y=S.Wap.expandShapeToKeepDim(m,l)),d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}};function El(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return S.D5U.makeZerosTypedArray(0,r);const i=Math.abs(Math.ceil((t-e)/n)),s=S.D5U.makeZerosTypedArray(i,r);t<e&&1===n&&(n=-1),s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+n;return s}const Al={kernelName:S.e6w,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:i,dtype:s,step:a}=n,o=El(r,i,a,s);return t.makeTensorInfo([o.length],s,o)}},Cl=Gr(S.$HU,(e=>1/e)),Il={kernelName:S.$HU,backendName:"cpu",kernelFunc:Cl},Nl={kernelName:S._Yw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i}=t,{alignCorners:s,halfPixelCenters:a,size:o}=r;$r(i,"resizeBilinear");const l=S.D5U.computeStrides(i.shape),[c,u]=o,[h,d,p,f]=i.shape,m=n.data.get(i.dataId).values,g=new Float32Array(S.D5U.sizeFromShape([h,c,u,f])),y=[s&&c>1?d-1:d,s&&u>1?p-1:p],v=[s&&c>1?c-1:c,s&&u>1?u-1:u];let x=0;const b=y[0]/v[0],w=y[1]/v[1];for(let e=0;e<h;e++)for(let t=0;t<c;t++){let n;n=a?b*(t+.5)-.5:b*t;const r=Math.max(0,Math.floor(n)),i=n-r,s=Math.min(d-1,Math.ceil(n)),o=e*l[0]+r*l[1],c=e*l[0]+s*l[1];for(let e=0;e<u;e++){let t;t=a?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),r=t-n,s=Math.min(p-1,Math.ceil(t)),u=o+n*l[2],h=c+n*l[2],d=o+s*l[2],y=c+s*l[2];for(let e=0;e<f;e++){const t=m[u+e],n=m[h+e],s=t+(m[d+e]-t)*r,a=s+(n+(m[y+e]-n)*r-s)*i;g[x++]=a}}}return n.makeTensorInfo([h,c,u,f],"float32",g)}},kl={kernelName:S.zbQ,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i,dy:s}=t,{alignCorners:a}=r;$r([s,i],"resizeBilinearGrad");const o=S.D5U.computeStrides(i.shape),[l,c,u,h]=i.shape,[,d,p]=s.shape,f=new Float32Array(l*c*u*h),m=[a&&d>1?c-1:c,a&&p>1?u-1:u],g=[a&&d>1?d-1:d,a&&p>1?p-1:p],y=m[0]/g[0],v=m[1]/g[1],x=n.data.get(s.dataId).values;let b=0;for(let e=0;e<l;e++){const t=e*o[0];for(let e=0;e<d;e++){const n=e*y,r=Math.floor(n),i=Math.min(Math.ceil(n),c-1),s=t+r*o[1],a=t+i*o[1],l=n-r,d=1-l;for(let e=0;e<p;e++){const t=e*v,n=Math.floor(t),r=Math.min(Math.ceil(t),u-1),i=t-n,c=1-i,p=s+n*o[2],m=s+r*o[2],g=a+n*o[2],y=a+r*o[2],w=d*c,_=d*i,S=l*c,M=l*i;for(let e=0;e<h;e++){const t=x[b++];f[p+e]+=t*w,f[m+e]+=t*_,f[g+e]+=t*S,f[y+e]+=t*M}}}}return n.makeTensorInfo([l,u,c,h],"float32",f)}},Rl={kernelName:S.dpD,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i}=t,{alignCorners:s,halfPixelCenters:a,size:o}=r;$r(i,"resizeNearestNeighbor");const l=S.D5U.computeStrides(i.shape),[c,u]=o,[h,d,p,f]=i.shape,m=n.data.get(i.dataId).values,g=new Float32Array(h*c*u*f),y=[s&&c>1?d-1:d,s&&u>1?p-1:p],v=[s&&c>1?c-1:c,s&&u>1?u-1:u],x=y[0]/v[0],b=y[1]/v[1];let w=0;for(let e=0;e<h;e++){const t=e*l[0];for(let e=0;e<c;e++){const n=a?x*(e+.5):x*e;let r=Math.min(d-1,s?Math.round(n):Math.floor(n));a&&(r=Math.max(0,r));const i=t+r*l[1];for(let e=0;e<u;e++){const t=a?b*(e+.5):b*e;let n=Math.min(p-1,s?Math.round(t):Math.floor(t));a&&(n=Math.max(0,n));const r=i+n*l[2];for(let e=0;e<f;e++){const t=m[r+e];g[w++]=t}}}}return n.makeTensorInfo([h,c,u,f],i.dtype,g)}},Dl={kernelName:S.Hmb,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i,dy:s}=t,{alignCorners:a}=r;$r([s,i],"resizeNearestNeighborGrad");const o=S.D5U.computeStrides(i.shape),l=S.D5U.computeStrides(s.shape),[c,u,h,d]=i.shape,[,p,f]=s.shape,m=new Float32Array(c*u*h*d),g=n.data.get(s.dataId).values,y=[a&&p>1?u-1:u,a&&f>1?h-1:h],v=[a&&p>1?p-1:p,a&&f>1?f-1:f],x=y[0]/v[0],b=y[1]/v[1],w=1/x,_=1/b,M=2*Math.ceil(w)+2,T=2*Math.ceil(_)+2;for(let e=0;e<c;e++){const t=e*o[0];for(let e=0;e<u;e++){const n=t+e*o[1],r=Math.floor(e*w),i=Math.floor(r-M/2);for(let r=0;r<h;r++){const s=n+r*o[2],c=Math.floor(r*_),y=Math.floor(c-T/2);for(let n=0;n<d;n++){let o=0;for(let s=0;s<M;s++){const c=s+i;if(c<0||c>=p)continue;const d=t+c*l[1],m=c*x;if(e===Math.min(u-1,a?Math.round(m):Math.floor(m)))for(let e=0;e<T;e++){const t=e+y;if(t<0||t>=f)continue;const i=d+t*l[2],s=t*b;r===Math.min(h-1,a?Math.round(s):Math.floor(s))&&(o+=g[i+n])}}m[s+n]=o}}}}return n.makeTensorInfo(i.shape,i.dtype,m)}},Ll={kernelName:S.mKl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{dims:s}=r;$r(i,"reverse");const a=i.shape.length,o=S.D5U.parseAxisParam(s,i.shape);if(0===a)return Xr({inputs:{x:i},backend:n});const l=new S.YDk(i.shape,i.dtype),c=n.bufferSync(i);for(let e=0;e<l.size;e++){const t=l.indexToLoc(e),n=t.slice();o.forEach((e=>n[e]=i.shape[e]-1-n[e])),l.set(c.get(...n),...t)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},Fl={kernelName:S.b9H,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:i,fillValue:s,center:a}=t,o=n,l=S.D5U.getTypedArrayFromDType(r.dtype,S.D5U.sizeFromShape(r.shape)),[c,u,h,d]=r.shape,[p,f]=S.Wap.getImageCenter(a,u,h),m=Math.sin(i),g=Math.cos(i),y=o.data.get(r.dataId).values;for(let e=0;e<c;e++){const t=e*h*u*d;for(let e=0;e<u;e++){const n=e*(h*d);for(let r=0;r<h;r++){const i=r*d;for(let a=0;a<d;a++){const o=[c,e,r,a],v=o[2],x=o[1];let b=(v-p)*g-(x-f)*m,w=(v-p)*m+(x-f)*g;b=Math.round(b+p),w=Math.round(w+f);let _=s;"number"!=typeof s&&(_=3===a?255:s[a]),b>=0&&b<h&&w>=0&&w<u&&(_=y[t+w*(h*d)+b*d+a]),l[t+n+i+a]=_}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Pl=Gr(S.e07,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1})),Ol={kernelName:S.e07,backendName:"cpu",kernelFunc:Pl},zl=ai((e=>1/Math.sqrt(e))),Bl=Hr(S.bV0,zl),Ul={kernelName:S.bV0,backendName:"cpu",kernelFunc:Bl};function $l(e,t,n,r,i,s,a,o,l,c){const u=[r/i,i],h=e.values,d=t.values;if(0===r)return(0,S.f3b)(n,t.dtype);const p=(0,S.f3b)(u,t.dtype);"string"==typeof l||"number"==typeof l?p.values.fill(l):"boolean"==typeof l&&p.values.fill(+l);for(let e=0;e<s;e++){const s=[];let l=0;for(let t=0;t<a;t++){const n=h[e*a+t];s.push(n),l+=n*o[t]}if(l<0||l>=r/i)throw new Error(`Invalid indices: ${s} does not index into ${n}`);for(let n=0;n<i;n++)c?p.values[l*i+n]+=d[e*i+n]:p.values[l*i+n]=0===t.rank?d[0]:d[e*i+n]}return p}const Vl={kernelName:S.xQA,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:i,updates:s}=t,{shape:a}=r,{sliceRank:o,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=S.Wap.calculateShapes(s,i,a),d=$l(n.bufferSync(i),n.bufferSync(s),a,h,c,l,o,u,0,!0);return n.makeTensorInfo(a,d.dtype,d.values)}};function Wl(e,t){let n=0,r=e.length,i=0;for(;n<r;)i=Math.floor((n+r)/2),e[i]<t?n=i+1:r=i;return r}function Gl(e,t){let n=0,r=e.length,i=0;for(;n<r;)i=Math.floor((n+r)/2),e[i]<=t?n=i+1:r=i;return r}const Hl={kernelName:S.nr8,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:i,values:s}=t,{side:a}=r,o=function(e,t,n,r,i,s){const a=S.D5U.getArrayFromDType("int32",n*i);for(let o=0;o<n;++o){const n=e.slice(o*r,(o+1)*r),l=o*i;for(let e=0;e<i;++e)a[l+e]="left"===s?Wl(n,t[e+l]):Gl(n,t[e+l])}return a}(n.data.get(i.dataId).values,n.data.get(s.dataId).values,i.shape[0],i.shape[1],s.shape[1],a);return n.makeTensorInfo(s.shape,"int32",o)}},jl={kernelName:S.PhF,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:i,e:s}=t;$r([r,i,s],"select");const a=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,c=n.data.get(s.dataId).values,u=(0,S.x8V)(i.dtype,s.dtype),h=S.D5U.makeZerosTypedArray(S.D5U.sizeFromShape(i.shape),u);let d=0;const p=0===a||a>1||1===i.shape.length?1:S.D5U.sizeFromShape(i.shape.slice(1));for(let e=0;e<o.length;e++)for(let t=0;t<p;t++)1===o[e]?h[d++]=l[e]:h[d++]=c[e];return n.makeTensorInfo(i.shape,u,h)}},ql=S.Wap.SELU_SCALEALPHA,Xl=S.Wap.SELU_SCALE,Yl=Gr(S.oFR,(e=>e>=0?Xl*e:ql*(Math.exp(e)-1))),Kl={kernelName:S.oFR,backendName:"cpu",kernelFunc:Yl},Zl=Gr(S.i5y,(e=>e<0?-1:e>0?1:0)),Jl={kernelName:S.i5y,backendName:"cpu",kernelFunc:Zl},Ql=Gr(S.RQH,(e=>Math.sin(e))),ec={kernelName:S.RQH,backendName:"cpu",kernelFunc:Ql},tc=Gr(S.wYB,(e=>Math.sinh(e))),nc={kernelName:S.wYB,backendName:"cpu",kernelFunc:tc},rc=Math.log(1.1920928955078125e-7)+2,ic=Gr(S.MRv,(e=>{const t=e>-rc,n=e<rc,r=Math.exp(e);let i;return i=n?r:t?e:Math.log(1+r),i})),sc={kernelName:S.MRv,backendName:"cpu",kernelFunc:ic},ac={kernelName:S.TQc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{blockShape:s,paddings:a}=r;$r([i],"spaceToBatchND");const o=S.D5U.sizeFromShape(s),l=[[0,0]];l.push(...a);for(let e=1+s.length;e<i.shape.length;++e)l.push([0,0]);const c=bl.kernelFunc({inputs:{x:i},backend:n,attrs:{paddings:l,constantValue:0}}),u=S.Wap.getReshaped(c.shape,s,o,!1),h=S.Wap.getPermuted(u.length,s.length,!1),d=S.Wap.getReshapedPermuted(c.shape,s,o,!1),p=Mi({inputs:{x:c},backend:n,attrs:{shape:u}}),f=Oi({inputs:{x:p},backend:n,attrs:{perm:h}}),m=Mi({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function oc(e,t,n,r,i,s,a){const o=t[0],l=s[0],c=new Array(l),u=new Array(o),h=t[1];if(0===l){if(0!==o)throw new Error(S.Wap.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));return[S.D5U.getArrayFromDType(n,0),[0,h],S.D5U.getArrayFromDType(i,0),c,u]}let d=!0,p=0;const f=new Array(l).fill(0);for(let t=0;t<o;++t){const n=e[t*h];if(n<0)throw new Error(S.Wap.getSparseFillEmptyRowsNegativeIndexErrorMessage(t,n));if(n>=l)throw new Error(S.Wap.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(t,n,l));++f[n],d=d&&n>=p,p=n}let m=!0;for(let e=0;e<l;++e){const t=0===f[e];c[e]=t,m=m&&!t,f[e]=Math.max(f[e],1),e>0&&(f[e]+=f[e-1])}if(m&&d){const t=e,n=r;for(let e=0;e<o;++e)u[e]=e;return[t,[o,h],n,c,u]}{const t=f[l-1],s=S.D5U.getArrayFromDType(n,t*h),d=S.D5U.getArrayFromDType(i,t),p=new Array(l).fill(0);for(let t=0;t<o;++t){const n=e[t*h],i=p[n],a=(0===n?0:f[n-1])+i;p[n]++;for(let n=0;n<h;++n)s[a*h+n]=e[t*h+n];d[a]=r[t],u[t]=a}for(let e=0;e<l;++e)if(0===p[e]){const t=0===e?0:f[e-1];s[t*h+0]=e;for(let e=1;e<h;++e)s[t*h+e]=0;d[t]=a}return[s,[t,h],d,c,u]}}const lc={kernelName:S.O3z,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:i,denseShape:s,defaultValue:a}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==i.shape.length)throw new Error(`Values must be a vector, saw:\n        ${i.shape}`);if(0!==a.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${a.shape}`);const o=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,c=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values[0],[h,d,p,f,m]=oc(o,r.shape,r.dtype,l,i.dtype,c,u);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],i.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function cc(e,t,n,r,i){const s=S.D5U.sizeFromShape(r),a=t[0],o=i.length,l=[];let c=1,u=-1;for(let e=0;e<o;++e){const t=i[e];if(-1===t){if(-1!==u)throw new Error(S.Wap.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(u,e));u=e,l.push(1)}else{if(t<0)throw new Error(S.Wap.getSparseReshapeNegativeOutputDimErrorMessage(e,t));c*=t,l.push(t)}}if(-1!==u){if(c<=0)throw new Error(S.Wap.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const e=Math.trunc(s/c);if(c*e!==s)throw new Error(S.Wap.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[u]=e}if(S.D5U.sizeFromShape(l)!==s)throw new Error(S.Wap.getSparseReshapeInputOutputMismatchErrorMessage(r,l));const h=r.length,d=[];if(h>0){d[h-1]=1;for(let e=h-2;e>=0;--e)d[e]=d[e+1]*r[e+1]}const p=[];if(o>0){p[o-1]=1;for(let e=o-2;e>=0;--e)p[e]=p[e+1]*l[e+1]}const f=S.D5U.getArrayFromDType(n,a*o);for(let t=0;t<a;++t){let n=0;for(let r=0;r<h;++r)n+=e[t*h+r]*d[r];for(let e=0;e<o;++e)f[t*o+e]=Math.trunc(n/p[e]),n%=p[e]}return[f,[a,o],l]}const uc={kernelName:S.nhH,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:i,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==i.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${i.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const a=Array.from(n.data.get(i.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[c,u,h]=cc(o,r.shape,r.dtype,a,l);return[n.makeTensorInfo(u,r.dtype,c),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}};function hc(e,t,n,r,i,s=!1,a=0){const o=r.length,l=[t[0],e.length/t[0]],c=l[1],u=o>0?i[o-1]+1:0;if(u<0)throw new Error(S.Wap.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const h=t.slice();h[0]=u;const d=h.reduce(((e,t)=>e*t),1),p=S.D5U.getArrayFromDType(n,d);if(0===o)return u>0&&p.fill(a),[p,h];if(u<=0)throw new Error(S.Wap.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,y=i[f];for(;;){let t=0;if(m<o){if(t=i[m],y===t){++m;continue}if(y>=t)throw new Error(S.Wap.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=u)throw new Error(S.Wap.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,u));y>g&&p.fill(a,g*c,y*c);for(let t=f;t<m;++t){const n=r[t];if(n<0||n>=l[0])throw new Error(S.Wap.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(t,r[t],l[0]));for(let t=0;t<c;t++)p[y*c+t]+=e[n*c+t]}if(s)for(let e=0;e<c;e++)p[y*c+e]/=m-f;if(f=m,++m,g=y+1,y=t,m>o)break}return g<u&&p.fill(a,g*c,u*c),[p,h]}const dc={kernelName:S.w3H,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:i,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${i.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(i.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const a=n.data.get(r.dataId).values,o=n.data.get(i.dataId).values,l=n.data.get(s.dataId).values,[c,u]=hc(a,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(u,r.dtype,c)}},pc={kernelName:S.ZjV,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:i,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${i.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(i.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const a=n.data.get(r.dataId).values,o=n.data.get(i.dataId).values,l=n.data.get(s.dataId).values,[c,u]=hc(a,r.shape,r.dtype,o,l);return n.makeTensorInfo(u,r.dtype,c)}},fc={kernelName:S.D2d,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:i,sparseValues:s,defaultValue:a}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=S.Wap.calculateShapes(s,i,o),p=!1,f=n.bufferSync(i);let m;switch(s.dtype){case"bool":m=$l(f,n.bufferSync(s),o,d,u,c,l,h,Boolean(n.data.get(a.dataId).values[0]),p);break;case"float32":case"int32":m=$l(f,n.bufferSync(s),o,d,u,c,l,h,n.data.get(a.dataId).values[0],p);break;case"string":m=$l(f,n.bufferSync(s),o,d,u,c,l,h,S.D5U.decodeString(n.data.get(a.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${s.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}},mc={kernelName:S.L8s,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{numOrSizeSplits:s,axis:a}=r,o=S.D5U.parseAxisParam(a,i.shape)[0],l=S.Wap.prepareSplitSize(i,s,o),c=new Array(i.shape.length).fill(0),u=i.shape.slice();return l.map((e=>{const t=[...u];t[o]=e;const r=cs({inputs:{x:i},backend:n,attrs:{begin:c,size:t}});return c[o]+=e,r}))}},gc=ai((e=>Math.sqrt(e))),yc=Gr(S.FKq,(e=>Math.sqrt(e))),vc={kernelName:S.FKq,backendName:"cpu",kernelFunc:yc},xc={kernelName:S.bK0,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t;$r(n,"square");const i=r.data.get(n.dataId).values,s=new Float32Array(i.length);for(let e=0;e<i.length;++e){const t=i[e];s[e]=t*t}return{dataId:r.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},bc=Jr(((e,t)=>{const n=e-t;return n*n})),wc=vi(S._tC,bc),_c={kernelName:S._tC,backendName:"cpu",kernelFunc:wc},Sc=Gr(S.h8e,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),Mc={kernelName:S.h8e,backendName:"cpu",kernelFunc:Sc};function Tc(e,t,n,r){const i=(0,S.f3b)(e,t.dtype);for(let e=0;e<i.size;e++){const s=i.indexToLoc(e),a=new Array(s.length);for(let e=0;e<a.length;e++)a[e]=s[e]*n[e]+r[e];i.set(t.get(...a),...s)}return i}const Ec={kernelName:S.jQk,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{begin:s,end:a,strides:o,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=r;$r(i,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:v,end:x,strides:b}=S.kuN.sliceInfo(i.shape,s,a,o,l,c,u,h,d);let w;if(m)w=Mi({inputs:{x:i},backend:n,attrs:{shape:f}});else if(g||y){S.D5U.assert(i.shape.length>=1,(()=>`Input must have rank at least 1, got: ${i.shape.length}`));const e=S.kuN.computeOutShape(v,x,b),t=cs({inputs:{x:i},backend:n,attrs:{begin:v,size:e}});w=Mi({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=Tc(p,n.bufferSync(i),b,v);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};class Ac{constructor(e,t,n,r,i,s){this.separator=S.D5U.encodeString(e),this.nGramWidths=t,this.leftPad=S.D5U.encodeString(n),this.rightPad=S.D5U.encodeString(r),this.padWidth=i,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,i,s){for(let a=0;a<i;++a){const o=this.getPadWidth(s),l=Math.max(0,o-a),c=Math.max(0,o-(i-(a+1))),u=s-(l+c),h=t+(l>0?0:a-o);let d=0;d+=l*this.leftPad.length;for(let t=0;t<u;++t)d+=e[h+t].length;d+=c*this.rightPad.length,d+=(l+c+u-1)*this.separator.length,n[r+a]=new Uint8Array(d);const p=n[r+a];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<u-1;++t)m(e[h+t]),m(this.separator);if(u>0){m(e[h+u-1]);for(let e=0;e<c;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<c-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let i=1;i<r;++i){let r=t[i]>=e;if(r=r&&t[i]<=n,!r)throw new Error(`Invalid split value ${t[i]}, must be in [${e}, ${n}]`);e=t[i]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const i=r-1,s=S.D5U.getArrayFromDType("int32",r);if(0===n||0===r){const e=new Array(n);for(let e=0;e<=i;++e)s[e]=0;return[e,s]}s[0]=0;for(let e=1;e<=i;++e){const n=t[e]-t[e-1];let r=0;this.nGramWidths.forEach((e=>{r+=this.getNumNGrams(n,e)})),this.preserveShort&&n>0&&0===r&&(r=1),s[e]=s[e-1]+r}const a=new Array(s[i]);for(let n=0;n<i;++n){const r=t[n];let i=s[n];if(this.nGramWidths.forEach((s=>{const o=t[n+1]-t[n],l=this.getNumNGrams(o,s);this.createNGrams(e,r,a,i,l,s),i+=l})),this.preserveShort&&i===s[n]){const s=t[n+1]-t[n];if(0===s)continue;const o=s+2*this.padWidth,l=1;this.createNGrams(e,r,a,i,l,o)}}return[a,s]}}function Cc(e,t,n,r,i,s,a,o){return new Ac(n,r,i,s,a,o).compute(e,t)}const Ic={kernelName:S._JP,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:i,nGramWidths:s,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=t,d=n.data.get(u.dataId).values,p=n.data.get(h.dataId).values,[f,m]=Cc(d,p,i,s,a,o,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};function Nc(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const i=t[0];let s=e.indexOf(i);for(;-1!==s;){const t=e.subarray(0,s);n&&0===t.length||r.push(t),s=(e=e.subarray(s+1)).indexOf(i)}return void(n&&0===e.length||r.push(e))}let i=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){const t=e.subarray(i,s);n&&0===t.length||r.push(t),i=s+1}}function kc(e,t,n){const r=e.length,i=[];let s=0,a=0;const o=new Array(r);for(let l=0;l<r;++l){const r=i.length;Nc(e[l],t,n,i);const c=i.length-r;o[l]=c,s+=c,a=Math.max(a,c)}const l=S.D5U.getArrayFromDType("int32",2*s),c=new Array(s),u=[r,a];let h=0;for(let e=0;e<r;++e)for(let t=0;t<o[e];++t)l[2*h]=e,l[2*h+1]=t,c[h]=i[h],++h;return[l,c,u]}const Rc={kernelName:S.s1s,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:i}=r,{input:s,delimiter:a}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==a.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values[0],[c,u,h]=kc(o,l,i),d=u.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};function Dc(e,t){const n=S.D5U.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=S.D5U.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}const Lc={kernelName:S.XkS,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:i}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const a=Dc(n.data.get(s.dataId).values,i);return n.makeTensorInfo(s.shape,"int32",a)}},Fc=Gr(S.sEM,(e=>Math.tan(e))),Pc={kernelName:S.sEM,backendName:"cpu",kernelFunc:Fc},Oc=Gr(S.MIZ,(e=>Math.tanh(e))),zc={kernelName:S.MIZ,backendName:"cpu",kernelFunc:Oc};function Bc(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const r=(0,S.f3b)(n,e.dtype);for(let t=0;t<r.values.length;++t){const n=r.indexToLoc(t),i=new Array(e.rank);for(let t=0;t<i.length;t++)i[t]=n[t]%e.shape[t];const s=e.locToIndex(i);r.values[t]=e.values[s]}return r}const Uc={kernelName:S.n9L,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{reps:s}=r;$r(i,"tile");const a=Bc(n.bufferSync(i),s);return n.makeTensorInfo(a.shape,a.dtype,a.values)}},$c=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function Vc(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){const i=r-n+1,s=t-n+1,a=Math.log(i),o=.5*Math.exp(2*a/3),l=.5*Math.sqrt(a*o*(i-o)/i)*Math.sign(s-i/2);Vc(e,t,Math.max(n,Math.floor(t-s*o/i+l)),Math.min(r,Math.floor(t+(i-s)*o/i+l)))}const i=e[t];let s=n,a=r;for(S.D5U.swap(e,n,t),$c(e[r],i)>0&&S.D5U.swap(e,n,r);s<a;){for(S.D5U.swap(e,s,a),s++,a--;$c(e[s],i)<0;)s+=1;for(;$c(e[a],i)>0;)a-=1}0===$c(e[n],i)?S.D5U.swap(e,n,a):(a+=1,S.D5U.swap(e,a,r)),a<=t&&(n=a+1),t<=a&&(r=a-1)}}function Wc(e,t,n,r,i){const s=t[t.length-1],[a,o]=[e.length/s,s],l=S.D5U.getTypedArrayFromDType(n,a*r),c=S.D5U.getTypedArrayFromDType("int32",a*r);for(let t=0;t<a;t++){const n=t*o,s=e.subarray(n,n+o);let a=new Array(s.length);s.forEach(((e,t)=>a[t]={value:e,index:t})),r<a.length&&(Vc(a,r),a=a.slice(0,r)),i&&a.sort($c);const u=t*r,h=l.subarray(u,u+r),d=c.subarray(u,u+r);for(let e=0;e<r;e++)h[e]=a[e].value,d[e]=a[e].index}const u=t.slice();return u[u.length-1]=r,[(0,S.f3b)(u,n,l),(0,S.f3b)(u,"int32",c)]}const Gc={kernelName:S.cWu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{k:s,sorted:a}=r;$r(i,"topk");const o=n.data.get(i.dataId).values,[l,c]=Wc(o,i.shape,i.dtype,s,a);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}},Hc={kernelName:S.wx7,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{image:i,transforms:s}=t,{interpolation:a,fillMode:o,fillValue:l,outputShape:c}=n,[u,h,d,p]=i.shape,[f,m]=null!=c?c:[h,d],g=[u,f,m,p],y=S.D5U.computeStrides(i.shape),v=y[0],x=y[1],b=y[2],w=S.D5U.getTypedArrayFromDType(i.dtype,S.D5U.sizeFromShape(g));w.fill(l);const _=r.data.get(i.dataId).values,M=r.data.get(s.dataId).values;for(let e=0;e<u;++e){const t=1===s.shape[0]?M:M.subarray(8*e,8*e+8);for(let n=0;n<f;++n)for(let r=0;r<m;++r)for(let i=0;i<p;++i){let s;const c=t[6]*r+t[7]*n+1;if(0===c)continue;const u=(t[0]*r+t[1]*n+t[2])/c,p=(t[3]*r+t[4]*n+t[5])/c,f=jc(u,d,o),m=jc(p,h,o);switch(a){case"nearest":s=Xc(_,h,d,v,x,b,e,m,f,i,l);break;case"bilinear":s=Yc(_,h,d,v,x,b,e,m,f,i,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}w[e*v+n*x+r*b+i]=s}return r.makeTensorInfo(g,i.dtype,w)}return{dataId:r.write(w,g,i.dtype),shape:i.shape,dtype:i.dtype}}};function jc(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return S.D5U.clamp(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return S.D5U.clamp(0,n,t-1)}(e,t);case"nearest":return function(e,t){return S.D5U.clamp(0,e,t-1)}(e,t);default:return function(e,t){return e}(e)}}function qc(e,t,n,r,i,s,a,o,l,c,u){return 0<=o&&o<t&&0<=l&&l<n?e[a*r+o*i+l*s+c]:u}function Xc(e,t,n,r,i,s,a,o,l,c,u){return qc(e,t,n,r,i,s,a,Math.round(o),Math.round(l),c,u)}function Yc(e,t,n,r,i,s,a,o,l,c,u){const h=Math.floor(o),d=Math.floor(l),p=h+1,f=d+1;return(p-o)*((f-l)*qc(e,t,n,r,i,s,a,h,d,c,u)+(l-d)*qc(e,t,n,r,i,s,a,h,f,c,u))+(o-h)*((f-l)*qc(e,t,n,r,i,s,a,p,d,c,u)+(l-d)*qc(e,t,n,r,i,s,a,p,f,c,u))}function Kc(e,t,n,r){const i=S.D5U.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let e=0;e<i;e++)s[0]*=n[e];s[1]=n[i];for(let e=i+1;e<n.length;e++)s[2]*=n[e];const a={},o=new Int32Array(n[i]),l=new S.YDk(s,r,e),c=[],u=1===s[0]&&1===s[2];for(let t=0;t<n[i];t++){let n;if(u)n=e[t].toString();else{const e=[];for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)e.push(l.get(n,t,r));n=e.join(",")}if(void 0!==a[n])o[t]=a[n];else{const e=Object.keys(a).length;a[n]=e,o[t]=e,c.push(t)}}const h=s.slice();h[1]=Object.keys(a).length;const d=new S.YDk(h,r);c.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)d.set(l.get(n,e,r),n,t,r)}));const p=n.slice();return p[i]=h[1],{outputValues:d.values,outputShape:p,indices:o}}const Zc={kernelName:S.kpP,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:i}=n,{x:s}=t;$r(s,"unique");const a=r.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:c}=Kc(a,i,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([c.length],"int32",c)]}},Jc={kernelName:S.ToN,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:i}=t;let{axis:s}=r;s<0&&(s+=i.shape.length);const a=i.shape.length,o=i.shape[s],l=new Array(a-1);let c=0;for(let e=0;e<a;e++)e!==s&&(l[c++]=i.shape[e]);const u=new Array(a).fill(0),h=i.shape.slice();h[s]=1;const d=new Array(o);for(let e=0;e<d.length;e++){u[s]=e;const t=cs({inputs:{x:i},backend:n,attrs:{begin:u,size:h}});d[e]=Mi({inputs:{x:t},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(t)}return d}},Qc={kernelName:S.Qvg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,segmentIds:s}=t,{numSegments:a}=r;$r(i,"unsortedSegmentSum");const o=[],l=[],c=i.shape.length-s.shape.length;let u=s;for(let e=0;e<c;++e){const t=xa({inputs:{input:u},backend:n,attrs:{dim:e+1}});u=t,l.push(t)}for(let e=0;e<a;++e){const t=S.D5U.createScalarValue(e,"int32"),r=n.makeTensorInfo([],"int32",t),s=aa({inputs:{a:r,b:u},backend:n}),a=gi({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),c=Qs({inputs:{a,b:i},backend:n}),h=ta({inputs:{x:c},backend:n,attrs:{axis:0,keepDims:!1}});o.push(h),l.push(r),l.push(s),l.push(a),l.push(c),l.push(h)}const h=vl({inputs:o,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}},eu=[Ci,Ni,Ri,Li,Si,Fi,Bi,Ui,$i,Vi,Gi,ji,Xi,Zi,Qi,rs,is,ss,as,Ai,os,hs,fs,ms,yi,vs,bs,di,ws,Es,Cs,Is,Ns,ks,Rs,Ds,Fs,Os,zs,Bs,Us,$s,Vs,Gs,Hs,js,qs,Xs,Ys,Ks,ra,qr,ia,oa,ma,va,ba,Sa,La,Pa,Oa,Ua,Wa,Ga,Ha,qa,Ya,Ja,to,Yr,no,Ms,io,ao,lo,Zr,ho,mo,yo,bo,_o,To,Ao,No,ko,Ro,Fo,zo,Bo,Uo,$o,Vo,Wo,Go,Ho,Xo,Yo,Jo,nl,ea,il,al,ll,ul,pl,fl,yl,xl,bl,Sl,ti,Tl,Al,mi,Ea,Il,ri,si,Ti,Nl,kl,Rl,Dl,Ll,Fl,Ol,Ul,Vl,Hl,jl,Kl,ci,Jl,ec,nc,us,tl,sc,ac,lc,uc,dc,pc,fc,mc,vc,xc,_c,Mc,Ec,Ic,Rc,Lc,Na,na,Pc,zc,Uc,Gc,Hc,zi,Zc,Jc,Qc,gl];for(const e of eu)(0,S.wCN)(e);const tu={},nu={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function ru(e,t){if(!(e in tu)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e):t;return n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete tu[e]}),!1),1===e?n.getContext("webgl",nu)||n.getContext("experimental-webgl",nu):n.getContext("webgl2",nu)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;tu[e]=n}const n=tu[e];return null==n||n.isContextLost()?(delete tu[e],ru(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),tu[e])}var iu,su,au;function ou(e,t){return[t,e]}function lu(e){const t=S.D5U.sizeFromShape(e),n=Math.ceil(t/4);return S.D5U.sizeToSquarishShape(n)}function cu(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function uu(e,t){const n=e;let r,i,s,a,o,l,c,u,h,d;return 2===(0,S.OBj)().getNumber("WEBGL_VERSION")?(r=n.R32F,i=n.R16F,s=n.RGBA16F,a=n.RGBA32F,o=n.RED,c=4,u=1,h=n.HALF_FLOAT,d=n.FLOAT,l=n.RGBA8):(r=e.RGBA,i=e.RGBA,s=e.RGBA,a=n.RGBA,o=e.RGBA,c=4,u=4,h=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:a,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}function hu(e,t){const n=t();return(0,S.OBj)().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}function du(e){return!!((0,S.OBj)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function pu(e,t){return _u(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(iu||(iu={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(su||(su={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(au||(au={}));const fu=/ERROR: [0-9]+:([0-9]+):/g;function mu(e,t){const n=fu.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],i=e.split("\n"),s=i.length.toString().length+2,a=i.map(((e,t)=>S.D5U.rightPad((t+1).toString(),s)+e));let o=0;for(let e=0;e<a.length;e++)o=Math.max(a[e].length,o);const l=a.slice(0,r-1),c=a.slice(r-1,r),u=a.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${S.D5U.rightPad(c[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function gu(e,t){if(hu(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function yu(e,t,n,r,i,s,a){const o=e.getAttribLocation(t,n);return-1!==o&&(hu(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),hu(e,(()=>e.vertexAttribPointer(o,i,e.FLOAT,!1,s,a))),hu(e,(()=>e.enableVertexAttribArray(o))),!0)}function vu(e,t,n,r){hu(e,(()=>function(e,t,n){(function(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(e,n),hu(e,(()=>e.activeTexture(e.TEXTURE0+n))),hu(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,r))),hu(e,(()=>e.uniform1i(n,r)))}function xu(e,t,n){hu(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),hu(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function bu(e,t){hu(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),hu(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function wu(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function _u(e,t,n){const r=hu(e,(()=>t()));if(null==r)throw new Error(n);return r}function Su(e,t=2){return S.D5U.sizeFromShape(e.slice(0,e.length-t))}function Mu(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Tu(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[Su(e),...Mu(e)]),t}function Eu(e){return e%2==0}function Au(e,t){if(e=e.slice(-2),t=t.slice(-2),S.D5U.arraysEqual(e,t))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r)return!0;if(Eu(n)&&Eu(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&Eu(e[0])&&Eu(t[0])}let Cu,Iu;function Nu(e,t){return null!=e.getExtension(t)}function ku(e){try{if(null!=ru(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function Ru(e){const t=uu(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),i}function Du(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&S.D5U.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const Lu=(0,S.OBj)();function Fu(){let e,t,n,r,i,s,a,o,l,c;return 2===(0,S.OBj)().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",i="texture",s="outputColor",a="out vec4 outputColor;",o="\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",i="texture2D",s="gl_FragColor",a="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:i,output:s,defineOutput:a,defineSpecialNaN:o,defineSpecialInf:l,defineRound:c}}function Pu(e,t,n="index"){const r=S.D5U.computeStrides(t);return r.map(((t,i)=>`int ${e[i]} = ${n} / ${t}; ${i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${t}`:`index -= ${e[i]} * ${t}`};`)).join("")}function Ou(e,t,n="index"){const r=S.D5U.computeStrides(t);return r.map(((t,i)=>`int ${e[i]} = ${n} / outShapeStrides[${i}]; ${i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * outShapeStrides[${i}]`:`index -= ${e[i]} * outShapeStrides[${i}]`};`)).join("")}function zu(e){const t=S.D5U.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}Lu.registerFlag("HAS_WEBGL",(()=>Lu.getNumber("WEBGL_VERSION")>0)),Lu.registerFlag("WEBGL_VERSION",(()=>ku(2)?2:ku(1)?1:0)),Lu.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),Lu.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===Lu.get("WEBGL_VERSION"))),Lu.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),Lu.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),Lu.registerFlag("WEBGL_PACK",(()=>Lu.getBool("HAS_WEBGL"))),Lu.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>Lu.getBool("WEBGL_PACK"))),Lu.registerFlag("WEBGL_PACK_CLIP",(()=>Lu.getBool("WEBGL_PACK"))),Lu.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>Lu.getBool("WEBGL_PACK"))),Lu.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>Lu.getBool("WEBGL_PACK"))),Lu.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>Lu.getBool("WEBGL_PACK"))),Lu.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>Lu.getBool("WEBGL_PACK"))),Lu.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>Lu.getBool("WEBGL_PACK"))),Lu.registerFlag("WEBGL_PACK_REDUCE",(()=>Lu.getBool("WEBGL_PACK"))),Lu.registerFlag("WEBGL_LAZILY_UNPACK",(()=>Lu.getBool("WEBGL_PACK"))),Lu.registerFlag("WEBGL_CONV_IM2COL",(()=>Lu.getBool("WEBGL_PACK"))),Lu.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==Cu){const t=ru(e);Cu=t.getParameter(t.MAX_TEXTURE_SIZE)}return Cu}(Lu.getNumber("WEBGL_VERSION")))),Lu.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==Iu){const t=ru(e);Iu=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Iu)}(Lu.getNumber("WEBGL_VERSION")))),Lu.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=Lu.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=ru(e);return t=Nu(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:Nu(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),Lu.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>Lu.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!S.C2$.isMobile())),Lu.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=ru(e);if(1===e){if(!Nu(t,"OES_texture_float"))return!1}else if(!Nu(t,"EXT_color_buffer_float"))return!1;return Ru(t)}(Lu.getNumber("WEBGL_VERSION")))),Lu.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!Lu.getBool("WEBGL_FORCE_F16_TEXTURES")&&Lu.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),Lu.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>function(e){if(0===e)return!1;const t=ru(e);if(1!==e){if(Nu(t,"EXT_color_buffer_float"))return Ru(t);const e="EXT_color_buffer_half_float";if(Nu(t,e)){const n=t.getExtension(e);return function(e,t){const n=uu(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),s}(t,n)}return!1}return!!Nu(t,"OES_texture_float")&&!!Nu(t,"WEBGL_color_buffer_float")&&Ru(t)}(Lu.getNumber("WEBGL_VERSION")))),Lu.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=Lu.getNumber("WEBGL_VERSION"))&&null!=ru(e).fenceSync;var e})),Lu.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>Lu.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),Lu.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),Lu.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>S.C2$.isMobile()?1:-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),Lu.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),Lu.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),Lu.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),Lu.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128));const Bu="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:Uu}=S.Wap;function $u(e,t,n){const r=[];if(e.forEach((e=>{const t=S.D5U.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=Zu(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const i=r.join("\n"),s=e.map((e=>function(e,t,n=!1,r){let i="";i+=n?Wu(e,r):Vu(e,r);const s=e.shapeInfo.logicalShape,a=t.logicalShape;return s.length<=a.length&&(i+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),i="get"+r+"AtOutCoords",s=e.shapeInfo.logicalShape.length,a=t.logicalShape.length,o=Uu(e.shapeInfo.logicalShape,t.logicalShape),l=Ku(a),c=a-s;let u;const h=["x","y","z","w","u","v"];u=0===s?"":a<2&&o.length>=1?"coords = 0;":o.map((e=>`coords.${h[e+c]} = 0;`)).join("\n");let d="";d=a<2&&s>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${h[t+c]}`)).join(", ");let p="return outputValue;";const f=1===S.D5U.sizeFromShape(e.shapeInfo.logicalShape),m=1===S.D5U.sizeFromShape(t.logicalShape);if(1!==s||f||m){if(f&&!m)p=1===a?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const e=s-2,t=s-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?p="return vec4(outputValue.x);":o.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${i}() {\n      ${l} coords = getOutputCoords();\n      ${u}\n      vec4 outputValue = get${r}(${d});\n      ${p}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),i="get"+r+"AtOutCoords",s=t.texShape,a=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&S.D5U.arraysEqual(a,s))return`\n      float ${i}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const c=Ku(l),u=Uu(e.shapeInfo.logicalShape,t.logicalShape),h=l-o;let d;const p=["x","y","z","w","u","v"];d=0===o?"":l<2&&u.length>=1?"coords = 0;":u.map((e=>`coords.${p[e+h]} = 0;`)).join("\n");let f="";return f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${p[t+h]}`)).join(", "),`\n    float ${i}() {\n      ${c} coords = getOutputCoords();\n      ${d}\n      return get${r}(${f});\n    }\n  `}(e,t)),i}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),a=t.texShape,o=Fu(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(o);let c,u,h=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Gu}\n    ${Hu}\n    ${ju}\n  `}(o);return t.isPacked?(c=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(S.D5U.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const i=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],i=Math.ceil(e[2]/2),s=i*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],i=Math.ceil(e[e.length-1]/2),s=i*Math.ceil(e[e.length-2]/2);let a=s,o="",l="b, r, c";for(let t=2;t<e.length-1;t++)a*=e[e.length-t-1],o=`\n      int b${t} = index / ${a};\n      index -= b${t} * ${a};\n    `+o,l=`b${t}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,a,n.enableShapeUniforms),u=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(o)):(c=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){return S.D5U.arraysEqual(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${Ou(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;const r=Pu(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${Ou(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=Pu(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=Pu(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=Pu(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,a,n.enableShapeUniforms),u=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(o)),n.packedInputs&&(h+=qu),[h,l,u,i,c,s,n.userCode].join("\n")}function Vu(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[i,s]=e.shapeInfo.texShape;if(1===i&&1===s)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const a=Xu(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${a});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${a});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${Yu(e)}\n      }\n    `;const i=e.shapeInfo.texShape,s=i[0],a=i[1];if(1===a&&1===s)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=Xu(n);return 1===a?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===s?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${a}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${a}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(null!=s&&S.D5U.arraysEqual(n,s)){if(t)return`\n      float ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=s[0];return`\n    float ${i}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:a,keptDims:o}=S.D5U.squeezeShape(n),l=a;if(l.length<n.length){const n=["row","col"];return`\n      ${Vu(Ju(e,l),t)}\n      float ${i}(int row, int col) {\n        return ${i}(${Qu(n,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${Yu(e)}\n      }\n    `;const c=s[0],u=s[1],h=Xu(r);return 1===u?t?`\n      float ${i}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===c?t?`\n      float ${i}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${i}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${h};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${i}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${c}, ${u}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],a=n[2],{newShape:o,keptDims:l}=S.D5U.squeezeShape(n),c=o;if(c.length<n.length){const n=["row","col","depth"];return`\n        ${Vu(Ju(e,c),t)}\n        float ${i}(int row, int col, int depth) {\n          return ${i}(${Qu(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${a}, 1)));\n        ${Yu(e)}\n      }\n    `;const u=e.shapeInfo.texShape,h=u[0],d=u[1],p=e.shapeInfo.flatOffset;if(d===s&&null==p)return t?`\n      float ${i}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${i}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${h}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(d===a&&null==p)return t?`\n      float ${i}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=Xu(r);return t?`\n    float ${i}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * ${s} + col * ${a} + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${i}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${a} + depth + ${f};\n        vec2 uv = uvFromFlat(${h}, ${d}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],a=n[2]*s,o=n[1]*a,{newShape:l,keptDims:c}=S.D5U.squeezeShape(n);if(l.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${Vu(Ju(e,l),t)}\n      float ${i}(int row, int col, int depth, int depth2) {\n        return ${i}(${Qu(n,c)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${a}, ${s}, 1)));\n        ${Yu(e)}\n      }\n    `;const u=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&null==u)return t?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===s&&null==u)return t?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const y=Xu(r);return t?`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${a} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${p}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=t[4],s=t[3]*i,a=t[2]*s,o=t[1]*a,{newShape:l,keptDims:c}=S.D5U.squeezeShape(t);if(l.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${Vu(Ju(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Qu(t,c)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${a}, ${s}, ${i})) +\n          depth3;\n        ${Yu(e)}\n      }\n    `;const u=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1];if(p===o&&null==u)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${a}, ${s}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===i&&null==u)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${a} + depth * ${s} +\n          depth2 * ${i} + depth3 + ${Xu(n)};\n      vec2 uv = uvFromFlat(${d}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:i,keptDims:s}=S.D5U.squeezeShape(t);if(i.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Vu(Ju(e,i))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Qu(t,s)});\n      }\n    `}const a=t[5],o=t[4]*a,l=t[3]*o,c=t[2]*l,u=t[1]*c;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${u}, ${c}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${a}, 1)));\n        ${Yu(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];if(f===u&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${l}, ${o}, ${a})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===a&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${c} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${a} + depth4 + ${Xu(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function Wu(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${Fu().texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=e.shapeInfo.texShape,s=Fu();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;const a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${a[0]}, ${a[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,a=s[0],o=s[1],l=Fu();if(null!=s&&S.D5U.arraysEqual(n,s))return t?`\n      vec4 ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${i}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${a}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${i}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const c=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${i}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(n[1]/2)}, ${c[0]}, ${c[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){const r=[1,2],s=["b","row","col"];return`\n        ${Wu(Ju(e,n.slice(1)),t)}\n        vec4 ${i}(int b, int row, int col) {\n          return ${i}(${Qu(s,r)});\n        }\n      `}const o=Fu();if(t)return`\n    vec4 ${i}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;const l=a[0],c=a[1],u=Math.ceil(n[2]/2);return`\n    vec4 ${i}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${c}, ${u*Math.ceil(n[1]/2)}, ${u}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=Fu();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${n}, uv);\n    }\n  `;const s=e.shapeInfo.logicalShape,a=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=l[0],u=l[1],h=Math.ceil(s[a-1]/2);let d=h*Math.ceil(s[a-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let e=2;e<a-1;e++)p=`int b${e}, `+p,d*=s[a-e-1],f=`b${e} * ${d} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});\n      return ${i.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}const Gu="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Hu="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",ju="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",qu="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Xu(e){return`offset${e}`}function Yu(e){const t=e.name,n=S.D5U.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function Ku(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function Zu(e,t,n){const{newShape:r,keptDims:i}=S.D5U.squeezeShape(t),s=t.length,a=e&&3===s&&1===t[0],o=a?t.slice(1):r,l=!e&&s>1&&!S.D5U.arraysEqual(t,n)&&r.length<s||a;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:i}}function Ju(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Qu(e,t){return t.map((t=>e[t])).join(", ")}function eh(e,t,n){const r={},i={},s={},a=[];let o,l,c,u=null,h=null;h=e.getUniformLocation(n,"NAN",!1),1===(0,S.OBj)().getNumber("WEBGL_VERSION")&&(u=e.getUniformLocation(n,"INFINITY",!1));const d=!1;for(let a=0;a<t.variableNames.length;a++){const o=t.variableNames[a];r[o]=e.getUniformLocation(n,o,d),r[`offset${o}`]=e.getUniformLocation(n,`offset${o}`,d),t.enableShapeUniforms&&(i[`${o}Shape`]=e.getUniformLocation(n,`${o}Shape`,d),s[`${o}TexShape`]=e.getUniformLocation(n,`${o}TexShape`,d))}return t.enableShapeUniforms&&(o=e.getUniformLocation(n,"outShape",d),c=e.getUniformLocation(n,"outShapeStrides",d),l=e.getUniformLocation(n,"outTexShape",d)),t.customUniforms&&t.customUniforms.forEach(((t,r)=>{a[r]=e.getUniformLocation(n,t.name,d)})),{uniformLocations:r,customUniformLocations:a,infLoc:u,nanLoc:h,inShapesLocations:i,inTexShapesLocations:s,outShapeLocation:o,outShapeStridesLocation:c,outTexShapeLocation:l}}function th(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const r=e.logicalShape,i=t[n],s=i.shape;if(!S.D5U.arraysEqual(r,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${s} must match`);if(e.isUniform&&i.isUniform)return;const a=e.texShape,o=i.isUniform?null:i.texData.texShape;if(!S.D5U.arraysEqual(a,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${o} must match`)}))}function nh(e){return(0,S.OBj)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class rh{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=iu.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Fu();this.outputShape=e,this.enableShapeUniforms=nh(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Ou(["r","c","d"],e):Pu(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class ih{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=iu.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Fu();this.outputShape=e,this.enableShapeUniforms=nh(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Ou(["r","c","d"],e):Pu(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class sh{constructor(e){this.variableNames=["A"],this.outTexUsage=su.DOWNLOAD;const t=Fu();this.outputShape=e,this.userCode=`\n      ${Bu}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class ah{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=su.DOWNLOAD;const t=Fu();this.outputShape=e,this.userCode=`\n      ${Bu}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}class oh{constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Fu();this.outputShape=e,this.enableShapeUniforms=nh(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)"),this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":zu(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${n.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${n.output} = vec4(${r}, 0., 0., 0.);\n      }\n    `}}class lh{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Fu();this.outputShape=e,this.enableShapeUniforms=nh(this.outputShape.length);let r="",i="result";t&&(i="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let i=0;i<=1;i++){const s=2*t+i;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${i};\n          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${t};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${s}] = values[0];\n            } else if (offset == 1) {\n              result[${s}] = values[1];\n            } else if (offset == 2) {\n              result[${s}] = values[2];\n            } else {\n              result[${s}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":zu(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${i};\n        }\n    `}}function ch(e,t,n,r,i,s){!function(e,t){const n=(0,S.OBj)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const a=function(e){return _u(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),o=e.TEXTURE_2D;return hu(e,(()=>e.bindTexture(o,a))),hu(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),hu(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),hu(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),hu(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===(0,S.OBj)().getNumber("WEBGL_VERSION")?hu(e,(()=>e.texImage2D(o,0,r,t,n,0,i,s,null))):hu(e,(()=>e.texStorage2D(o,1,r,t,n))),hu(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:a,texShape:[n,t]}}function uh(e){return e.internalFormatFloat}function hh(e){return e.internalFormatHalfFloat}function dh(e){return e.downloadTextureFormat}function ph(e){return e.internalFormatPackedFloat}function fh(e){return e.internalFormatPackedHalfFloat}class mh{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=(0,S.OBj)().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,function(e,t){tu[e]=t}(t,e)):this.gl=ru(t);let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===(0,S.OBj)().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=pu(this.gl,e),Nu(this.gl,t))this.textureHalfFloatExtension=pu(this.gl,t);else if((0,S.OBj)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Nu(this.gl,r))this.colorBufferHalfFloatExtension=pu(this.gl,r);else if((0,S.OBj)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Nu(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!Nu(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=function(e){return function(e,t){const n=_u(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return hu(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),hu(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(e){return function(e,t){const n=_u(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return hu(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),hu(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(e){return _u(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=uu(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,S.OBj)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;hu(e,(()=>e.finish())),hu(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),hu(e,(()=>e.deleteFramebuffer(this.framebuffer))),hu(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),hu(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),hu(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[i,s]=ou(t,n);return ch(e,i,s,uh(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[i,s]=ou(t,n);return ch(e,i,s,hh(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[i,s]=ou(t,n);return ch(e,i,s,dh(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){hu(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===(0,S.OBj)().getNumber("WEBGL_VERSION")?hu(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):hu(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===(0,S.OBj)().getNumber("WEBGL_VERSION")?hu(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):hu(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),hu(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,i,s){let a,o,l;hu(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),i instanceof Uint8Array?(a=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(a=new Float32Array(n*r*4),o=e.FLOAT,l=s.internalFormatPackedFloat),a.set(i),2===(0,S.OBj)().getNumber("WEBGL_VERSION")?hu(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,a))):hu(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,a))),hu(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[i,s]=cu(t,n);return ch(e,i,s,fh(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[i,s]=cu(t,n);return ch(e,i,s,ph(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(bu(this.gl,this.framebuffer),this.outputTexture=null),hu(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,r){const[i,s]=ou(t,n),a=new Uint8Array(t*n*4);return hu(e,(()=>e.readPixels(0,0,i,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,a))),new Float32Array(a.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,i,s){return function(e,t,n,r,i,s,a,o){const l=e,c=new Float32Array(function(e,t){const[n,r]=cu(e,t);return n*r*4}(s,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}(this.gl,e,0,0,0,i,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,i=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,i),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),i}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n,r){const i=e.createBuffer();hu(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,i)));const s=16*t*n;return hu(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ))),hu(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),hu(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),i}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if((0,S.OBj)().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(i,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=i}else(0,S.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,(0,S.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const r=new Float32Array(t*n*4);return hu(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=function(e){const t=Fu();return function(e,t){const n=_u(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(hu(e,(()=>e.shaderSource(n,t))),hu(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(t));const n=function(e){return _u(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);return hu(t,(()=>t.attachShader(n,this.vertexShader))),hu(t,(()=>t.attachShader(n,e))),function(e,t){if(hu(e,(()=>e.linkProgram(t))),!(0,S.OBj)().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n),this.debug&&gu(t,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=function(e,t,n){return hu(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),yu(e,t,"clipSpacePos",n,3,20,0)&&yu(e,t,"uv",n,2,20,12)}(t,this.program,this.vertexBuffer)),n}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&hu(this.gl,(()=>this.gl.deleteProgram(e)))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&gu(this.gl,this.program),hu(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?function(e,t,n){return _u(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),hu(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),vu(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,i]=cu(t,n);this.setOutputMatrixTextureDriver(e,r,i)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&gu(this.gl,this.program),wu(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),hu(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),hu(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=pu(this.gl,2===(0,S.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,S.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===(0,S.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await S.D5U.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,(0,S.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,(0,S.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||S.D5U.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),xu(this.gl,e,this.framebuffer),this.debug&&wu(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(xu(this.gl,this.outputTexture,this.framebuffer),this.debug&&wu(this.gl)):bu(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;xu(r,e,this.framebuffer),this.debug&&wu(r),this.outputTexture=e,hu(r,(()=>r.viewport(0,0,t,n))),hu(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),hu(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:gh,bincountImpl:yh,bincountReduceImpl:vh,ceilImpl:xh,concatImpl:bh,equalImpl:wh,expImpl:_h,expm1Impl:Sh,floorImpl:Mh,gatherNdImpl:Th,gatherV2Impl:Eh,greaterImpl:Ah,greaterEqualImpl:Ch,lessImpl:Ih,lessEqualImpl:Nh,linSpaceImpl:kh,logImpl:Rh,maxImpl:Dh,maximumImpl:Lh,minimumImpl:Fh,multiplyImpl:Ph,negImpl:Oh,notEqualImpl:zh,prodImpl:Bh,rangeImpl:Uh,rsqrtImpl:$h,scatterImpl:Vh,sigmoidImpl:Wh,simpleAbsImpl:Gh,sliceImpl:Hh,sparseFillEmptyRowsImpl:jh,sparseReshapeImpl:qh,sparseSegmentReductionImpl:Xh,sqrtImpl:Yh,stridedSliceImpl:Kh,stringNGramsImpl:Zh,stringSplitImpl:Jh,stringToHashBucketFastImpl:Qh,subImpl:ed,tileImpl:td,topKImpl:nd,transposeImpl:rd,uniqueImpl:id}=_;function sd(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function ad(e,t){return 1===t?[e]:sd(e,t)}class od{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=nh(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=ad("rc",this.rank),t=Ku(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),i=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${i}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let i=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)i=`${e[e.length-1-t]},`+i;t.push(i)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class ld{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=nh(this.outputShape.length);let n="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}var r,i;this.userCode=`\n      ${r=t,i=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${i?function(e,t,n="index"){const r=function(e,t){const n=e.length,r=e.map((e=>`${t}[${e}]`)),i=new Array(n-1);i[n-2]=r[n-1];for(let e=n-3;e>=0;--e)i[e]=`(${i[e+1]} * ${r[e+1]})`;return i}(e.map(((e,t)=>t)),t);return r.map(((t,i)=>`int ${e[i]} = ${n} / ${r[i]}; ${i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${r[i]}`:`index -= ${e[i]} * ${r[i]}`};`)).join("")}(["r","c","d"],"inputShape"):Pu(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":zu(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class cd{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const r=hd(t,n),i=dd(e,r,n);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const s=ud(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const e=this.freeTextures[i].shift();return this.usedTextures[i].push(e),e}let a;return r===au.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===au.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===au.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===au.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===au.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),a}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const i=hd(n,r),s=dd(t,i,r);s in this.freeTextures||(this.freeTextures[s]=[]);const a=ud(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=(0,S.OBj)().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const l=this.usedTextures[s],c=l.indexOf(e);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(c,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function ud(e,t,n,r,i){const s=function(e,t){switch(e){case au.PACKED_2X2_FLOAT32:return ph(t);case au.PACKED_2X2_FLOAT16:return fh(t);case au.UNPACKED_FLOAT32:return uh(t);case au.UNPACKED_FLOAT16:return hh(t);case au.PACKED_4X1_UNSIGNED_BYTE:return dh(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let a;if(i){const[t,n]=cu(e[0],e[1]);a=t*n}else{const[t,n]=ou(e[0],e[1]);a=t*n}const o=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,s);return a*o}function hd(e,t){if(e===su.UPLOAD)return au.PACKED_2X2_FLOAT32;if(e===su.RENDER||null==e)return function(e){return(0,S.OBj)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?au.PACKED_2X2_FLOAT32:au.UNPACKED_FLOAT32:e?au.PACKED_2X2_FLOAT16:au.UNPACKED_FLOAT16}(t);if(e===su.DOWNLOAD||e===su.PIXELS)return au.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function dd(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class pd{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=nh(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const fd="return abs(x);",md="return x;";class gd{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=nh(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class yd{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=nh(this.outputShape.length);const t=e.length,n=ad("rc",t),r=Ku(t),i=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),s=n.slice(-2),a=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${i});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const vd=S.GDt.whereImpl,xd={},bd=(0,S.OBj)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class wd extends S.Zuw{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!(0,S.OBj)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof mh)t=e;else{const n=ru((0,S.OBj)().getNumber("WEBGL_VERSION"),e);t=new mh(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=ru((0,S.OBj)().getNumber("WEBGL_VERSION"));t=new mh(e),this.binaryCache=((n=(0,S.OBj)().getNumber("WEBGL_VERSION"))in xd||(xd[n]={}),xd[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new cd(this.gpgpu),this.numMBBeforeWarning=null==(0,S.OBj)().global.screen?1024:(0,S.OBj)().global.screen.height*(0,S.OBj)().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new S.JLz(this,(0,S.SRH)())}nextDataId(){return wd.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if(((0,S.OBj)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,S.OBj)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:su.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,t,n,r,i){if((0,S.OBj)().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:su.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:i,slice:s,shape:a,isPacked:o}=t;if(null!=s){let t;t=o?new gd(a,md):new pd(a,md);const n=this.runWebGLProgram(t,[{dataId:e,shape:a,dtype:r}],r),i=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),i}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const l=null!=this.activeTimers;let c,u;if(l&&(c=S.D5U.now()),"complex64"===r){const e=this.readSync(i.real.dataId),t=this.readSync(i.imag.dataId);u=S.Wap.mergeRealAndImagArrays(e,t)}else u=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=S.D5U.now()-c),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:i,dtype:s,complexTensorInfos:a,isPacked:o}=t;if(null!=i){let t;t=o?new gd(r,md):new pd(r,md);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),i=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),i}if(null!=n)return this.convertAndCacheOnCPU(e);if((0,S.OBj)().getBool("DEBUG")&&!(0,S.OBj)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===(0,S.OBj)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,c,u=null;if("complex64"!==s&&(0,S.OBj)().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);u=this.gpgpu.createBufferFromTexture(t.texture.texture,...lu(r))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){const e=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),t=e[0],n=e[1];c=S.Wap.mergeRealAndImagArrays(t,n)}else if(null==u)c=this.getValuesFromTexture(e);else{const e=S.D5U.sizeFromShape(r);c=this.gpgpu.downloadFloat32MatrixFromBuffer(u,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=u){const e=this.gpgpu.gl;hu(e,(()=>e.deleteBuffer(u)))}const h=this.convertAndCacheOnCPU(e,c),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach((e=>e(h))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&(0,S.SRH)().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e,t={}){const n=this.texData.get(e),{values:r,shape:i,slice:s,dtype:a,isPacked:o,texture:l}=n;if("complex64"===a)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=o?new gd(i,md):new pd(i,md);const r=this.runWebGLProgram(n,[{dataId:e,shape:i,dtype:a}],a),s=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),s}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,t.customTexShape),u=(0,S.SRH)().makeTensorFromTensorInfo(c),h=this.texData.get(c.dataId);return Object.assign({tensorRef:u},h.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>S.D5U.decodeString(e)));return(0,S.f3b)(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,S.f3b)(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!du(n)){if((0,S.OBj)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),i=S.D5U.sizeFromShape(t);if((0,S.OBj)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...lu(t)).subarray(0,i);return this.disposeIntermediateTensorInfo(n),s}const s=(0,S.OBj)().getBool("WEBGL_PACK")&&!0===r,a=s?Tu(t):t,o=s?new ah(a):new sh(a),l=this.runWebGLProgram(o,[{shape:a,dtype:n,dataId:e}],"float32"),c=this.texData.get(l.dataId),u=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(l),u}timerAvailable(){return(0,S.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const i=S.D5U.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=S.D5U.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if((0,S.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(i);a.kernelMs=S.D5U.sum(e),a.getExtraProfileInfo=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,S.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:S.D5U.now(),endMs:null}}endTimer(e){return(0,S.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=S.D5U.now(),e)}async getQueryTime(e){if((0,S.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:i,isPacked:s,slice:a}=this.texData.get(e),o=a&&a.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,i,s)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=bd){return(0,S.OBj)().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&S.D5U.sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){S.Wap.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return vd(e.shape,t)}packedUnaryOp(e,t,n){const r=new gd(e.shape,t),i=this.compileAndRun(r,[e],n);return(0,S.SRH)().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=Gh(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if((0,S.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,fd,e.dtype);const t=new pd(e.shape,fd),n=this.compileAndRun(t,[e]);return(0,S.SRH)().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&S.D5U.isString(n[0])){const i=n.map((e=>S.D5U.encodeString(e)));r=this.write(i,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return(0,S.SRH)().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new yd(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new od(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[Su(e.shape),...Mu(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},i=[Su(t),...Mu(t)],s=new ld(i,n),a=[n],o=this.runWebGLProgram(s,[r],e.dtype,a,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:i,dtype:s}=n;if(null!=t){const e=S.D5U.sizeFromShape(i),n=t[0]*t[1]*4;S.D5U.assert(e<=n,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const a=Tu(i);let o;o=r?new ih(a):new rh(a);const l=[null!=t?t:lu(a)];return{dtype:s,shape:i,dataId:this.runWebGLProgram(o,[{shape:a,dtype:s,dataId:e}],s,l,!0,t).dataId}}runWebGLProgram(e,t,n,r,i=!1,s){const a=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(a.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===iu.DENSE){const t=null!=s?s:lu(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===S.D5U.sizeFromShape(a.shape))return o.values=S.D5U.getTypedArrayFromDType(a.dtype,0),a;const l=[],c=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&S.D5U.sizeFromShape(t.shape)<=(0,S.OBj)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!Au(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(a.dataId);const u={shape:a.shape,texData:o,isUniform:!1},h=function(e,t,n){let r="";t.concat(n).forEach((t=>{const i=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const s=t.texData.texShape,{useSqueezeShape:a,uniformShape:o,keptDims:l}=Zu(e.packedInputs,t.shape,s);let c="",u="",h="";if(1===o.length&&e.packedInputs){const e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];c=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){const e=S.D5U.computeStrides(o);h=`${e[0]===s[1]}_${e[e.length-1]===s[1]}`}}else u=`${o[0]>1}_${o[1]>1}`;const d=t.shape.length,p=2===o.length&&S.D5U.arraysEqual(t.shape,s),f=1===S.D5U.sizeFromShape(t.shape),m=S.Wap.getBroadcastDims(t.shape,n.shape),g=!e.packedInputs&&d===n.shape.length&&S.D5U.arraysEqual(s,n.texData.texShape),y=e.packedInputs||o.length>2?"":`${s[0]>1}_${s[1]>1}`;r+=`${d}_${g}_${a?l:""}_${o.length}_${f}_${m}_${p}_${c}_${u}_${h}_${y}_${i}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${i}`}}));const i=e.userCode;let s=e.constructor.name;return s+="_"+r+"_"+i+`${(0,S.OBj)().getNumber("WEBGL_VERSION")}`,s}(e,c,u),d=this.getAndSaveBinary(h,(()=>function(e,t,n,r){const i=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),s=i.map((e=>e.shapeInfo)),a={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=$u(i,a,t),l=function(e,t){const n=_u(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(hu(e,(()=>e.shaderSource(n,t))),hu(e,(()=>e.compileShader(n))),(0,S.OBj)().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw mu(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,o),c=e.createProgram(l);return(0,S.OBj)().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:c,inShapeInfos:s,outShapeInfo:a,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:c,inShapeInfos:s,outShapeInfo:a},eh(e,t,c))}(this.gpgpu,e,c,u))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),(0,S.OBj)().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,i){t.program.enableShapeUniforms||(th(t.inShapeInfos,n),th([t.outShapeInfo],[r]));const s=r.texData.texture,a=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,a[0],a[1]):e.setOutputMatrixTexture(s.texture,a[0],a[1]),e.setProgram(t.webGLProgram),1===(0,S.OBj)().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach(((n,r)=>{const i=t.program.variableNames[r],s=t.uniformLocations[i],a=t.uniformLocations[`offset${i}`],o=t.inShapesLocations[`${i}Shape`],l=t.inTexShapesLocations[`${i}TexShape`];if(o){const{uniformShape:r}=Zu(t.program.packedInputs,n.shape,n.texData.texShape);switch(r.length){case 1:e.gl.uniform1iv(o,new Int32Array(r));break;case 2:e.gl.uniform2iv(o,new Int32Array(r));break;case 3:e.gl.uniform3iv(o,new Int32Array(r));break;case 4:e.gl.uniform4iv(o,new Int32Array(r))}}if(l&&e.gl.uniform2i(l,n.texData.texShape[0],n.texData.texShape[1]),null!=s)if(n.isUniform)if(S.D5U.sizeFromShape(n.shape)<2)e.gl.uniform1f(s,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}else null!=n.texData.slice&&null!=a&&e.gl.uniform1i(a,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture.texture,s,r)}));const o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const n=S.D5U.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&i&&t.program.customUniforms.forEach(((n,r)=>{const s=t.customUniformLocations[r],a=i[r];if("float"===n.type)e.gl.uniform1fv(s,a);else if("vec2"===n.type)e.gl.uniform2fv(s,a);else if("vec3"===n.type)e.gl.uniform3fv(s,a);else if("vec4"===n.type)e.gl.uniform4fv(s,a);else if("int"===n.type)e.gl.uniform1iv(s,a);else if("ivec2"===n.type)e.gl.uniform2iv(s,a);else if("ivec3"===n.type)e.gl.uniform3iv(s,a);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(s,a)}})),e.executeProgram()}(this.gpgpu,d,c,u,r),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=(0,S.OBj)().get("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=S.D5U.now();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!(0,S.OBj)().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===i){const e=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),e}return a}compileAndRun(e,t,n,r,i=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,i)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||((0,S.OBj)().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(0,S.lub)((()=>{if(!(0,S.OBj)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=(0,S.OBj)().getBool("DEBUG");(0,S.OBj)().set("DEBUG",!1);const t=this.abs((0,S.iD$)(1e-8)).dataSync()[0];if((0,S.OBj)().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:i,texture:s,usage:a,isPacked:o}=t;if(null!=s)return;const l=null!=this.activeTimers;let c;l&&(c=S.D5U.now());let u=t.texShape;if(null==u&&(u=function(e,t=!1){let n=(0,S.OBj)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t&&(n*=2,1===(e=e.map(((t,n)=>n>=e.length-2?S.D5U.nearestLargerEven(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=S.D5U.squeezeShape(e);e=t.newShape}let r=S.D5U.sizeFromShape(e);if(e.length<=1&&r<=n)return[1,r];if(2===e.length&&e[0]<=n&&e[1]<=n)return e;if(3===e.length&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){const t=Su(e);let n=2,i=2;return e.length&&([n,i]=Mu(e)),r=t*(n/2)*(i/2),S.D5U.sizeToSquarishShape(r).map((e=>2*e))}return S.D5U.sizeToSquarishShape(r)}(n,o),t.texShape=u),null!=i){const e=Tu(n);let s,a=u[1],h=u[0];const d=i instanceof Uint8Array||i instanceof Uint8ClampedArray;!o&&d||([a,h]=cu(u[0],u[1])),s=o?new lh(e,d):new oh(e,d);const p=d?[h,a]:u,f=this.makeTensorInfo(p,r),m=this.texData.get(f.dataId);m.usage=d?su.PIXELS:su.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),a,h,i);const g=[[h,a]],y=!0,v=this.runWebGLProgram(s,[f],r,g,y),x=this.texData.get(v.dataId);t.texShape=x.texShape,t.isPacked=x.isPacked,t.usage=x.usage,(0,S.OBj)().get("ENGINE_COMPILE_ONLY")?this.disposeData(v.dataId):(t.texture=x.texture,t.values=null,this.texData.delete(v.dataId)),this.disposeIntermediateTensorInfo(f),l&&(this.uploadWaitMs+=S.D5U.now()-c)}else{const e=this.acquireTexture(u,a,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*S.D5U.bytesPerElement(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(e){throw e}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await(0,S.glt)(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw mu(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:t,customUniformLocations:n,infLoc:r,nanLoc:i,inShapesLocations:s,inTexShapesLocations:a,outShapeLocation:o,outShapeStridesLocation:l,outTexShapeLocation:c}=eh(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=i,e.inShapesLocations=s,e.inTexShapesLocations=a,e.outShapeLocation=o,e.outShapeStridesLocation=l,e.outTexShapeLocation=c}}}wd.nextDataId=0,S.C2$.isBrowser()&&(0,S.jqO)("webgl",(()=>new wd),2);class _d{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=S.Wap.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=nh(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class Sd{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=S.Wap.assertAndGetBroadcastShape(t,n);const i=this.outputShape.length;this.enableShapeUniforms=nh(i);let s="";if(r)if(0===i||1===S.D5U.sizeFromShape(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(s=`\n          ${Ku(i)} coords = getOutputCoords();\n        `,1===i)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=ad("coords",i);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${e[i-2]} + 1) >= outShape[${i} - 2];\n            bool nextColOutOfBounds =\n              (${e[i-1]} + 1) >= outShape[${i} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${e[i-2]} + 1) >= ${this.outputShape[i-2]};\n            bool nextColOutOfBounds =\n              (${e[i-1]} + 1) >= ${this.outputShape[i-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}}function Md(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Td={kernelName:S.iJz,backendName:"webgl",kernelFunc:Md};function Ed(e){const{inputs:t,backend:n}=e,{real:r,imag:i}=t,s=n.makeTensorInfo(r.shape,"complex64"),a=n.texData.get(s.dataId),o=Md({inputs:{x:r},backend:n}),l=Md({inputs:{x:i},backend:n});return a.complexTensorInfos={real:o,imag:l},s}const Ad={kernelName:S.Zz9,backendName:"webgl",kernelFunc:Ed},Cd="return (a < 0.) ? b * a : a;",Id="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",Nd={kernelName:S.J$2,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{alpha:s}=r,a=n.makeTensorInfo([],"float32",S.D5U.createScalarValue(s,"float32")),o=(0,S.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Sd(Id,i.shape,a.shape):new _d(Cd,i.shape,a.shape),l=n.runWebGLProgram(o,[i,a],"float32");return n.disposeIntermediateTensorInfo(a),l}},kd="return (a < 0.) ? b * a : a;",Rd="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",Dd={kernelName:S.o0g,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:i}=t,s=(0,S.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Sd(Rd,r.shape,i.shape):new _d(kd,r.shape,i.shape);return n.runWebGLProgram(s,[r,i],"float32")}};function Ld({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:i,backend:s})=>{const{x:a}=i,o=s,l=r||a.dtype;if(o.shouldExecuteOnCPU([a])&&null!=n){const e=o.texData.get(a.dataId),t=n(e.values,l);return o.makeTensorInfo(a.shape,l,t)}let c;return c=(0,S.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new gd(a.shape,t):new pd(a.shape,e),o.runWebGLProgram(c,[a],l)}}function Fd({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:i,dtype:s}){return({inputs:a,backend:o})=>{const{a:l,b:c}=a,u=o;if(r&&"complex64"===l.dtype){const t=u.texData.get(l.dataId),n=u.texData.get(c.dataId),[r,i]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,i={dataId:n.dataId,dtype:n.dtype,shape:l.shape},s={dataId:r.dataId,dtype:r.dtype,shape:c.shape},a=new _d(e,l.shape,c.shape);return u.runWebGLProgram(a,[i,s],(0,S.x8V)(n.dtype,r.dtype))})),s=Ed({inputs:{real:r,imag:i},backend:u});return u.disposeIntermediateTensorInfo(r),u.disposeIntermediateTensorInfo(i),s}const h=s||(0,S.x8V)(l.dtype,c.dtype);if(("string"===l.dtype||"string"===c.dtype||u.shouldExecuteOnCPU([l,c]))&&null!=i){const e=u.texData.get(l.dataId).values,t=u.texData.get(c.dataId).values,n="string"===l.dtype?S.Wap.fromUint8ToStringArray(e):e,r="string"===l.dtype?S.Wap.fromUint8ToStringArray(t):t,[s,a]=i(l.shape,c.shape,n,r,h),o=u.makeTensorInfo(a,h);return u.texData.get(o.dataId).values=s,o}let d;return d=(0,S.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new Sd(t,l.shape,c.shape,n):new _d(e,l.shape,c.shape),u.runWebGLProgram(d,[l,c],h)}}function Pd(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===e)return t?Rd:kd;if("leakyrelu"===e)return t?Id:Cd;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class Od{constructor(e,t,n,r=!1,i=!1,s=!1,a=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=nh(this.outputShape.length);const c=r?e[1]:e[2],u=Math.ceil(c/2),h=r?"i * 2, rc.y":"rc.y, i * 2",d=i?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";a&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,g="result = activation(result);");const y=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let v="rc.x",x="rc.x";e[0]<t[0]?v=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(x=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${u}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${u}; i++) {\n          int batchA = ${v};\n          int batchB = ${x};\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${d});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}class zd{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=S.Wap.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const Bd="return a * b;";function Ud(e){const{inputs:t,backend:n}=e,{a:r,b:i}=t,s=S.Wap.upcastType(r.dtype,i.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(i.dataId),s=new zd("return areal * breal - aimag * bimag;",r.shape,i.shape),a=new zd("return areal * bimag + aimag * breal;",r.shape,i.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:i.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:i.shape}],l=n.runWebGLProgram(s,o,"float32"),c=n.runWebGLProgram(a,o,"float32"),u=Ed({inputs:{real:l,imag:c},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),u}if(n.shouldExecuteOnCPU([r,i])){const e=n.texData.get(r.dataId),t=n.texData.get(i.dataId),[a,o]=Ph(r.shape,i.shape,e.values,t.values,s),l=n.makeTensorInfo(o,s);return n.texData.get(l.dataId).values=a,l}let a;return a=(0,S.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Sd(Bd,r.shape,i.shape):new _d(Bd,r.shape,i.shape),n.runWebGLProgram(a,[r,i],s)}const $d={kernelName:S.wYn,backendName:"webgl",kernelFunc:Ud};function Vd(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{shape:s}=r,a=n,o=S.D5U.sizeFromShape(i.shape),l=S.D5U.inferFromImplicitShape(s,o),c=S.D5U.sizeFromShape(l);S.D5U.assert(o===c,(()=>`The new shape (${l}) has ${c} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));const u=a.texData.get(i.dataId);return!u.isPacked||Au(i.shape,l)||null!==u.texture&&Au(u.shape,l)?(a.incRef(i.dataId),{dataId:i.dataId,shape:l,dtype:i.dtype}):function(e,t,n){const r=[Su(e.shape),...Mu(e.shape)],i={dtype:e.dtype,shape:r,dataId:e.dataId},s=[Su(t),...Mu(t)],a=new ld(s,r),o=[r],l=n.runWebGLProgram(a,[i],e.dtype,o,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(i,l,a)}const Wd={kernelName:S.HZH,backendName:"webgl",kernelFunc:Vd};class Gd{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:i,outSize:s}=e;this.outputShape=[r,s];const a=4*Math.floor(n/4),o=n%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${S.D5U.isInt(e)?e.toPrecision(2):e}, ones);`}let c="";i%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class Hd{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:i,outSize:s}=e;this.outputShape=[r,s];let a="0.0",o="";"prod"===t?a="1.0":"min"===t?(a="1.0 / 1e-20",o="min"):"max"===t&&(a="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");const c=4*Math.floor(n/4),u=n%4;let h=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,d="vec4";"all"===t?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";i%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===u}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===u}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===u}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${l});\n      }\n    `}}function jd(e,t,n,r){const i=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=S.Wap.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let s=e;for(let a=0;a<i.length;a++){const{inSize:o,windowSize:l,outSize:c}=i[a];let u,h;u="mean"===n?0===a?new Gd({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:c},o):new Gd({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:c}):new Hd({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:c},n),h=s,s=r.runWebGLProgram(u,[s],t),h.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(h)}return s}class qd{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;const r=Ku(this.rank),i=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let t=0;t<e.length;t++)r[e[t]]=n[t];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${i}));\n    }\n    `}}class Xd{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Ku(this.rank),i=sd("rc",this.rank),s=new Array(this.rank);for(let e=0;e<t.length;e++)s[t[e]]=i[e];const a=`vec2(${s.slice(-2).join()})`,o=`++${i[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${i[this.rank-1]};\n      if(++${i[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function Yd(e,t,n){const r=(0,S.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Xd(e.shape,t):new qd(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function Kd(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,keepDims:a}=r;return function(e,t,n,r){const i=t,s=e.shape.length,a=S.D5U.parseAxisParam(i,e.shape);let o=a;const l=S.Wap.getAxesPermutation(o,s),c=null!=l;let u=e;c&&(u=Yd(e,l,r),o=S.Wap.getInnerMostAxes(o.length,s)),S.Wap.assertAxesAreInnerMostDims("sum",o,s);const[h,d]=S.Wap.computeOutAndReduceShapes(u.shape,o);let p=h;n&&(p=S.Wap.expandShapeToKeepDim(h,a));const f=S.D5U.sizeFromShape(d),m=Vd({inputs:{x:u},attrs:{shape:[S.D5U.sizeFromShape(e.shape)/f,f]},backend:r}),g=jd(m,(0,S.z4k)(e.dtype),"sum",r),y=Vd({inputs:{x:g},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),c&&r.disposeIntermediateTensorInfo(u),y}(i,s,a,n)}const Zd={kernelName:S.GBy,backendName:"webgl",kernelFunc:Kd};function Jd(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{perm:s}=r,a=n,o=i.shape.length,l=new Array(o);for(let e=0;e<l.length;e++)l[e]=i.shape[s[e]];let c;if(a.shouldExecuteOnCPU([i])){const e=a.texData.get(i.dataId).values,t=rd(e,i.shape,i.dtype,s,l);c=a.makeTensorInfo(l,i.dtype),a.texData.get(c.dataId).values=t}else c=Yd(i,s,a);return c}const Qd={kernelName:S.G3Y,backendName:"webgl",kernelFunc:Jd};function ep({a:e,b:t,transposeA:n,transposeB:r,backend:i,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:l=null}){const c=e.shape.length,u=t.shape.length,h=n?e.shape[c-2]:e.shape[c-1],d=r?t.shape[u-1]:t.shape[u-2],p=n?e.shape[c-1]:e.shape[c-2],f=r?t.shape[u-2]:t.shape[u-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=S.D5U.sizeFromShape(m),v=S.D5U.sizeFromShape(g),x=S.Jyw.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);S.D5U.assert(h===d,(()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`));const b=n?[y,h,p]:[y,p,h],w=r?[v,f,d]:[v,d,f],_=Vd({inputs:{x:e},backend:i,attrs:{shape:b}}),M=Vd({inputs:{x:t},backend:i,attrs:{shape:w}}),T=[_,M],E=Math.max(y,v),A=n?_.shape[1]:_.shape[2],C=null!=s,I=null!=a,N="leakyrelu"===l,k=null!=l?Pd(l,!0):null;let R;if((1===p||1===f)&&A>1e3&&!1===(C||I||N||null!=k)){let e=_,t=M;n&&(e=Jd({inputs:{x:_},backend:i,attrs:{perm:[0,2,1]}}),T.push(e)),r&&(t=Jd({inputs:{x:M},backend:i,attrs:{perm:[0,2,1]}}),T.push(t));const s=1===f;let a=e;1!==f&&(a=Vd({inputs:{x:e},backend:i,attrs:{shape:[E,A,1]}}),T.push(a));const o=1===f?2:1;let l=t;s&&(l=Vd({inputs:{x:t},backend:i,attrs:{shape:[E,1,A]}}),T.push(l));const c=Ud({inputs:{a,b:l},backend:i});R=Kd({inputs:{x:c},backend:i,attrs:{axis:o,keepDims:!0}}),T.push(c)}else{const l=(0,S.x8V)(e.dtype,t.dtype),c=new Od(b,w,[E,p,f],n,r,C,k,I,N),u=[_,M];if(null!=s&&u.push(s),I&&u.push(a),N){const e=i.makeTensorInfo([],"float32",S.D5U.createScalarValue(o,"float32"));u.push(e),T.push(e)}R=i.runWebGLProgram(c,u,l)}const D=Vd({inputs:{x:R},backend:i,attrs:{shape:x}});T.push(R);for(const e of T)i.disposeIntermediateTensorInfo(e);return D}const tp={kernelName:S.usg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:i,b:s,bias:a,preluActivationWeights:o}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;return ep({a:i,b:s,transposeA:l,transposeB:c,backend:n,bias:a,preluActivationWeights:o,leakyreluAlpha:h,activation:u})}},np="return abs(x);",rp={kernelName:S.SYM,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=Gh(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let i;return i=(0,S.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new gd(r.shape,np):new pd(r.shape,np),n.runWebGLProgram(i,[r],r.dtype)}},ip=Ld({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),sp={kernelName:S.VGw,backendName:"webgl",kernelFunc:ip},ap=Ld({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),op={kernelName:S.SpW,backendName:"webgl",kernelFunc:ap},lp="return a + b;",cp=Fd({opSnippet:lp,packedOpSnippet:lp,supportsComplex:!0,cpuKernelImpl:gh}),up={kernelName:S.mm_,backendName:"webgl",kernelFunc:cp};class hp{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class dp{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const pp={kernelName:S.Xze,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,i=n;if(1===i.length)return Md({inputs:{x:i[0]},backend:r});if(i.length>(0,S.OBj)().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(i.length/2),n=e({inputs:i.slice(0,t),backend:r}),s=e({inputs:i.slice(t),backend:r});return e({inputs:[n,s],backend:r})}const s=i.map((e=>e.dtype)).reduce(((e,t)=>(0,S.x8V)(e,t))),a=i.map((e=>e.shape)),o=(0,S.OBj)().getBool("WEBGL_PACK")?new dp(i[0].shape,a):new hp(i[0].shape,a);return r.runWebGLProgram(o,i,s)}},fp={kernelName:S.oT6,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,keepDims:a}=r,o=i.shape.length,l=S.D5U.parseAxisParam(s,i.shape);let c=l;const u=S.Wap.getAxesPermutation(c,o);let h=i;null!=u&&(h=Jd({inputs:{x:i},backend:n,attrs:{perm:u}}),c=S.Wap.getInnerMostAxes(c.length,o)),S.Wap.assertAxesAreInnerMostDims("all",c,o);const[d,p]=S.Wap.computeOutAndReduceShapes(h.shape,c),f=Vd({inputs:{x:h},backend:n,attrs:{shape:[-1,S.D5U.sizeFromShape(p)]}}),m=jd(f,f.dtype,"all",n);let g;return g=Vd(a?{inputs:{x:m},backend:n,attrs:{shape:S.Wap.expandShapeToKeepDim(d,l)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(h),g}},mp={kernelName:S.IKK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,keepDims:a}=r,o=i.shape.length,l=S.D5U.parseAxisParam(s,i.shape);let c=l;const u=S.Wap.getAxesPermutation(c,o);let h=i;null!=u&&(h=Jd({inputs:{x:i},backend:n,attrs:{perm:u}}),c=S.Wap.getInnerMostAxes(c.length,o)),S.Wap.assertAxesAreInnerMostDims("any",c,o);const[d,p]=S.Wap.computeOutAndReduceShapes(h.shape,c),f=Vd({inputs:{x:h},backend:n,attrs:{shape:[-1,S.D5U.sizeFromShape(p)]}}),m=jd(f,f.dtype,"any",n);let g;return g=Vd(a?{inputs:{x:m},backend:n,attrs:{shape:S.Wap.expandShapeToKeepDim(d,l)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(h),g}};class gp{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[i,s];const a="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${a} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class yp{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,S.D5U.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const i=e[e.length-1],s=Math.ceil(i/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,o=a.length,l=Ku(o),c=ad("coords",o);let u,h;if(1===s){h=o+1;const e=Ku(h);u=`\n        ${e} sourceLocR = ${e}(${c.join()}, 0);\n        ++${c[o-1]};\n        ${e} sourceLocG = ${e}(${c.join()}, 0);\n        ++${c[o-2]};\n        ${e} sourceLocA = ${e}(${c.join()}, 0);\n        --${c[o-1]};\n        ${e} sourceLocB = ${e}(${c.join()}, 0);\n        --${c[o-2]};`}else h=o,u=`\n        ${l} sourceLocR = coords;\n        ++${c[o-1]};\n        ${l} sourceLocG = coords;\n        ++${c[o-2]};\n        ${l} sourceLocA = coords;\n        --${c[o-1]};\n        ${l} sourceLocB = coords;\n        --${c[o-2]};`;const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map((e=>"int "+e)),m=ad("sourceLocR",h-1).concat("inIdx.r"),g=ad("sourceLocG",h-1).concat("inIdx.g"),y=ad("sourceLocB",h-1).concat("inIdx.b"),v=ad("sourceLocA",h-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",b=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${v.join()})));`,w=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,_=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${d.join()}),\n                                          vec2(${d.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${d.join()}),\n                               vec2(${d.slice(-2).join()}));\n      }\n      ${_}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${c[o-1]} < ${a[o-1]-1};\n        bool hasNextRow = ${c[o-2]} < ${a[o-2]-1};\n        ${u}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${b}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function vp(e,t,n,r=null){let i=t.shape[0],s=t.shape[1];null!=r&&(i=r.shape[0],s=r.shape[1]);const a=S.Wap.computeOptimalWindowSize(s),o={windowSize:a,inSize:s,batchSize:i,outSize:Math.ceil(s/a)},l=new gp(o,n,null==r),c=[t];null!=r&&c.push(r);const u=e.runWebGLProgram(l,c,"int32");if(1===u.shape[1])return u;const h=vp(e,t,n,u);return e.disposeIntermediateTensorInfo(u),h}function xp(e,t,n,r=null){const i=null!=r?r.shape:t.shape,s=i[i.length-1],a=S.Wap.computeOptimalWindowSize(s),o=new yp(i,a,n,null==r),l=null==r?[t]:[t,r],c=e.runWebGLProgram(o,l,"int32");if(c.shape.length===t.shape.length){const r=xp(e,t,n,c);return e.disposeIntermediateTensorInfo(c),r}return c}function bp(e,t,n,r){const i=[n];if(S.Wap.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),i,t.shape.length),!(0,S.OBj)().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],s=e.texData.get(t.dataId);let a=t;null!==s&&s.isPacked&&(a=e.unpackTensor(t),n.push(a));const[o,l]=S.Wap.computeOutAndReduceShapes(a.shape,i),c=S.D5U.sizeFromShape(l),u=Vd({inputs:{x:a},backend:e,attrs:{shape:[-1,c]}});n.push(u);const h=vp(e,u,r);n.push(h);const d=Vd({inputs:{x:h},backend:e,attrs:{shape:o}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),d}return xp(e,t,r)}const wp={kernelName:S.sJF,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s}=r;let a=S.D5U.parseAxisParam(s,i.shape);const o=S.Wap.getAxesPermutation(a,i.shape.length);let l=i;const c=[];null!=o&&(l=Jd({inputs:{x:i},backend:n,attrs:{perm:o}}),c.push(l),a=S.Wap.getInnerMostAxes(a.length,l.shape.length)),S.Wap.assertAxesAreInnerMostDims("argMax",[a[0]],l.shape.length);const u=bp(n,l,a[0],"max");return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}},_p={kernelName:S.aJk,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s}=r;let a=S.D5U.parseAxisParam(s,i.shape);const o=S.Wap.getAxesPermutation(a,i.shape.length);let l=i;const c=[];null!=o&&(l=Jd({inputs:{x:i},backend:n,attrs:{perm:o}}),c.push(l),a=S.Wap.getInnerMostAxes(a.length,l.shape.length)),S.Wap.assertAxesAreInnerMostDims("argMin",[a[0]],l.shape.length);const u=bp(n,l,a[0],"min");return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}},Sp=Ld({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),Mp={kernelName:S.M2y,backendName:"webgl",kernelFunc:Sp},Tp=Ld({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),Ep={kernelName:S.qw7,backendName:"webgl",kernelFunc:Tp},Ap=Ld({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),Cp={kernelName:S.jMg,backendName:"webgl",kernelFunc:Ap},Ip=Fd({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),Np={kernelName:S.QCc,backendName:"webgl",kernelFunc:Ip},kp=Ld({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),Rp={kernelName:S.Oyi,backendName:"webgl",kernelFunc:kp};class Dp{constructor(e,t,n,r=!1,i=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,a=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let y="0.0";if(f||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${o});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${u};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${c}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?i?m:g:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(v="avgValue / count");const x=4*Math.floor(s/4),b=s%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${o});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${u};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${x}; wC += 4) {\n            int xC = xCCorner + wC * ${c};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              getValue(batch, xR, xC + 3 * ${c}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${x};\n          if (${1===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${v});\n      }\n    `}}class Lp{constructor(e,t,n,r=!1,i=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,a=e.strideDepth,o=e.strideHeight,l=e.strideWidth,c=e.dilationDepth,u=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const v="avg"===t;let x="0.0";if(v||(x="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${c}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${u}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / count");const w=4*Math.floor(s/4),_=s%4,S=`\n      if (${v}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${c}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n          setOutput(${b});\n        }\n      }\n    `}}const Fp={kernelName:S.JhU,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t;Du(i,"avgPool");const{filterSize:s,strides:a,pad:o,dimRoundingMode:l}=r;S.D5U.assert(S.Wap.eitherStridesOrDilationsAreOne(a,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`));const c=S.Wap.computePool2DInfo(i.shape,s,a,1,o,l);if(1===c.filterWidth&&1===c.filterHeight&&S.D5U.arraysEqual(c.inShape,c.outShape))return Md({inputs:{x:i},backend:n});const u=new Dp(c,"avg",!1);return n.runWebGLProgram(u,[i],"float32")}},Pp={kernelName:S._k9,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{filterSize:s,strides:a,pad:o,dimRoundingMode:l,dataFormat:c}=r,u=S.Wap.computePool3DInfo(i.shape,s,a,[1,1,1],o,l,c),h=new Lp(u,"avg",!1);return n.runWebGLProgram(h,[i],"float32")}};class Op{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,i=e.strideWidth,s=e.dilationHeight,a=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=o-1-e.padInfo.top,u=l-1-e.padInfo.left,h=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${c}, ${u});\n      const float avgMultiplier = float(${h});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${a}) {\n            float dyC = float(dyCCorner + wC) / ${i}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class zp{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,i=e.strideDepth,s=e.strideHeight,a=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,u=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=u-1-e.padInfo.front,f=h-1-e.padInfo.top,m=d-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${u};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${i}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${d};\n                wC += ${c}) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Bp={kernelName:S.IMb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:i,input:s}=t,a=s,{filterSize:o,strides:l,pad:c,dimRoundingMode:u}=r,h=S.Wap.computePool3DInfo(a.shape,o,l,[1,1,1],c,u),d=new zp(h);return n.runWebGLProgram(d,[i],a.dtype)}},Up={kernelName:S.ROF,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:i,input:s}=t,a=s;Du([i,s],"avgPoolGrad");const{filterSize:o,strides:l,pad:c}=r,u=S.Wap.computePool2DInfo(a.shape,o,l,1,c),h=new Op(u);return n.runWebGLProgram(h,[i],a.dtype)}},$p={kernelName:S.XLW,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:i,b:s}=t,{transposeA:a,transposeB:o}=r;return ep({a:i,b:s,transposeA:a,transposeB:o,backend:n})}};class Vp{constructor(e,t,n,r,i,s){this.outputShape=[],this.variableNames=["x","mean","variance"],S.Wap.assertAndGetBroadcastShape(e,t),S.Wap.assertAndGetBroadcastShape(e,n);let a="0.0";null!=r&&(S.Wap.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let o="1.0";null!=i&&(S.Wap.assertAndGetBroadcastShape(e,i),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Wp{constructor(e,t,n,r,i,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],S.Wap.assertAndGetBroadcastShape(e,t),S.Wap.assertAndGetBroadcastShape(e,n);let a="vec4(0.0)";null!=r&&(S.Wap.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=i&&(S.Wap.assertAndGetBroadcastShape(e,i),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const Gp={kernelName:S.sHE,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:i,variance:s,offset:a,scale:o}=e;S.D5U.assert(i.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),S.D5U.assert(null==a||i.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),S.D5U.assert(null==o||i.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=n;null==l&&(l=.001);const c=[r,i,s];let u=null;null!=a&&(u=a.shape,c.push(a));let h=null;null!=o&&(h=o.shape,c.push(o));const d=(0,S.OBj)().getBool("WEBGL_PACK_NORMALIZATION")?new Wp(r.shape,i.shape,s.shape,u,h,l):new Vp(r.shape,i.shape,s.shape,u,h,l);return t.runWebGLProgram(d,c,c[0].dtype)}};class Hp{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Ku(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return jp.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${jp[t]} = start[${t}] + coords.${jp[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const jp=["x","y","z","w","u","v"];class qp{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Ku(this.rank),n=ad("coords",this.rank),r=ad("sourceLoc",this.rank),i=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${i})`,a=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${s};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${a}\n        ${o}\n        setOutput(result);\n      }\n    `}}function Xp(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{begin:s,size:a}=r,[o,l]=S.kuN.parseSliceParams(i,s,a);if(S.kuN.assertParamsValid(i,o,l),0===S.D5U.sizeFromShape(l))return n.makeTensorInfo(l,i.dtype,[]);if(n.shouldExecuteOnCPU([i])||"string"===i.dtype){const e=n.texData.get(i.dataId),t=Hh(e.values,o,l,i.shape,i.dtype);return n.makeTensorInfo(l,i.dtype,t)}const{isPacked:c}=n.texData.get(i.dataId),u=S.kuN.isSliceContinous(i.shape,o,l);if(c||!u){const e=(0,S.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new qp(l):new Hp(l),t=[o];return n.runWebGLProgram(e,[i],i.dtype,t)}return n.uploadToGPU(i.dataId),function(e,t,n,r){const i=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),a=r.texData.get(s.dataId);Object.assign(a,i),a.refCount=1,a.shape=n,a.dtype=e.dtype;let o=S.kuN.computeFlatOffset(t,S.D5U.computeStrides(e.shape));i.slice&&(o+=i.slice.flatOffset),a.slice={flatOffset:o,origDataId:i.slice&&i.slice.origDataId||e.dataId};const l=r.dataRefCount.get(a.slice.origDataId)||1;return r.dataRefCount.set(a.slice.origDataId,l+1),s}(i,o,l,n)}const Yp={kernelName:S.p2w,backendName:"webgl",kernelFunc:Xp},Kp={kernelName:S.zws,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{blockShape:s,crops:a}=r;S.D5U.assert(i.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const o=s.reduce(((e,t)=>e*t)),l=S.Wap.getReshaped(i.shape,s,o),c=S.Wap.getPermuted(l.length,s.length),u=S.Wap.getReshapedPermuted(i.shape,s,o),h=S.Wap.getSliceBeginCoords(a,s.length),d=S.Wap.getSliceSize(u,a,s.length),p=[],f=Vd({inputs:{x:i},backend:n,attrs:{shape:l}}),m=Jd({inputs:{x:f},backend:n,attrs:{perm:c}}),g=Vd({inputs:{x:m},backend:n,attrs:{shape:u}}),y=Xp({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}},Zp={kernelName:S.zvY,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,weights:s}=t,{size:a}=r,o=n.readSync(i.dataId),l=n.readSync(s.dataId),c=yh(o,l,s.dtype,s.shape,a);return n.makeTensorInfo([a],s.dtype,c)}},Jp={kernelName:S.eEB,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:i}=t,s=n.readSync(r.dataId),a=n.readSync(i.dataId),o=S.Wap.assertAndGetBroadcastShape(Array.from(s),Array.from(a));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},Qp=Fd({opSnippet:"return float(a != b);",cpuKernelImpl:zh,dtype:"bool"}),ef={kernelName:S.yQU,backendName:"webgl",kernelFunc:Qp};function tf(e){const{inputs:t,backend:n}=e,{input:r}=t;return Md({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const nf={kernelName:S.xJR,backendName:"webgl",kernelFunc:tf},rf={kernelName:S.RFZ,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:i}=t,{x:s}=n,{dtype:a}=i;if("complex64"===a){if("complex64"===s.dtype)return Md({inputs:{x:s},backend:r});const t=S.lls(s.shape),n=e({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),i=Ed({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),i}if("complex64"===s.dtype){const t=tf({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:a}});return r.disposeIntermediateTensorInfo(t),n}if(!S.D5U.hasEncodingLoss(s.dtype,a)){const e=Md({inputs:{x:s},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:a}}if("int32"===a)return function(e,t){const n=new pd(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,r);if("bool"===a){const e=r.makeTensorInfo([],"bool",S.D5U.getTypedArrayFromDType("bool",1)),t=Qp({inputs:{a:s,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}},sf="return ceil(x);",af=Ld({opSnippet:sf,packedOpSnippet:sf,cpuKernelImpl:xh}),of={kernelName:S.gJX,backendName:"webgl",kernelFunc:af};class lf{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class cf{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const uf={kernelName:S.xnO,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{clipValueMin:s,clipValueMax:a}=r;let o;o=(0,S.OBj)().getBool("WEBGL_PACK_CLIP")?new cf(i.shape):new lf(i.shape);const l=[[s],[a]];return n.runWebGLProgram(o,[i],i.dtype,l)}};class hf{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function df(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const pf={kernelName:S.yj2,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,i=n.texData.get(r.dataId),s=new hf(r.shape),a=[df(r,i.complexTensorInfos.real),df(r,i.complexTensorInfos.imag)];return n.runWebGLProgram(s,a,a[0].dtype)}};class ff{constructor(e){this.outputShape=[],this.outputShape=S.Wap.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++)t[n]=t[n-1]+e[n][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const r=t[e-1];n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${r}));`)}const r=t.length,i=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class mf{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=S.Wap.computeOutShape(e,t);const n=this.outputShape,r=n.length,i=Ku(r),s=ad("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const o=new Array(e.length-1);o[0]=e[0][t];for(let n=1;n<o.length;n++)o[n]=o[n-1]+e[n][t];const l=a[t],c=a.slice(-2),u=a.join();let h=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${u}), vec2(${c.join()}));\n        }`;for(let e=1;e<o.length;e++){const t=o[e-1];h+=`\n        if (${l} < ${o[e]}  && ${l} >= ${o[e-1]}) {\n          return getChannel(\n            getT${e}(${gf(a,l,t)}),\n            vec2(${gf(c,l,t)}));\n        }`}const d=o.length,p=o[o.length-1];h+=`\n        return getChannel(\n          getT${d}(${gf(a,l,p)}),\n          vec2(${gf(c,l,p)}));`,this.userCode=`\n      float getValue(${a.map((e=>"int "+e))}) {\n        ${h}\n      }\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[r-1]} = ${s[r-1]} + 1;\n        if (${s[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[r-2]} = ${s[r-2]} + 1;\n        if (${s[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[r-1]} = ${s[r-1]} - 1;\n        if (${s[r-2]} < ${n[r-2]} &&\n            ${s[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}}function gf(e,t,n){const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function yf(e){const{inputs:t,backend:n}=e,{input:r}=t;return Md({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const vf={kernelName:S.J_u,backendName:"webgl",kernelFunc:yf};function xf(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>tf({inputs:{input:e},backend:n}))),i=e.map((e=>yf({inputs:{input:e},backend:n}))),s=xf(r,t,n),a=xf(i,t,n),o=Ed({inputs:{real:s,imag:a},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),i.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),o}let i=n.shouldExecuteOnCPU(e);if("string"===r&&(i=!0),i){const i=e.map((e=>{const r=S.D5U.sizeFromShape(e.shape.slice(t));return Vd({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),s=i.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),a=S.Wap.computeOutShape(i.map((e=>e.shape)),1),o=1===i[0].shape[0],l=bh(s,a,r,o),c=S.Wap.computeOutShape(e.map((e=>e.shape)),t),u=n.makeTensorInfo(c,r,l);return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}if(e.length>(0,S.OBj)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const r=Math.floor(e.length/2),i=xf(e.slice(0,r),t,n),s=xf(e.slice(r),t,n),a=xf([i,s],t,n);return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),a}if((0,S.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const i=new mf(e.map((e=>e.shape)),t);return n.runWebGLProgram(i,e,r)}const{tensors2D:s,outShape:a}=function(e,t,n){const r=S.Wap.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>Vd({inputs:{x:e},attrs:{shape:[-1,S.D5U.sizeFromShape(e.shape.slice(t))]},backend:n}))),outShape:r}}(e,t,n),o=new ff(s.map((e=>e.shape))),l=n.runWebGLProgram(o,s,r);s.forEach((e=>n.disposeIntermediateTensorInfo(e)));const c=Vd({inputs:{x:l},attrs:{shape:a},backend:n});return n.disposeIntermediateTensorInfo(l),c}function bf(e){const{inputs:t,backend:n,attrs:r}=e,{axis:i}=r,s=S.D5U.parseAxisParam(i,t[0].shape)[0],a=S.Wap.computeOutShape(t.map((e=>e.shape)),s);if(0===S.D5U.sizeFromShape(a))return n.makeTensorInfo(a,t[0].dtype,[]);const o=t.filter((e=>S.D5U.sizeFromShape(e.shape)>0));if(1===o.length)return Md({inputs:{x:o[0]},backend:n});const l=o.map((e=>e.shape));return S.Wap.assertParamsConsistent(l,s),xf(o,s,n)}const wf={kernelName:S.Eh3,backendName:"webgl",kernelFunc:bf};class _f{constructor(e,t=!1,n=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const s=e.padInfo.top,a=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,u=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,v=m?3:1;let x="",b="";n&&(x=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:i?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,b="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${s}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${v}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${c};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${u};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${b}\n        setOutput(result);\n      }\n    `}}class Sf{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,i=e.strideDepth,s=e.strideHeight,a=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,u=e.filterDepth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${i}, ${s}, ${a});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${u}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${c};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Mf{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=nh(this.outputShape.length);const{dataFormat:n}=t,r=Fu(),i="channelsLast"===n,s=i?0:1,a=i?1:2,o=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${e[1]} && pos < ${e[0]}) {`;let l="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)l+=`\n          blockIndex = rc.y + ${t};\n          pos = rc.x + ${e};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${i}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*e+t}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*e+t}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}}function Tf({x:e,filter:t,convInfo:n,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:o=null}){const l=e.shape,c=r.texData.get(e.dataId),u=n.inChannels,h=l[0]*l[1]*l[2],d=n.outChannels,p="channelsLast"===n.dataFormat;let f;const m=[];if(null!=s&&!p&&3===s.shape.length){const e=Jd({inputs:{x:s},backend:r,attrs:{perm:[1,2,0]}});m.push(e),s=e}if((1!==h&&1!==d||!(u>1e3))&&c.isPacked&&p&&null!=c.texture&&l[2]%2!=0&&S.D5U.arraysEqual(c.shape.slice(-3),l.slice(-3))){const u=l[0]*l[1]*(l[2]+1),h={dataId:e.dataId,shape:[1,u,n.inChannels],dtype:e.dtype},d=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,S.D5U.assert(Au(c.shape,h.shape),(()=>`packed reshape ${c.shape} to ${h.shape} isn't free`));const p=Vd({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});m.push(p);const g=ep({a:h,b:p,backend:r,transposeA:!1,transposeB:!1,bias:i,activation:o,preluActivationWeights:s,leakyreluAlpha:a}),y=r.texData.get(g.dataId);S.D5U.assert(y.isPacked,(()=>"batchMatMul result is expected to be packed")),c.shape=d,y.shape=n.outShape,f=Md({inputs:{x:g},backend:r}),f.shape=n.outShape,m.push(g)}else{const l=p?e:Jd({inputs:{x:e},backend:r,attrs:{perm:[0,2,3,1]}}),c=l.shape,u=Vd({inputs:{x:l},backend:r,attrs:{shape:[1,c[0]*c[1]*c[2],n.inChannels]}}),h=Vd({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),d=ep({a:u,b:h,transposeA:!1,transposeB:!1,backend:r,bias:i,activation:o,preluActivationWeights:s,leakyreluAlpha:a}),g=Vd({inputs:{x:d},backend:r,attrs:{shape:[n.batchSize,n.outHeight,n.outWidth,n.outChannels]}});f=p?g:Jd({inputs:{x:g},backend:r,attrs:{perm:[0,3,1,2]}}),p||(m.push(l),m.push(g)),m.push(u),m.push(h),m.push(d)}for(const e of m)r.disposeIntermediateTensorInfo(e);return f}function Ef({x:e,filter:t,convInfo:n,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:o=null}){const{filterWidth:l,filterHeight:c,inChannels:u,outWidth:h,outHeight:d,dataFormat:p}=n,f="channelsLast"===p,m=l*c*u,g=d*h,y=[m,g],v=[];if(null!=s&&!f&&3===s.shape.length){const e=Jd({inputs:{x:s},backend:r,attrs:{perm:[1,2,0]}});v.push(e),s=e}const x=Vd({inputs:{x:e},backend:r,attrs:{shape:e.shape.slice(1)}}),b=Vd({inputs:{x:t},backend:r,attrs:{shape:[1,m,S.D5U.sizeFromShape(t.shape)/m]}});v.push(x),v.push(b);const w=new Mf(y,n),_=[x.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],M=r.runWebGLProgram(w,[x],"float32",_),T=Vd({inputs:{x:M},backend:r,attrs:{shape:[1,y[0],y[1]]}});v.push(M),v.push(T);const E=null!=i,A=null!=s,C="leakyrelu"===o,I=o?Pd(o,!0):null,N=new Od(T.shape,b.shape,[1,g,n.outChannels],!0,!1,E,I,A,C),k=[T,b];if(i&&k.push(i),A&&k.push(s),C){const e=r.makeTensorInfo([],"float32",S.D5U.createScalarValue(a,"float32"));k.push(e),v.push(e)}const R=r.runWebGLProgram(N,k,"float32"),D=Vd({inputs:{x:R},backend:r,attrs:{shape:[1,d,h,n.outChannels]}}),L=f?D:Jd({inputs:{x:D},backend:r,attrs:{perm:[0,3,1,2]}});f||v.push(D),v.push(R);for(const e of v)r.disposeIntermediateTensorInfo(e);return L}const Af={kernelName:S.mhS,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:s}=t,{strides:a,pad:o,dataFormat:l,dilations:c,dimRoundingMode:u}=r,h=S.Wap.convertConv2DDataFormat(l),d=S.Wap.computeConv2DInfo(i.shape,s.shape,a,c,o,u,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if((0,S.OBj)().getBool("WEBGL_CONV_IM2COL")&&1===i.shape[0])p=Ef({x:i,filter:s,convInfo:d,backend:n});else{const e=new _f(d);p=n.runWebGLProgram(e,[i,s],"float32")}else p=Tf({x:i,filter:s,convInfo:d,backend:n});const f=Vd({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class Cf{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${i};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${s}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class If{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,i=e.strideWidth,s="channelsLast"===e.dataFormat,a=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,c=s?2:3,u=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${u}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${c}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${i}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Nf{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,i=e.padInfo.front,s=e.padInfo.top,a=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${i};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${a};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class kf{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,i=e.strideDepth,s=e.strideHeight,a=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,c=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${c});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${i}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Rf={kernelName:S.wUP,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,dy:s}=t,{strides:a,pad:o,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,h=S.Wap.convertConv2DDataFormat(l),d=S.Wap.computeConv2DInfo(i.shape,u,a,1,o,c,!1,h),p=new Cf(d);return n.runWebGLProgram(p,[i,s],"float32")}},Df={kernelName:S.wm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:i,filter:s}=t,{inputShape:a,strides:o,pad:l,dataFormat:c,dimRoundingMode:u}=r,h=S.Wap.convertConv2DDataFormat(c),d=S.Wap.computeConv2DInfo(a,s.shape,o,1,l,u,!1,h),p=new If(d);return n.runWebGLProgram(p,[i,s],"float32")}},Lf={kernelName:S.x12,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:s}=t,{strides:a,pad:o,dilations:l}=r,c=S.Wap.computeConv3DInfo(i.shape,s.shape,a,l,o),u=new Sf(c);return n.runWebGLProgram(u,[i,s],"float32")}},Ff={kernelName:S.o2y,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,dy:s}=t,{strides:a,pad:o,filterShape:l}=r,c=S.Wap.computeConv3DInfo(i.shape,l,a,1,o),u=new Nf(c);return n.runWebGLProgram(u,[i,s],"float32")}},Pf={kernelName:S.ik2,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:i,filter:s}=t,{pad:a,strides:o,inputShape:l}=r,c=S.Wap.computeConv3DInfo(l,s.shape,o,1,a),u=new kf(c);return n.runWebGLProgram(u,[i,s],"float32")}},Of=Ld({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),zf={kernelName:S.mc4,backendName:"webgl",kernelFunc:Of},Bf=Ld({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),Uf={kernelName:S.TR1,backendName:"webgl",kernelFunc:Bf};class $f{constructor(e,t,n,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,a,o,l]=e,[c]=t,[u,h]=n;this.outputShape=[c,u,h,l];const d="bilinear"===r?1:0,[p,f]=[a-1+".0",o-1+".0"],[m,g,y]=u>1?[""+(a-1)/(u-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[v,x,b]=h>1?[""+(o-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${v});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${x};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${i}));\n          return;\n        }\n        float in_x = ${b};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${i}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const Vf={kernelName:S.VcC,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:i,boxes:s,boxInd:a}=t,{cropSize:o,method:l,extrapolationValue:c}=r,u=new $f(i.shape,s.shape,o,l,c);return n.runWebGLProgram(u,[i,s,a],"float32")}};var Wf;!function(e){e.Prod="*",e.Sum="+"}(Wf||(Wf={}));class Gf{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,s=this.op===Wf.Prod?"1.0":"0.0",a=n?s:`getX(${Hf(i,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let l="",c="";n?(l=r?"end != "+(o-1):"end != 0",c=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${Ku(i)} coords = getOutputCoords();\n        int end = ${jf(i,"coords",this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${c};\n          ${jf(i,"coords",this.op)} = idx;\n          val ${this.op}= getX(${Hf(i,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function Hf(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function jf(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function qf(e,t,n,r,i,s){const a=t.shape.length,o=S.Wap.getAxesPermutation([r],a);let l=t;null!=o&&(l=Jd({inputs:{x:t},backend:n,attrs:{perm:o}}));const c=S.Wap.getInnerMostAxes(1,a)[0];if(c!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const u=l.shape[c];let h=Md({inputs:{x:l},backend:n});for(let t=0;t<=Math.ceil(Math.log2(u))-1;t++){const r=new Gf(e,l.shape,!1,s),i=[[t]],a=h;h=n.runWebGLProgram(r,[h],h.dtype,i),n.disposeIntermediateTensorInfo(a)}if(i){const t=new Gf(e,l.shape,i,s),r=h;h=n.runWebGLProgram(t,[h],h.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){const e=Jd({inputs:{x:h},backend:n,attrs:{perm:S.Wap.getUndoAxesPermutation(o)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),e}return h}const Xf={kernelName:S.Byc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,exclusive:a,reverse:o}=r;return qf(Wf.Prod,i,n,s,a,o)}},Yf={kernelName:S.iHb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,exclusive:a,reverse:o}=r;return qf(Wf.Sum,i,n,s,a,o)}},Kf={kernelName:S.QRR,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,weights:s}=t,{size:a,binaryOutput:o}=r;if(1===i.shape.length){const e=n.readSync(i.dataId),t=n.readSync(s.dataId),r=yh(e,t,s.dtype,s.shape,a);return n.makeTensorInfo([a],s.dtype,r)}if(2===i.shape.length){const e=n.bufferSync(i),t=n.bufferSync(s),r=vh(e,t,a,o);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}};class Zf{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Jf={kernelName:S.T0n,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{blockSize:s,dataFormat:a}=r,o=i.shape[0],l=("NHWC"===a?i.shape[1]:i.shape[2])*s,c=("NHWC"===a?i.shape[2]:i.shape[3])*s,u=("NHWC"===a?i.shape[3]:i.shape[1])/(s*s),h=new Zf("NHWC"===a?[o,l,c,u]:[o,u,l,c],s,a);return n.runWebGLProgram(h,[i],i.dtype)}};class Qf{constructor(e,t=!1,n=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=nh(this.outputShape.length);const s=e.filterHeight,a=e.filterWidth,o=e.outChannels/e.inChannels;let l="",c="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:i?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,c="result = activation(result);");const u=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${u}\n        ${c}\n        setOutput(result);\n      }\n    `}}class em{constructor(e,t=!1,n=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=nh(this.outputShape.length);const s=e.outChannels/e.inChannels,a=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,u=e.filterWidth,h=u;let d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<u;e++)d+=`\n          vec4 xTexelC${2*e};\n          int xTexelC${2*e}Ready;\n          vec4 xTexelC${2*e+1};\n          int xTexelC${2*e+1}Ready;\n          vec4 xC${e};`;d+=`\n    for (int r = 0; r < ${c}; r++) {\n      `;for(let e=0;e<u;e++)d+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xTexelC${2*e+1} = vec4(0.0);\n          xTexelC${2*e+1}Ready = 0;\n          xC${e} = vec4(0.0);`;d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let e=0;e<(h+1)/2;e++){const t=2*e;if(d+=`\n          xC = xCCorner + ${t*l};\n          `,1===o){if(t<u&&(a%2==1?(d+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n              `,d+=1===l&&t>0?`\n                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                  }\n                  `):d+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xC${t} = xTexelC${t};\n                `,t+1<u)){const e=a%2==0?S.D5U.nearestLargerEven(l):l;l%2==0&&a%2==1||l%2!=0&&a%2!=1?(d+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${t+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${t+1}Ready = 1;\n                  }\n                  `,l>1&&(d+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                      xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${t}Ready = 1;\n                    }\n                    `),d+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                  `):d+=1===e?`\n                    xC${t+1} = xTexelC${t};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${t+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${t+1}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${t+1};\n                    `}}else t<u&&(a%2==1?(d+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n              `,t+1<u&&(d+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                `)):(d+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${t}.xy, xTexelC${t+1}.xy);\n              `,t+1<u&&(d+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                `)));t<u&&(d+=`\n            wTexel = getW(r, ${t}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,t+1<u&&(d+=`\n              wTexel = getW(r, ${t+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}d+="\n    }\n  ",d+="\n      }\n    ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:i?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${d}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}}const tm={kernelName:S.cie,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:s}=t,{strides:a,pad:o,dilations:l,dimRoundingMode:c}=r;let u=l;null==u&&(u=[1,1]),S.D5U.assert(S.Wap.eitherStridesOrDilationsAreOne(a,u),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`));const h=S.Wap.computeConv2DInfo(i.shape,s.shape,a,u,o,c,!0);let d;d=(0,S.OBj)().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?new em(h):new Qf(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[i,s],"float32",p)}};class nm{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${i};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class rm{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,i=e.strideWidth,s=t-1-e.padInfo.top,a=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${i}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const im={kernelName:S.sL$,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,dy:s}=t,{strides:a,dilations:o,pad:l,dimRoundingMode:c,filterShape:u}=r,h=S.Wap.computeConv2DInfo(i.shape,u,a,o,l,c,!0),d=new nm(h);return n.runWebGLProgram(d,[i,s],"float32")}},sm={kernelName:S.y7R,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:i,filter:s}=t,{strides:a,dilations:o,pad:l,dimRoundingMode:c,inputShape:u}=r,h=S.Wap.computeConv2DInfo(u,s.shape,a,o,l,c,!0),d=new rm(h);return n.runWebGLProgram(d,[i,s],"float32")}};class am{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const om={kernelName:S.$w,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,i=[...r.shape,...r.shape],s=S.D5U.sizeFromShape(r.shape),a=Vd({inputs:{x:r},backend:n,attrs:{shape:[s]}}),o=new am(s),l=n.runWebGLProgram(o,[a],a.dtype),c=Vd({inputs:{x:l},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),c}};class lm{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:i,strideWidth:s,filterHeight:a,filterWidth:o,dilationHeight:l,dilationWidth:c}=e,{top:u,left:h}=r;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${s});\n      const ivec2 pads = ivec2(${u}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${c};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const cm={kernelName:S.p4S,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:s}=t,{strides:a,pad:o,dilations:l}=r,c=S.Wap.computeDilation2DInfo(i.shape,s.shape,a,o,"NHWC",l);let u;const h=new lm(c);u=n.runWebGLProgram(h,[i,s],"float32");const d=Vd({inputs:{x:u},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(u),d}},um={kernelName:S.$g6,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:i}=r,s=t,{allDims:a,summedDims:o,idDims:l}=S.Wap.decodeEinsumEquation(i,s.length);S.Wap.checkEinsumDimSizes(a.length,l,s);const{path:c,steps:u}=S.Wap.getEinsumComputePath(o,l),h=u.length;let d=null,p=a.length;const f=[];for(let e=0;e<h;++e){for(const t of u[e]){const{permutationIndices:e,expandDims:r}=S.Wap.getEinsumPermutation(p,l[t]);let i;S.Wap.isIdentityPermutation(e)?i=s[t]:(i=Jd({inputs:{x:s[t]},backend:n,attrs:{perm:e}}),f.push(i));const a=i.shape.slice();for(let e=0;e<r.length;++e)a.splice(r[e],0,1);S.D5U.arraysEqual(i.shape,a)||(i=Vd({inputs:{x:i},backend:n,attrs:{shape:a}}),f.push(i)),null===d?d=i:(d=Ud({inputs:{a:i,b:d},backend:n}),f.push(d))}e<h-1&&(c[e]>=0&&(d=Kd({inputs:{x:d},backend:n,attrs:{axis:c[e]-(a.length-p),keepDims:!1}}),f.push(d)),p--)}for(const e of f)e!==d&&n.disposeIntermediateTensorInfo(e);return d}},hm=Ld({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),dm={kernelName:S.SX0,backendName:"webgl",kernelFunc:hm},pm={kernelName:S.HEU,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:i}=t,s=(0,S.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Sd("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,i.shape):new _d("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,i.shape);return n.runWebGLProgram(s,[r,i],r.dtype)}},fm=Fd({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:wh}),mm={kernelName:S.hdR,backendName:"webgl",kernelFunc:fm},gm=Ld({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${S.Wap.ERF_P};\n  float a1 = ${S.Wap.ERF_A1};\n  float a2 = ${S.Wap.ERF_A2};\n  float a3 = ${S.Wap.ERF_A3};\n  float a4 = ${S.Wap.ERF_A4};\n  float a5 = ${S.Wap.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),ym={kernelName:S.Omj,backendName:"webgl",kernelFunc:gm},vm=Ld({opSnippet:"if (isnan(x)) return x;\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:_h,dtype:"float32"}),xm={kernelName:S.NEP,backendName:"webgl",kernelFunc:vm};function bm(e){const{inputs:t,attrs:n,backend:r}=e,{dim:i}=n,{input:s}=t,a=s.shape.length,o=s.shape.slice();let l=i;return i<0&&(S.D5U.assert(-(a+1)<=i,(()=>`Axis must be in the interval [${-(a+1)}, ${a}]`)),l=a+i+1),o.splice(l,0,1),Vd({inputs:{x:s},backend:r,attrs:{shape:o}})}const wm={kernelName:S.YFo,backendName:"webgl",kernelFunc:bm},_m="return exp(x) - 1.0;",Sm=Ld({opSnippet:_m,packedOpSnippet:_m,cpuKernelImpl:Sh}),Mm={kernelName:S.Y0y,backendName:"webgl",kernelFunc:Sm};class Tm{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const i=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${r}.0`:"1.0";let a;if("real"===e)a="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${i};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${s};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function Em(e,t,n){const r=n.texData.get(e.dataId),i=S.D5U.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],a=Vd({inputs:{x:e},backend:n,attrs:{shape:[i/s,s]}}),o=a.shape,l=new Tm("real",o,t),c=new Tm("imag",o,t),u=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],h=n.runWebGLProgram(l,u,"float32"),d=n.runWebGLProgram(c,u,"float32"),p=Ed({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=Vd({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(p),f}const Am={kernelName:S.vwp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return Em(r,!1,n)}};class Cm{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Im(e){const{backend:t,attrs:n}=e,{shape:r,value:i}=n;let{dtype:s}=n;if(s=s||S.D5U.inferDtype(i),"string"===s){const e=S.D5U.getArrayFromDType(s,S.D5U.sizeFromShape(r));return e.fill(i),t.makeTensorInfo(r,s,e)}{const e=new Cm(r,i),n=[[i]];return t.runWebGLProgram(e,[],s,n)}}const Nm={kernelName:S.deh,backendName:"webgl",kernelFunc:Im};class km{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Rm={kernelName:S.Uyb,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,i=new km(n.shape);return r.runWebGLProgram(i,[n],n.dtype)}},Dm="return floor(x);",Lm=Ld({opSnippet:Dm,packedOpSnippet:Dm,cpuKernelImpl:Mh}),Fm={kernelName:S.OR,backendName:"webgl",kernelFunc:Lm},Pm=Fd({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),Om={kernelName:S.jeX,backendName:"webgl",kernelFunc:Pm};class zm{constructor(e){this.variableNames=["A"];const t=Fu(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class Bm{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Fu(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const Um={kernelName:S.eBW,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:i}=t;const{numChannels:s}=r,a="undefined"!=typeof HTMLVideoElement&&i instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&i instanceof HTMLImageElement,[l,c]=a?[i.videoWidth,i.videoHeight]:[i.width,i.height],u=[c,l],h=[c,l,s];(o||a)&&(null==$m&&($m=document.createElement("canvas").getContext("2d")),$m.canvas.width=l,$m.canvas.height=c,$m.drawImage(i,0,0,l,c),i=$m.canvas);const d=n.makeTensorInfo(u,"int32");n.texData.get(d.dataId).usage=su.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),i);const p=(0,S.OBj)().getBool("WEBGL_PACK")?new Bm(h):new zm(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let $m;const Vm={kernelName:S._V0,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:s,bias:a,preluActivationWeights:o}=t,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=S.Wap.convertConv2DDataFormat(u),g=S.Wap.computeConv2DInfo(i.shape,s.shape,l,h,c,d,!1,m);let y;const v=[];if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if((0,S.OBj)().getBool("WEBGL_CONV_IM2COL")&&1===i.shape[0])y=Ef({x:i,filter:s,convInfo:g,backend:n,bias:a,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const e=null!=a,t=null!=o,r="leakyrelu"===p,l=p?Pd(p,!1):null,c=new _f(g,e,l,t,r),h=[i,s],d=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=Vd({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return v.push(t),t}return e};if(e&&h.push(d(a,u)),t&&h.push(d(o,u)),r){const e=n.makeTensorInfo([],"float32",S.D5U.createScalarValue(f,"float32"));h.push(e),v.push(e)}y=n.runWebGLProgram(c,h,"float32")}else y=Tf({x:i,filter:s,convInfo:g,backend:n,bias:a,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const x=Vd({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return v.push(y),v.forEach((e=>n.disposeIntermediateTensorInfo(e))),x}},Wm={kernelName:S.luS,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:s,bias:a,preluActivationWeights:o}=t,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=r,f=[];let m=u;null==m&&(m=[1,1]),S.D5U.assert(S.Wap.eitherStridesOrDilationsAreOne(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const g=S.Wap.computeConv2DInfo(i.shape,s.shape,l,m,c,h,!0),y=(0,S.OBj)().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,v=d?Pd(d,y):null,x=[i,s],b=null!=a,w=null!=o,_="leakyrelu"===d;if(b&&x.push(a),w&&x.push(o),_){const e=n.makeTensorInfo([],"float32",S.D5U.createScalarValue(p,"float32"));x.push(e),f.push(e)}let M;M=y?new em(g,b,v,w,_):new Qf(g,b,v,w,_);const T=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],E=n.runWebGLProgram(M,x,"float32",T);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),E}};class Gm{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;const r=Ku(t.length),i=Ku(n.length),s=this.sliceDim>1?"strides[j]":"strides";this.userCode=`\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${i} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${s};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const Hm={kernelName:S.q1x,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:i}=t,s=i.shape,a=s[s.length-1],o=S.D5U.sizeFromShape(r.shape),[l,c,u,h]=S.Wap.prepareAndValidate(r,i),d=Vd({inputs:{x:i},backend:n,attrs:{shape:[c,a]}}),p=Vd({inputs:{x:r},backend:n,attrs:{shape:[S.D5U.sizeFromShape(r.shape)/u,u]}});if(n.shouldExecuteOnCPU([r,i])||"string"===r.dtype){const e=n.readSync(i.dataId),t=n.bufferSync(r),s=Th(e,t,r.dtype,c,a,u,h,r.shape,o);return n.makeTensorInfo(l,r.dtype,s.values)}const f=new Gm(a,h,[c,u]),m=n.runWebGLProgram(f,[p,d],p.dtype),g=Vd({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class jm{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=Ku(this.rank),r=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let t=0;t<e.length;t++)2===t?r.push("index"):r.push(`${n[t]}`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function qm(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,indices:s}=t,{axis:a,batchDims:o}=r,l=S.D5U.parseAxisParam(a,i.shape)[0];if((0,S.OBj)().get("DEBUG")){const e=n.readSync(s.dataId),t=i.shape[l];for(let n=0;n<e.length;++n){const r=e[n];S.D5U.assert(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}const c=S.Wap.segment_util.collectGatherOpShapeInfo(i,s,l,o),u=S.D5U.sizeFromShape(s.shape),h=[],d=Vd({inputs:{x:i},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=Vd({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(d),h.push(p);const f=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([i,s])||"string"===i.dtype){const e=n.bufferSync(p),t=n.bufferSync(d),r=Eh(t,e,f);return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c.outputShape,r.dtype,r.values)}const m=new jm(d.shape,f),g=n.runWebGLProgram(m,[d,p],d.dtype);h.push(g);const y=Vd({inputs:{x:g},backend:n,attrs:{shape:c.outputShape}});return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}const Xm={kernelName:S.qi_,backendName:"webgl",kernelFunc:qm},Ym=Fd({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:Ah,dtype:"bool"}),Km={kernelName:S.iZT,backendName:"webgl",kernelFunc:Ym},Zm=Fd({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:Ch}),Jm={kernelName:S.Acj,backendName:"webgl",kernelFunc:Zm},Qm={kernelName:S.Qg5,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return Em(r,!0,n)}},eg=Ld({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),tg={kernelName:S.avt,backendName:"webgl",kernelFunc:eg},ng=Ld({opSnippet:"return float(isinf(x));",dtype:"bool"}),rg={kernelName:S.iWB,backendName:"webgl",kernelFunc:ng},ig=Ld({opSnippet:"return float(isnan(x));",dtype:"bool"}),sg={kernelName:S.r7n,backendName:"webgl",kernelFunc:ig},ag=Fd({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:Ih,dtype:"bool"}),og={kernelName:S.vtC,backendName:"webgl",kernelFunc:ag},lg=Fd({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:Nh,dtype:"bool"}),cg={kernelName:S.CAk,backendName:"webgl",kernelFunc:lg},ug={kernelName:S.e7N,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:i,num:s}=n,a=kh(r,i,s);return t.makeTensorInfo([a.length],"float32",a)}},hg=Ld({opSnippet:"if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:Rh}),dg={kernelName:S.ZbH,backendName:"webgl",kernelFunc:hg},pg=Ld({opSnippet:"if (isnan(x)) return x;\n  return log(1.0 + x);\n"}),fg={kernelName:S.kU,backendName:"webgl",kernelFunc:pg},mg=Fd({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),gg={kernelName:S.PYm,backendName:"webgl",kernelFunc:mg},yg=Ld({opSnippet:"return float(!(x >= 1.0));"}),vg={kernelName:S.VfG,backendName:"webgl",kernelFunc:yg},xg=Fd({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),bg={kernelName:S.MZg,backendName:"webgl",kernelFunc:xg};class wg{constructor(e,t,n,r,i){this.variableNames=["x"],this.outputShape=[];const s=t,a=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===i?`inversesqrt(${l})`:1===i?`1.0/(${l})`:`exp(log(${l}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class _g{constructor(e,t,n,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=t,a=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===i?`inversesqrt(${l})`:1===i?`1.0/(${l})`:`exp(log(${l}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const Sg={kernelName:S.eZ0,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{depthRadius:s,bias:a,alpha:o,beta:l}=r,c=(0,S.OBj)().getBool("WEBGL_PACK_NORMALIZATION")?new _g(i.shape,s,a,o,l):new wg(i.shape,s,a,o,l);return n.runWebGLProgram(c,[i],i.dtype)}};class Mg{constructor(e,t,n,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=i,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${i})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${i});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const Tg={kernelName:S.Hhh,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:i,y:s,dy:a}=t,{depthRadius:o,bias:l,alpha:c,beta:u}=r,h=new Mg(i.shape,o,l,c,u);return n.runWebGLProgram(h,[i,s,a],i.dtype)}};function Eg(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{reductionIndices:s,keepDims:a}=r,o=i.shape.length,l=S.D5U.parseAxisParam(s,i.shape);let c=l;const u=S.Wap.getAxesPermutation(c,o),h=null!=u,d=n.shouldExecuteOnCPU([i]);let p=i;if(h){if(d){const e=n.texData.get(p.dataId).values,t=new Array(o);for(let e=0;e<t.length;e++)t[e]=i.shape[u[e]];const r=rd(e,i.shape,i.dtype,u,t);p=n.makeTensorInfo(t,i.dtype),n.texData.get(p.dataId).values=r}else p=Yd(i,u,n);c=S.Wap.getInnerMostAxes(c.length,o)}S.Wap.assertAxesAreInnerMostDims("max",c,o);const[f,m]=S.Wap.computeOutAndReduceShapes(p.shape,c);let g,y=f;if(a&&(y=S.Wap.expandShapeToKeepDim(f,l)),d){const e=n.texData.get(p.dataId).values,t=Dh(e,S.D5U.sizeFromShape(m),y,i.dtype);g=n.makeTensorInfo(y,i.dtype),n.texData.get(g.dataId).values=t}else g=function(e,t,n,r){const i=S.D5U.sizeFromShape(t),s=Vd({inputs:{x:e},attrs:{shape:[S.D5U.sizeFromShape(e.shape)/i,i]},backend:r}),a=jd(s,e.dtype,"max",r),o=Vd({inputs:{x:a},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(a),o}(p,m,y,n);return h&&n.disposeIntermediateTensorInfo(p),g}const Ag={kernelName:S.YoZ,backendName:"webgl",kernelFunc:Eg},Cg=Fd({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Lh}),Ig={kernelName:S.BMI,backendName:"webgl",kernelFunc:Cg},Ng={kernelName:S.mTV,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t;Du(i,"maxPool");const{filterSize:s,strides:a,pad:o,dimRoundingMode:l}=r;S.D5U.assert(S.Wap.eitherStridesOrDilationsAreOne(a,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`));const c=S.Wap.computePool2DInfo(i.shape,s,a,1,o,l);if(1===c.filterWidth&&1===c.filterHeight&&S.D5U.arraysEqual(c.inShape,c.outShape))return Md({inputs:{x:i},backend:n});const u=new Dp(c,"max",!1);return n.runWebGLProgram(u,[i],i.dtype)}},kg={kernelName:S.OAf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{filterSize:s,strides:a,pad:o,dataFormat:l,dimRoundingMode:c}=r,u=S.Wap.computePool3DInfo(i.shape,s,a,[1,1,1],o,c,l),h=new Lp(u,"max",!1);return n.runWebGLProgram(h,[i],i.dtype)}};class Rg{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,i=e.effectiveFilterHeight,s=e.effectiveFilterWidth,a=i-1-e.padInfo.top,o=s-1-e.padInfo.left,l=i*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Dg{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,i=e.dilationDepth,s=e.dilationHeight,a=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,u=o-1-e.padInfo.front,h=l-1-e.padInfo.top,d=c-1-e.padInfo.left,p=o*l*c-1;this.userCode=`\n      const ivec3 pads = ivec3(${u}, ${h}, ${d});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${i}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${c};\n                wC += ${a}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${c} +\n                  wR * ${c} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Lg={kernelName:S.OU7,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:i,input:s}=t,a=s,{filterSize:o,strides:l,pad:c,dimRoundingMode:u}=r,h=S.Wap.computePool3DInfo(a.shape,o,l,[1,1,1],c,u),d=new Lp(h,"max",!0),p=n.runWebGLProgram(d,[a],a.dtype),f=new Dg(h),m=n.runWebGLProgram(f,[i,p],a.dtype);return n.disposeIntermediateTensorInfo(p),m}},Fg={kernelName:S.OV7,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:i,input:s,output:a}=t,o=s;Du([s,a],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,d=S.Wap.computePool2DInfo(o.shape,l,c,1,u,h),p=new Dp(d,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new Rg(d),g=n.runWebGLProgram(m,[i,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}},Pg={kernelName:S.vFR,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:i,strides:s,pad:a,includeBatchInIndex:o}=t,l=n;S.D5U.assert(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const c=[1,1];S.D5U.assert(S.Wap.eitherStridesOrDilationsAreOne(s,c),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${c}'`));const u=S.Wap.computePool2DInfo(r.shape,i,s,c,a),[h,d]=function(e,t,n,r){let i=new Dp(n,"max",!1);const s=r.runWebGLProgram(i,[e],"float32");return i=new Dp(n,"max",!0,!0,t),[s,r.runWebGLProgram(i,[e],"float32")]}(r,o,u,l);return[h,d]}},Og={kernelName:S.q2K,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:i,axis:s}=t,a=n,o=r.shape.length,l=S.D5U.parseAxisParam(s,r.shape);let c=l;const u=S.Wap.getAxesPermutation(c,o),h=null!=u,d=a.shouldExecuteOnCPU([r]),p=[];let f=r;if(h){if(d){const e=a.texData.get(f.dataId).values,t=new Array(o);for(let e=0;e<t.length;e++)t[e]=r.shape[u[e]];const n=rd(e,r.shape,r.dtype,u,t);f=a.makeTensorInfo(t,r.dtype),a.texData.get(f.dataId).values=n}else f=Yd(r,u,a);p.push(f),c=S.Wap.getInnerMostAxes(c.length,o)}S.Wap.assertAxesAreInnerMostDims("sum",c,o);const[m,g]=S.Wap.computeOutAndReduceShapes(f.shape,c);let y=m;i&&(y=S.Wap.expandShapeToKeepDim(m,l));const v=function(e,t,n,r){const i=S.D5U.sizeFromShape(t),s=Vd({inputs:{x:e},attrs:{shape:[S.D5U.sizeFromShape(e.shape)/i,i]},backend:r}),a=jd(s,"float32","mean",r),o=Vd({inputs:{x:a},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(a),o}(f,g,y,a);for(const e of p)a.disposeIntermediateTensorInfo(e);return v}},zg={kernelName:S.c17,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,keepDims:a}=r,o=i.shape.length,l=S.D5U.parseAxisParam(s,i.shape);let c=l;const u=S.Wap.getAxesPermutation(c,o);let h=i;null!=u&&(h=Jd({inputs:{x:i},backend:n,attrs:{perm:u}}),c=S.Wap.getInnerMostAxes(c.length,i.shape.length)),S.Wap.assertAxesAreInnerMostDims("min",c,o);const[d,p]=S.Wap.computeOutAndReduceShapes(h.shape,c),f=Vd({inputs:{x:h},backend:n,attrs:{shape:[-1,S.D5U.sizeFromShape(p)]}}),m=jd(f,f.dtype,"min",n);let g;return g=Vd(a?{inputs:{x:m},backend:n,attrs:{shape:S.Wap.expandShapeToKeepDim(d,l)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(h),g}},Bg=Fd({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Fh}),Ug={kernelName:S.q8u,backendName:"webgl",kernelFunc:Bg};class $g{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,i=Ku(r),s=t.map((e=>e[0])).join(","),a=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${i} start = ${i}(${s});\n      ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${i} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class Vg{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,i=Ku(r),s=t.map((e=>e[0])).join(","),a=t.map(((t,n)=>t[0]+e[n])).join(","),o=ad("rc",r),l=ad("source",r),c=`${o[r-1]} < ${this.outputShape[r-1]}`,u=1===r?"source":`vec2(${l.slice(-2).join()})`,h="reflect"===n?0:1;let d="";if(1===r){const e=`\n        ${i} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;d=`\n        ${i} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${u});\n        ${o[r-1]} += 1;\n        if(${c}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${u});\n        }\n      `}else{const e=`\n        ${i} source = rc;\n        ${i} lt = ${i}(lessThan(source, start));\n        ${i} gte = ${i}(greaterThanEqual(source, end));\n        ${i} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;d=`\n        ${i} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${u});\n        ${o[r-1]} += 1;\n        if(${c}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${u});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${u});\n          ${o[r-1]} += 1;\n          if(${c}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${u});\n          }\n        }\n      `}this.userCode=`\n      const ${i} start = ${i}(${s});\n      const ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const Wg={kernelName:S.jQs,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:i,mode:s}=n,a=(0,S.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Vg(r.shape,i,s):new $g(r.shape,i,s);return t.runWebGLProgram(a,[r],r.dtype)}},Gg=Fd({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),Hg={kernelName:S.Vbg,backendName:"webgl",kernelFunc:Gg};class jg{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const qg=Fd({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),Xg={kernelName:S.oHH,backendName:"webgl",kernelFunc:qg},Yg="return a - b;",Kg=Fd({opSnippet:Yg,packedOpSnippet:Yg,supportsComplex:!0,cpuKernelImpl:ed}),Zg={kernelName:S.Tr8,backendName:"webgl",kernelFunc:Kg};function Jg(e){const{inputs:t,backend:n,attrs:r}=e,{logits:i}=t,{dim:s}=r,a=S.D5U.parseAxisParam([s],i.shape),o=Eg({inputs:{x:i},backend:n,attrs:{reductionIndices:a,keepDims:!1}}),l=S.Wap.expandShapeToKeepDim(o.shape,a),c=Vd({inputs:{x:o},backend:n,attrs:{shape:l}}),u=Kg({inputs:{a:i,b:c},backend:n}),h=vm({inputs:{x:u},backend:n}),d=Kd({inputs:{x:h},backend:n,attrs:{axis:a,keepDims:!1}}),p=Vd({inputs:{x:d},backend:n,attrs:{shape:l}}),f=qg({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const Qg={kernelName:S.Gcp,backendName:"webgl",kernelFunc:Jg},ey={kernelName:S.NZg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:i}=t,{numSamples:s,seed:a,normalized:o}=r,l=o?i:Jg({inputs:{logits:i},backend:n,attrs:{dim:i.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new jg(c,u,s),d=[[a]],p=n.runWebGLProgram(h,[l],"int32",d);return o||n.disposeIntermediateTensorInfo(l),p}},ty={kernelName:S.kuV,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,i]=Oh(e.values,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,t)}let i;return i=(0,S.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new gd(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new pd(r.shape,"if (isnan(x)) return x;\n  return -x;\n"),n.runWebGLProgram(i,[r],r.dtype)}},ny=S.GDt.nonMaxSuppressionV3Impl,ry={kernelName:S.uv1,backendName:"webgl",kernelFunc:function(e){S.Wap.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:i,scores:s}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=r,c=n.readSync(i.dataId),u=n.readSync(s.dataId),{selectedIndices:h}=ny(c,u,a,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},iy=S.GDt.nonMaxSuppressionV4Impl,sy={kernelName:S.cye,backendName:"webgl",kernelFunc:function(e){S.Wap.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:i,scores:s}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:c}=r,u=n.readSync(i.dataId),h=n.readSync(s.dataId),{selectedIndices:d,validOutputs:p}=iy(u,h,a,o,l,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},ay=S.GDt.nonMaxSuppressionV5Impl,oy={kernelName:S.W0H,backendName:"webgl",kernelFunc:function(e){S.Wap.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:i,scores:s}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:c}=r,u=n.readSync(i.dataId),h=n.readSync(s.dataId),d=a,p=o,f=l,m=c,{selectedIndices:g,selectedScores:y}=ay(u,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class ly{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const cy={kernelName:S.we_,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:i}=t,{depth:s,onValue:a,offValue:o}=r,l=S.D5U.sizeFromShape(i.shape),c=new ly(l,s,a,o),u=Vd({inputs:{x:i},backend:n,attrs:{shape:[l]}}),h=n.runWebGLProgram(c,[u],i.dtype);n.disposeIntermediateTensorInfo(u);const d=Vd({inputs:{x:h},backend:n,attrs:{shape:[...i.shape,s]}});return n.disposeIntermediateTensorInfo(h),d}};function uy(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=tf({inputs:{input:r},backend:n}),t=uy({inputs:{x:e},backend:n}),i=yf({inputs:{input:r},backend:n}),s=uy({inputs:{x:i},backend:n}),a=Ed({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),a}return Im({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const hy={kernelName:S.RuY,backendName:"webgl",kernelFunc:uy},dy={kernelName:S.qWM,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:i}=n;if("string"===i.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===i.dtype){const t=tf({inputs:{input:i},backend:r}),n=e({inputs:{x:t},backend:r}),s=yf({inputs:{input:i},backend:r}),a=uy({inputs:{x:s},backend:r}),o=Ed({inputs:{real:n,imag:a},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(a),o}return Im({attrs:{shape:i.shape,dtype:i.dtype,value:1},backend:r})}},py={kernelName:S.QiL,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:i}=r;if(1===t.length)return bm({inputs:{input:t[0]},backend:n,attrs:{dim:i}});const s=t[0].shape,a=t[0].dtype;t.forEach((e=>{S.D5U.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),S.D5U.assert(a===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=bf({inputs:t.map((e=>{const t=bm({inputs:{input:e},backend:n,attrs:{dim:i}});return o.push(t),t})),backend:n,attrs:{axis:i}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}};class fy{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,i=Ku(r),s=t.map((e=>e[0])).join(","),a=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${i} start = ${i}(${s});\n      ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${i} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class my{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,i=Ku(r),s=t.map((e=>e[0])).join(","),a=t.map(((t,n)=>t[0]+e[n])).join(","),o=ad("rc",r),l=ad("source",r),c=`${o[r-1]} < ${this.outputShape[r-1]}`,u=1===r?"source":`vec2(${l.slice(-2).join()})`,h=[`${i} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${c}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${c}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let e=0,t=1===r?2:4;e<t;e++)p+=`\n        ${h[e]}\n        if (${d}) {\n          result[${e}] = float(value);\n        } else {\n          ${i} source = rc - start;\n          result[${e}] = getChannel(getX(${l.join()}), ${u});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${i} start = ${i}(${s});\n      const ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const gy=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{paddings:s,constantValue:a}=r;if(0===S.D5U.sizeFromShape(i.shape)){const e=s.map(((e,t)=>e[0]+i.shape[t]+e[1]));return Im({backend:n,attrs:{shape:e,value:a,dtype:i.dtype}})}const o=(0,S.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new my(i.shape,s,a):new fy(i.shape,s,a),l=[[a]];return n.runWebGLProgram(o,[i],i.dtype,l)},yy={kernelName:S.lyA,backendName:"webgl",kernelFunc:gy},vy=Fd({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),xy={kernelName:S.pe_,backendName:"webgl",kernelFunc:vy},by={kernelName:S.DlI,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,keepDims:a}=r,o=i.shape.length,l=[],c=S.D5U.parseAxisParam(s,i.shape);let u=c;const h=S.Wap.getAxesPermutation(u,o);let d,p=i;if(null!=h&&(p=Jd({inputs:{x:i},backend:n,attrs:{perm:h}}),u=S.Wap.getInnerMostAxes(u.length,o),l.push(p)),S.Wap.assertAxesAreInnerMostDims("prod",u,o),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:r,outDtype:i}=Bh(p.shape,p.dtype,e,u);d=n.makeTensorInfo(r,i,t)}else{const[e,t]=S.Wap.computeOutAndReduceShapes(p.shape,u),r=S.D5U.sizeFromShape(t),s=Vd({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),a=jd(s,(0,S.z4k)(i.dtype),"prod",n);d=Vd({inputs:{x:a},backend:n,attrs:{shape:e}}),l.push(s),l.push(a)}if(a){l.push(d);const e=S.Wap.expandShapeToKeepDim(d.shape,c);d=Vd({inputs:{x:d},backend:n,attrs:{shape:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},wy=e=>{const{backend:t,attrs:n}=e,{start:r,stop:i,step:s,dtype:a}=n,o=Uh(r,i,s,a);return t.makeTensorInfo([o.length],a,o)},_y={kernelName:S.e6w,backendName:"webgl",kernelFunc:wy},Sy=Ld({opSnippet:"return 1.0 / x;"}),My={kernelName:S.$HU,backendName:"webgl",kernelFunc:Sy},Ty=Ld({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Ey={kernelName:S.qkr,backendName:"webgl",kernelFunc:Ty},Ay=Ld({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Cy={kernelName:S.SbG,backendName:"webgl",kernelFunc:Ay};class Iy{constructor(e,t,n,r,i){this.variableNames=["A"],this.outputShape=[];const[s,a,o,l]=e;this.outputShape=[s,t,n,l];const c=[r&&t>1?a-1:a,r&&n>1?o-1:o],u=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=i?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/u[0]},\n          ${c[1]/u[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class Ny{constructor(e,t,n,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,a,o,l]=e;this.outputShape=[s,t,n,l];const c=[r&&t>1?a-1:a,r&&n>1?o-1:o],u=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=i?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/u[0]},\n          ${c[1]/u[1]},\n          ${c[1]/u[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const ky={kernelName:S._Yw,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i}=t,{alignCorners:s,halfPixelCenters:a,size:o}=r,[l,c]=o,u=(0,S.OBj)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Ny(i.shape,l,c,s,a):new Iy(i.shape,l,c,s,a);return n.runWebGLProgram(u,[i],"float32")}};class Ry{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,s,a]=e,o=[n&&s>1?r-1:r,n&&a>1?i-1:i],l=[n&&s>1?s-1:s,n&&a>1?a-1:a],c=o[0]/l[0],u=o[1]/l[1],h=1/c,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${u});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Dy={kernelName:S.zbQ,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i,dy:s}=t,{alignCorners:a}=r,o=new Ry(s.shape,i.shape,a);return n.runWebGLProgram(o,[s],s.dtype)}};class Ly{constructor(e,t,n,r,i){this.variableNames=["A"],this.outputShape=[];const[s,a,o,l]=e;this.outputShape=[s,t,n,l];const c=[r&&t>1?a-1:a,r&&n>1?o-1:o],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=i?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/u[0]},\n          ${c[1]/u[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class Fy{constructor(e,t,n,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,a,o,l]=e;this.outputShape=[s,t,n,l];const c=[r&&t>1?a-1:a,r&&n>1?o-1:o],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=i?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/u[0]},\n          ${c[1]/u[1]},\n          ${c[1]/u[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const Py={kernelName:S.dpD,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i}=t,{alignCorners:s,halfPixelCenters:a,size:o}=r,[l,c]=o,u=(0,S.OBj)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Fy(i.shape,l,c,s,a):new Ly(i.shape,l,c,s,a);return n.runWebGLProgram(u,[i],i.dtype)}};class Oy{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,s,a]=e,o=[n&&s>1?r-1:r,n&&a>1?i-1:i],l=[n&&s>1?s-1:s,n&&a>1?a-1:a],c=o[0]/l[0],u=o[1]/l[1],h=1/c,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${u});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${i}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const zy={kernelName:S.Hmb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i,dy:s}=t,{alignCorners:a}=r,o=new Oy(s.shape,i.shape,a);return n.runWebGLProgram(o,[s],s.dtype)}};class By{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),i=Ku(n);this.userCode=`\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class Uy{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=ad("rc",n),i=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,a=Ku(n);function o(n){const r=e.map(((r,i)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(i,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${i}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return o(e)}(r.slice())};\n          if(${i}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(r.slice())};\n          }\n          if(${s}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            if(${i}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const $y={kernelName:S.mKl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{dims:s}=r,a=i.shape.length,o=S.D5U.parseAxisParam(s,i.shape);if(0===a)return Md({inputs:{x:i},backend:n});const l=(0,S.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Uy(i.shape,o):new By(i.shape,o);return n.runWebGLProgram(l,[i],i.dtype)}};class Vy{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let i="";i="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${i}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Wy={kernelName:S.b9H,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:i,fillValue:s,center:a}=t,o=n,l=new Vy(r.shape,s),[c,u]=S.Wap.getImageCenter(a,r.shape[1],r.shape[2]),h=[[c,u,Math.sin(i),Math.cos(i)]];return o.runWebGLProgram(l,[r],r.dtype,h)}},Gy=Ld({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),Hy={kernelName:S.e07,backendName:"webgl",kernelFunc:Gy},jy=Ld({opSnippet:"return inversesqrt(x);",cpuKernelImpl:$h}),qy={kernelName:S.bV0,backendName:"webgl",kernelFunc:jy};class Xy{constructor(e,t,n,r,i,s,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const o=Ku(i.length),l=Ku(s.length);let c="";1===n?c="i":2===n&&(c="i, j");const u=`getIndices(${c})`;let h="";1===r?h="i":2===r&&(h="i, coords[1]");const d=`getUpdates(${h})`,p=t>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${i});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${u});\n              flattenedIndex += index * ${p};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${d};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const Yy={kernelName:S.xQA,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:i,updates:s}=t,{shape:a}=r,{sliceRank:o,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=S.Wap.calculateShapes(s,i,a),d=[h/c,c];if(0===h)return n.makeTensorInfo(a,i.dtype);const p=Vd({inputs:{x:i},backend:n,attrs:{shape:[l,o]}}),f=Vd({inputs:{x:s},backend:n,attrs:{shape:[l,c]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new Xy(l,o,p.shape.length,f.shape.length,u,d),y=n.runWebGLProgram(g,[f,p,m],f.dtype),v=Vd({inputs:{x:y},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),v}};class Ky{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const i=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,s=2===(0,S.OBj)().getNumber("WEBGL_VERSION")?"while (left < right) {":i,a="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${s}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${a} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const Zy={kernelName:S.nr8,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:i,values:s}=t,{side:a}=r,o=new Ky(i.shape[0],i.shape[1],s.shape[1],a),l=[[i.shape[1]]];return n.runWebGLProgram(o,[i,s],"int32",l)}};class Jy{constructor(e,t,n){let r,i;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)i="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],a=[];for(let r=0;r<t.length;r++)a.push(`${n[r]}`),r<e&&s.push(`${n[r]}`);r=s.join(),i=a.join()}const s=Ku(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${i}));\n        } else {\n          setOutput(getB(${i}));\n        }\n      }\n    `}}const Qy={kernelName:S.PhF,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:i,e:s}=t,a=new Jy(r.shape.length,i.shape,i.shape.length);return n.runWebGLProgram(a,[r,i,s],(0,S.x8V)(i.dtype,s.dtype))}},ev=Ld({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${S.Wap.SELU_SCALEALPHA};\n  float scale = ${S.Wap.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),tv={kernelName:S.oFR,backendName:"webgl",kernelFunc:ev},nv=Ld({opSnippet:"if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Wh}),rv={kernelName:S.a5O,backendName:"webgl",kernelFunc:nv},iv=Ld({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),sv={kernelName:S.i5y,backendName:"webgl",kernelFunc:iv},av=Ld({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),ov={kernelName:S.RQH,backendName:"webgl",kernelFunc:av},lv=Ld({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),cv={kernelName:S.wYB,backendName:"webgl",kernelFunc:lv},uv=Ld({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),hv={kernelName:S.MRv,backendName:"webgl",kernelFunc:uv},dv={kernelName:S.TQc,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{blockShape:s,paddings:a}=r;S.D5U.assert(i.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const o=s.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...a);for(let e=1+s.length;e<i.shape.length;++e)l.push([0,0]);const c=[],u=gy({inputs:{x:i},backend:n,attrs:{paddings:l,constantValue:0}}),h=S.Wap.getReshaped(u.shape,s,o,!1),d=S.Wap.getPermuted(h.length,s.length,!1),p=S.Wap.getReshapedPermuted(u.shape,s,o,!1),f=Vd({inputs:{x:u},backend:n,attrs:{shape:h}}),m=Jd({inputs:{x:f},backend:n,attrs:{perm:d}}),g=Vd({inputs:{x:m},backend:n,attrs:{shape:p}});return c.push(u),c.push(f),c.push(m),c.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}},pv={kernelName:S.O3z,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:i,denseShape:s,defaultValue:a}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==i.shape.length)throw new Error(`Values must be a vector, saw:\n         ${i.shape}`);if(0!==a.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${a.shape}`);const o=n.readSync(r.dataId),l=n.readSync(i.dataId),c=n.readSync(s.dataId),u=n.readSync(a.dataId)[0],[h,d,p,f,m]=jh(o,r.shape,r.dtype,l,i.dtype,c,u);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],i.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},fv={kernelName:S.nhH,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:i,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==i.shape.length)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const a=Array.from(n.readSync(i.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[c,u,h]=qh(o,r.shape,r.dtype,a,l);return[n.makeTensorInfo(u,r.dtype,c),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}},mv={kernelName:S.w3H,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:i,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${i.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);const a=n.readSync(r.dataId),o=n.readSync(i.dataId),l=n.readSync(s.dataId),[c,u]=Xh(a,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(u,r.dtype,c)}},gv={kernelName:S.ZjV,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:i,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${i.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);const a=n.readSync(r.dataId),o=n.readSync(i.dataId),l=n.readSync(s.dataId),[c,u]=Xh(a,r.shape,r.dtype,o,l);return n.makeTensorInfo(u,r.dtype,c)}},yv={kernelName:S.D2d,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:i,sparseValues:s,defaultValue:a}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=S.Wap.calculateShapes(s,i,o);if("string"===s.dtype){const e=n.bufferSync(i),t=n.bufferSync(s),r=S.D5U.decodeString(n.readSync(a.dataId)[0]),p=Vh(e,t,o,d,u,c,l,h,r,!1);return n.makeTensorInfo(o,p.dtype,p.values)}const p=new Xy(c,l,i.shape.length,s.shape.length,h,[d,1],!1),f=n.runWebGLProgram(p,[s,i,a],s.dtype),m=Vd({inputs:{x:f},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),m}},vv={kernelName:S.L8s,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{numOrSizeSplits:s,axis:a}=r,o=S.D5U.parseAxisParam(a,i.shape)[0],l=S.Wap.prepareSplitSize(i,s,o),c=i.shape.length,u=new Array(c).fill(0),h=i.shape.slice();return l.map((e=>{const t=[...h];t[o]=e;const r=Xp({inputs:{x:i},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r}))}},xv="return sqrt(x);",bv=Ld({opSnippet:xv,packedOpSnippet:xv,cpuKernelImpl:Yh}),wv={kernelName:S.FKq,backendName:"webgl",kernelFunc:bv},_v=Ld({opSnippet:"return x * x;"}),Sv={kernelName:S.bK0,backendName:"webgl",kernelFunc:_v},Mv="return (a - b) * (a - b);",Tv=Fd({opSnippet:Mv,packedOpSnippet:Mv}),Ev={kernelName:S._tC,backendName:"webgl",kernelFunc:Tv},Av={kernelName:S.h8e,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,i=`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,s=new pd(r.shape,i);return n.runWebGLProgram(s,[r],r.dtype)}};class Cv{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,i=Ku(n.length),s=Ku(n.length);let a="";if(1===r)a="coords * strides + begin";else{let e=0;a=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${i} begin = ${i}(${e});\n      ${i} strides = ${i}(${t});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const Iv={kernelName:S.jQk,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{begin:s,end:a,strides:o,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:v,end:x,strides:b}=S.kuN.sliceInfo(i.shape,s,a,o,l,c,u,h,d);let w;if(m)w=Vd({inputs:{x:i},backend:n,attrs:{shape:f}});else if(g||y){S.D5U.assert(i.shape.length>=1,(()=>`Input must have rank at least 1, got: ${i.shape.length}`));const e=S.kuN.computeOutShape(v,x,b),t=Xp({inputs:{x:i},backend:n,attrs:{begin:v,size:e}});w=Vd({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else if(n.shouldExecuteOnCPU([i])){const e=n.readSync(i.dataId),t=(0,S.f3b)(i.shape,i.dtype,e),r=Kh(p,t,b,v);w=n.makeTensorInfo(f,i.dtype,r.values)}else{const e=new Cv(v,b,p);w=n.runWebGLProgram(e,[i],i.dtype)}const _=Vd({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),_}},Nv={kernelName:S._JP,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:i,nGramWidths:s,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=t,d=n.readSync(u.dataId),p=n.readSync(h.dataId),[f,m]=Zh(d,p,i,s,a,o,l,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}},kv={kernelName:S.s1s,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:i}=r,{input:s,delimiter:a}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==a.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=n.readSync(s.dataId),l=n.readSync(a.dataId)[0],[c,u,h]=Jh(o,l,i),d=u.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}},Rv={kernelName:S.XkS,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:i}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const a=n.readSync(s.dataId),o=Qh(a,i);return n.makeTensorInfo(s.shape,"int32",o)}},Dv=Ld({opSnippet:"return tan(x);"}),Lv={kernelName:S.sEM,backendName:"webgl",kernelFunc:Dv},Fv=Ld({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),Pv={kernelName:S.MIZ,backendName:"webgl",kernelFunc:Fv};class Ov{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;const r=Ku(this.rank),i=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let t=0;t<e.length;t++)r.push(`imod(${n[t]}, ${e[t]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `}}function zv(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{reps:s}=r;if("string"===i.dtype||i.shape.length>5){const e=n.readSync(i.dataId),t="string"===i.dtype?e.map((e=>S.D5U.decodeString(e))):e,r=(0,S.f3b)(i.shape,i.dtype,t),a=td(r,s);return n.makeTensorInfo(a.shape,a.dtype,a.values)}const a=new Ov(i.shape,s);return n.runWebGLProgram(a,[i],i.dtype)}const Bv={kernelName:S.n9L,backendName:"webgl",kernelFunc:zv};class Uv{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class $v{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function Vv(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function Wv(e){let t=1;for(;t<e;)t*=2;return t}const Gv={kernelName:S.cWu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{k:s,sorted:a}=r,o=(0,S.OBj)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=(0,S.OBj)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=i.shape,u=c[c.length-1];if(n.shouldExecuteOnCPU([i])||u<o||s>l){const e=n.readSync(i.dataId),[t,r]=nd(e,c,i.dtype,s,a);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return c[c.length-1]=0,[n.makeTensorInfo(c,i.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(1===u)return[i,Im({attrs:{shape:c,dtype:"int32",value:0},backend:n})];const h=n.texData.get(i.dataId),d=null!==h&&h.isPacked,p=d?n.unpackTensor(i):i,f=S.D5U.sizeFromShape(c)/u,m=Vd({inputs:{x:p},attrs:{shape:[f,u]},backend:n});d&&Vv(n,p);const g=Wv(s),y=Wv(u);let v=null;const x=()=>null===v?[m,m]:[m,v],b=(e,t,r)=>{const i=x(),s=new Uv(r),a=[[u],[null===v?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=v;v=n.runWebGLProgram(s,i,"int32",a),Vv(n,o)};for(let e=1;e<g;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)b(t,n,[f,y])}for(let e=y;e>g;e/=2){const t=x(),r=new $v([f,e/2]),i=[[u],[null===v?1:0],[g]],s=v;v=n.runWebGLProgram(r,t,"int32",i),Vv(n,s);const a=g/2,o=2*a;for(let e=a;e>=1;e/=2)b(o,e,v.shape)}let w=v;v=Xp({inputs:{x:v},backend:n,attrs:{begin:0,size:[f,s]}}),Vv(n,w);let _=qm({inputs:{x:m,indices:v},backend:n,attrs:{axis:1,batchDims:1}});Vv(n,m);const M=c.slice(0,-1);M.push(s),w=v,v=Vd({inputs:{x:v},attrs:{shape:M},backend:n}),Vv(n,w);const T=_;return _=Vd({inputs:{x:_},attrs:{shape:M},backend:n}),Vv(n,T),[_,v]}};class Hv{constructor(e,t,n,r,i,s){this.variableNames=["Image","Transforms"],this.outputShape=s;const a="nearest"===n?1:2;let o;switch(r){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${i});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${i});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const jv={kernelName:S.wx7,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:i,transforms:s}=t,{interpolation:a,fillMode:o,fillValue:l,outputShape:c}=r,[u,h,d,p]=i.shape,[f,m]=null!=c?c:[h,d],g=new Hv(h,d,a,o,l,[u,f,m,p]);return n.runWebGLProgram(g,[i,s],"float32")}},qv={kernelName:S.kpP,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:i}=n,{x:s}=t;Du(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=r.readSync(s.dataId),{outputValues:o,outputShape:l,indices:c}=id(a,i,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([c.length],"int32",c)]}},Xv={kernelName:S.ToN,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:i}=t;let{axis:s}=r;s<0&&(s+=i.shape.length);const a=i,o=a.shape.length,l=i.shape[s],c=new Array(o-1);let u=0;for(let e=0;e<o;e++)e!==s&&(c[u++]=a.shape[e]);const h=[],d=new Array(o).fill(0),p=a.shape.slice();p[s]=1;const f=new Array(l);for(let e=0;e<f.length;e++){d[s]=e;const t=Xp({inputs:{x:a},backend:n,attrs:{begin:d,size:p}}),r=Vd({inputs:{x:t},backend:n,attrs:{shape:c}});f[e]=r,h.push(t)}return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class Yv{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,i=e.inSize,s=e.numSegments,a=s*Math.ceil(i/n);this.outputShape=[r,a];const o=4*Math.floor(n/4),l=n%4,c="\n        sumValue += dot(values, segFilter);\n    ";let u="";i%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `);let h="";i%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${c}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${c}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}const Kv=[tp,rp,sp,op,up,pp,fp,mp,wp,_p,Mp,Ep,Cp,Np,Rp,Fp,Pp,Bp,Up,$p,Gp,Kp,Zp,Jp,rf,of,uf,Ad,pf,wf,Af,Rf,Df,Lf,Ff,Pf,zf,Uf,Vf,Xf,Yf,Kf,Jf,tm,im,sm,om,cm,um,dm,pm,mm,ym,xm,wm,Mm,Am,Nm,Rm,Fm,Om,Um,Vm,Wm,Hm,Xm,Km,Jm,Td,Qm,vf,tg,rg,sg,Nd,og,cg,ug,dg,fg,gg,vg,bg,Sg,Tg,Ag,Ig,Ng,kg,Lg,Fg,Pg,Og,zg,Ug,Wg,Hg,ey,$d,ty,ry,sy,oy,ef,cy,dy,py,yy,xy,Dd,by,_y,nf,Xg,My,Ey,Cy,Wd,ky,Dy,Py,zy,$y,Wy,Hy,qy,Yy,Zy,Qy,tv,rv,sv,ov,cv,Yp,Qg,hv,dv,pv,fv,mv,gv,yv,vv,wv,Sv,Ev,Av,Iv,Nv,kv,Rv,Zg,Zd,Lv,Pv,Bv,Gv,jv,Qd,qv,Xv,{kernelName:S.Qvg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,segmentIds:s}=t,{numSegments:a}=r,o=i.shape.length,l=[];let c=0;const u=S.Wap.getAxesPermutation([c],o);let h=i;null!=u&&(h=Jd({inputs:{x:i},backend:n,attrs:{perm:u}}),l.push(h),c=S.Wap.getInnerMostAxes(1,o)[0]);const d=S.Wap.segment_util.computeOutShape(h.shape,c,a),p=S.D5U.sizeFromShape([h.shape[c]]),f=Vd({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});l.push(f);const m=(0,S.z4k)(i.dtype),g=(e,t,r,i,s)=>{const a=e.shape[0],o=e.shape[1],c=S.Wap.segment_util.segOpComputeOptimalWindowSize(o,s),u=new Yv({windowSize:c,inSize:o,batchSize:a,numSegments:s},t),h=n.compileAndRun(u,[e,r],i);if(l.push(h),h.shape[1]===s)return h;const d=wy({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),p=zv({inputs:{x:d},backend:n,attrs:{reps:[o/c]}});return l.push(d),l.push(p),g(h,t,p,i,s)},y=Vd({inputs:{x:g(f,"unsortedSegmentSum",s,m,a)},backend:n,attrs:{shape:d}});let v=y;if(null!=u){l.push(y);const e=S.Wap.getUndoAxesPermutation(u);v=Jd({inputs:{x:v},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),v}},hy];for(const e of Kv)(0,S.wCN)(e);const Zv={"tfjs-core":S.jTM,"tfjs-backend-cpu":"3.18.0","tfjs-backend-webgl":"3.18.0","tfjs-data":Ur.version_data,"tfjs-layers":Ht.H6,"tfjs-converter":Br,tfjs:"3.18.0"}},1924:(e,t,n)=>{"use strict";var r=n(210),i=n(5559),s=i(r("String.prototype.indexOf"));e.exports=function(e,t){var n=r(e,!!t);return"function"==typeof n&&s(e,".prototype.")>-1?i(n):n}},5559:(e,t,n)=>{"use strict";var r=n(8612),i=n(210),s=i("%Function.prototype.apply%"),a=i("%Function.prototype.call%"),o=i("%Reflect.apply%",!0)||r.call(a,s),l=i("%Object.getOwnPropertyDescriptor%",!0),c=i("%Object.defineProperty%",!0),u=i("%Math.max%");if(c)try{c({},"a",{value:1})}catch(e){c=null}e.exports=function(e){var t=o(r,a,arguments);if(l&&c){var n=l(t,"length");n.configurable&&c(t,"length",{value:1+u(0,e.length-(arguments.length-1))})}return t};var h=function(){return o(r,s,arguments)};c?c(e.exports,"apply",{value:h}):e.exports.apply=h},3687:(e,t,n)=>{"use strict";n.r(t),n.d(t,{AABB:()=>u,ArrayCollisionMatrix:()=>p,BODY_SLEEP_STATES:()=>k,BODY_TYPES:()=>N,Body:()=>R,Box:()=>A,Broadphase:()=>j,COLLISION_TYPES:()=>yr,ConeTwistConstraint:()=>ht,Constraint:()=>Ue,ContactEquation:()=>Ye,ContactMaterial:()=>wt,ConvexPolyhedron:()=>_,Cylinder:()=>wn,DistanceConstraint:()=>dt,Equation:()=>Ve,EventTarget:()=>f,FrictionEquation:()=>vt,GSSolver:()=>tr,GridBroadphase:()=>Z,Heightfield:()=>Tn,HingeConstraint:()=>mt,JacobianElement:()=>$e,LockConstraint:()=>pt,Mat3:()=>i,Material:()=>_t,NaiveBroadphase:()=>Q,Narrowphase:()=>vr,ObjectCollisionMatrix:()=>r,Particle:()=>_n,Plane:()=>Sn,PointToPointConstraint:()=>it,Pool:()=>mr,Quaternion:()=>m,RAY_MODES:()=>le,Ray:()=>ce,RaycastResult:()=>ee,RaycastVehicle:()=>zt,RigidVehicle:()=>un,RotationalEquation:()=>lt,RotationalMotorEquation:()=>ft,SAPBroadphase:()=>ze,SHAPE_TYPES:()=>v,SPHSystem:()=>pn,Shape:()=>x,Solver:()=>er,Sphere:()=>cn,SplitSolver:()=>sr,Spring:()=>St,Transform:()=>b,Trimesh:()=>Un,Vec3:()=>a,Vec3Pool:()=>gr,WheelInfo:()=>Ft,World:()=>Bi});class r{constructor(){this.matrix={}}get(e,t){let{id:n}=e,{id:r}=t;if(r>n){const e=r;r=n,n=e}return`${n}-${r}`in this.matrix}set(e,t,n){let{id:r}=e,{id:i}=t;if(i>r){const e=i;i=r,r=e}n?this.matrix[`${r}-${i}`]=!0:delete this.matrix[`${r}-${i}`]}reset(){this.matrix={}}setNumObjects(e){}}class i{constructor(e){void 0===e&&(e=[0,0,0,0,0,0,0,0,0]),this.elements=e}identity(){const e=this.elements;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1}setZero(){const e=this.elements;e[0]=0,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=0,e[6]=0,e[7]=0,e[8]=0}setTrace(e){const t=this.elements;t[0]=e.x,t[4]=e.y,t[8]=e.z}getTrace(e){void 0===e&&(e=new a);const t=this.elements;return e.x=t[0],e.y=t[4],e.z=t[8],e}vmult(e,t){void 0===t&&(t=new a);const n=this.elements,r=e.x,i=e.y,s=e.z;return t.x=n[0]*r+n[1]*i+n[2]*s,t.y=n[3]*r+n[4]*i+n[5]*s,t.z=n[6]*r+n[7]*i+n[8]*s,t}smult(e){for(let t=0;t<this.elements.length;t++)this.elements[t]*=e}mmult(e,t){void 0===t&&(t=new i);const n=this.elements,r=e.elements,s=t.elements,a=n[0],o=n[1],l=n[2],c=n[3],u=n[4],h=n[5],d=n[6],p=n[7],f=n[8],m=r[0],g=r[1],y=r[2],v=r[3],x=r[4],b=r[5],w=r[6],_=r[7],S=r[8];return s[0]=a*m+o*v+l*w,s[1]=a*g+o*x+l*_,s[2]=a*y+o*b+l*S,s[3]=c*m+u*v+h*w,s[4]=c*g+u*x+h*_,s[5]=c*y+u*b+h*S,s[6]=d*m+p*v+f*w,s[7]=d*g+p*x+f*_,s[8]=d*y+p*b+f*S,t}scale(e,t){void 0===t&&(t=new i);const n=this.elements,r=t.elements;for(let t=0;3!==t;t++)r[3*t+0]=e.x*n[3*t+0],r[3*t+1]=e.y*n[3*t+1],r[3*t+2]=e.z*n[3*t+2];return t}solve(e,t){void 0===t&&(t=new a);const n=[];let r,i;for(r=0;r<12;r++)n.push(0);for(r=0;r<3;r++)for(i=0;i<3;i++)n[r+4*i]=this.elements[r+3*i];n[3]=e.x,n[7]=e.y,n[11]=e.z;let s=3;const o=s;let l,c;do{if(r=o-s,0===n[r+4*r])for(i=r+1;i<o;i++)if(0!==n[r+4*i]){l=4;do{c=4-l,n[c+4*r]+=n[c+4*i]}while(--l);break}if(0!==n[r+4*r])for(i=r+1;i<o;i++){const e=n[r+4*i]/n[r+4*r];l=4;do{c=4-l,n[c+4*i]=c<=r?0:n[c+4*i]-n[c+4*r]*e}while(--l)}}while(--s);if(t.z=n[11]/n[10],t.y=(n[7]-n[6]*t.z)/n[5],t.x=(n[3]-n[2]*t.z-n[1]*t.y)/n[0],isNaN(t.x)||isNaN(t.y)||isNaN(t.z)||t.x===1/0||t.y===1/0||t.z===1/0)throw`Could not solve equation! Got x=[${t.toString()}], b=[${e.toString()}], A=[${this.toString()}]`;return t}e(e,t,n){if(void 0===n)return this.elements[t+3*e];this.elements[t+3*e]=n}copy(e){for(let t=0;t<e.elements.length;t++)this.elements[t]=e.elements[t];return this}toString(){let e="";for(let t=0;t<9;t++)e+=this.elements[t]+",";return e}reverse(e){void 0===e&&(e=new i);const t=s;let n,r;for(n=0;n<3;n++)for(r=0;r<3;r++)t[n+6*r]=this.elements[n+3*r];t[3]=1,t[9]=0,t[15]=0,t[4]=0,t[10]=1,t[16]=0,t[5]=0,t[11]=0,t[17]=1;let a=3;const o=a;let l,c;do{if(n=o-a,0===t[n+6*n])for(r=n+1;r<o;r++)if(0!==t[n+6*r]){l=6;do{c=6-l,t[c+6*n]+=t[c+6*r]}while(--l);break}if(0!==t[n+6*n])for(r=n+1;r<o;r++){const e=t[n+6*r]/t[n+6*n];l=6;do{c=6-l,t[c+6*r]=c<=n?0:t[c+6*r]-t[c+6*n]*e}while(--l)}}while(--a);n=2;do{r=n-1;do{const e=t[n+6*r]/t[n+6*n];l=6;do{c=6-l,t[c+6*r]=t[c+6*r]-t[c+6*n]*e}while(--l)}while(r--)}while(--n);n=2;do{const e=1/t[n+6*n];l=6;do{c=6-l,t[c+6*n]=t[c+6*n]*e}while(--l)}while(n--);n=2;do{r=2;do{if(c=t[3+r+6*n],isNaN(c)||c===1/0)throw`Could not reverse! A=[${this.toString()}]`;e.e(n,r,c)}while(r--)}while(n--);return e}setRotationFromQuaternion(e){const t=e.x,n=e.y,r=e.z,i=e.w,s=t+t,a=n+n,o=r+r,l=t*s,c=t*a,u=t*o,h=n*a,d=n*o,p=r*o,f=i*s,m=i*a,g=i*o,y=this.elements;return y[0]=1-(h+p),y[1]=c-g,y[2]=u+m,y[3]=c+g,y[4]=1-(l+p),y[5]=d-f,y[6]=u-m,y[7]=d+f,y[8]=1-(l+h),this}transpose(e){void 0===e&&(e=new i);const t=this.elements,n=e.elements;let r;return n[0]=t[0],n[4]=t[4],n[8]=t[8],r=t[1],n[1]=t[3],n[3]=r,r=t[2],n[2]=t[6],n[6]=r,r=t[5],n[5]=t[7],n[7]=r,e}}const s=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class a{constructor(e,t,n){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),this.x=e,this.y=t,this.z=n}cross(e,t){void 0===t&&(t=new a);const n=e.x,r=e.y,i=e.z,s=this.x,o=this.y,l=this.z;return t.x=o*i-l*r,t.y=l*n-s*i,t.z=s*r-o*n,t}set(e,t,n){return this.x=e,this.y=t,this.z=n,this}setZero(){this.x=this.y=this.z=0}vadd(e,t){if(!t)return new a(this.x+e.x,this.y+e.y,this.z+e.z);t.x=e.x+this.x,t.y=e.y+this.y,t.z=e.z+this.z}vsub(e,t){if(!t)return new a(this.x-e.x,this.y-e.y,this.z-e.z);t.x=this.x-e.x,t.y=this.y-e.y,t.z=this.z-e.z}crossmat(){return new i([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const e=this.x,t=this.y,n=this.z,r=Math.sqrt(e*e+t*t+n*n);if(r>0){const e=1/r;this.x*=e,this.y*=e,this.z*=e}else this.x=0,this.y=0,this.z=0;return r}unit(e){void 0===e&&(e=new a);const t=this.x,n=this.y,r=this.z;let i=Math.sqrt(t*t+n*n+r*r);return i>0?(i=1/i,e.x=t*i,e.y=n*i,e.z=r*i):(e.x=1,e.y=0,e.z=0),e}length(){const e=this.x,t=this.y,n=this.z;return Math.sqrt(e*e+t*t+n*n)}lengthSquared(){return this.dot(this)}distanceTo(e){const t=this.x,n=this.y,r=this.z,i=e.x,s=e.y,a=e.z;return Math.sqrt((i-t)*(i-t)+(s-n)*(s-n)+(a-r)*(a-r))}distanceSquared(e){const t=this.x,n=this.y,r=this.z,i=e.x,s=e.y,a=e.z;return(i-t)*(i-t)+(s-n)*(s-n)+(a-r)*(a-r)}scale(e,t){void 0===t&&(t=new a);const n=this.x,r=this.y,i=this.z;return t.x=e*n,t.y=e*r,t.z=e*i,t}vmul(e,t){return void 0===t&&(t=new a),t.x=e.x*this.x,t.y=e.y*this.y,t.z=e.z*this.z,t}addScaledVector(e,t,n){return void 0===n&&(n=new a),n.x=this.x+e*t.x,n.y=this.y+e*t.y,n.z=this.z+e*t.z,n}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}negate(e){return void 0===e&&(e=new a),e.x=-this.x,e.y=-this.y,e.z=-this.z,e}tangents(e,t){const n=this.length();if(n>0){const r=o,i=1/n;r.set(this.x*i,this.y*i,this.z*i);const s=l;Math.abs(r.x)<.9?(s.set(1,0,0),r.cross(s,e)):(s.set(0,1,0),r.cross(s,e)),r.cross(e,t)}else e.set(1,0,0),t.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}lerp(e,t,n){const r=this.x,i=this.y,s=this.z;n.x=r+(e.x-r)*t,n.y=i+(e.y-i)*t,n.z=s+(e.z-s)*t}almostEquals(e,t){return void 0===t&&(t=1e-6),!(Math.abs(this.x-e.x)>t||Math.abs(this.y-e.y)>t||Math.abs(this.z-e.z)>t)}almostZero(e){return void 0===e&&(e=1e-6),!(Math.abs(this.x)>e||Math.abs(this.y)>e||Math.abs(this.z)>e)}isAntiparallelTo(e,t){return this.negate(c),c.almostEquals(e,t)}clone(){return new a(this.x,this.y,this.z)}}a.ZERO=new a(0,0,0),a.UNIT_X=new a(1,0,0),a.UNIT_Y=new a(0,1,0),a.UNIT_Z=new a(0,0,1);const o=new a,l=new a,c=new a;class u{constructor(e){void 0===e&&(e={}),this.lowerBound=new a,this.upperBound=new a,e.lowerBound&&this.lowerBound.copy(e.lowerBound),e.upperBound&&this.upperBound.copy(e.upperBound)}setFromPoints(e,t,n,r){const i=this.lowerBound,s=this.upperBound,a=n;i.copy(e[0]),a&&a.vmult(i,i),s.copy(i);for(let t=1;t<e.length;t++){let n=e[t];a&&(a.vmult(n,h),n=h),n.x>s.x&&(s.x=n.x),n.x<i.x&&(i.x=n.x),n.y>s.y&&(s.y=n.y),n.y<i.y&&(i.y=n.y),n.z>s.z&&(s.z=n.z),n.z<i.z&&(i.z=n.z)}return t&&(t.vadd(i,i),t.vadd(s,s)),r&&(i.x-=r,i.y-=r,i.z-=r,s.x+=r,s.y+=r,s.z+=r),this}copy(e){return this.lowerBound.copy(e.lowerBound),this.upperBound.copy(e.upperBound),this}clone(){return(new u).copy(this)}extend(e){this.lowerBound.x=Math.min(this.lowerBound.x,e.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,e.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,e.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,e.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,e.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,e.upperBound.z)}overlaps(e){const t=this.lowerBound,n=this.upperBound,r=e.lowerBound,i=e.upperBound,s=r.x<=n.x&&n.x<=i.x||t.x<=i.x&&i.x<=n.x,a=r.y<=n.y&&n.y<=i.y||t.y<=i.y&&i.y<=n.y,o=r.z<=n.z&&n.z<=i.z||t.z<=i.z&&i.z<=n.z;return s&&a&&o}volume(){const e=this.lowerBound,t=this.upperBound;return(t.x-e.x)*(t.y-e.y)*(t.z-e.z)}contains(e){const t=this.lowerBound,n=this.upperBound,r=e.lowerBound,i=e.upperBound;return t.x<=r.x&&n.x>=i.x&&t.y<=r.y&&n.y>=i.y&&t.z<=r.z&&n.z>=i.z}getCorners(e,t,n,r,i,s,a,o){const l=this.lowerBound,c=this.upperBound;e.copy(l),t.set(c.x,l.y,l.z),n.set(c.x,c.y,l.z),r.set(l.x,c.y,c.z),i.set(c.x,l.y,c.z),s.set(l.x,c.y,l.z),a.set(l.x,l.y,c.z),o.copy(c)}toLocalFrame(e,t){const n=d,r=n[0],i=n[1],s=n[2],a=n[3],o=n[4],l=n[5],c=n[6],u=n[7];this.getCorners(r,i,s,a,o,l,c,u);for(let t=0;8!==t;t++){const r=n[t];e.pointToLocal(r,r)}return t.setFromPoints(n)}toWorldFrame(e,t){const n=d,r=n[0],i=n[1],s=n[2],a=n[3],o=n[4],l=n[5],c=n[6],u=n[7];this.getCorners(r,i,s,a,o,l,c,u);for(let t=0;8!==t;t++){const r=n[t];e.pointToWorld(r,r)}return t.setFromPoints(n)}overlapsRay(e){const{direction:t,from:n}=e,r=1/t.x,i=1/t.y,s=1/t.z,a=(this.lowerBound.x-n.x)*r,o=(this.upperBound.x-n.x)*r,l=(this.lowerBound.y-n.y)*i,c=(this.upperBound.y-n.y)*i,u=(this.lowerBound.z-n.z)*s,h=(this.upperBound.z-n.z)*s,d=Math.max(Math.max(Math.min(a,o),Math.min(l,c)),Math.min(u,h)),p=Math.min(Math.min(Math.max(a,o),Math.max(l,c)),Math.max(u,h));return!(p<0||d>p)}}const h=new a,d=[new a,new a,new a,new a,new a,new a,new a,new a];class p{constructor(){this.matrix=[]}get(e,t){let{index:n}=e,{index:r}=t;if(r>n){const e=r;r=n,n=e}return this.matrix[(n*(n+1)>>1)+r-1]}set(e,t,n){let{index:r}=e,{index:i}=t;if(i>r){const e=i;i=r,r=e}this.matrix[(r*(r+1)>>1)+i-1]=n?1:0}reset(){for(let e=0,t=this.matrix.length;e!==t;e++)this.matrix[e]=0}setNumObjects(e){this.matrix.length=e*(e-1)>>1}}class f{addEventListener(e,t){void 0===this._listeners&&(this._listeners={});const n=this._listeners;return void 0===n[e]&&(n[e]=[]),n[e].includes(t)||n[e].push(t),this}hasEventListener(e,t){if(void 0===this._listeners)return!1;const n=this._listeners;return!(void 0===n[e]||!n[e].includes(t))}hasAnyEventListener(e){return void 0!==this._listeners&&void 0!==this._listeners[e]}removeEventListener(e,t){if(void 0===this._listeners)return this;const n=this._listeners;if(void 0===n[e])return this;const r=n[e].indexOf(t);return-1!==r&&n[e].splice(r,1),this}dispatchEvent(e){if(void 0===this._listeners)return this;const t=this._listeners[e.type];if(void 0!==t){e.target=this;for(let n=0,r=t.length;n<r;n++)t[n].call(this,e)}return this}}class m{constructor(e,t,n,r){void 0===e&&(e=0),void 0===t&&(t=0),void 0===n&&(n=0),void 0===r&&(r=1),this.x=e,this.y=t,this.z=n,this.w=r}set(e,t,n,r){return this.x=e,this.y=t,this.z=n,this.w=r,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(e,t){const n=Math.sin(.5*t);return this.x=e.x*n,this.y=e.y*n,this.z=e.z*n,this.w=Math.cos(.5*t),this}toAxisAngle(e){void 0===e&&(e=new a),this.normalize();const t=2*Math.acos(this.w),n=Math.sqrt(1-this.w*this.w);return n<.001?(e.x=this.x,e.y=this.y,e.z=this.z):(e.x=this.x/n,e.y=this.y/n,e.z=this.z/n),[e,t]}setFromVectors(e,t){if(e.isAntiparallelTo(t)){const t=g,n=y;e.tangents(t,n),this.setFromAxisAngle(t,Math.PI)}else{const n=e.cross(t);this.x=n.x,this.y=n.y,this.z=n.z,this.w=Math.sqrt(e.length()**2*t.length()**2)+e.dot(t),this.normalize()}return this}mult(e,t){void 0===t&&(t=new m);const n=this.x,r=this.y,i=this.z,s=this.w,a=e.x,o=e.y,l=e.z,c=e.w;return t.x=n*c+s*a+r*l-i*o,t.y=r*c+s*o+i*a-n*l,t.z=i*c+s*l+n*o-r*a,t.w=s*c-n*a-r*o-i*l,t}inverse(e){void 0===e&&(e=new m);const t=this.x,n=this.y,r=this.z,i=this.w;this.conjugate(e);const s=1/(t*t+n*n+r*r+i*i);return e.x*=s,e.y*=s,e.z*=s,e.w*=s,e}conjugate(e){return void 0===e&&(e=new m),e.x=-this.x,e.y=-this.y,e.z=-this.z,e.w=this.w,e}normalize(){let e=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(e=1/e,this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}normalizeFast(){const e=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}vmult(e,t){void 0===t&&(t=new a);const n=e.x,r=e.y,i=e.z,s=this.x,o=this.y,l=this.z,c=this.w,u=c*n+o*i-l*r,h=c*r+l*n-s*i,d=c*i+s*r-o*n,p=-s*n-o*r-l*i;return t.x=u*c+p*-s+h*-l-d*-o,t.y=h*c+p*-o+d*-s-u*-l,t.z=d*c+p*-l+u*-o-h*-s,t}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}toEuler(e,t){let n,r,i;void 0===t&&(t="YZX");const s=this.x,a=this.y,o=this.z,l=this.w;if("YZX"!==t)throw new Error(`Euler order ${t} not supported yet.`);{const e=s*a+o*l;if(e>.499&&(n=2*Math.atan2(s,l),r=Math.PI/2,i=0),e<-.499&&(n=-2*Math.atan2(s,l),r=-Math.PI/2,i=0),void 0===n){const t=s*s,c=a*a,u=o*o;n=Math.atan2(2*a*l-2*s*o,1-2*c-2*u),r=Math.asin(2*e),i=Math.atan2(2*s*l-2*a*o,1-2*t-2*u)}}e.y=n,e.z=r,e.x=i}setFromEuler(e,t,n,r){void 0===r&&(r="XYZ");const i=Math.cos(e/2),s=Math.cos(t/2),a=Math.cos(n/2),o=Math.sin(e/2),l=Math.sin(t/2),c=Math.sin(n/2);return"XYZ"===r?(this.x=o*s*a+i*l*c,this.y=i*l*a-o*s*c,this.z=i*s*c+o*l*a,this.w=i*s*a-o*l*c):"YXZ"===r?(this.x=o*s*a+i*l*c,this.y=i*l*a-o*s*c,this.z=i*s*c-o*l*a,this.w=i*s*a+o*l*c):"ZXY"===r?(this.x=o*s*a-i*l*c,this.y=i*l*a+o*s*c,this.z=i*s*c+o*l*a,this.w=i*s*a-o*l*c):"ZYX"===r?(this.x=o*s*a-i*l*c,this.y=i*l*a+o*s*c,this.z=i*s*c-o*l*a,this.w=i*s*a+o*l*c):"YZX"===r?(this.x=o*s*a+i*l*c,this.y=i*l*a+o*s*c,this.z=i*s*c-o*l*a,this.w=i*s*a-o*l*c):"XZY"===r&&(this.x=o*s*a-i*l*c,this.y=i*l*a-o*s*c,this.z=i*s*c+o*l*a,this.w=i*s*a+o*l*c),this}clone(){return new m(this.x,this.y,this.z,this.w)}slerp(e,t,n){void 0===n&&(n=new m);const r=this.x,i=this.y,s=this.z,a=this.w;let o,l,c,u,h,d=e.x,p=e.y,f=e.z,g=e.w;return l=r*d+i*p+s*f+a*g,l<0&&(l=-l,d=-d,p=-p,f=-f,g=-g),1-l>1e-6?(o=Math.acos(l),c=Math.sin(o),u=Math.sin((1-t)*o)/c,h=Math.sin(t*o)/c):(u=1-t,h=t),n.x=u*r+h*d,n.y=u*i+h*p,n.z=u*s+h*f,n.w=u*a+h*g,n}integrate(e,t,n,r){void 0===r&&(r=new m);const i=e.x*n.x,s=e.y*n.y,a=e.z*n.z,o=this.x,l=this.y,c=this.z,u=this.w,h=.5*t;return r.x+=h*(i*u+s*c-a*l),r.y+=h*(s*u+a*o-i*c),r.z+=h*(a*u+i*l-s*o),r.w+=h*(-i*o-s*l-a*c),r}}const g=new a,y=new a,v={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class x{constructor(e){void 0===e&&(e={}),this.id=x.idCounter++,this.type=e.type||0,this.boundingSphereRadius=0,this.collisionResponse=!e.collisionResponse||e.collisionResponse,this.collisionFilterGroup=void 0!==e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask=void 0!==e.collisionFilterMask?e.collisionFilterMask:-1,this.material=e.material?e.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(e,t){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(e,t,n,r){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}x.idCounter=0,x.types=v;class b{constructor(e){void 0===e&&(e={}),this.position=new a,this.quaternion=new m,e.position&&this.position.copy(e.position),e.quaternion&&this.quaternion.copy(e.quaternion)}pointToLocal(e,t){return b.pointToLocalFrame(this.position,this.quaternion,e,t)}pointToWorld(e,t){return b.pointToWorldFrame(this.position,this.quaternion,e,t)}vectorToWorldFrame(e,t){return void 0===t&&(t=new a),this.quaternion.vmult(e,t),t}static pointToLocalFrame(e,t,n,r){return void 0===r&&(r=new a),n.vsub(e,r),t.conjugate(w),w.vmult(r,r),r}static pointToWorldFrame(e,t,n,r){return void 0===r&&(r=new a),t.vmult(n,r),r.vadd(e,r),r}static vectorToWorldFrame(e,t,n){return void 0===n&&(n=new a),e.vmult(t,n),n}static vectorToLocalFrame(e,t,n,r){return void 0===r&&(r=new a),t.w*=-1,t.vmult(n,r),t.w*=-1,r}}const w=new m;class _ extends x{constructor(e){void 0===e&&(e={});const{vertices:t=[],faces:n=[],normals:r=[],axes:i,boundingSphereRadius:s}=e;super({type:x.types.CONVEXPOLYHEDRON}),this.vertices=t,this.faces=n,this.faceNormals=r,0===this.faceNormals.length&&this.computeNormals(),s?this.boundingSphereRadius=s:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=i?i.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const e=this.faces,t=this.vertices,n=this.uniqueEdges;n.length=0;const r=new a;for(let i=0;i!==e.length;i++){const s=e[i],a=s.length;for(let e=0;e!==a;e++){const i=(e+1)%a;t[s[e]].vsub(t[s[i]],r),r.normalize();let o=!1;for(let e=0;e!==n.length;e++)if(n[e].almostEquals(r)||n[e].almostEquals(r)){o=!0;break}o||n.push(r.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let e=0;e<this.faces.length;e++){for(let t=0;t<this.faces[e].length;t++)if(!this.vertices[this.faces[e][t]])throw new Error(`Vertex ${this.faces[e][t]} not found!`);const t=this.faceNormals[e]||new a;this.getFaceNormal(e,t),t.negate(t),this.faceNormals[e]=t;const n=this.vertices[this.faces[e][0]];if(t.dot(n)<0){console.error(`.faceNormals[${e}] = Vec3(${t.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let t=0;t<this.faces[e].length;t++)console.warn(`.vertices[${this.faces[e][t]}] = Vec3(${this.vertices[this.faces[e][t]].toString()})`)}}}getFaceNormal(e,t){const n=this.faces[e],r=this.vertices[n[0]],i=this.vertices[n[1]],s=this.vertices[n[2]];_.computeNormal(r,i,s,t)}static computeNormal(e,t,n,r){const i=new a,s=new a;t.vsub(e,s),n.vsub(t,i),i.cross(s,r),r.isZero()||r.normalize()}clipAgainstHull(e,t,n,r,i,s,o,l,c){const u=new a;let h=-1,d=-Number.MAX_VALUE;for(let e=0;e<n.faces.length;e++){u.copy(n.faceNormals[e]),i.vmult(u,u);const t=u.dot(s);t>d&&(d=t,h=e)}const p=[];for(let e=0;e<n.faces[h].length;e++){const t=n.vertices[n.faces[h][e]],s=new a;s.copy(t),i.vmult(s,s),r.vadd(s,s),p.push(s)}h>=0&&this.clipFaceAgainstHull(s,e,t,p,o,l,c)}findSeparatingAxis(e,t,n,r,i,s,o,l){const c=new a,u=new a,h=new a,d=new a,p=new a,f=new a;let m=Number.MAX_VALUE;const g=this;if(g.uniqueAxes)for(let a=0;a!==g.uniqueAxes.length;a++){n.vmult(g.uniqueAxes[a],c);const o=g.testSepAxis(c,e,t,n,r,i);if(!1===o)return!1;o<m&&(m=o,s.copy(c))}else{const a=o?o.length:g.faces.length;for(let l=0;l<a;l++){const a=o?o[l]:l;c.copy(g.faceNormals[a]),n.vmult(c,c);const u=g.testSepAxis(c,e,t,n,r,i);if(!1===u)return!1;u<m&&(m=u,s.copy(c))}}if(e.uniqueAxes)for(let a=0;a!==e.uniqueAxes.length;a++){i.vmult(e.uniqueAxes[a],u);const o=g.testSepAxis(u,e,t,n,r,i);if(!1===o)return!1;o<m&&(m=o,s.copy(u))}else{const a=l?l.length:e.faces.length;for(let o=0;o<a;o++){const a=l?l[o]:o;u.copy(e.faceNormals[a]),i.vmult(u,u);const c=g.testSepAxis(u,e,t,n,r,i);if(!1===c)return!1;c<m&&(m=c,s.copy(u))}}for(let a=0;a!==g.uniqueEdges.length;a++){n.vmult(g.uniqueEdges[a],d);for(let a=0;a!==e.uniqueEdges.length;a++)if(i.vmult(e.uniqueEdges[a],p),d.cross(p,f),!f.almostZero()){f.normalize();const a=g.testSepAxis(f,e,t,n,r,i);if(!1===a)return!1;a<m&&(m=a,s.copy(f))}}return r.vsub(t,h),h.dot(s)>0&&s.negate(s),!0}testSepAxis(e,t,n,r,i,s){_.project(this,e,n,r,S),_.project(t,e,i,s,M);const a=S[0],o=S[1],l=M[0],c=M[1];if(a<c||l<o)return!1;const u=a-c,h=l-o;return u<h?u:h}calculateLocalInertia(e,t){const n=new a,r=new a;this.computeLocalAABB(r,n);const i=n.x-r.x,s=n.y-r.y,o=n.z-r.z;t.x=1/12*e*(2*s*2*s+2*o*2*o),t.y=1/12*e*(2*i*2*i+2*o*2*o),t.z=1/12*e*(2*s*2*s+2*i*2*i)}getPlaneConstantOfFace(e){const t=this.faces[e],n=this.faceNormals[e],r=this.vertices[t[0]];return-n.dot(r)}clipFaceAgainstHull(e,t,n,r,i,s,o){const l=new a,c=new a,u=new a,h=new a,d=new a,p=new a,f=new a,m=new a,g=this,y=r,v=[];let x=-1,b=Number.MAX_VALUE;for(let t=0;t<g.faces.length;t++){l.copy(g.faceNormals[t]),n.vmult(l,l);const r=l.dot(e);r<b&&(b=r,x=t)}if(x<0)return;const w=g.faces[x];w.connectedFaces=[];for(let e=0;e<g.faces.length;e++)for(let t=0;t<g.faces[e].length;t++)-1!==w.indexOf(g.faces[e][t])&&e!==x&&-1===w.connectedFaces.indexOf(e)&&w.connectedFaces.push(e);const _=w.length;for(let e=0;e<_;e++){const r=g.vertices[w[e]],i=g.vertices[w[(e+1)%_]];r.vsub(i,c),u.copy(c),n.vmult(u,u),t.vadd(u,u),h.copy(this.faceNormals[x]),n.vmult(h,h),t.vadd(h,h),u.cross(h,d),d.negate(d),p.copy(r),n.vmult(p,p),t.vadd(p,p);const s=w.connectedFaces[e];f.copy(this.faceNormals[s]);const a=this.getPlaneConstantOfFace(s);m.copy(f),n.vmult(m,m);const o=a-m.dot(t);for(this.clipFaceAgainstPlane(y,v,m,o);y.length;)y.shift();for(;v.length;)y.push(v.shift())}f.copy(this.faceNormals[x]);const S=this.getPlaneConstantOfFace(x);m.copy(f),n.vmult(m,m);const M=S-m.dot(t);for(let e=0;e<y.length;e++){let t=m.dot(y[e])+M;if(t<=i&&(console.log(`clamped: depth=${t} to minDist=${i}`),t=i),t<=s){const n=y[e];if(t<=1e-6){const e={point:n,normal:m,depth:t};o.push(e)}}}}clipFaceAgainstPlane(e,t,n,r){let i,s;const o=e.length;if(o<2)return t;let l=e[e.length-1],c=e[0];i=n.dot(l)+r;for(let u=0;u<o;u++){if(c=e[u],s=n.dot(c)+r,i<0)if(s<0){const e=new a;e.copy(c),t.push(e)}else{const e=new a;l.lerp(c,i/(i-s),e),t.push(e)}else if(s<0){const e=new a;l.lerp(c,i/(i-s),e),t.push(e),t.push(c)}l=c,i=s}return t}computeWorldVertices(e,t){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new a);const n=this.vertices,r=this.worldVertices;for(let i=0;i!==this.vertices.length;i++)t.vmult(n[i],r[i]),e.vadd(r[i],r[i]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(e,t){const n=this.vertices;e.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),t.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let r=0;r<this.vertices.length;r++){const i=n[r];i.x<e.x?e.x=i.x:i.x>t.x&&(t.x=i.x),i.y<e.y?e.y=i.y:i.y>t.y&&(t.y=i.y),i.z<e.z?e.z=i.z:i.z>t.z&&(t.z=i.z)}}computeWorldFaceNormals(e){const t=this.faceNormals.length;for(;this.worldFaceNormals.length<t;)this.worldFaceNormals.push(new a);const n=this.faceNormals,r=this.worldFaceNormals;for(let i=0;i!==t;i++)e.vmult(n[i],r[i]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let e=0;const t=this.vertices;for(let n=0;n!==t.length;n++){const r=t[n].lengthSquared();r>e&&(e=r)}this.boundingSphereRadius=Math.sqrt(e)}calculateWorldAABB(e,t,n,r){const i=this.vertices;let s,o,l,c,u,h,d=new a;for(let n=0;n<i.length;n++){d.copy(i[n]),t.vmult(d,d),e.vadd(d,d);const r=d;(void 0===s||r.x<s)&&(s=r.x),(void 0===c||r.x>c)&&(c=r.x),(void 0===o||r.y<o)&&(o=r.y),(void 0===u||r.y>u)&&(u=r.y),(void 0===l||r.z<l)&&(l=r.z),(void 0===h||r.z>h)&&(h=r.z)}n.set(s,o,l),r.set(c,u,h)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(e){void 0===e&&(e=new a);const t=this.vertices;for(let n=0;n<t.length;n++)e.vadd(t[n],e);return e.scale(1/t.length,e),e}transformAllPoints(e,t){const n=this.vertices.length,r=this.vertices;if(t){for(let e=0;e<n;e++){const n=r[e];t.vmult(n,n)}for(let e=0;e<this.faceNormals.length;e++){const n=this.faceNormals[e];t.vmult(n,n)}}if(e)for(let t=0;t<n;t++){const n=r[t];n.vadd(e,n)}}pointIsInside(e){const t=this.vertices,n=this.faces,r=this.faceNormals,i=new a;this.getAveragePointLocal(i);for(let s=0;s<this.faces.length;s++){let o=r[s];const l=t[n[s][0]],c=new a;e.vsub(l,c);const u=o.dot(c),h=new a;i.vsub(l,h);const d=o.dot(h);if(u<0&&d>0||u>0&&d<0)return!1}return-1}static project(e,t,n,r,i){const s=e.vertices.length,a=T;let o=0,l=0;const c=E,u=e.vertices;c.setZero(),b.vectorToLocalFrame(n,r,t,a),b.pointToLocalFrame(n,r,c,c);const h=c.dot(a);l=o=u[0].dot(a);for(let e=1;e<s;e++){const t=u[e].dot(a);t>o&&(o=t),t<l&&(l=t)}if(l-=h,o-=h,l>o){const e=l;l=o,o=e}i[0]=o,i[1]=l}}const S=[],M=[],T=(new a,new a),E=new a;class A extends x{constructor(e){super({type:x.types.BOX}),this.halfExtents=e,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const e=this.halfExtents.x,t=this.halfExtents.y,n=this.halfExtents.z,r=a,i=[new r(-e,-t,-n),new r(e,-t,-n),new r(e,t,-n),new r(-e,t,-n),new r(-e,-t,n),new r(e,-t,n),new r(e,t,n),new r(-e,t,n)],s=[new r(0,0,1),new r(0,1,0),new r(1,0,0)],o=new _({vertices:i,faces:[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],axes:s});this.convexPolyhedronRepresentation=o,o.material=this.material}calculateLocalInertia(e,t){return void 0===t&&(t=new a),A.calculateInertia(this.halfExtents,e,t),t}static calculateInertia(e,t,n){const r=e;n.x=1/12*t*(2*r.y*2*r.y+2*r.z*2*r.z),n.y=1/12*t*(2*r.x*2*r.x+2*r.z*2*r.z),n.z=1/12*t*(2*r.y*2*r.y+2*r.x*2*r.x)}getSideNormals(e,t){const n=e,r=this.halfExtents;if(n[0].set(r.x,0,0),n[1].set(0,r.y,0),n[2].set(0,0,r.z),n[3].set(-r.x,0,0),n[4].set(0,-r.y,0),n[5].set(0,0,-r.z),void 0!==t)for(let e=0;e!==n.length;e++)t.vmult(n[e],n[e]);return n}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(e,t,n){const r=this.halfExtents,i=[[r.x,r.y,r.z],[-r.x,r.y,r.z],[-r.x,-r.y,r.z],[-r.x,-r.y,-r.z],[r.x,-r.y,-r.z],[r.x,r.y,-r.z],[-r.x,r.y,-r.z],[r.x,-r.y,r.z]];for(let r=0;r<i.length;r++)C.set(i[r][0],i[r][1],i[r][2]),t.vmult(C,C),e.vadd(C,C),n(C.x,C.y,C.z)}calculateWorldAABB(e,t,n,r){const i=this.halfExtents;I[0].set(i.x,i.y,i.z),I[1].set(-i.x,i.y,i.z),I[2].set(-i.x,-i.y,i.z),I[3].set(-i.x,-i.y,-i.z),I[4].set(i.x,-i.y,-i.z),I[5].set(i.x,i.y,-i.z),I[6].set(-i.x,i.y,-i.z),I[7].set(i.x,-i.y,i.z);const s=I[0];t.vmult(s,s),e.vadd(s,s),r.copy(s),n.copy(s);for(let i=1;i<8;i++){const s=I[i];t.vmult(s,s),e.vadd(s,s);const a=s.x,o=s.y,l=s.z;a>r.x&&(r.x=a),o>r.y&&(r.y=o),l>r.z&&(r.z=l),a<n.x&&(n.x=a),o<n.y&&(n.y=o),l<n.z&&(n.z=l)}}}const C=new a,I=[new a,new a,new a,new a,new a,new a,new a,new a],N={DYNAMIC:1,STATIC:2,KINEMATIC:4},k={AWAKE:0,SLEEPY:1,SLEEPING:2};class R extends f{constructor(e){void 0===e&&(e={}),super(),this.id=R.idCounter++,this.index=-1,this.world=null,this.vlambda=new a,this.collisionFilterGroup="number"==typeof e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask="number"==typeof e.collisionFilterMask?e.collisionFilterMask:-1,this.collisionResponse="boolean"!=typeof e.collisionResponse||e.collisionResponse,this.position=new a,this.previousPosition=new a,this.interpolatedPosition=new a,this.initPosition=new a,e.position&&(this.position.copy(e.position),this.previousPosition.copy(e.position),this.interpolatedPosition.copy(e.position),this.initPosition.copy(e.position)),this.velocity=new a,e.velocity&&this.velocity.copy(e.velocity),this.initVelocity=new a,this.force=new a;const t="number"==typeof e.mass?e.mass:0;this.mass=t,this.invMass=t>0?1/t:0,this.material=e.material||null,this.linearDamping="number"==typeof e.linearDamping?e.linearDamping:.01,this.type=t<=0?R.STATIC:R.DYNAMIC,typeof e.type==typeof R.STATIC&&(this.type=e.type),this.allowSleep=void 0===e.allowSleep||e.allowSleep,this.sleepState=R.AWAKE,this.sleepSpeedLimit=void 0!==e.sleepSpeedLimit?e.sleepSpeedLimit:.1,this.sleepTimeLimit=void 0!==e.sleepTimeLimit?e.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new a,this.quaternion=new m,this.initQuaternion=new m,this.previousQuaternion=new m,this.interpolatedQuaternion=new m,e.quaternion&&(this.quaternion.copy(e.quaternion),this.initQuaternion.copy(e.quaternion),this.previousQuaternion.copy(e.quaternion),this.interpolatedQuaternion.copy(e.quaternion)),this.angularVelocity=new a,e.angularVelocity&&this.angularVelocity.copy(e.angularVelocity),this.initAngularVelocity=new a,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new a,this.invInertia=new a,this.invInertiaWorld=new i,this.invMassSolve=0,this.invInertiaSolve=new a,this.invInertiaWorldSolve=new i,this.fixedRotation=void 0!==e.fixedRotation&&e.fixedRotation,this.angularDamping=void 0!==e.angularDamping?e.angularDamping:.01,this.linearFactor=new a(1,1,1),e.linearFactor&&this.linearFactor.copy(e.linearFactor),this.angularFactor=new a(1,1,1),e.angularFactor&&this.angularFactor.copy(e.angularFactor),this.aabb=new u,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new a,this.isTrigger=Boolean(e.isTrigger),e.shape&&this.addShape(e.shape),this.updateMassProperties()}wakeUp(){const e=this.sleepState;this.sleepState=R.AWAKE,this.wakeUpAfterNarrowphase=!1,e===R.SLEEPING&&this.dispatchEvent(R.wakeupEvent)}sleep(){this.sleepState=R.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(e){if(this.allowSleep){const t=this.sleepState,n=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),r=this.sleepSpeedLimit**2;t===R.AWAKE&&n<r?(this.sleepState=R.SLEEPY,this.timeLastSleepy=e,this.dispatchEvent(R.sleepyEvent)):t===R.SLEEPY&&n>r?this.wakeUp():t===R.SLEEPY&&e-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(R.sleepEvent))}}updateSolveMassProperties(){this.sleepState===R.SLEEPING||this.type===R.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(e,t){return void 0===t&&(t=new a),e.vsub(this.position,t),this.quaternion.conjugate().vmult(t,t),t}vectorToLocalFrame(e,t){return void 0===t&&(t=new a),this.quaternion.conjugate().vmult(e,t),t}pointToWorldFrame(e,t){return void 0===t&&(t=new a),this.quaternion.vmult(e,t),t.vadd(this.position,t),t}vectorToWorldFrame(e,t){return void 0===t&&(t=new a),this.quaternion.vmult(e,t),t}addShape(e,t,n){const r=new a,i=new m;return t&&r.copy(t),n&&i.copy(n),this.shapes.push(e),this.shapeOffsets.push(r),this.shapeOrientations.push(i),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=this,this}removeShape(e){const t=this.shapes.indexOf(e);return-1===t?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(t,1),this.shapeOffsets.splice(t,1),this.shapeOrientations.splice(t,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=null,this)}updateBoundingRadius(){const e=this.shapes,t=this.shapeOffsets,n=e.length;let r=0;for(let i=0;i!==n;i++){const n=e[i];n.updateBoundingSphereRadius();const s=t[i].length(),a=n.boundingSphereRadius;s+a>r&&(r=s+a)}this.boundingRadius=r}updateAABB(){const e=this.shapes,t=this.shapeOffsets,n=this.shapeOrientations,r=e.length,i=D,s=L,a=this.quaternion,o=this.aabb,l=F;for(let c=0;c!==r;c++){const r=e[c];a.vmult(t[c],i),i.vadd(this.position,i),a.mult(n[c],s),r.calculateWorldAABB(i,s,l.lowerBound,l.upperBound),0===c?o.copy(l):o.extend(l)}this.aabbNeedsUpdate=!1}updateInertiaWorld(e){const t=this.invInertia;if(t.x!==t.y||t.y!==t.z||e){const e=P,n=O;e.setRotationFromQuaternion(this.quaternion),e.transpose(n),e.scale(t,e),e.mmult(n,this.invInertiaWorld)}}applyForce(e,t){if(void 0===t&&(t=new a),this.type!==R.DYNAMIC)return;this.sleepState===R.SLEEPING&&this.wakeUp();const n=z;t.cross(e,n),this.force.vadd(e,this.force),this.torque.vadd(n,this.torque)}applyLocalForce(e,t){if(void 0===t&&(t=new a),this.type!==R.DYNAMIC)return;const n=B,r=U;this.vectorToWorldFrame(e,n),this.vectorToWorldFrame(t,r),this.applyForce(n,r)}applyTorque(e){this.type===R.DYNAMIC&&(this.sleepState===R.SLEEPING&&this.wakeUp(),this.torque.vadd(e,this.torque))}applyImpulse(e,t){if(void 0===t&&(t=new a),this.type!==R.DYNAMIC)return;this.sleepState===R.SLEEPING&&this.wakeUp();const n=t,r=$;r.copy(e),r.scale(this.invMass,r),this.velocity.vadd(r,this.velocity);const i=V;n.cross(e,i),this.invInertiaWorld.vmult(i,i),this.angularVelocity.vadd(i,this.angularVelocity)}applyLocalImpulse(e,t){if(void 0===t&&(t=new a),this.type!==R.DYNAMIC)return;const n=W,r=G;this.vectorToWorldFrame(e,n),this.vectorToWorldFrame(t,r),this.applyImpulse(n,r)}updateMassProperties(){const e=H;this.invMass=this.mass>0?1/this.mass:0;const t=this.inertia,n=this.fixedRotation;this.updateAABB(),e.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),A.calculateInertia(e,this.mass,t),this.invInertia.set(t.x>0&&!n?1/t.x:0,t.y>0&&!n?1/t.y:0,t.z>0&&!n?1/t.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(e,t){const n=new a;return e.vsub(this.position,n),this.angularVelocity.cross(n,t),this.velocity.vadd(t,t),t}integrate(e,t,n){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),this.type!==R.DYNAMIC&&this.type!==R.KINEMATIC||this.sleepState===R.SLEEPING)return;const r=this.velocity,i=this.angularVelocity,s=this.position,a=this.force,o=this.torque,l=this.quaternion,c=this.invMass,u=this.invInertiaWorld,h=this.linearFactor,d=c*e;r.x+=a.x*d*h.x,r.y+=a.y*d*h.y,r.z+=a.z*d*h.z;const p=u.elements,f=this.angularFactor,m=o.x*f.x,g=o.y*f.y,y=o.z*f.z;i.x+=e*(p[0]*m+p[1]*g+p[2]*y),i.y+=e*(p[3]*m+p[4]*g+p[5]*y),i.z+=e*(p[6]*m+p[7]*g+p[8]*y),s.x+=r.x*e,s.y+=r.y*e,s.z+=r.z*e,l.integrate(this.angularVelocity,e,this.angularFactor,l),t&&(n?l.normalizeFast():l.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}R.idCounter=0,R.COLLIDE_EVENT_NAME="collide",R.DYNAMIC=N.DYNAMIC,R.STATIC=N.STATIC,R.KINEMATIC=N.KINEMATIC,R.AWAKE=k.AWAKE,R.SLEEPY=k.SLEEPY,R.SLEEPING=k.SLEEPING,R.wakeupEvent={type:"wakeup"},R.sleepyEvent={type:"sleepy"},R.sleepEvent={type:"sleep"};const D=new a,L=new m,F=new u,P=new i,O=new i,z=(new i,new a),B=new a,U=new a,$=new a,V=new a,W=new a,G=new a,H=new a;class j{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(e,t,n){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(e,t){return 0!=(e.collisionFilterGroup&t.collisionFilterMask)&&0!=(t.collisionFilterGroup&e.collisionFilterMask)&&(0==(e.type&R.STATIC)&&e.sleepState!==R.SLEEPING||0==(t.type&R.STATIC)&&t.sleepState!==R.SLEEPING)}intersectionTest(e,t,n,r){this.useBoundingBoxes?this.doBoundingBoxBroadphase(e,t,n,r):this.doBoundingSphereBroadphase(e,t,n,r)}doBoundingSphereBroadphase(e,t,n,r){const i=q;t.position.vsub(e.position,i);const s=(e.boundingRadius+t.boundingRadius)**2;i.lengthSquared()<s&&(n.push(e),r.push(t))}doBoundingBoxBroadphase(e,t,n,r){e.aabbNeedsUpdate&&e.updateAABB(),t.aabbNeedsUpdate&&t.updateAABB(),e.aabb.overlaps(t.aabb)&&(n.push(e),r.push(t))}makePairsUnique(e,t){const n=X,r=Y,i=K,s=e.length;for(let n=0;n!==s;n++)r[n]=e[n],i[n]=t[n];e.length=0,t.length=0;for(let e=0;e!==s;e++){const t=r[e].id,s=i[e].id,a=t<s?`${t},${s}`:`${s},${t}`;n[a]=e,n.keys.push(a)}for(let s=0;s!==n.keys.length;s++){const s=n.keys.pop(),a=n[s];e.push(r[a]),t.push(i[a]),delete n[s]}}setWorld(e){}static boundingSphereCheck(e,t){const n=new a;e.position.vsub(t.position,n);const r=e.shapes[0],i=t.shapes[0];return Math.pow(r.boundingSphereRadius+i.boundingSphereRadius,2)>n.lengthSquared()}aabbQuery(e,t,n){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const q=new a;new a,new m,new a;const X={keys:[]},Y=[],K=[];new a;class Z extends j{constructor(e,t,n,r,i){void 0===e&&(e=new a(100,100,100)),void 0===t&&(t=new a(-100,-100,-100)),void 0===n&&(n=10),void 0===r&&(r=10),void 0===i&&(i=10),super(),this.nx=n,this.ny=r,this.nz=i,this.aabbMin=e,this.aabbMax=t;const s=this.nx*this.ny*this.nz;if(s<=0)throw"GridBroadphase: Each dimension's n must be >0";this.bins=[],this.binLengths=[],this.bins.length=s,this.binLengths.length=s;for(let e=0;e<s;e++)this.bins[e]=[],this.binLengths[e]=0}collisionPairs(e,t,n){const r=e.bodies.length,i=e.bodies,s=this.aabbMax,a=this.aabbMin,o=this.nx,l=this.ny,c=this.nz,u=l*c,h=c,d=s.x,p=s.y,f=s.z,m=a.x,g=a.y,y=a.z,v=o/(d-m),b=l/(p-g),w=c/(f-y),_=(d-m)/o,S=(p-g)/l,M=(f-y)/c,T=.5*Math.sqrt(_*_+S*S+M*M),E=x.types,A=E.SPHERE,C=E.PLANE;E.BOX,E.COMPOUND,E.CONVEXPOLYHEDRON;const I=this.bins,N=this.binLengths,k=this.bins.length;for(let e=0;e!==k;e++)N[e]=0;const R=Math.ceil;function D(e,t,n,r,i,s,a){let d=(e-m)*v|0,p=(t-g)*b|0,f=(n-y)*w|0,x=R((r-m)*v),_=R((i-g)*b),S=R((s-y)*w);d<0?d=0:d>=o&&(d=o-1),p<0?p=0:p>=l&&(p=l-1),f<0?f=0:f>=c&&(f=c-1),x<0?x=0:x>=o&&(x=o-1),_<0?_=0:_>=l&&(_=l-1),S<0?S=0:S>=c&&(S=c-1),d*=u,p*=h,f*=1,x*=u,_*=h,S*=1;for(let e=d;e<=x;e+=u)for(let t=p;t<=_;t+=h)for(let n=f;n<=S;n+=1){const r=e+t+n;I[r][N[r]++]=a}}for(let e=0;e!==r;e++){const t=i[e],n=t.shapes[0];switch(n.type){case A:{const e=n,r=t.position.x,i=t.position.y,s=t.position.z,a=e.radius;D(r-a,i-a,s-a,r+a,i+a,s+a,t);break}case C:{const e=n;e.worldNormalNeedsUpdate&&e.computeWorldNormal(t.quaternion);const r=e.worldNormal,i=m+.5*_-t.position.x,s=g+.5*S-t.position.y,a=y+.5*M-t.position.z,d=J;d.set(i,s,a);for(let e=0,n=0;e!==o;e++,n+=u,d.y=s,d.x+=_)for(let e=0,i=0;e!==l;e++,i+=h,d.z=a,d.y+=S)for(let e=0,s=0;e!==c;e++,s+=1,d.z+=M)if(d.dot(r)<T){const e=n+i+s;I[e][N[e]++]=t}break}default:t.aabbNeedsUpdate&&t.updateAABB(),D(t.aabb.lowerBound.x,t.aabb.lowerBound.y,t.aabb.lowerBound.z,t.aabb.upperBound.x,t.aabb.upperBound.y,t.aabb.upperBound.z,t)}}for(let e=0;e!==k;e++){const r=N[e];if(r>1){const i=I[e];for(let e=0;e!==r;e++){const r=i[e];for(let s=0;s!==e;s++){const e=i[s];this.needBroadphaseCollision(r,e)&&this.intersectionTest(r,e,t,n)}}}}this.makePairsUnique(t,n)}}const J=new a;new a;class Q extends j{constructor(){super()}collisionPairs(e,t,n){const r=e.bodies,i=r.length;let s,a;for(let e=0;e!==i;e++)for(let i=0;i!==e;i++)s=r[e],a=r[i],this.needBroadphaseCollision(s,a)&&this.intersectionTest(s,a,t,n)}aabbQuery(e,t,n){void 0===n&&(n=[]);for(let r=0;r<e.bodies.length;r++){const i=e.bodies[r];i.aabbNeedsUpdate&&i.updateAABB(),i.aabb.overlaps(t)&&n.push(i)}return n}}class ee{constructor(){this.rayFromWorld=new a,this.rayToWorld=new a,this.hitNormalWorld=new a,this.hitPointWorld=new a,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(e,t,n,r,i,s,a){this.rayFromWorld.copy(e),this.rayToWorld.copy(t),this.hitNormalWorld.copy(n),this.hitPointWorld.copy(r),this.shape=i,this.body=s,this.distance=a}}let te,ne,re,ie,se,ae,oe;const le={CLOSEST:1,ANY:2,ALL:4};te=x.types.SPHERE,ne=x.types.PLANE,re=x.types.BOX,ie=x.types.CYLINDER,se=x.types.CONVEXPOLYHEDRON,ae=x.types.HEIGHTFIELD,oe=x.types.TRIMESH;class ce{get[te](){return this._intersectSphere}get[ne](){return this._intersectPlane}get[re](){return this._intersectBox}get[ie](){return this._intersectConvex}get[se](){return this._intersectConvex}get[ae](){return this._intersectHeightfield}get[oe](){return this._intersectTrimesh}constructor(e,t){void 0===e&&(e=new a),void 0===t&&(t=new a),this.from=e.clone(),this.to=t.clone(),this.direction=new a,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=ce.ANY,this.result=new ee,this.hasHit=!1,this.callback=e=>{}}intersectWorld(e,t){return this.mode=t.mode||ce.ANY,this.result=t.result||new ee,this.skipBackfaces=!!t.skipBackfaces,this.collisionFilterMask=void 0!==t.collisionFilterMask?t.collisionFilterMask:-1,this.collisionFilterGroup=void 0!==t.collisionFilterGroup?t.collisionFilterGroup:-1,this.checkCollisionResponse=void 0===t.checkCollisionResponse||t.checkCollisionResponse,t.from&&this.from.copy(t.from),t.to&&this.to.copy(t.to),this.callback=t.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(ue),he.length=0,e.broadphase.aabbQuery(e,ue,he),this.intersectBodies(he),this.hasHit}intersectBody(e,t){t&&(this.result=t,this.updateDirection());const n=this.checkCollisionResponse;if(n&&!e.collisionResponse)return;if(0==(this.collisionFilterGroup&e.collisionFilterMask)||0==(e.collisionFilterGroup&this.collisionFilterMask))return;const r=fe,i=me;for(let t=0,s=e.shapes.length;t<s;t++){const s=e.shapes[t];if((!n||s.collisionResponse)&&(e.quaternion.mult(e.shapeOrientations[t],i),e.quaternion.vmult(e.shapeOffsets[t],r),r.vadd(e.position,r),this.intersectShape(s,i,r,e),this.result.shouldStop))break}}intersectBodies(e,t){t&&(this.result=t,this.updateDirection());for(let t=0,n=e.length;!this.result.shouldStop&&t<n;t++)this.intersectBody(e[t])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(e,t,n,r){const i=function(e,t,n){n.vsub(e,Pe);const r=Pe.dot(t);return t.scale(r,Oe),Oe.vadd(e,Oe),n.distanceTo(Oe)}(this.from,this.direction,n);if(i>e.boundingSphereRadius)return;const s=this[e.type];s&&s.call(this,e,t,n,r,e)}_intersectBox(e,t,n,r,i){return this._intersectConvex(e.convexPolyhedronRepresentation,t,n,r,i)}_intersectPlane(e,t,n,r,i){const s=this.from,o=this.to,l=this.direction,c=new a(0,0,1);t.vmult(c,c);const u=new a;s.vsub(n,u);const h=u.dot(c);if(o.vsub(n,u),h*u.dot(c)>0)return;if(s.distanceTo(o)<h)return;const d=c.dot(l);if(Math.abs(d)<this.precision)return;const p=new a,f=new a,m=new a;s.vsub(n,p);const g=-c.dot(p)/d;l.scale(g,f),s.vadd(f,m),this.reportIntersection(c,m,i,r,-1)}getAABB(e){const{lowerBound:t,upperBound:n}=e,r=this.to,i=this.from;t.x=Math.min(r.x,i.x),t.y=Math.min(r.y,i.y),t.z=Math.min(r.z,i.z),n.x=Math.max(r.x,i.x),n.y=Math.max(r.y,i.y),n.z=Math.max(r.z,i.z)}_intersectHeightfield(e,t,n,r,i){e.data,e.elementSize;const s=_e;s.from.copy(this.from),s.to.copy(this.to),b.pointToLocalFrame(n,t,s.from,s.from),b.pointToLocalFrame(n,t,s.to,s.to),s.updateDirection();const a=Se;let o,l,c,h;o=l=0,c=h=e.data.length-1;const d=new u;s.getAABB(d),e.getIndexOfPosition(d.lowerBound.x,d.lowerBound.y,a,!0),o=Math.max(o,a[0]),l=Math.max(l,a[1]),e.getIndexOfPosition(d.upperBound.x,d.upperBound.y,a,!0),c=Math.min(c,a[0]+1),h=Math.min(h,a[1]+1);for(let a=o;a<c;a++)for(let o=l;o<h;o++){if(this.result.shouldStop)return;if(e.getAabbAtIndex(a,o,d),d.overlapsRay(s)){if(e.getConvexTrianglePillar(a,o,!1),b.pointToWorldFrame(n,t,e.pillarOffset,we),this._intersectConvex(e.pillarConvex,t,we,r,i,be),this.result.shouldStop)return;e.getConvexTrianglePillar(a,o,!0),b.pointToWorldFrame(n,t,e.pillarOffset,we),this._intersectConvex(e.pillarConvex,t,we,r,i,be)}}}_intersectSphere(e,t,n,r,i){const s=this.from,a=this.to,o=e.radius,l=(a.x-s.x)**2+(a.y-s.y)**2+(a.z-s.z)**2,c=2*((a.x-s.x)*(s.x-n.x)+(a.y-s.y)*(s.y-n.y)+(a.z-s.z)*(s.z-n.z)),u=c**2-4*l*((s.x-n.x)**2+(s.y-n.y)**2+(s.z-n.z)**2-o**2),h=Me,d=Te;if(!(u<0))if(0===u)s.lerp(a,u,h),h.vsub(n,d),d.normalize(),this.reportIntersection(d,h,i,r,-1);else{const e=(-c-Math.sqrt(u))/(2*l),t=(-c+Math.sqrt(u))/(2*l);if(e>=0&&e<=1&&(s.lerp(a,e,h),h.vsub(n,d),d.normalize(),this.reportIntersection(d,h,i,r,-1)),this.result.shouldStop)return;t>=0&&t<=1&&(s.lerp(a,t,h),h.vsub(n,d),d.normalize(),this.reportIntersection(d,h,i,r,-1))}}_intersectConvex(e,t,n,r,i,s){const a=Ee,o=Ae,l=s&&s.faceList||null,c=e.faces,u=e.vertices,h=e.faceNormals,d=this.direction,p=this.from,f=this.to,m=p.distanceTo(f),g=l?l.length:c.length,y=this.result;for(let e=0;!y.shouldStop&&e<g;e++){const s=l?l[e]:e,f=c[s],g=h[s],v=t,x=n;o.copy(u[f[0]]),v.vmult(o,o),o.vadd(x,o),o.vsub(p,o),v.vmult(g,a);const b=d.dot(a);if(Math.abs(b)<this.precision)continue;const w=a.dot(o)/b;if(!(w<0)){d.scale(w,ge),ge.vadd(p,ge),ye.copy(u[f[0]]),v.vmult(ye,ye),x.vadd(ye,ye);for(let e=1;!y.shouldStop&&e<f.length-1;e++){ve.copy(u[f[e]]),xe.copy(u[f[e+1]]),v.vmult(ve,ve),v.vmult(xe,xe),x.vadd(ve,ve),x.vadd(xe,xe);const t=ge.distanceTo(p);!ce.pointInTriangle(ge,ye,ve,xe)&&!ce.pointInTriangle(ge,ve,ye,xe)||t>m||this.reportIntersection(a,ge,i,r,s)}}}}_intersectTrimesh(e,t,n,r,i,s){const a=Ce,o=Le,l=Fe,c=Ae,u=Ie,h=Ne,d=ke,p=De,f=Re,m=e.indices;e.vertices;const g=this.from,y=this.to,v=this.direction;l.position.copy(n),l.quaternion.copy(t),b.vectorToLocalFrame(n,t,v,u),b.pointToLocalFrame(n,t,g,h),b.pointToLocalFrame(n,t,y,d),d.x*=e.scale.x,d.y*=e.scale.y,d.z*=e.scale.z,h.x*=e.scale.x,h.y*=e.scale.y,h.z*=e.scale.z,d.vsub(h,u),u.normalize();const x=h.distanceSquared(d);e.tree.rayQuery(this,l,o);for(let s=0,l=o.length;!this.result.shouldStop&&s!==l;s++){const l=o[s];e.getNormal(l,a),e.getVertex(m[3*l],ye),ye.vsub(h,c);const d=u.dot(a),g=a.dot(c)/d;if(g<0)continue;u.scale(g,ge),ge.vadd(h,ge),e.getVertex(m[3*l+1],ve),e.getVertex(m[3*l+2],xe);const y=ge.distanceSquared(h);!ce.pointInTriangle(ge,ve,ye,xe)&&!ce.pointInTriangle(ge,ye,ve,xe)||y>x||(b.vectorToWorldFrame(t,a,f),b.pointToWorldFrame(n,t,ge,p),this.reportIntersection(f,p,i,r,l))}o.length=0}reportIntersection(e,t,n,r,i){const s=this.from,a=this.to,o=s.distanceTo(t),l=this.result;if(!(this.skipBackfaces&&e.dot(this.direction)>0))switch(l.hitFaceIndex=void 0!==i?i:-1,this.mode){case ce.ALL:this.hasHit=!0,l.set(s,a,e,t,n,r,o),l.hasHit=!0,this.callback(l);break;case ce.CLOSEST:(o<l.distance||!l.hasHit)&&(this.hasHit=!0,l.hasHit=!0,l.set(s,a,e,t,n,r,o));break;case ce.ANY:this.hasHit=!0,l.hasHit=!0,l.set(s,a,e,t,n,r,o),l.shouldStop=!0}}static pointInTriangle(e,t,n,r){r.vsub(t,Pe),n.vsub(t,de),e.vsub(t,pe);const i=Pe.dot(Pe),s=Pe.dot(de),a=Pe.dot(pe),o=de.dot(de),l=de.dot(pe);let c,u;return(c=o*a-s*l)>=0&&(u=i*l-s*a)>=0&&c+u<i*o-s*s}}ce.CLOSEST=le.CLOSEST,ce.ANY=le.ANY,ce.ALL=le.ALL;const ue=new u,he=[],de=new a,pe=new a,fe=new a,me=new m,ge=new a,ye=new a,ve=new a,xe=new a;new a,new ee;const be={faceList:[0]},we=new a,_e=new ce,Se=[],Me=new a,Te=new a,Ee=new a,Ae=(new a,new a,new a),Ce=new a,Ie=new a,Ne=new a,ke=new a,Re=new a,De=new a;new u;const Le=[],Fe=new b,Pe=new a,Oe=new a;class ze extends j{static checkBounds(e,t,n){let r,i;0===n?(r=e.position.x,i=t.position.x):1===n?(r=e.position.y,i=t.position.y):2===n&&(r=e.position.z,i=t.position.z);const s=e.boundingRadius;return i-t.boundingRadius<r+s}static insertionSortX(e){for(let t=1,n=e.length;t<n;t++){const n=e[t];let r;for(r=t-1;r>=0&&!(e[r].aabb.lowerBound.x<=n.aabb.lowerBound.x);r--)e[r+1]=e[r];e[r+1]=n}return e}static insertionSortY(e){for(let t=1,n=e.length;t<n;t++){const n=e[t];let r;for(r=t-1;r>=0&&!(e[r].aabb.lowerBound.y<=n.aabb.lowerBound.y);r--)e[r+1]=e[r];e[r+1]=n}return e}static insertionSortZ(e){for(let t=1,n=e.length;t<n;t++){const n=e[t];let r;for(r=t-1;r>=0&&!(e[r].aabb.lowerBound.z<=n.aabb.lowerBound.z);r--)e[r+1]=e[r];e[r+1]=n}return e}constructor(e){super(),this.axisList=[],this.world=null,this.axisIndex=0;const t=this.axisList;this._addBodyHandler=e=>{t.push(e.body)},this._removeBodyHandler=e=>{const n=t.indexOf(e.body);-1!==n&&t.splice(n,1)},e&&this.setWorld(e)}setWorld(e){this.axisList.length=0;for(let t=0;t<e.bodies.length;t++)this.axisList.push(e.bodies[t]);e.removeEventListener("addBody",this._addBodyHandler),e.removeEventListener("removeBody",this._removeBodyHandler),e.addEventListener("addBody",this._addBodyHandler),e.addEventListener("removeBody",this._removeBodyHandler),this.world=e,this.dirty=!0}collisionPairs(e,t,n){const r=this.axisList,i=r.length,s=this.axisIndex;let a,o;for(this.dirty&&(this.sortList(),this.dirty=!1),a=0;a!==i;a++){const e=r[a];for(o=a+1;o<i;o++){const i=r[o];if(this.needBroadphaseCollision(e,i)){if(!ze.checkBounds(e,i,s))break;this.intersectionTest(e,i,t,n)}}}}sortList(){const e=this.axisList,t=this.axisIndex,n=e.length;for(let t=0;t!==n;t++){const n=e[t];n.aabbNeedsUpdate&&n.updateAABB()}0===t?ze.insertionSortX(e):1===t?ze.insertionSortY(e):2===t&&ze.insertionSortZ(e)}autoDetectAxis(){let e=0,t=0,n=0,r=0,i=0,s=0;const a=this.axisList,o=a.length,l=1/o;for(let l=0;l!==o;l++){const o=a[l],c=o.position.x;e+=c,t+=c*c;const u=o.position.y;n+=u,r+=u*u;const h=o.position.z;i+=h,s+=h*h}const c=t-e*e*l,u=r-n*n*l,h=s-i*i*l;this.axisIndex=c>u?c>h?0:2:u>h?1:2}aabbQuery(e,t,n){void 0===n&&(n=[]),this.dirty&&(this.sortList(),this.dirty=!1);const r=this.axisIndex;let i="x";1===r&&(i="y"),2===r&&(i="z");const s=this.axisList;t.lowerBound[i],t.upperBound[i];for(let e=0;e<s.length;e++){const r=s[e];r.aabbNeedsUpdate&&r.updateAABB(),r.aabb.overlaps(t)&&n.push(r)}return n}}class Be{static defaults(e,t){void 0===e&&(e={});for(let n in t)n in e||(e[n]=t[n]);return e}}class Ue{constructor(e,t,n){void 0===n&&(n={}),n=Be.defaults(n,{collideConnected:!0,wakeUpBodies:!0}),this.equations=[],this.bodyA=e,this.bodyB=t,this.id=Ue.idCounter++,this.collideConnected=n.collideConnected,n.wakeUpBodies&&(e&&e.wakeUp(),t&&t.wakeUp())}update(){throw new Error("method update() not implmemented in this Constraint subclass!")}enable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!0}disable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!1}}Ue.idCounter=0;class $e{constructor(){this.spatial=new a,this.rotational=new a}multiplyElement(e){return e.spatial.dot(this.spatial)+e.rotational.dot(this.rotational)}multiplyVectors(e,t){return e.dot(this.spatial)+t.dot(this.rotational)}}class Ve{constructor(e,t,n,r){void 0===n&&(n=-1e6),void 0===r&&(r=1e6),this.id=Ve.idCounter++,this.minForce=n,this.maxForce=r,this.bi=e,this.bj=t,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new $e,this.jacobianElementB=new $e,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(e,t,n){const r=t,i=e,s=n;this.a=4/(s*(1+4*r)),this.b=4*r/(1+4*r),this.eps=4/(s*s*i*(1+4*r))}computeB(e,t,n){const r=this.computeGW();return-this.computeGq()*e-r*t-this.computeGiMf()*n}computeGq(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.position,s=r.position;return e.spatial.dot(i)+t.spatial.dot(s)}computeGW(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.velocity,s=r.velocity,a=n.angularVelocity,o=r.angularVelocity;return e.multiplyVectors(i,a)+t.multiplyVectors(s,o)}computeGWlambda(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.vlambda,s=r.vlambda,a=n.wlambda,o=r.wlambda;return e.multiplyVectors(i,a)+t.multiplyVectors(s,o)}computeGiMf(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.force,s=n.torque,a=r.force,o=r.torque,l=n.invMassSolve,c=r.invMassSolve;return i.scale(l,We),a.scale(c,Ge),n.invInertiaWorldSolve.vmult(s,He),r.invInertiaWorldSolve.vmult(o,je),e.multiplyVectors(We,He)+t.multiplyVectors(Ge,je)}computeGiMGt(){const e=this.jacobianElementA,t=this.jacobianElementB,n=this.bi,r=this.bj,i=n.invMassSolve,s=r.invMassSolve,a=n.invInertiaWorldSolve,o=r.invInertiaWorldSolve;let l=i+s;return a.vmult(e.rotational,qe),l+=qe.dot(e.rotational),o.vmult(t.rotational,qe),l+=qe.dot(t.rotational),l}addToWlambda(e){const t=this.jacobianElementA,n=this.jacobianElementB,r=this.bi,i=this.bj,s=Xe;r.vlambda.addScaledVector(r.invMassSolve*e,t.spatial,r.vlambda),i.vlambda.addScaledVector(i.invMassSolve*e,n.spatial,i.vlambda),r.invInertiaWorldSolve.vmult(t.rotational,s),r.wlambda.addScaledVector(e,s,r.wlambda),i.invInertiaWorldSolve.vmult(n.rotational,s),i.wlambda.addScaledVector(e,s,i.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}Ve.idCounter=0;const We=new a,Ge=new a,He=new a,je=new a,qe=new a,Xe=new a;class Ye extends Ve{constructor(e,t,n){void 0===n&&(n=1e6),super(e,t,0,n),this.restitution=0,this.ri=new a,this.rj=new a,this.ni=new a}computeB(e){const t=this.a,n=this.b,r=this.bi,i=this.bj,s=this.ri,a=this.rj,o=Ke,l=Ze,c=r.velocity,u=r.angularVelocity;r.force,r.torque;const h=i.velocity,d=i.angularVelocity;i.force,i.torque;const p=Je,f=this.jacobianElementA,m=this.jacobianElementB,g=this.ni;s.cross(g,o),a.cross(g,l),g.negate(f.spatial),o.negate(f.rotational),m.spatial.copy(g),m.rotational.copy(l),p.copy(i.position),p.vadd(a,p),p.vsub(r.position,p),p.vsub(s,p);const y=g.dot(p),v=this.restitution+1;return-y*t-(v*h.dot(g)-v*c.dot(g)+d.dot(l)-u.dot(o))*n-e*this.computeGiMf()}getImpactVelocityAlongNormal(){const e=Qe,t=et,n=tt,r=nt,i=rt;return this.bi.position.vadd(this.ri,n),this.bj.position.vadd(this.rj,r),this.bi.getVelocityAtWorldPoint(n,e),this.bj.getVelocityAtWorldPoint(r,t),e.vsub(t,i),this.ni.dot(i)}}const Ke=new a,Ze=new a,Je=new a,Qe=new a,et=new a,tt=new a,nt=new a,rt=new a;class it extends Ue{constructor(e,t,n,r,i){void 0===t&&(t=new a),void 0===r&&(r=new a),void 0===i&&(i=1e6),super(e,n),this.pivotA=t.clone(),this.pivotB=r.clone();const s=this.equationX=new Ye(e,n),o=this.equationY=new Ye(e,n),l=this.equationZ=new Ye(e,n);this.equations.push(s,o,l),s.minForce=o.minForce=l.minForce=-i,s.maxForce=o.maxForce=l.maxForce=i,s.ni.set(1,0,0),o.ni.set(0,1,0),l.ni.set(0,0,1)}update(){const e=this.bodyA,t=this.bodyB,n=this.equationX,r=this.equationY,i=this.equationZ;e.quaternion.vmult(this.pivotA,n.ri),t.quaternion.vmult(this.pivotB,n.rj),r.ri.copy(n.ri),r.rj.copy(n.rj),i.ri.copy(n.ri),i.rj.copy(n.rj)}}class st extends Ve{constructor(e,t,n){void 0===n&&(n={});const r=void 0!==n.maxForce?n.maxForce:1e6;super(e,t,-r,r),this.axisA=n.axisA?n.axisA.clone():new a(1,0,0),this.axisB=n.axisB?n.axisB.clone():new a(0,1,0),this.angle=void 0!==n.angle?n.angle:0}computeB(e){const t=this.a,n=this.b,r=this.axisA,i=this.axisB,s=at,a=ot,o=this.jacobianElementA,l=this.jacobianElementB;return r.cross(i,s),i.cross(r,a),o.rotational.copy(a),l.rotational.copy(s),-(Math.cos(this.angle)-r.dot(i))*t-this.computeGW()*n-e*this.computeGiMf()}}const at=new a,ot=new a;class lt extends Ve{constructor(e,t,n){void 0===n&&(n={});const r=void 0!==n.maxForce?n.maxForce:1e6;super(e,t,-r,r),this.axisA=n.axisA?n.axisA.clone():new a(1,0,0),this.axisB=n.axisB?n.axisB.clone():new a(0,1,0),this.maxAngle=Math.PI/2}computeB(e){const t=this.a,n=this.b,r=this.axisA,i=this.axisB,s=ct,a=ut,o=this.jacobianElementA,l=this.jacobianElementB;return r.cross(i,s),i.cross(r,a),o.rotational.copy(a),l.rotational.copy(s),-(Math.cos(this.maxAngle)-r.dot(i))*t-this.computeGW()*n-e*this.computeGiMf()}}const ct=new a,ut=new a;class ht extends it{constructor(e,t,n){void 0===n&&(n={});const r=void 0!==n.maxForce?n.maxForce:1e6;super(e,n.pivotA?n.pivotA.clone():new a,t,n.pivotB?n.pivotB.clone():new a,r),this.axisA=n.axisA?n.axisA.clone():new a,this.axisB=n.axisB?n.axisB.clone():new a,this.collideConnected=!!n.collideConnected,this.angle=void 0!==n.angle?n.angle:0;const i=this.coneEquation=new st(e,t,n),s=this.twistEquation=new lt(e,t,n);this.twistAngle=void 0!==n.twistAngle?n.twistAngle:0,i.maxForce=0,i.minForce=-r,s.maxForce=0,s.minForce=-r,this.equations.push(i,s)}update(){const e=this.bodyA,t=this.bodyB,n=this.coneEquation,r=this.twistEquation;super.update(),e.vectorToWorldFrame(this.axisA,n.axisA),t.vectorToWorldFrame(this.axisB,n.axisB),this.axisA.tangents(r.axisA,r.axisA),e.vectorToWorldFrame(r.axisA,r.axisA),this.axisB.tangents(r.axisB,r.axisB),t.vectorToWorldFrame(r.axisB,r.axisB),n.angle=this.angle,r.maxAngle=this.twistAngle}}new a,new a;class dt extends Ue{constructor(e,t,n,r){void 0===r&&(r=1e6),super(e,t),void 0===n&&(n=e.position.distanceTo(t.position)),this.distance=n;const i=this.distanceEquation=new Ye(e,t);this.equations.push(i),i.minForce=-r,i.maxForce=r}update(){const e=this.bodyA,t=this.bodyB,n=this.distanceEquation,r=.5*this.distance,i=n.ni;t.position.vsub(e.position,i),i.normalize(),i.scale(r,n.ri),i.scale(-r,n.rj)}}class pt extends it{constructor(e,t,n){void 0===n&&(n={});const r=void 0!==n.maxForce?n.maxForce:1e6,i=new a,s=new a,o=new a;e.position.vadd(t.position,o),o.scale(.5,o),t.pointToLocalFrame(o,s),e.pointToLocalFrame(o,i),super(e,i,t,s,r),this.xA=e.vectorToLocalFrame(a.UNIT_X),this.xB=t.vectorToLocalFrame(a.UNIT_X),this.yA=e.vectorToLocalFrame(a.UNIT_Y),this.yB=t.vectorToLocalFrame(a.UNIT_Y),this.zA=e.vectorToLocalFrame(a.UNIT_Z),this.zB=t.vectorToLocalFrame(a.UNIT_Z);const l=this.rotationalEquation1=new lt(e,t,n),c=this.rotationalEquation2=new lt(e,t,n),u=this.rotationalEquation3=new lt(e,t,n);this.equations.push(l,c,u)}update(){const e=this.bodyA,t=this.bodyB;this.motorEquation;const n=this.rotationalEquation1,r=this.rotationalEquation2,i=this.rotationalEquation3;super.update(),e.vectorToWorldFrame(this.xA,n.axisA),t.vectorToWorldFrame(this.yB,n.axisB),e.vectorToWorldFrame(this.yA,r.axisA),t.vectorToWorldFrame(this.zB,r.axisB),e.vectorToWorldFrame(this.zA,i.axisA),t.vectorToWorldFrame(this.xB,i.axisB)}}new a,new a;class ft extends Ve{constructor(e,t,n){void 0===n&&(n=1e6),super(e,t,-n,n),this.axisA=new a,this.axisB=new a,this.targetVelocity=0}computeB(e){this.a;const t=this.b;this.bi,this.bj;const n=this.axisA,r=this.axisB,i=this.jacobianElementA,s=this.jacobianElementB;return i.rotational.copy(n),r.negate(s.rotational),-(this.computeGW()-this.targetVelocity)*t-e*this.computeGiMf()}}class mt extends it{constructor(e,t,n){void 0===n&&(n={});const r=void 0!==n.maxForce?n.maxForce:1e6;super(e,n.pivotA?n.pivotA.clone():new a,t,n.pivotB?n.pivotB.clone():new a,r),(this.axisA=n.axisA?n.axisA.clone():new a(1,0,0)).normalize(),(this.axisB=n.axisB?n.axisB.clone():new a(1,0,0)).normalize(),this.collideConnected=!!n.collideConnected;const i=this.rotationalEquation1=new lt(e,t,n),s=this.rotationalEquation2=new lt(e,t,n),o=this.motorEquation=new ft(e,t,r);o.enabled=!1,this.equations.push(i,s,o)}enableMotor(){this.motorEquation.enabled=!0}disableMotor(){this.motorEquation.enabled=!1}setMotorSpeed(e){this.motorEquation.targetVelocity=e}setMotorMaxForce(e){this.motorEquation.maxForce=e,this.motorEquation.minForce=-e}update(){const e=this.bodyA,t=this.bodyB,n=this.motorEquation,r=this.rotationalEquation1,i=this.rotationalEquation2,s=gt,a=yt,o=this.axisA,l=this.axisB;super.update(),e.quaternion.vmult(o,s),t.quaternion.vmult(l,a),s.tangents(r.axisA,i.axisA),r.axisB.copy(a),i.axisB.copy(a),this.motorEquation.enabled&&(e.quaternion.vmult(this.axisA,n.axisA),t.quaternion.vmult(this.axisB,n.axisB))}}const gt=new a,yt=new a;class vt extends Ve{constructor(e,t,n){super(e,t,-n,n),this.ri=new a,this.rj=new a,this.t=new a}computeB(e){this.a;const t=this.b;this.bi,this.bj;const n=this.ri,r=this.rj,i=xt,s=bt,a=this.t;n.cross(a,i),r.cross(a,s);const o=this.jacobianElementA,l=this.jacobianElementB;return a.negate(o.spatial),i.negate(o.rotational),l.spatial.copy(a),l.rotational.copy(s),-this.computeGW()*t-e*this.computeGiMf()}}const xt=new a,bt=new a;class wt{constructor(e,t,n){n=Be.defaults(n,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=wt.idCounter++,this.materials=[e,t],this.friction=n.friction,this.restitution=n.restitution,this.contactEquationStiffness=n.contactEquationStiffness,this.contactEquationRelaxation=n.contactEquationRelaxation,this.frictionEquationStiffness=n.frictionEquationStiffness,this.frictionEquationRelaxation=n.frictionEquationRelaxation}}wt.idCounter=0;class _t{constructor(e){void 0===e&&(e={});let t="";"string"==typeof e&&(t=e,e={}),this.name=t,this.id=_t.idCounter++,this.friction=void 0!==e.friction?e.friction:-1,this.restitution=void 0!==e.restitution?e.restitution:-1}}_t.idCounter=0;class St{constructor(e,t,n){void 0===n&&(n={}),this.restLength="number"==typeof n.restLength?n.restLength:1,this.stiffness=n.stiffness||100,this.damping=n.damping||1,this.bodyA=e,this.bodyB=t,this.localAnchorA=new a,this.localAnchorB=new a,n.localAnchorA&&this.localAnchorA.copy(n.localAnchorA),n.localAnchorB&&this.localAnchorB.copy(n.localAnchorB),n.worldAnchorA&&this.setWorldAnchorA(n.worldAnchorA),n.worldAnchorB&&this.setWorldAnchorB(n.worldAnchorB)}setWorldAnchorA(e){this.bodyA.pointToLocalFrame(e,this.localAnchorA)}setWorldAnchorB(e){this.bodyB.pointToLocalFrame(e,this.localAnchorB)}getWorldAnchorA(e){this.bodyA.pointToWorldFrame(this.localAnchorA,e)}getWorldAnchorB(e){this.bodyB.pointToWorldFrame(this.localAnchorB,e)}applyForce(){const e=this.stiffness,t=this.damping,n=this.restLength,r=this.bodyA,i=this.bodyB,s=Mt,a=Tt,o=Et,l=At,c=Lt,u=Ct,h=It,d=Nt,p=kt,f=Rt,m=Dt;this.getWorldAnchorA(u),this.getWorldAnchorB(h),u.vsub(r.position,d),h.vsub(i.position,p),h.vsub(u,s);const g=s.length();a.copy(s),a.normalize(),i.velocity.vsub(r.velocity,o),i.angularVelocity.cross(p,c),o.vadd(c,o),r.angularVelocity.cross(d,c),o.vsub(c,o),a.scale(-e*(g-n)-t*o.dot(a),l),r.force.vsub(l,r.force),i.force.vadd(l,i.force),d.cross(l,f),p.cross(l,m),r.torque.vsub(f,r.torque),i.torque.vadd(m,i.torque)}}const Mt=new a,Tt=new a,Et=new a,At=new a,Ct=new a,It=new a,Nt=new a,kt=new a,Rt=new a,Dt=new a,Lt=new a;class Ft{constructor(e){void 0===e&&(e={}),e=Be.defaults(e,{chassisConnectionPointLocal:new a,chassisConnectionPointWorld:new a,directionLocal:new a,directionWorld:new a,axleLocal:new a,axleWorld:new a,suspensionRestLength:1,suspensionMaxLength:2,radius:1,suspensionStiffness:100,dampingCompression:10,dampingRelaxation:10,frictionSlip:10.5,forwardAcceleration:1,sideAcceleration:1,steering:0,rotation:0,deltaRotation:0,rollInfluence:.01,maxSuspensionForce:Number.MAX_VALUE,isFrontWheel:!0,clippedInvContactDotSuspension:1,suspensionRelativeVelocity:0,suspensionForce:0,slipInfo:0,skidInfo:0,suspensionLength:0,maxSuspensionTravel:1,useCustomSlidingRotationalSpeed:!1,customSlidingRotationalSpeed:-.1}),this.maxSuspensionTravel=e.maxSuspensionTravel,this.customSlidingRotationalSpeed=e.customSlidingRotationalSpeed,this.useCustomSlidingRotationalSpeed=e.useCustomSlidingRotationalSpeed,this.sliding=!1,this.chassisConnectionPointLocal=e.chassisConnectionPointLocal.clone(),this.chassisConnectionPointWorld=e.chassisConnectionPointWorld.clone(),this.directionLocal=e.directionLocal.clone(),this.directionWorld=e.directionWorld.clone(),this.axleLocal=e.axleLocal.clone(),this.axleWorld=e.axleWorld.clone(),this.suspensionRestLength=e.suspensionRestLength,this.suspensionMaxLength=e.suspensionMaxLength,this.radius=e.radius,this.suspensionStiffness=e.suspensionStiffness,this.dampingCompression=e.dampingCompression,this.dampingRelaxation=e.dampingRelaxation,this.frictionSlip=e.frictionSlip,this.forwardAcceleration=e.forwardAcceleration,this.sideAcceleration=e.sideAcceleration,this.steering=0,this.rotation=0,this.deltaRotation=0,this.rollInfluence=e.rollInfluence,this.maxSuspensionForce=e.maxSuspensionForce,this.engineForce=0,this.brake=0,this.isFrontWheel=e.isFrontWheel,this.clippedInvContactDotSuspension=1,this.suspensionRelativeVelocity=0,this.suspensionForce=0,this.slipInfo=0,this.skidInfo=0,this.suspensionLength=0,this.sideImpulse=0,this.forwardImpulse=0,this.raycastResult=new ee,this.worldTransform=new b,this.isInContact=!1}updateWheel(e){const t=this.raycastResult;if(this.isInContact){const n=t.hitNormalWorld.dot(t.directionWorld);t.hitPointWorld.vsub(e.position,Ot),e.getVelocityAtWorldPoint(Ot,Pt);const r=t.hitNormalWorld.dot(Pt);if(n>=-.1)this.suspensionRelativeVelocity=0,this.clippedInvContactDotSuspension=10;else{const e=-1/n;this.suspensionRelativeVelocity=r*e,this.clippedInvContactDotSuspension=e}}else t.suspensionLength=this.suspensionRestLength,this.suspensionRelativeVelocity=0,t.directionWorld.scale(-1,t.hitNormalWorld),this.clippedInvContactDotSuspension=1}}const Pt=new a,Ot=new a;class zt{constructor(e){this.chassisBody=e.chassisBody,this.wheelInfos=[],this.sliding=!1,this.world=null,this.indexRightAxis=void 0!==e.indexRightAxis?e.indexRightAxis:2,this.indexForwardAxis=void 0!==e.indexForwardAxis?e.indexForwardAxis:0,this.indexUpAxis=void 0!==e.indexUpAxis?e.indexUpAxis:1,this.constraints=[],this.preStepCallback=()=>{},this.currentVehicleSpeedKmHour=0,this.numWheelsOnGround=0}addWheel(e){void 0===e&&(e={});const t=new Ft(e),n=this.wheelInfos.length;return this.wheelInfos.push(t),n}setSteeringValue(e,t){this.wheelInfos[t].steering=e}applyEngineForce(e,t){this.wheelInfos[t].engineForce=e}setBrake(e,t){this.wheelInfos[t].brake=e}addToWorld(e){e.addBody(this.chassisBody);const t=this;this.preStepCallback=()=>{t.updateVehicle(e.dt)},e.addEventListener("preStep",this.preStepCallback),this.world=e}getVehicleAxisWorld(e,t){t.set(0===e?1:0,1===e?1:0,2===e?1:0),this.chassisBody.vectorToWorldFrame(t,t)}updateVehicle(e){const t=this.wheelInfos,n=t.length,r=this.chassisBody;for(let e=0;e<n;e++)this.updateWheelTransform(e);this.currentVehicleSpeedKmHour=3.6*r.velocity.length();const i=new a;this.getVehicleAxisWorld(this.indexForwardAxis,i),i.dot(r.velocity)<0&&(this.currentVehicleSpeedKmHour*=-1);for(let e=0;e<n;e++)this.castRay(t[e]);this.updateSuspension(e);const s=new a,o=new a;for(let i=0;i<n;i++){const n=t[i];let a=n.suspensionForce;a>n.maxSuspensionForce&&(a=n.maxSuspensionForce),n.raycastResult.hitNormalWorld.scale(a*e,s),n.raycastResult.hitPointWorld.vsub(r.position,o),r.applyImpulse(s,o)}this.updateFriction(e);const l=new a,c=new a,u=new a;for(let i=0;i<n;i++){const n=t[i];r.getVelocityAtWorldPoint(n.chassisConnectionPointWorld,u);let s=1;if(1===this.indexUpAxis&&(s=-1),n.isInContact){this.getVehicleAxisWorld(this.indexForwardAxis,c);const t=c.dot(n.raycastResult.hitNormalWorld);n.raycastResult.hitNormalWorld.scale(t,l),c.vsub(l,c);const r=c.dot(u);n.deltaRotation=s*r*e/n.radius}!n.sliding&&n.isInContact||0===n.engineForce||!n.useCustomSlidingRotationalSpeed||(n.deltaRotation=(n.engineForce>0?1:-1)*n.customSlidingRotationalSpeed*e),Math.abs(n.brake)>Math.abs(n.engineForce)&&(n.deltaRotation=0),n.rotation+=n.deltaRotation,n.deltaRotation*=.99}}updateSuspension(e){const t=this.chassisBody.mass,n=this.wheelInfos,r=n.length;for(let e=0;e<r;e++){const r=n[e];if(r.isInContact){let e;const n=r.suspensionRestLength-r.suspensionLength;e=r.suspensionStiffness*n*r.clippedInvContactDotSuspension;const i=r.suspensionRelativeVelocity;let s;s=i<0?r.dampingCompression:r.dampingRelaxation,e-=s*i,r.suspensionForce=e*t,r.suspensionForce<0&&(r.suspensionForce=0)}else r.suspensionForce=0}}removeFromWorld(e){this.constraints,e.removeBody(this.chassisBody),e.removeEventListener("preStep",this.preStepCallback),this.world=null}castRay(e){const t=Vt,n=Wt;this.updateWheelTransformWorld(e);const r=this.chassisBody;let i=-1;const s=e.suspensionRestLength+e.radius;e.directionWorld.scale(s,t);const o=e.chassisConnectionPointWorld;o.vadd(t,n);const l=e.raycastResult;l.reset();const c=r.collisionResponse;r.collisionResponse=!1,this.world.rayTest(o,n,l),r.collisionResponse=c;const u=l.body;if(e.raycastResult.groundObject=0,u){i=l.distance,e.raycastResult.hitNormalWorld=l.hitNormalWorld,e.isInContact=!0;const t=l.distance;e.suspensionLength=t-e.radius;const n=e.suspensionRestLength-e.maxSuspensionTravel,s=e.suspensionRestLength+e.maxSuspensionTravel;e.suspensionLength<n&&(e.suspensionLength=n),e.suspensionLength>s&&(e.suspensionLength=s,e.raycastResult.reset());const o=e.raycastResult.hitNormalWorld.dot(e.directionWorld),c=new a;r.getVelocityAtWorldPoint(e.raycastResult.hitPointWorld,c);const u=e.raycastResult.hitNormalWorld.dot(c);if(o>=-.1)e.suspensionRelativeVelocity=0,e.clippedInvContactDotSuspension=10;else{const t=-1/o;e.suspensionRelativeVelocity=u*t,e.clippedInvContactDotSuspension=t}}else e.suspensionLength=e.suspensionRestLength+0*e.maxSuspensionTravel,e.suspensionRelativeVelocity=0,e.directionWorld.scale(-1,e.raycastResult.hitNormalWorld),e.clippedInvContactDotSuspension=1;return i}updateWheelTransformWorld(e){e.isInContact=!1;const t=this.chassisBody;t.pointToWorldFrame(e.chassisConnectionPointLocal,e.chassisConnectionPointWorld),t.vectorToWorldFrame(e.directionLocal,e.directionWorld),t.vectorToWorldFrame(e.axleLocal,e.axleWorld)}updateWheelTransform(e){const t=Bt,n=Ut,r=$t,i=this.wheelInfos[e];this.updateWheelTransformWorld(i),i.directionLocal.scale(-1,t),n.copy(i.axleLocal),t.cross(n,r),r.normalize(),n.normalize();const s=i.steering,a=new m;a.setFromAxisAngle(t,s);const o=new m;o.setFromAxisAngle(n,i.rotation);const l=i.worldTransform.quaternion;this.chassisBody.quaternion.mult(a,l),l.mult(o,l),l.normalize();const c=i.worldTransform.position;c.copy(i.directionWorld),c.scale(i.suspensionLength,c),c.vadd(i.chassisConnectionPointWorld,c)}getWheelTransformWorld(e){return this.wheelInfos[e].worldTransform}updateFriction(e){const t=Ht,n=this.wheelInfos,r=n.length,i=this.chassisBody,s=qt,o=jt;this.numWheelsOnGround=0;for(let e=0;e<r;e++){const t=n[e];t.raycastResult.body&&this.numWheelsOnGround++,t.sideImpulse=0,t.forwardImpulse=0,s[e]||(s[e]=new a),o[e]||(o[e]=new a)}for(let e=0;e<r;e++){const r=n[e],a=r.raycastResult.body;if(a){const n=o[e];this.getWheelTransformWorld(e).vectorToWorldFrame(Gt[this.indexRightAxis],n);const l=r.raycastResult.hitNormalWorld,c=n.dot(l);l.scale(c,t),n.vsub(t,n),n.normalize(),l.cross(n,s[e]),s[e].normalize(),r.sideImpulse=ln(i,r.raycastResult.hitPointWorld,a,r.raycastResult.hitPointWorld,n),r.sideImpulse*=Xt}}this.sliding=!1;for(let t=0;t<r;t++){const r=n[t],a=r.raycastResult.body;let o=0;if(r.slipInfo=1,a){const n=0,l=r.brake?r.brake:n;o=Jt(i,a,r.raycastResult.hitPointWorld,s[t],l),o+=r.engineForce*e;const c=l/o;r.slipInfo*=c}if(r.forwardImpulse=0,r.skidInfo=1,a){r.skidInfo=1;const t=r.suspensionForce*e*r.frictionSlip,n=t*t;r.forwardImpulse=o;const i=.5*r.forwardImpulse/r.forwardAcceleration,s=1*r.sideImpulse/r.sideAcceleration,a=i*i+s*s;if(r.sliding=!1,a>n){this.sliding=!0,r.sliding=!0;const e=t/Math.sqrt(a);r.skidInfo*=e}}}if(this.sliding)for(let e=0;e<r;e++){const t=n[e];0!==t.sideImpulse&&t.skidInfo<1&&(t.forwardImpulse*=t.skidInfo,t.sideImpulse*=t.skidInfo)}for(let e=0;e<r;e++){const t=n[e],r=new a;if(t.raycastResult.hitPointWorld.vsub(i.position,r),0!==t.forwardImpulse){const n=new a;s[e].scale(t.forwardImpulse,n),i.applyImpulse(n,r)}if(0!==t.sideImpulse){const n=t.raycastResult.body,s=new a;t.raycastResult.hitPointWorld.vsub(n.position,s);const l=new a;o[e].scale(t.sideImpulse,l),i.vectorToLocalFrame(r,r),r["xyz"[this.indexUpAxis]]*=t.rollInfluence,i.vectorToWorldFrame(r,r),i.applyImpulse(l,r),l.scale(-1,l),n.applyImpulse(l,s)}}}}new a,new a,new a;const Bt=new a,Ut=new a,$t=new a;new ce,new a;const Vt=new a,Wt=new a,Gt=[new a(1,0,0),new a(0,1,0),new a(0,0,1)],Ht=new a,jt=[],qt=[],Xt=1,Yt=new a,Kt=new a,Zt=new a;function Jt(e,t,n,r,i){let s=0;const a=n,o=Yt,l=Kt,c=Zt;return e.getVelocityAtWorldPoint(a,o),t.getVelocityAtWorldPoint(a,l),o.vsub(l,c),s=-r.dot(c)*(1/(rn(e,n,r)+rn(t,n,r))),i<s&&(s=i),s<-i&&(s=-i),s}const Qt=new a,en=new a,tn=new a,nn=new a;function rn(e,t,n){const r=Qt,i=en,s=tn,a=nn;return t.vsub(e.position,r),r.cross(n,i),e.invInertiaWorld.vmult(i,a),a.cross(r,s),e.invMass+n.dot(s)}const sn=new a,an=new a,on=new a;function ln(e,t,n,r,i){if(i.lengthSquared()>1.1)return 0;const s=sn,a=an,o=on;return e.getVelocityAtWorldPoint(t,s),n.getVelocityAtWorldPoint(r,a),s.vsub(a,o),-.2*i.dot(o)*(1/(e.invMass+n.invMass))}class cn extends x{constructor(e){if(super({type:x.types.SPHERE}),this.radius=void 0!==e?e:1,this.radius<0)throw new Error("The sphere radius cannot be negative.");this.updateBoundingSphereRadius()}calculateLocalInertia(e,t){void 0===t&&(t=new a);const n=2*e*this.radius*this.radius/5;return t.x=n,t.y=n,t.z=n,t}volume(){return 4*Math.PI*Math.pow(this.radius,3)/3}updateBoundingSphereRadius(){this.boundingSphereRadius=this.radius}calculateWorldAABB(e,t,n,r){const i=this.radius,s=["x","y","z"];for(let t=0;t<s.length;t++){const a=s[t];n[a]=e[a]-i,r[a]=e[a]+i}}}class un{constructor(e){void 0===e&&(e={}),this.wheelBodies=[],this.coordinateSystem=void 0!==e.coordinateSystem?e.coordinateSystem.clone():new a(1,2,3),e.chassisBody?this.chassisBody=e.chassisBody:this.chassisBody=new R({mass:1,shape:new A(new a(5,.5,2))}),this.constraints=[],this.wheelAxes=[],this.wheelForces=[]}addWheel(e){let t;void 0===e&&(e={}),t=e.body?e.body:new R({mass:1,shape:new cn(1.2)}),this.wheelBodies.push(t),this.wheelForces.push(0);const n=void 0!==e.position?e.position.clone():new a,r=new a;this.chassisBody.pointToWorldFrame(n,r),t.position.set(r.x,r.y,r.z);const i=void 0!==e.axis?e.axis.clone():new a(0,0,1);this.wheelAxes.push(i);const s=new mt(this.chassisBody,t,{pivotA:n,axisA:i,pivotB:a.ZERO,axisB:i,collideConnected:!1});return this.constraints.push(s),this.wheelBodies.length-1}setSteeringValue(e,t){const n=this.wheelAxes[t],r=Math.cos(e),i=Math.sin(e),s=n.x,a=n.z;this.constraints[t].axisA.set(-r*s+i*a,0,i*s+r*a)}setMotorSpeed(e,t){const n=this.constraints[t];n.enableMotor(),n.motorTargetVelocity=e}disableMotor(e){this.constraints[e].disableMotor()}setWheelForce(e,t){this.wheelForces[t]=e}applyWheelForce(e,t){const n=this.wheelAxes[t],r=this.wheelBodies[t],i=r.torque;n.scale(e,hn),r.vectorToWorldFrame(hn,hn),i.vadd(hn,i)}addToWorld(e){const t=this.constraints,n=this.wheelBodies.concat([this.chassisBody]);for(let t=0;t<n.length;t++)e.addBody(n[t]);for(let n=0;n<t.length;n++)e.addConstraint(t[n]);e.addEventListener("preStep",this._update.bind(this))}_update(){const e=this.wheelForces;for(let t=0;t<e.length;t++)this.applyWheelForce(e[t],t)}removeFromWorld(e){const t=this.constraints,n=this.wheelBodies.concat([this.chassisBody]);for(let t=0;t<n.length;t++)e.removeBody(n[t]);for(let n=0;n<t.length;n++)e.removeConstraint(t[n])}getWheelSpeed(e){const t=this.wheelAxes[e],n=this.wheelBodies[e].angularVelocity;return this.chassisBody.vectorToWorldFrame(t,dn),n.dot(dn)}}const hn=new a,dn=new a;class pn{constructor(){this.particles=[],this.density=1,this.smoothingRadius=1,this.speedOfSound=1,this.viscosity=.01,this.eps=1e-6,this.pressures=[],this.densities=[],this.neighbors=[]}add(e){this.particles.push(e),this.neighbors.length<this.particles.length&&this.neighbors.push([])}remove(e){const t=this.particles.indexOf(e);-1!==t&&(this.particles.splice(t,1),this.neighbors.length>this.particles.length&&this.neighbors.pop())}getNeighbors(e,t){const n=this.particles.length,r=e.id,i=this.smoothingRadius*this.smoothingRadius,s=fn;for(let a=0;a!==n;a++){const n=this.particles[a];n.position.vsub(e.position,s),r!==n.id&&s.lengthSquared()<i&&t.push(n)}}update(){const e=this.particles.length,t=mn,n=this.speedOfSound,r=this.eps;for(let r=0;r!==e;r++){const e=this.particles[r],i=this.neighbors[r];i.length=0,this.getNeighbors(e,i),i.push(this.particles[r]);const s=i.length;let a=0;for(let n=0;n!==s;n++){e.position.vsub(i[n].position,t);const r=t.length(),s=this.w(r);a+=i[n].mass*s}this.densities[r]=a,this.pressures[r]=n*n*(this.densities[r]-this.density)}const i=gn,s=yn,a=vn,o=xn,l=bn;for(let t=0;t!==e;t++){const e=this.particles[t];let n,c;i.set(0,0,0),s.set(0,0,0);const u=this.neighbors[t],h=u.length;for(let d=0;d!==h;d++){const h=u[d];e.position.vsub(h.position,o);const p=o.length();n=-h.mass*(this.pressures[t]/(this.densities[t]*this.densities[t]+r)+this.pressures[d]/(this.densities[d]*this.densities[d]+r)),this.gradw(o,a),a.scale(n,a),i.vadd(a,i),h.velocity.vsub(e.velocity,l),l.scale(1/(1e-4+this.densities[t]*this.densities[d])*this.viscosity*h.mass,l),c=this.nablaw(p),l.scale(c,l),s.vadd(l,s)}s.scale(e.mass,s),i.scale(e.mass,i),e.force.vadd(s,e.force),e.force.vadd(i,e.force)}}w(e){const t=this.smoothingRadius;return 315/(64*Math.PI*t**9)*(t*t-e*e)**3}gradw(e,t){const n=e.length(),r=this.smoothingRadius;e.scale(945/(32*Math.PI*r**9)*(r*r-n*n)**2,t)}nablaw(e){const t=this.smoothingRadius;return 945/(32*Math.PI*t**9)*(t*t-e*e)*(7*e*e-3*t*t)}}const fn=new a,mn=new a,gn=new a,yn=new a,vn=new a,xn=new a,bn=new a;class wn extends _{constructor(e,t,n,r){if(void 0===e&&(e=1),void 0===t&&(t=1),void 0===n&&(n=1),void 0===r&&(r=8),e<0)throw new Error("The cylinder radiusTop cannot be negative.");if(t<0)throw new Error("The cylinder radiusBottom cannot be negative.");const i=r,s=[],o=[],l=[],c=[],u=[],h=Math.cos,d=Math.sin;s.push(new a(-t*d(0),.5*-n,t*h(0))),c.push(0),s.push(new a(-e*d(0),.5*n,e*h(0))),u.push(1);for(let r=0;r<i;r++){const p=2*Math.PI/i*(r+1),f=2*Math.PI/i*(r+.5);r<i-1?(s.push(new a(-t*d(p),.5*-n,t*h(p))),c.push(2*r+2),s.push(new a(-e*d(p),.5*n,e*h(p))),u.push(2*r+3),l.push([2*r,2*r+1,2*r+3,2*r+2])):l.push([2*r,2*r+1,1,0]),(i%2==1||r<i/2)&&o.push(new a(-d(f),0,h(f)))}l.push(c),o.push(new a(0,1,0));const p=[];for(let e=0;e<u.length;e++)p.push(u[u.length-e-1]);l.push(p),super({vertices:s,faces:l,axes:o}),this.type=x.types.CYLINDER,this.radiusTop=e,this.radiusBottom=t,this.height=n,this.numSegments=r}}class _n extends x{constructor(){super({type:x.types.PARTICLE})}calculateLocalInertia(e,t){return void 0===t&&(t=new a),t.set(0,0,0),t}volume(){return 0}updateBoundingSphereRadius(){this.boundingSphereRadius=0}calculateWorldAABB(e,t,n,r){n.copy(e),r.copy(e)}}class Sn extends x{constructor(){super({type:x.types.PLANE}),this.worldNormal=new a,this.worldNormalNeedsUpdate=!0,this.boundingSphereRadius=Number.MAX_VALUE}computeWorldNormal(e){const t=this.worldNormal;t.set(0,0,1),e.vmult(t,t),this.worldNormalNeedsUpdate=!1}calculateLocalInertia(e,t){return void 0===t&&(t=new a),t}volume(){return Number.MAX_VALUE}calculateWorldAABB(e,t,n,r){Mn.set(0,0,1),t.vmult(Mn,Mn);const i=Number.MAX_VALUE;n.set(-i,-i,-i),r.set(i,i,i),1===Mn.x?r.x=e.x:-1===Mn.x&&(n.x=e.x),1===Mn.y?r.y=e.y:-1===Mn.y&&(n.y=e.y),1===Mn.z?r.z=e.z:-1===Mn.z&&(n.z=e.z)}updateBoundingSphereRadius(){this.boundingSphereRadius=Number.MAX_VALUE}}const Mn=new a;class Tn extends x{constructor(e,t){void 0===t&&(t={}),t=Be.defaults(t,{maxValue:null,minValue:null,elementSize:1}),super({type:x.types.HEIGHTFIELD}),this.data=e,this.maxValue=t.maxValue,this.minValue=t.minValue,this.elementSize=t.elementSize,null===t.minValue&&this.updateMinValue(),null===t.maxValue&&this.updateMaxValue(),this.cacheEnabled=!0,this.pillarConvex=new _,this.pillarOffset=new a,this.updateBoundingSphereRadius(),this._cachedPillars={}}update(){this._cachedPillars={}}updateMinValue(){const e=this.data;let t=e[0][0];for(let n=0;n!==e.length;n++)for(let r=0;r!==e[n].length;r++){const i=e[n][r];i<t&&(t=i)}this.minValue=t}updateMaxValue(){const e=this.data;let t=e[0][0];for(let n=0;n!==e.length;n++)for(let r=0;r!==e[n].length;r++){const i=e[n][r];i>t&&(t=i)}this.maxValue=t}setHeightValueAtIndex(e,t,n){this.data[e][t]=n,this.clearCachedConvexTrianglePillar(e,t,!1),e>0&&(this.clearCachedConvexTrianglePillar(e-1,t,!0),this.clearCachedConvexTrianglePillar(e-1,t,!1)),t>0&&(this.clearCachedConvexTrianglePillar(e,t-1,!0),this.clearCachedConvexTrianglePillar(e,t-1,!1)),t>0&&e>0&&this.clearCachedConvexTrianglePillar(e-1,t-1,!0)}getRectMinMax(e,t,n,r,i){void 0===i&&(i=[]);const s=this.data;let a=this.minValue;for(let i=e;i<=n;i++)for(let e=t;e<=r;e++){const t=s[i][e];t>a&&(a=t)}i[0]=this.minValue,i[1]=a}getIndexOfPosition(e,t,n,r){const i=this.elementSize,s=this.data;let a=Math.floor(e/i),o=Math.floor(t/i);return n[0]=a,n[1]=o,r&&(a<0&&(a=0),o<0&&(o=0),a>=s.length-1&&(a=s.length-1),o>=s[0].length-1&&(o=s[0].length-1)),!(a<0||o<0||a>=s.length-1||o>=s[0].length-1)}getTriangleAt(e,t,n,r,i,s){const a=En;this.getIndexOfPosition(e,t,a,n);let o=a[0],l=a[1];const c=this.data;n&&(o=Math.min(c.length-2,Math.max(0,o)),l=Math.min(c[0].length-2,Math.max(0,l)));const u=this.elementSize,h=(e/u-o)**2+(t/u-l)**2>(e/u-(o+1))**2+(t/u-(l+1))**2;return this.getTriangle(o,l,h,r,i,s),h}getNormalAt(e,t,n,r){const i=kn,s=Rn,a=Dn,o=Ln,l=Fn;this.getTriangleAt(e,t,n,i,s,a),s.vsub(i,o),a.vsub(i,l),o.cross(l,r),r.normalize()}getAabbAtIndex(e,t,n){let{lowerBound:r,upperBound:i}=n;const s=this.data,a=this.elementSize;r.set(e*a,t*a,s[e][t]),i.set((e+1)*a,(t+1)*a,s[e+1][t+1])}getHeightAt(e,t,n){const r=this.data,i=Cn,s=In,a=Nn,o=En;this.getIndexOfPosition(e,t,o,n);let l=o[0],c=o[1];n&&(l=Math.min(r.length-2,Math.max(0,l)),c=Math.min(r[0].length-2,Math.max(0,c)));const u=this.getTriangleAt(e,t,n,i,s,a);!function(e,t,n,r,i,s,a,o,l){l.x=((s-o)*(e-a)+(a-i)*(t-o))/((s-o)*(n-a)+(a-i)*(r-o)),l.y=((o-r)*(e-a)+(n-a)*(t-o))/((s-o)*(n-a)+(a-i)*(r-o)),l.z=1-l.x-l.y}(e,t,i.x,i.y,s.x,s.y,a.x,a.y,An);const h=An;return u?r[l+1][c+1]*h.x+r[l][c+1]*h.y+r[l+1][c]*h.z:r[l][c]*h.x+r[l+1][c]*h.y+r[l][c+1]*h.z}getCacheConvexTrianglePillarKey(e,t,n){return`${e}_${t}_${n?1:0}`}getCachedConvexTrianglePillar(e,t,n){return this._cachedPillars[this.getCacheConvexTrianglePillarKey(e,t,n)]}setCachedConvexTrianglePillar(e,t,n,r,i){this._cachedPillars[this.getCacheConvexTrianglePillarKey(e,t,n)]={convex:r,offset:i}}clearCachedConvexTrianglePillar(e,t,n){delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(e,t,n)]}getTriangle(e,t,n,r,i,s){const a=this.data,o=this.elementSize;n?(r.set((e+1)*o,(t+1)*o,a[e+1][t+1]),i.set(e*o,(t+1)*o,a[e][t+1]),s.set((e+1)*o,t*o,a[e+1][t])):(r.set(e*o,t*o,a[e][t]),i.set((e+1)*o,t*o,a[e+1][t]),s.set(e*o,(t+1)*o,a[e][t+1]))}getConvexTrianglePillar(e,t,n){let r=this.pillarConvex,i=this.pillarOffset;if(this.cacheEnabled){const s=this.getCachedConvexTrianglePillar(e,t,n);if(s)return this.pillarConvex=s.convex,void(this.pillarOffset=s.offset);r=new _,i=new a,this.pillarConvex=r,this.pillarOffset=i}const s=this.data,o=this.elementSize,l=r.faces;r.vertices.length=6;for(let e=0;e<6;e++)r.vertices[e]||(r.vertices[e]=new a);l.length=5;for(let e=0;e<5;e++)l[e]||(l[e]=[]);const c=r.vertices,u=(Math.min(s[e][t],s[e+1][t],s[e][t+1],s[e+1][t+1])-this.minValue)/2+this.minValue;n?(i.set((e+.75)*o,(t+.75)*o,u),c[0].set(.25*o,.25*o,s[e+1][t+1]-u),c[1].set(-.75*o,.25*o,s[e][t+1]-u),c[2].set(.25*o,-.75*o,s[e+1][t]-u),c[3].set(.25*o,.25*o,-Math.abs(u)-1),c[4].set(-.75*o,.25*o,-Math.abs(u)-1),c[5].set(.25*o,-.75*o,-Math.abs(u)-1),l[0][0]=0,l[0][1]=1,l[0][2]=2,l[1][0]=5,l[1][1]=4,l[1][2]=3,l[2][0]=2,l[2][1]=5,l[2][2]=3,l[2][3]=0,l[3][0]=3,l[3][1]=4,l[3][2]=1,l[3][3]=0,l[4][0]=1,l[4][1]=4,l[4][2]=5,l[4][3]=2):(i.set((e+.25)*o,(t+.25)*o,u),c[0].set(-.25*o,-.25*o,s[e][t]-u),c[1].set(.75*o,-.25*o,s[e+1][t]-u),c[2].set(-.25*o,.75*o,s[e][t+1]-u),c[3].set(-.25*o,-.25*o,-Math.abs(u)-1),c[4].set(.75*o,-.25*o,-Math.abs(u)-1),c[5].set(-.25*o,.75*o,-Math.abs(u)-1),l[0][0]=0,l[0][1]=1,l[0][2]=2,l[1][0]=5,l[1][1]=4,l[1][2]=3,l[2][0]=0,l[2][1]=2,l[2][2]=5,l[2][3]=3,l[3][0]=1,l[3][1]=0,l[3][2]=3,l[3][3]=4,l[4][0]=4,l[4][1]=5,l[4][2]=2,l[4][3]=1),r.computeNormals(),r.computeEdges(),r.updateBoundingSphereRadius(),this.setCachedConvexTrianglePillar(e,t,n,r,i)}calculateLocalInertia(e,t){return void 0===t&&(t=new a),t.set(0,0,0),t}volume(){return Number.MAX_VALUE}calculateWorldAABB(e,t,n,r){n.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),r.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)}updateBoundingSphereRadius(){const e=this.data,t=this.elementSize;this.boundingSphereRadius=new a(e.length*t,e[0].length*t,Math.max(Math.abs(this.maxValue),Math.abs(this.minValue))).length()}setHeightsFromImage(e,t){const{x:n,z:r,y:i}=t,s=document.createElement("canvas");s.width=e.width,s.height=e.height;const a=s.getContext("2d");a.drawImage(e,0,0);const o=a.getImageData(0,0,e.width,e.height),l=this.data;l.length=0,this.elementSize=Math.abs(n)/o.width;for(let e=0;e<o.height;e++){const t=[];for(let i=0;i<o.width;i++){const s=(o.data[4*(e*o.height+i)]+o.data[4*(e*o.height+i)+1]+o.data[4*(e*o.height+i)+2])/4/255*r;n<0?t.push(s):t.unshift(s)}i<0?l.unshift(t):l.push(t)}this.updateMaxValue(),this.updateMinValue(),this.update()}}const En=[],An=new a,Cn=new a,In=new a,Nn=new a,kn=new a,Rn=new a,Dn=new a,Ln=new a,Fn=new a;class Pn{constructor(e){void 0===e&&(e={}),this.root=e.root||null,this.aabb=e.aabb?e.aabb.clone():new u,this.data=[],this.children=[]}reset(){this.children.length=this.data.length=0}insert(e,t,n){void 0===n&&(n=0);const r=this.data;if(!this.aabb.contains(e))return!1;const i=this.children;if(n<(this.maxDepth||this.root.maxDepth)){let r=!1;i.length||(this.subdivide(),r=!0);for(let r=0;8!==r;r++)if(i[r].insert(e,t,n+1))return!0;r&&(i.length=0)}return r.push(t),!0}subdivide(){const e=this.aabb,t=e.lowerBound,n=e.upperBound,r=this.children;r.push(new Pn({aabb:new u({lowerBound:new a(0,0,0)})}),new Pn({aabb:new u({lowerBound:new a(1,0,0)})}),new Pn({aabb:new u({lowerBound:new a(1,1,0)})}),new Pn({aabb:new u({lowerBound:new a(1,1,1)})}),new Pn({aabb:new u({lowerBound:new a(0,1,1)})}),new Pn({aabb:new u({lowerBound:new a(0,0,1)})}),new Pn({aabb:new u({lowerBound:new a(1,0,1)})}),new Pn({aabb:new u({lowerBound:new a(0,1,0)})})),n.vsub(t,zn),zn.scale(.5,zn);const i=this.root||this;for(let e=0;8!==e;e++){const n=r[e];n.root=i;const s=n.aabb.lowerBound;s.x*=zn.x,s.y*=zn.y,s.z*=zn.z,s.vadd(t,s),s.vadd(zn,n.aabb.upperBound)}}aabbQuery(e,t){this.data,this.children;const n=[this];for(;n.length;){const r=n.pop();r.aabb.overlaps(e)&&Array.prototype.push.apply(t,r.data),Array.prototype.push.apply(n,r.children)}return t}rayQuery(e,t,n){return e.getAABB(Bn),Bn.toLocalFrame(t,Bn),this.aabbQuery(Bn,n),n}removeEmptyNodes(){for(let e=this.children.length-1;e>=0;e--)this.children[e].removeEmptyNodes(),this.children[e].children.length||this.children[e].data.length||this.children.splice(e,1)}}class On extends Pn{constructor(e,t){void 0===t&&(t={}),super({root:null,aabb:e}),this.maxDepth=void 0!==t.maxDepth?t.maxDepth:8}}const zn=new a,Bn=new u;class Un extends x{constructor(e,t){super({type:x.types.TRIMESH}),this.vertices=new Float32Array(e),this.indices=new Int16Array(t),this.normals=new Float32Array(t.length),this.aabb=new u,this.edges=null,this.scale=new a(1,1,1),this.tree=new On,this.updateEdges(),this.updateNormals(),this.updateAABB(),this.updateBoundingSphereRadius(),this.updateTree()}updateTree(){const e=this.tree;e.reset(),e.aabb.copy(this.aabb);const t=this.scale;e.aabb.lowerBound.x*=1/t.x,e.aabb.lowerBound.y*=1/t.y,e.aabb.lowerBound.z*=1/t.z,e.aabb.upperBound.x*=1/t.x,e.aabb.upperBound.y*=1/t.y,e.aabb.upperBound.z*=1/t.z;const n=new u,r=new a,i=new a,s=new a,o=[r,i,s];for(let t=0;t<this.indices.length/3;t++){const a=3*t;this._getUnscaledVertex(this.indices[a],r),this._getUnscaledVertex(this.indices[a+1],i),this._getUnscaledVertex(this.indices[a+2],s),n.setFromPoints(o),e.insert(n,t)}e.removeEmptyNodes()}getTrianglesInAABB(e,t){Vn.copy(e);const n=this.scale,r=n.x,i=n.y,s=n.z,a=Vn.lowerBound,o=Vn.upperBound;return a.x/=r,a.y/=i,a.z/=s,o.x/=r,o.y/=i,o.z/=s,this.tree.aabbQuery(Vn,t)}setScale(e){const t=this.scale.x===this.scale.y&&this.scale.y===this.scale.z,n=e.x===e.y&&e.y===e.z;t&&n||this.updateNormals(),this.scale.copy(e),this.updateAABB(),this.updateBoundingSphereRadius()}updateNormals(){const e=$n,t=this.normals;for(let n=0;n<this.indices.length/3;n++){const r=3*n,i=this.indices[r],s=this.indices[r+1],a=this.indices[r+2];this.getVertex(i,qn),this.getVertex(s,Xn),this.getVertex(a,Yn),Un.computeNormal(Xn,qn,Yn,e),t[r]=e.x,t[r+1]=e.y,t[r+2]=e.z}}updateEdges(){const e={},t=(t,n)=>{e[t<n?`${t}_${n}`:`${n}_${t}`]=!0};for(let e=0;e<this.indices.length/3;e++){const n=3*e,r=this.indices[n],i=this.indices[n+1],s=this.indices[n+2];t(r,i),t(i,s),t(s,r)}const n=Object.keys(e);this.edges=new Int16Array(2*n.length);for(let e=0;e<n.length;e++){const t=n[e].split("_");this.edges[2*e]=parseInt(t[0],10),this.edges[2*e+1]=parseInt(t[1],10)}}getEdgeVertex(e,t,n){const r=this.edges[2*e+(t?1:0)];this.getVertex(r,n)}getEdgeVector(e,t){const n=Wn,r=Gn;this.getEdgeVertex(e,0,n),this.getEdgeVertex(e,1,r),r.vsub(n,t)}static computeNormal(e,t,n,r){t.vsub(e,jn),n.vsub(t,Hn),Hn.cross(jn,r),r.isZero()||r.normalize()}getVertex(e,t){const n=this.scale;return this._getUnscaledVertex(e,t),t.x*=n.x,t.y*=n.y,t.z*=n.z,t}_getUnscaledVertex(e,t){const n=3*e,r=this.vertices;return t.set(r[n],r[n+1],r[n+2])}getWorldVertex(e,t,n,r){return this.getVertex(e,r),b.pointToWorldFrame(t,n,r,r),r}getTriangleVertices(e,t,n,r){const i=3*e;this.getVertex(this.indices[i],t),this.getVertex(this.indices[i+1],n),this.getVertex(this.indices[i+2],r)}getNormal(e,t){const n=3*e;return t.set(this.normals[n],this.normals[n+1],this.normals[n+2])}calculateLocalInertia(e,t){this.computeLocalAABB(Kn);const n=Kn.upperBound.x-Kn.lowerBound.x,r=Kn.upperBound.y-Kn.lowerBound.y,i=Kn.upperBound.z-Kn.lowerBound.z;return t.set(1/12*e*(2*r*2*r+2*i*2*i),1/12*e*(2*n*2*n+2*i*2*i),1/12*e*(2*r*2*r+2*n*2*n))}computeLocalAABB(e){const t=e.lowerBound,n=e.upperBound,r=this.vertices.length;this.vertices;const i=Zn;this.getVertex(0,i),t.copy(i),n.copy(i);for(let e=0;e!==r;e++)this.getVertex(e,i),i.x<t.x?t.x=i.x:i.x>n.x&&(n.x=i.x),i.y<t.y?t.y=i.y:i.y>n.y&&(n.y=i.y),i.z<t.z?t.z=i.z:i.z>n.z&&(n.z=i.z)}updateAABB(){this.computeLocalAABB(this.aabb)}updateBoundingSphereRadius(){let e=0;const t=this.vertices,n=new a;for(let r=0,i=t.length/3;r!==i;r++){this.getVertex(r,n);const t=n.lengthSquared();t>e&&(e=t)}this.boundingSphereRadius=Math.sqrt(e)}calculateWorldAABB(e,t,n,r){const i=Jn,s=Qn;i.position=e,i.quaternion=t,this.aabb.toWorldFrame(i,s),n.copy(s.lowerBound),r.copy(s.upperBound)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}static createTorus(e,t,n,r,i){void 0===e&&(e=1),void 0===t&&(t=.5),void 0===n&&(n=8),void 0===r&&(r=6),void 0===i&&(i=2*Math.PI);const s=[],a=[];for(let a=0;a<=n;a++)for(let o=0;o<=r;o++){const l=o/r*i,c=a/n*Math.PI*2,u=(e+t*Math.cos(c))*Math.cos(l),h=(e+t*Math.cos(c))*Math.sin(l),d=t*Math.sin(c);s.push(u,h,d)}for(let e=1;e<=n;e++)for(let t=1;t<=r;t++){const n=(r+1)*e+t-1,i=(r+1)*(e-1)+t-1,s=(r+1)*(e-1)+t,o=(r+1)*e+t;a.push(n,i,o),a.push(i,s,o)}return new Un(s,a)}}const $n=new a,Vn=new u,Wn=new a,Gn=new a,Hn=new a,jn=new a,qn=new a,Xn=new a,Yn=new a,Kn=new u,Zn=new a,Jn=new b,Qn=new u;class er{constructor(){this.equations=[]}solve(e,t){return 0}addEquation(e){!e.enabled||e.bi.isTrigger||e.bj.isTrigger||this.equations.push(e)}removeEquation(e){const t=this.equations,n=t.indexOf(e);-1!==n&&t.splice(n,1)}removeAllEquations(){this.equations.length=0}}class tr extends er{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(e,t){let n=0;const r=this.iterations,i=this.tolerance*this.tolerance,s=this.equations,a=s.length,o=t.bodies,l=o.length,c=e;let u,h,d,p,f,m;if(0!==a)for(let e=0;e!==l;e++)o[e].updateSolveMassProperties();const g=rr,y=ir,v=nr;g.length=a,y.length=a,v.length=a;for(let e=0;e!==a;e++){const t=s[e];v[e]=0,y[e]=t.computeB(c),g[e]=1/t.computeC()}if(0!==a){for(let e=0;e!==l;e++){const t=o[e],n=t.vlambda,r=t.wlambda;n.set(0,0,0),r.set(0,0,0)}for(n=0;n!==r;n++){p=0;for(let e=0;e!==a;e++){const t=s[e];u=y[e],h=g[e],m=v[e],f=t.computeGWlambda(),d=h*(u-f-t.eps*m),m+d<t.minForce?d=t.minForce-m:m+d>t.maxForce&&(d=t.maxForce-m),v[e]+=d,p+=d>0?d:-d,t.addToWlambda(d)}if(p*p<i)break}for(let e=0;e!==l;e++){const t=o[e],n=t.velocity,r=t.angularVelocity;t.vlambda.vmul(t.linearFactor,t.vlambda),n.vadd(t.vlambda,n),t.wlambda.vmul(t.angularFactor,t.wlambda),r.vadd(t.wlambda,r)}let e=s.length;const t=1/c;for(;e--;)s[e].multiplier=v[e]*t}return n}}const nr=[],rr=[],ir=[];class sr extends er{constructor(e){for(super(),this.iterations=10,this.tolerance=1e-7,this.subsolver=e,this.nodes=[],this.nodePool=[];this.nodePool.length<128;)this.nodePool.push(this.createNode())}createNode(){return{body:null,children:[],eqs:[],visited:!1}}solve(e,t){const n=ar,r=this.nodePool,i=t.bodies,s=this.equations,a=s.length,o=i.length,l=this.subsolver;for(;r.length<o;)r.push(this.createNode());n.length=o;for(let e=0;e<o;e++)n[e]=r[e];for(let e=0;e!==o;e++){const t=n[e];t.body=i[e],t.children.length=0,t.eqs.length=0,t.visited=!1}for(let e=0;e!==a;e++){const t=s[e],r=i.indexOf(t.bi),a=i.indexOf(t.bj),o=n[r],l=n[a];o.children.push(l),o.eqs.push(t),l.children.push(o),l.eqs.push(t)}let c,u=0,h=or;l.tolerance=this.tolerance,l.iterations=this.iterations;const d=lr;for(;c=ur(n);){h.length=0,d.bodies.length=0,dr(c,pr,d.bodies,h);const t=h.length;h=h.sort(fr);for(let e=0;e!==t;e++)l.addEquation(h[e]);l.solve(e,d),l.removeAllEquations(),u++}return u}}const ar=[],or=[],lr={bodies:[]},cr=R.STATIC;function ur(e){const t=e.length;for(let n=0;n!==t;n++){const t=e[n];if(!(t.visited||t.body.type&cr))return t}return!1}const hr=[];function dr(e,t,n,r){for(hr.push(e),e.visited=!0,t(e,n,r);hr.length;){const e=hr.pop();let i;for(;i=ur(e.children);)i.visited=!0,t(i,n,r),hr.push(i)}}function pr(e,t,n){t.push(e.body);const r=e.eqs.length;for(let t=0;t!==r;t++){const r=e.eqs[t];n.includes(r)||n.push(r)}}function fr(e,t){return t.id-e.id}class mr{constructor(){this.objects=[],this.type=Object}release(){const e=arguments.length;for(let t=0;t!==e;t++)this.objects.push(t<0||arguments.length<=t?void 0:arguments[t]);return this}get(){return 0===this.objects.length?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(e){const t=this.objects;for(;t.length>e;)t.pop();for(;t.length<e;)t.push(this.constructObject());return this}}class gr extends mr{constructor(){super(...arguments),this.type=a}constructObject(){return new a}}const yr={sphereSphere:x.types.SPHERE,spherePlane:x.types.SPHERE|x.types.PLANE,boxBox:x.types.BOX|x.types.BOX,sphereBox:x.types.SPHERE|x.types.BOX,planeBox:x.types.PLANE|x.types.BOX,convexConvex:x.types.CONVEXPOLYHEDRON,sphereConvex:x.types.SPHERE|x.types.CONVEXPOLYHEDRON,planeConvex:x.types.PLANE|x.types.CONVEXPOLYHEDRON,boxConvex:x.types.BOX|x.types.CONVEXPOLYHEDRON,sphereHeightfield:x.types.SPHERE|x.types.HEIGHTFIELD,boxHeightfield:x.types.BOX|x.types.HEIGHTFIELD,convexHeightfield:x.types.CONVEXPOLYHEDRON|x.types.HEIGHTFIELD,sphereParticle:x.types.PARTICLE|x.types.SPHERE,planeParticle:x.types.PLANE|x.types.PARTICLE,boxParticle:x.types.BOX|x.types.PARTICLE,convexParticle:x.types.PARTICLE|x.types.CONVEXPOLYHEDRON,cylinderCylinder:x.types.CYLINDER,sphereCylinder:x.types.SPHERE|x.types.CYLINDER,planeCylinder:x.types.PLANE|x.types.CYLINDER,boxCylinder:x.types.BOX|x.types.CYLINDER,convexCylinder:x.types.CONVEXPOLYHEDRON|x.types.CYLINDER,heightfieldCylinder:x.types.HEIGHTFIELD|x.types.CYLINDER,particleCylinder:x.types.PARTICLE|x.types.CYLINDER,sphereTrimesh:x.types.SPHERE|x.types.TRIMESH,planeTrimesh:x.types.PLANE|x.types.TRIMESH};class vr{get[yr.sphereSphere](){return this.sphereSphere}get[yr.spherePlane](){return this.spherePlane}get[yr.boxBox](){return this.boxBox}get[yr.sphereBox](){return this.sphereBox}get[yr.planeBox](){return this.planeBox}get[yr.convexConvex](){return this.convexConvex}get[yr.sphereConvex](){return this.sphereConvex}get[yr.planeConvex](){return this.planeConvex}get[yr.boxConvex](){return this.boxConvex}get[yr.sphereHeightfield](){return this.sphereHeightfield}get[yr.boxHeightfield](){return this.boxHeightfield}get[yr.convexHeightfield](){return this.convexHeightfield}get[yr.sphereParticle](){return this.sphereParticle}get[yr.planeParticle](){return this.planeParticle}get[yr.boxParticle](){return this.boxParticle}get[yr.convexParticle](){return this.convexParticle}get[yr.cylinderCylinder](){return this.convexConvex}get[yr.sphereCylinder](){return this.sphereConvex}get[yr.planeCylinder](){return this.planeConvex}get[yr.boxCylinder](){return this.boxConvex}get[yr.convexCylinder](){return this.convexConvex}get[yr.heightfieldCylinder](){return this.heightfieldCylinder}get[yr.particleCylinder](){return this.particleCylinder}get[yr.sphereTrimesh](){return this.sphereTrimesh}get[yr.planeTrimesh](){return this.planeTrimesh}constructor(e){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new gr,this.world=e,this.currentContactMaterial=e.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(e,t,n,r,i,s){let a;this.contactPointPool.length?(a=this.contactPointPool.pop(),a.bi=e,a.bj=t):a=new Ye(e,t),a.enabled=e.collisionResponse&&t.collisionResponse&&n.collisionResponse&&r.collisionResponse;const o=this.currentContactMaterial;a.restitution=o.restitution,a.setSpookParams(o.contactEquationStiffness,o.contactEquationRelaxation,this.world.dt);const l=n.material||e.material,c=r.material||t.material;return l&&c&&l.restitution>=0&&c.restitution>=0&&(a.restitution=l.restitution*c.restitution),a.si=i||n,a.sj=s||r,a}createFrictionEquationsFromContact(e,t){const n=e.bi,r=e.bj,i=e.si,s=e.sj,a=this.world,o=this.currentContactMaterial;let l=o.friction;const c=i.material||n.material,u=s.material||r.material;if(c&&u&&c.friction>=0&&u.friction>=0&&(l=c.friction*u.friction),l>0){const i=l*a.gravity.length();let s=n.invMass+r.invMass;s>0&&(s=1/s);const c=this.frictionEquationPool,u=c.length?c.pop():new vt(n,r,i*s),h=c.length?c.pop():new vt(n,r,i*s);return u.bi=h.bi=n,u.bj=h.bj=r,u.minForce=h.minForce=-i*s,u.maxForce=h.maxForce=i*s,u.ri.copy(e.ri),u.rj.copy(e.rj),h.ri.copy(e.ri),h.rj.copy(e.rj),e.ni.tangents(u.t,h.t),u.setSpookParams(o.frictionEquationStiffness,o.frictionEquationRelaxation,a.dt),h.setSpookParams(o.frictionEquationStiffness,o.frictionEquationRelaxation,a.dt),u.enabled=h.enabled=e.enabled,t.push(u,h),!0}return!1}createFrictionFromAverage(e){let t=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(t,this.frictionResult)||1===e)return;const n=this.frictionResult[this.frictionResult.length-2],r=this.frictionResult[this.frictionResult.length-1];xr.setZero(),br.setZero(),wr.setZero();const i=t.bi;t.bj;for(let n=0;n!==e;n++)t=this.result[this.result.length-1-n],t.bi!==i?(xr.vadd(t.ni,xr),br.vadd(t.ri,br),wr.vadd(t.rj,wr)):(xr.vsub(t.ni,xr),br.vadd(t.rj,br),wr.vadd(t.ri,wr));const s=1/e;br.scale(s,n.ri),wr.scale(s,n.rj),r.ri.copy(n.ri),r.rj.copy(n.rj),xr.normalize(),xr.tangents(n.t,r.t)}getContacts(e,t,n,r,i,s,a){this.contactPointPool=i,this.frictionEquationPool=a,this.result=r,this.frictionResult=s;const o=Mr,l=Tr,c=_r,u=Sr;for(let r=0,i=e.length;r!==i;r++){const i=e[r],s=t[r];let a=null;i.material&&s.material&&(a=n.getContactMaterial(i.material,s.material)||null);const h=i.type&R.KINEMATIC&&s.type&R.STATIC||i.type&R.STATIC&&s.type&R.KINEMATIC||i.type&R.KINEMATIC&&s.type&R.KINEMATIC;for(let e=0;e<i.shapes.length;e++){i.quaternion.mult(i.shapeOrientations[e],o),i.quaternion.vmult(i.shapeOffsets[e],c),c.vadd(i.position,c);const t=i.shapes[e];for(let e=0;e<s.shapes.length;e++){s.quaternion.mult(s.shapeOrientations[e],l),s.quaternion.vmult(s.shapeOffsets[e],u),u.vadd(s.position,u);const r=s.shapes[e];if(!(t.collisionFilterMask&r.collisionFilterGroup&&r.collisionFilterMask&t.collisionFilterGroup))continue;if(c.distanceTo(u)>t.boundingSphereRadius+r.boundingSphereRadius)continue;let d=null;t.material&&r.material&&(d=n.getContactMaterial(t.material,r.material)||null),this.currentContactMaterial=d||a||n.defaultContactMaterial;const p=this[t.type|r.type];if(p){let e=!1;e=t.type<r.type?p.call(this,t,r,c,u,o,l,i,s,t,r,h):p.call(this,r,t,u,c,l,o,s,i,t,r,h),e&&h&&(n.shapeOverlapKeeper.set(t.id,r.id),n.bodyOverlapKeeper.set(i.id,s.id))}}}}}sphereSphere(e,t,n,r,i,s,a,o,l,c,u){if(u)return n.distanceSquared(r)<(e.radius+t.radius)**2;const h=this.createContactEquation(a,o,e,t,l,c);r.vsub(n,h.ni),h.ni.normalize(),h.ri.copy(h.ni),h.rj.copy(h.ni),h.ri.scale(e.radius,h.ri),h.rj.scale(-t.radius,h.rj),h.ri.vadd(n,h.ri),h.ri.vsub(a.position,h.ri),h.rj.vadd(r,h.rj),h.rj.vsub(o.position,h.rj),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}spherePlane(e,t,n,r,i,s,a,o,l,c,u){const h=this.createContactEquation(a,o,e,t,l,c);if(h.ni.set(0,0,1),s.vmult(h.ni,h.ni),h.ni.negate(h.ni),h.ni.normalize(),h.ni.scale(e.radius,h.ri),n.vsub(r,Gr),h.ni.scale(h.ni.dot(Gr),Hr),Gr.vsub(Hr,h.rj),-Gr.dot(h.ni)<=e.radius){if(u)return!0;const e=h.ri,t=h.rj;e.vadd(n,e),e.vsub(a.position,e),t.vadd(r,t),t.vsub(o.position,t),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}}boxBox(e,t,n,r,i,s,a,o,l,c,u){return e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t.convexPolyhedronRepresentation,n,r,i,s,a,o,e,t,u)}sphereBox(e,t,n,r,i,s,a,o,l,c,u){const h=this.v3pool,d=ei;n.vsub(r,Kr),t.getSideNormals(d,s);const p=e.radius;let f=!1;const m=ni,g=ri,y=ii;let v=null,x=0,b=0,w=0,_=null;for(let e=0,t=d.length;e!==t&&!1===f;e++){const t=Zr;t.copy(d[e]);const n=t.length();t.normalize();const r=Kr.dot(t);if(r<n+p&&r>0){const i=Jr,s=Qr;i.copy(d[(e+1)%3]),s.copy(d[(e+2)%3]);const a=i.length(),o=s.length();i.normalize(),s.normalize();const l=Kr.dot(i),c=Kr.dot(s);if(l<a&&l>-a&&c<o&&c>-o){const e=Math.abs(r-n-p);if((null===_||e<_)&&(_=e,b=l,w=c,v=n,m.copy(t),g.copy(i),y.copy(s),x++,u))return!0}}}if(x){f=!0;const i=this.createContactEquation(a,o,e,t,l,c);m.scale(-p,i.ri),i.ni.copy(m),i.ni.negate(i.ni),m.scale(v,m),g.scale(b,g),m.vadd(g,m),y.scale(w,y),m.vadd(y,i.rj),i.ri.vadd(n,i.ri),i.ri.vsub(a.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(o.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}let S=h.get();const M=ti;for(let i=0;2!==i&&!f;i++)for(let s=0;2!==s&&!f;s++)for(let h=0;2!==h&&!f;h++)if(S.set(0,0,0),i?S.vadd(d[0],S):S.vsub(d[0],S),s?S.vadd(d[1],S):S.vsub(d[1],S),h?S.vadd(d[2],S):S.vsub(d[2],S),r.vadd(S,M),M.vsub(n,M),M.lengthSquared()<p*p){if(u)return!0;f=!0;const i=this.createContactEquation(a,o,e,t,l,c);i.ri.copy(M),i.ri.normalize(),i.ni.copy(i.ri),i.ri.scale(p,i.ri),i.rj.copy(S),i.ri.vadd(n,i.ri),i.ri.vsub(a.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(o.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}h.release(S),S=null;const T=h.get(),E=h.get(),A=h.get(),C=h.get(),I=h.get(),N=d.length;for(let i=0;i!==N&&!f;i++)for(let s=0;s!==N&&!f;s++)if(i%3!=s%3){d[s].cross(d[i],T),T.normalize(),d[i].vadd(d[s],E),A.copy(n),A.vsub(E,A),A.vsub(r,A);const h=A.dot(T);T.scale(h,C);let m=0;for(;m===i%3||m===s%3;)m++;I.copy(n),I.vsub(C,I),I.vsub(E,I),I.vsub(r,I);const g=Math.abs(h),y=I.length();if(g<d[m].length()&&y<p){if(u)return!0;f=!0;const i=this.createContactEquation(a,o,e,t,l,c);E.vadd(C,i.rj),i.rj.copy(i.rj),I.negate(i.ni),i.ni.normalize(),i.ri.copy(i.rj),i.ri.vadd(r,i.ri),i.ri.vsub(n,i.ri),i.ri.normalize(),i.ri.scale(p,i.ri),i.ri.vadd(n,i.ri),i.ri.vsub(a.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(o.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}h.release(T,E,A,C,I)}planeBox(e,t,n,r,i,s,a,o,l,c,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,t.convexPolyhedronRepresentation.id=t.id,this.planeConvex(e,t.convexPolyhedronRepresentation,n,r,i,s,a,o,e,t,u)}convexConvex(e,t,n,r,i,s,a,o,l,c,u,h,d){const p=xi;if(!(n.distanceTo(r)>e.boundingSphereRadius+t.boundingSphereRadius)&&e.findSeparatingAxis(t,n,i,r,s,p,h,d)){const h=[],d=bi;e.clipAgainstHull(n,i,t,r,s,p,-100,100,h);let f=0;for(let i=0;i!==h.length;i++){if(u)return!0;const s=this.createContactEquation(a,o,e,t,l,c),m=s.ri,g=s.rj;p.negate(s.ni),h[i].normal.negate(d),d.scale(h[i].depth,d),h[i].point.vadd(d,m),g.copy(h[i].point),m.vsub(n,m),g.vsub(r,g),m.vadd(n,m),m.vsub(a.position,m),g.vadd(r,g),g.vsub(o.position,g),this.result.push(s),f++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(s,this.frictionResult)}this.enableFrictionReduction&&f&&this.createFrictionFromAverage(f)}}sphereConvex(e,t,n,r,i,s,a,o,l,c,u){const h=this.v3pool;n.vsub(r,si);const d=t.faceNormals,p=t.faces,f=t.vertices,m=e.radius;let g=!1;for(let i=0;i!==f.length;i++){const h=f[i],d=ci;s.vmult(h,d),r.vadd(d,d);const p=li;if(d.vsub(n,p),p.lengthSquared()<m*m){if(u)return!0;g=!0;const i=this.createContactEquation(a,o,e,t,l,c);return i.ri.copy(p),i.ri.normalize(),i.ni.copy(i.ri),i.ri.scale(m,i.ri),d.vsub(r,i.rj),i.ri.vadd(n,i.ri),i.ri.vsub(a.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(o.position,i.rj),this.result.push(i),void this.createFrictionEquationsFromContact(i,this.frictionResult)}}for(let i=0,y=p.length;i!==y&&!1===g;i++){const y=d[i],v=p[i],x=ui;s.vmult(y,x);const b=hi;s.vmult(f[v[0]],b),b.vadd(r,b);const w=di;x.scale(-m,w),n.vadd(w,w);const _=pi;w.vsub(b,_);const S=_.dot(x),M=fi;if(n.vsub(b,M),S<0&&M.dot(x)>0){const i=[];for(let e=0,t=v.length;e!==t;e++){const t=h.get();s.vmult(f[v[e]],t),r.vadd(t,t),i.push(t)}if(Yr(i,x,n)){if(u)return!0;g=!0;const s=this.createContactEquation(a,o,e,t,l,c);x.scale(-m,s.ri),x.negate(s.ni);const d=h.get();x.scale(-S,d);const p=h.get();x.scale(-m,p),n.vsub(r,s.rj),s.rj.vadd(p,s.rj),s.rj.vadd(d,s.rj),s.rj.vadd(r,s.rj),s.rj.vsub(o.position,s.rj),s.ri.vadd(n,s.ri),s.ri.vsub(a.position,s.ri),h.release(d),h.release(p),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult);for(let e=0,t=i.length;e!==t;e++)h.release(i[e]);return}for(let d=0;d!==v.length;d++){const p=h.get(),g=h.get();s.vmult(f[v[(d+1)%v.length]],p),s.vmult(f[v[(d+2)%v.length]],g),r.vadd(p,p),r.vadd(g,g);const y=ai;g.vsub(p,y);const x=oi;y.unit(x);const b=h.get(),w=h.get();n.vsub(p,w);const _=w.dot(x);x.scale(_,b),b.vadd(p,b);const S=h.get();if(b.vsub(n,S),_>0&&_*_<y.lengthSquared()&&S.lengthSquared()<m*m){if(u)return!0;const s=this.createContactEquation(a,o,e,t,l,c);b.vsub(r,s.rj),b.vsub(n,s.ni),s.ni.normalize(),s.ni.scale(m,s.ri),s.rj.vadd(r,s.rj),s.rj.vsub(o.position,s.rj),s.ri.vadd(n,s.ri),s.ri.vsub(a.position,s.ri),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult);for(let e=0,t=i.length;e!==t;e++)h.release(i[e]);return h.release(p),h.release(g),h.release(b),h.release(S),void h.release(w)}h.release(p),h.release(g),h.release(b),h.release(S),h.release(w)}for(let e=0,t=i.length;e!==t;e++)h.release(i[e])}}}planeConvex(e,t,n,r,i,s,a,o,l,c,u){const h=mi,d=gi;d.set(0,0,1),i.vmult(d,d);let p=0;const f=yi;for(let i=0;i!==t.vertices.length;i++)if(h.copy(t.vertices[i]),s.vmult(h,h),r.vadd(h,h),h.vsub(n,f),d.dot(f)<=0){if(u)return!0;const i=this.createContactEquation(a,o,e,t,l,c),s=vi;d.scale(d.dot(f),s),h.vsub(s,s),s.vsub(n,i.ri),i.ni.copy(d),h.vsub(r,i.rj),i.ri.vadd(n,i.ri),i.ri.vsub(a.position,i.ri),i.rj.vadd(r,i.rj),i.rj.vsub(o.position,i.rj),this.result.push(i),p++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(i,this.frictionResult)}this.enableFrictionReduction&&p&&this.createFrictionFromAverage(p)}boxConvex(e,t,n,r,i,s,a,o,l,c,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t,n,r,i,s,a,o,e,t,u)}sphereHeightfield(e,t,n,r,i,s,a,o,l,c,u){const h=t.data,d=e.radius,p=t.elementSize,f=Li,m=Di;b.pointToLocalFrame(r,s,n,m);let g=Math.floor((m.x-d)/p)-1,y=Math.ceil((m.x+d)/p)+1,v=Math.floor((m.y-d)/p)-1,x=Math.ceil((m.y+d)/p)+1;if(y<0||x<0||g>h.length||v>h[0].length)return;g<0&&(g=0),y<0&&(y=0),v<0&&(v=0),x<0&&(x=0),g>=h.length&&(g=h.length-1),y>=h.length&&(y=h.length-1),x>=h[0].length&&(x=h[0].length-1),v>=h[0].length&&(v=h[0].length-1);const w=[];t.getRectMinMax(g,v,y,x,w);const _=w[0],S=w[1];if(m.z-d>S||m.z+d<_)return;const M=this.result;for(let l=g;l<y;l++)for(let c=v;c<x;c++){const h=M.length;let d=!1;if(t.getConvexTrianglePillar(l,c,!1),b.pointToWorldFrame(r,s,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(d=this.sphereConvex(e,t.pillarConvex,n,f,i,s,a,o,e,t,u)),u&&d)return!0;if(t.getConvexTrianglePillar(l,c,!0),b.pointToWorldFrame(r,s,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(d=this.sphereConvex(e,t.pillarConvex,n,f,i,s,a,o,e,t,u)),u&&d)return!0;if(M.length-h>2)return}}boxHeightfield(e,t,n,r,i,s,a,o,l,c,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexHeightfield(e.convexPolyhedronRepresentation,t,n,r,i,s,a,o,e,t,u)}convexHeightfield(e,t,n,r,i,s,a,o,l,c,u){const h=t.data,d=t.elementSize,p=e.boundingSphereRadius,f=ki,m=Ri,g=Ni;b.pointToLocalFrame(r,s,n,g);let y=Math.floor((g.x-p)/d)-1,v=Math.ceil((g.x+p)/d)+1,x=Math.floor((g.y-p)/d)-1,w=Math.ceil((g.y+p)/d)+1;if(v<0||w<0||y>h.length||x>h[0].length)return;y<0&&(y=0),v<0&&(v=0),x<0&&(x=0),w<0&&(w=0),y>=h.length&&(y=h.length-1),v>=h.length&&(v=h.length-1),w>=h[0].length&&(w=h[0].length-1),x>=h[0].length&&(x=h[0].length-1);const _=[];t.getRectMinMax(y,x,v,w,_);const S=_[0],M=_[1];if(!(g.z-p>M||g.z+p<S))for(let l=y;l<v;l++)for(let c=x;c<w;c++){let h=!1;if(t.getConvexTrianglePillar(l,c,!1),b.pointToWorldFrame(r,s,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(h=this.convexConvex(e,t.pillarConvex,n,f,i,s,a,o,null,null,u,m,null)),u&&h)return!0;if(t.getConvexTrianglePillar(l,c,!0),b.pointToWorldFrame(r,s,t.pillarOffset,f),n.distanceTo(f)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(h=this.convexConvex(e,t.pillarConvex,n,f,i,s,a,o,null,null,u,m,null)),u&&h)return!0}}sphereParticle(e,t,n,r,i,s,a,o,l,c,u){const h=Mi;if(h.set(0,0,1),r.vsub(n,h),h.lengthSquared()<=e.radius*e.radius){if(u)return!0;const n=this.createContactEquation(o,a,t,e,l,c);h.normalize(),n.rj.copy(h),n.rj.scale(e.radius,n.rj),n.ni.copy(h),n.ni.negate(n.ni),n.ri.set(0,0,0),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}planeParticle(e,t,n,r,i,s,a,o,l,c,u){const h=wi;h.set(0,0,1),a.quaternion.vmult(h,h);const d=_i;if(r.vsub(a.position,d),h.dot(d)<=0){if(u)return!0;const n=this.createContactEquation(o,a,t,e,l,c);n.ni.copy(h),n.ni.negate(n.ni),n.ri.set(0,0,0);const i=Si;h.scale(h.dot(r),i),r.vsub(i,i),n.rj.copy(i),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}boxParticle(e,t,n,r,i,s,a,o,l,c,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexParticle(e.convexPolyhedronRepresentation,t,n,r,i,s,a,o,e,t,u)}convexParticle(e,t,n,r,i,s,a,o,l,c,u){let h=-1;const d=Ai,p=Ii;let f=null;const m=Ei;if(m.copy(r),m.vsub(n,m),i.conjugate(Ti),Ti.vmult(m,m),e.pointIsInside(m)){e.worldVerticesNeedsUpdate&&e.computeWorldVertices(n,i),e.worldFaceNormalsNeedsUpdate&&e.computeWorldFaceNormals(i);for(let t=0,n=e.faces.length;t!==n;t++){const n=[e.worldVertices[e.faces[t][0]]],i=e.worldFaceNormals[t];r.vsub(n[0],Ci);const s=-i.dot(Ci);if(null===f||Math.abs(s)<Math.abs(f)){if(u)return!0;f=s,h=t,d.copy(i)}}if(-1!==h){const i=this.createContactEquation(o,a,t,e,l,c);d.scale(f,p),p.vadd(r,p),p.vsub(n,p),i.rj.copy(p),d.negate(i.ni),i.ri.set(0,0,0);const s=i.ri,u=i.rj;s.vadd(r,s),s.vsub(o.position,s),u.vadd(n,u),u.vsub(a.position,u),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(e,t,n,r,i,s,a,o,l,c,u){return this.convexHeightfield(t,e,r,n,s,i,o,a,l,c,u)}particleCylinder(e,t,n,r,i,s,a,o,l,c,u){return this.convexParticle(t,e,r,n,s,i,o,a,l,c,u)}sphereTrimesh(e,t,n,r,i,s,a,o,l,c,u){const h=Dr,d=Lr,p=Fr,f=Pr,m=Or,g=zr,y=Vr,v=Rr,x=Nr,w=Wr;b.pointToLocalFrame(r,s,n,m);const _=e.radius;y.lowerBound.set(m.x-_,m.y-_,m.z-_),y.upperBound.set(m.x+_,m.y+_,m.z+_),t.getTrianglesInAABB(y,w);const S=kr,M=e.radius*e.radius;for(let i=0;i<w.length;i++)for(let h=0;h<3;h++)if(t.getVertex(t.indices[3*w[i]+h],S),S.vsub(m,x),x.lengthSquared()<=M){if(v.copy(S),b.pointToWorldFrame(r,s,v,S),S.vsub(n,x),u)return!0;let i=this.createContactEquation(a,o,e,t,l,c);i.ni.copy(x),i.ni.normalize(),i.ri.copy(i.ni),i.ri.scale(e.radius,i.ri),i.ri.vadd(n,i.ri),i.ri.vsub(a.position,i.ri),i.rj.copy(S),i.rj.vsub(o.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}for(let i=0;i<w.length;i++)for(let y=0;y<3;y++){t.getVertex(t.indices[3*w[i]+y],h),t.getVertex(t.indices[3*w[i]+(y+1)%3],d),d.vsub(h,p),m.vsub(d,g);const v=g.dot(p);m.vsub(h,g);let x=g.dot(p);if(x>0&&v<0&&(m.vsub(h,g),f.copy(p),f.normalize(),x=g.dot(f),f.scale(x,g),g.vadd(h,g),g.distanceTo(m)<e.radius)){if(u)return!0;const i=this.createContactEquation(a,o,e,t,l,c);g.vsub(m,i.ni),i.ni.normalize(),i.ni.scale(e.radius,i.ri),i.ri.vadd(n,i.ri),i.ri.vsub(a.position,i.ri),b.pointToWorldFrame(r,s,g,g),g.vsub(o.position,i.rj),b.vectorToWorldFrame(s,i.ni,i.ni),b.vectorToWorldFrame(s,i.ri,i.ri),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}const T=Br,E=Ur,A=$r,C=Ir;for(let i=0,h=w.length;i!==h;i++){t.getTriangleVertices(w[i],T,E,A),t.getNormal(w[i],C),m.vsub(T,g);let h=g.dot(C);if(C.scale(h,g),m.vsub(g,g),h=g.distanceTo(m),ce.pointInTriangle(g,T,E,A)&&h<e.radius){if(u)return!0;let i=this.createContactEquation(a,o,e,t,l,c);g.vsub(m,i.ni),i.ni.normalize(),i.ni.scale(e.radius,i.ri),i.ri.vadd(n,i.ri),i.ri.vsub(a.position,i.ri),b.pointToWorldFrame(r,s,g,g),g.vsub(o.position,i.rj),b.vectorToWorldFrame(s,i.ni,i.ni),b.vectorToWorldFrame(s,i.ri,i.ri),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}w.length=0}planeTrimesh(e,t,n,r,i,s,o,l,c,u,h){const d=new a,p=Er;p.set(0,0,1),i.vmult(p,p);for(let i=0;i<t.vertices.length/3;i++){t.getVertex(i,d);const f=new a;f.copy(d),b.pointToWorldFrame(r,s,f,d);const m=Ar;if(d.vsub(n,m),p.dot(m)<=0){if(h)return!0;const n=this.createContactEquation(o,l,e,t,c,u);n.ni.copy(p);const r=Cr;p.scale(m.dot(p),r),d.vsub(r,r),n.ri.copy(r),n.ri.vsub(o.position,n.ri),n.rj.copy(d),n.rj.vsub(l.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}}}const xr=new a,br=new a,wr=new a,_r=new a,Sr=new a,Mr=new m,Tr=new m,Er=new a,Ar=new a,Cr=new a,Ir=new a,Nr=new a;new a;const kr=new a,Rr=new a,Dr=new a,Lr=new a,Fr=new a,Pr=new a,Or=new a,zr=new a,Br=new a,Ur=new a,$r=new a,Vr=new u,Wr=[],Gr=new a,Hr=new a,jr=new a,qr=new a,Xr=new a;function Yr(e,t,n){let r=null;const i=e.length;for(let s=0;s!==i;s++){const a=e[s],o=jr;e[(s+1)%i].vsub(a,o);const l=qr;o.cross(t,l);const c=Xr;n.vsub(a,c);const u=l.dot(c);if(!(null===r||u>0&&!0===r||u<=0&&!1===r))return!1;null===r&&(r=u>0)}return!0}const Kr=new a,Zr=new a,Jr=new a,Qr=new a,ei=[new a,new a,new a,new a,new a,new a],ti=new a,ni=new a,ri=new a,ii=new a,si=new a,ai=new a,oi=new a,li=new a,ci=new a,ui=new a,hi=new a,di=new a,pi=new a,fi=new a;new a,new a;const mi=new a,gi=new a,yi=new a,vi=new a,xi=new a,bi=new a,wi=new a,_i=new a,Si=new a,Mi=new a,Ti=new m,Ei=new a;new a;const Ai=new a,Ci=new a,Ii=new a,Ni=new a,ki=new a,Ri=[0],Di=new a,Li=new a;class Fi{constructor(){this.current=[],this.previous=[]}getKey(e,t){if(t<e){const n=t;t=e,e=n}return e<<16|t}set(e,t){const n=this.getKey(e,t),r=this.current;let i=0;for(;n>r[i];)i++;if(n!==r[i]){for(let e=r.length-1;e>=i;e--)r[e+1]=r[e];r[i]=n}}tick(){const e=this.current;this.current=this.previous,this.previous=e,this.current.length=0}getDiff(e,t){const n=this.current,r=this.previous,i=n.length,s=r.length;let a=0;for(let t=0;t<i;t++){let i=!1;const s=n[t];for(;s>r[a];)a++;i=s===r[a],i||Pi(e,s)}a=0;for(let e=0;e<s;e++){let i=!1;const s=r[e];for(;s>n[a];)a++;i=n[a]===s,i||Pi(t,s)}}}function Pi(e,t){e.push((4294901760&t)>>16,65535&t)}const Oi=(e,t)=>e<t?`${e}-${t}`:`${t}-${e}`;class zi{constructor(){this.data={keys:[]}}get(e,t){const n=Oi(e,t);return this.data[n]}set(e,t,n){const r=Oi(e,t);this.get(e,t)||this.data.keys.push(r),this.data[r]=n}delete(e,t){const n=Oi(e,t),r=this.data.keys.indexOf(n);-1!==r&&this.data.keys.splice(r,1),delete this.data[n]}reset(){const e=this.data,t=e.keys;for(;t.length>0;)delete e[t.pop()]}}class Bi extends f{constructor(e){void 0===e&&(e={}),super(),this.dt=-1,this.allowSleep=!!e.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=void 0!==e.quatNormalizeSkip?e.quatNormalizeSkip:0,this.quatNormalizeFast=void 0!==e.quatNormalizeFast&&e.quatNormalizeFast,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new a,e.gravity&&this.gravity.copy(e.gravity),this.broadphase=void 0!==e.broadphase?e.broadphase:new Q,this.bodies=[],this.hasActiveBodies=!1,this.solver=void 0!==e.solver?e.solver:new tr,this.constraints=[],this.narrowphase=new vr(this),this.collisionMatrix=new p,this.collisionMatrixPrevious=new p,this.bodyOverlapKeeper=new Fi,this.shapeOverlapKeeper=new Fi,this.contactmaterials=[],this.contactMaterialTable=new zi,this.defaultMaterial=new _t("default"),this.defaultContactMaterial=new wt(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(e,t){return this.contactMaterialTable.get(e.id,t.id)}collisionMatrixTick(){const e=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=e,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(e){this.constraints.push(e)}removeConstraint(e){const t=this.constraints.indexOf(e);-1!==t&&this.constraints.splice(t,1)}rayTest(e,t,n){n instanceof ee?this.raycastClosest(e,t,{skipBackfaces:!0},n):this.raycastAll(e,t,{skipBackfaces:!0},n)}raycastAll(e,t,n,r){return void 0===n&&(n={}),n.mode=ce.ALL,n.from=e,n.to=t,n.callback=r,Ui.intersectWorld(this,n)}raycastAny(e,t,n,r){return void 0===n&&(n={}),n.mode=ce.ANY,n.from=e,n.to=t,n.result=r,Ui.intersectWorld(this,n)}raycastClosest(e,t,n,r){return void 0===n&&(n={}),n.mode=ce.CLOSEST,n.from=e,n.to=t,n.result=r,Ui.intersectWorld(this,n)}addBody(e){this.bodies.includes(e)||(e.index=this.bodies.length,this.bodies.push(e),e.world=this,e.initPosition.copy(e.position),e.initVelocity.copy(e.velocity),e.timeLastSleepy=this.time,e instanceof R&&(e.initAngularVelocity.copy(e.angularVelocity),e.initQuaternion.copy(e.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=e,this.idToBodyMap[e.id]=e,this.dispatchEvent(this.addBodyEvent))}removeBody(e){e.world=null;const t=this.bodies.length-1,n=this.bodies,r=n.indexOf(e);if(-1!==r){n.splice(r,1);for(let e=0;e!==n.length;e++)n[e].index=e;this.collisionMatrix.setNumObjects(t),this.removeBodyEvent.body=e,delete this.idToBodyMap[e.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(e){return this.idToBodyMap[e]}getShapeById(e){const t=this.bodies;for(let n=0;n<t.length;n++){const r=t[n].shapes;for(let t=0;t<r.length;t++){const n=r[t];if(n.id===e)return n}}return null}addContactMaterial(e){this.contactmaterials.push(e),this.contactMaterialTable.set(e.materials[0].id,e.materials[1].id,e)}removeContactMaterial(e){const t=this.contactmaterials.indexOf(e);-1!==t&&(this.contactmaterials.splice(t,1),this.contactMaterialTable.delete(e.materials[0].id,e.materials[1].id))}fixedStep(e,t){void 0===e&&(e=1/60),void 0===t&&(t=10);const n=$i.now()/1e3;if(this.lastCallTime){const r=n-this.lastCallTime;this.step(e,r,t)}else this.step(e,void 0,t);this.lastCallTime=n}step(e,t,n){if(void 0===n&&(n=10),void 0===t)this.internalStep(e),this.time+=e;else{this.accumulator+=t;const r=$i.now();let i=0;for(;this.accumulator>=e&&i<n&&(this.internalStep(e),this.accumulator-=e,i++,!($i.now()-r>1e3*e)););this.accumulator=this.accumulator%e;const s=this.accumulator/e;for(let e=0;e!==this.bodies.length;e++){const t=this.bodies[e];t.previousPosition.lerp(t.position,s,t.interpolatedPosition),t.previousQuaternion.slerp(t.quaternion,s,t.interpolatedQuaternion),t.previousQuaternion.normalize()}this.time+=t}}internalStep(e){this.dt=e;const t=this.contacts,n=qi,r=Xi,i=this.bodies.length,s=this.bodies,a=this.solver,o=this.gravity,l=this.doProfiling,c=this.profile,u=R.DYNAMIC;let h=-1/0;const d=this.constraints,p=ji;o.length();const f=o.x,m=o.y,g=o.z;let y=0;for(l&&(h=$i.now()),y=0;y!==i;y++){const e=s[y];if(e.type===u){const t=e.force,n=e.mass;t.x+=n*f,t.y+=n*m,t.z+=n*g}}for(let e=0,t=this.subsystems.length;e!==t;e++)this.subsystems[e].update();l&&(h=$i.now()),n.length=0,r.length=0,this.broadphase.collisionPairs(this,n,r),l&&(c.broadphase=$i.now()-h);let v=d.length;for(y=0;y!==v;y++){const e=d[y];if(!e.collideConnected)for(let t=n.length-1;t>=0;t-=1)(e.bodyA===n[t]&&e.bodyB===r[t]||e.bodyB===n[t]&&e.bodyA===r[t])&&(n.splice(t,1),r.splice(t,1))}this.collisionMatrixTick(),l&&(h=$i.now());const x=Hi,b=t.length;for(y=0;y!==b;y++)x.push(t[y]);t.length=0;const w=this.frictionEquations.length;for(y=0;y!==w;y++)p.push(this.frictionEquations[y]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(n,r,this,t,x,this.frictionEquations,p),l&&(c.narrowphase=$i.now()-h),l&&(h=$i.now()),y=0;y<this.frictionEquations.length;y++)a.addEquation(this.frictionEquations[y]);const _=t.length;for(let e=0;e!==_;e++){const n=t[e],r=n.bi,i=n.bj,s=n.si,o=n.sj;let l;l=r.material&&i.material&&this.getContactMaterial(r.material,i.material)||this.defaultContactMaterial,l.friction,r.material&&i.material&&(r.material.friction>=0&&i.material.friction>=0&&(r.material.friction,i.material.friction),r.material.restitution>=0&&i.material.restitution>=0&&(n.restitution=r.material.restitution*i.material.restitution)),a.addEquation(n),r.allowSleep&&r.type===R.DYNAMIC&&r.sleepState===R.SLEEPING&&i.sleepState===R.AWAKE&&i.type!==R.STATIC&&i.velocity.lengthSquared()+i.angularVelocity.lengthSquared()>=2*i.sleepSpeedLimit**2&&(r.wakeUpAfterNarrowphase=!0),i.allowSleep&&i.type===R.DYNAMIC&&i.sleepState===R.SLEEPING&&r.sleepState===R.AWAKE&&r.type!==R.STATIC&&r.velocity.lengthSquared()+r.angularVelocity.lengthSquared()>=2*r.sleepSpeedLimit**2&&(i.wakeUpAfterNarrowphase=!0),this.collisionMatrix.set(r,i,!0),this.collisionMatrixPrevious.get(r,i)||(Gi.body=i,Gi.contact=n,r.dispatchEvent(Gi),Gi.body=r,i.dispatchEvent(Gi)),this.bodyOverlapKeeper.set(r.id,i.id),this.shapeOverlapKeeper.set(s.id,o.id)}for(this.emitContactEvents(),l&&(c.makeContactConstraints=$i.now()-h,h=$i.now()),y=0;y!==i;y++){const e=s[y];e.wakeUpAfterNarrowphase&&(e.wakeUp(),e.wakeUpAfterNarrowphase=!1)}for(v=d.length,y=0;y!==v;y++){const e=d[y];e.update();for(let t=0,n=e.equations.length;t!==n;t++){const n=e.equations[t];a.addEquation(n)}}a.solve(e,this),l&&(c.solve=$i.now()-h),a.removeAllEquations();const S=Math.pow;for(y=0;y!==i;y++){const t=s[y];if(t.type&u){const n=S(1-t.linearDamping,e),r=t.velocity;r.scale(n,r);const i=t.angularVelocity;if(i){const n=S(1-t.angularDamping,e);i.scale(n,i)}}}this.dispatchEvent(Wi),l&&(h=$i.now());const M=this.stepnumber%(this.quatNormalizeSkip+1)==0,T=this.quatNormalizeFast;for(y=0;y!==i;y++)s[y].integrate(e,M,T);this.clearForces(),this.broadphase.dirty=!0,l&&(c.integrate=$i.now()-h),this.stepnumber+=1,this.dispatchEvent(Vi);let E=!0;if(this.allowSleep)for(E=!1,y=0;y!==i;y++){const e=s[y];e.sleepTick(this.time),e.sleepState!==R.SLEEPING&&(E=!0)}this.hasActiveBodies=E}emitContactEvents(){const e=this.hasAnyEventListener("beginContact"),t=this.hasAnyEventListener("endContact");if((e||t)&&this.bodyOverlapKeeper.getDiff(Yi,Ki),e){for(let e=0,t=Yi.length;e<t;e+=2)Zi.bodyA=this.getBodyById(Yi[e]),Zi.bodyB=this.getBodyById(Yi[e+1]),this.dispatchEvent(Zi);Zi.bodyA=Zi.bodyB=null}if(t){for(let e=0,t=Ki.length;e<t;e+=2)Ji.bodyA=this.getBodyById(Ki[e]),Ji.bodyB=this.getBodyById(Ki[e+1]),this.dispatchEvent(Ji);Ji.bodyA=Ji.bodyB=null}Yi.length=Ki.length=0;const n=this.hasAnyEventListener("beginShapeContact"),r=this.hasAnyEventListener("endShapeContact");if((n||r)&&this.shapeOverlapKeeper.getDiff(Yi,Ki),n){for(let e=0,t=Yi.length;e<t;e+=2){const t=this.getShapeById(Yi[e]),n=this.getShapeById(Yi[e+1]);Qi.shapeA=t,Qi.shapeB=n,t&&(Qi.bodyA=t.body),n&&(Qi.bodyB=n.body),this.dispatchEvent(Qi)}Qi.bodyA=Qi.bodyB=Qi.shapeA=Qi.shapeB=null}if(r){for(let e=0,t=Ki.length;e<t;e+=2){const t=this.getShapeById(Ki[e]),n=this.getShapeById(Ki[e+1]);es.shapeA=t,es.shapeB=n,t&&(es.bodyA=t.body),n&&(es.bodyB=n.body),this.dispatchEvent(es)}es.bodyA=es.bodyB=es.shapeA=es.shapeB=null}}clearForces(){const e=this.bodies,t=e.length;for(let n=0;n!==t;n++){const t=e[n];t.force,t.torque,t.force.set(0,0,0),t.torque.set(0,0,0)}}}new u;const Ui=new ce,$i=globalThis.performance||{};if(!$i.now){let e=Date.now();$i.timing&&$i.timing.navigationStart&&(e=$i.timing.navigationStart),$i.now=()=>Date.now()-e}new a;const Vi={type:"postStep"},Wi={type:"preStep"},Gi={type:R.COLLIDE_EVENT_NAME,body:null,contact:null},Hi=[],ji=[],qi=[],Xi=[],Yi=[],Ki=[],Zi={type:"beginContact",bodyA:null,bodyB:null},Ji={type:"endContact",bodyA:null,bodyB:null},Qi={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},es={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null}},5426:(e,t,n)=>{"use strict";n.d(t,{Z:()=>o});var r=n(8081),i=n.n(r),s=n(3645),a=n.n(s)()(i());a.push([e.id,"* {\n  box-sizing: border-box;\n  padding: 0;\n  margin: 0;\n}\n\n#blocker {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, 0.5);\n}\n\n#instructions {\n  width: 100%;\n  height: 100%;\n\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n\n  text-align: center;\n  font-size: 14px;\n  cursor: pointer;\n}\n#aim {\n  display: none;\n  position: absolute;\n  border: 3px solid red;\n  width: 16px;\n  height: 16px;\n  border-radius: 50%;\n  top: calc(50% - 8px);\n  left: calc(50% - 8px);\n  z-index: 1;\n}\n",""]);const o=a},3645:e=>{"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",r=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),r&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),r&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,r,i,s){"string"==typeof e&&(e=[[null,e,void 0]]);var a={};if(r)for(var o=0;o<this.length;o++){var l=this[o][0];null!=l&&(a[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&a[u[0]]||(void 0!==s&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=s),n&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=n):u[2]=n),i&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=i):u[4]="".concat(i)),t.push(u))}},t}},8081:e=>{"use strict";e.exports=function(e){return e[1]}},4029:(e,t,n)=>{"use strict";var r=n(5320),i=Object.prototype.toString,s=Object.prototype.hasOwnProperty,a=function(e,t,n){for(var r=0,i=e.length;r<i;r++)s.call(e,r)&&(null==n?t(e[r],r,e):t.call(n,e[r],r,e))},o=function(e,t,n){for(var r=0,i=e.length;r<i;r++)null==n?t(e.charAt(r),r,e):t.call(n,e.charAt(r),r,e)},l=function(e,t,n){for(var r in e)s.call(e,r)&&(null==n?t(e[r],r,e):t.call(n,e[r],r,e))};e.exports=function(e,t,n){if(!r(t))throw new TypeError("iterator must be a function");var s;arguments.length>=3&&(s=n),"[object Array]"===i.call(e)?a(e,t,s):"string"==typeof e?o(e,t,s):l(e,t,s)}},7648:e=>{"use strict";var t="Function.prototype.bind called on incompatible ",n=Array.prototype.slice,r=Object.prototype.toString,i="[object Function]";e.exports=function(e){var s=this;if("function"!=typeof s||r.call(s)!==i)throw new TypeError(t+s);for(var a,o=n.call(arguments,1),l=function(){if(this instanceof a){var t=s.apply(this,o.concat(n.call(arguments)));return Object(t)===t?t:this}return s.apply(e,o.concat(n.call(arguments)))},c=Math.max(0,s.length-o.length),u=[],h=0;h<c;h++)u.push("$"+h);if(a=Function("binder","return function ("+u.join(",")+"){ return binder.apply(this,arguments); }")(l),s.prototype){var d=function(){};d.prototype=s.prototype,a.prototype=new d,d.prototype=null}return a}},8612:(e,t,n)=>{"use strict";var r=n(7648);e.exports=Function.prototype.bind||r},210:(e,t,n)=>{"use strict";var r,i=SyntaxError,s=Function,a=TypeError,o=function(e){try{return s('"use strict"; return ('+e+").constructor;")()}catch(e){}},l=Object.getOwnPropertyDescriptor;if(l)try{l({},"")}catch(e){l=null}var c=function(){throw new a},u=l?function(){try{return c}catch(e){try{return l(arguments,"callee").get}catch(e){return c}}}():c,h=n(5295)(),d=Object.getPrototypeOf||function(e){return e.__proto__},p={},f="undefined"==typeof Uint8Array?r:d(Uint8Array),m={"%AggregateError%":"undefined"==typeof AggregateError?r:AggregateError,"%Array%":Array,"%ArrayBuffer%":"undefined"==typeof ArrayBuffer?r:ArrayBuffer,"%ArrayIteratorPrototype%":h?d([][Symbol.iterator]()):r,"%AsyncFromSyncIteratorPrototype%":r,"%AsyncFunction%":p,"%AsyncGenerator%":p,"%AsyncGeneratorFunction%":p,"%AsyncIteratorPrototype%":p,"%Atomics%":"undefined"==typeof Atomics?r:Atomics,"%BigInt%":"undefined"==typeof BigInt?r:BigInt,"%Boolean%":Boolean,"%DataView%":"undefined"==typeof DataView?r:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":Error,"%eval%":eval,"%EvalError%":EvalError,"%Float32Array%":"undefined"==typeof Float32Array?r:Float32Array,"%Float64Array%":"undefined"==typeof Float64Array?r:Float64Array,"%FinalizationRegistry%":"undefined"==typeof FinalizationRegistry?r:FinalizationRegistry,"%Function%":s,"%GeneratorFunction%":p,"%Int8Array%":"undefined"==typeof Int8Array?r:Int8Array,"%Int16Array%":"undefined"==typeof Int16Array?r:Int16Array,"%Int32Array%":"undefined"==typeof Int32Array?r:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":h?d(d([][Symbol.iterator]())):r,"%JSON%":"object"==typeof JSON?JSON:r,"%Map%":"undefined"==typeof Map?r:Map,"%MapIteratorPrototype%":"undefined"!=typeof Map&&h?d((new Map)[Symbol.iterator]()):r,"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":"undefined"==typeof Promise?r:Promise,"%Proxy%":"undefined"==typeof Proxy?r:Proxy,"%RangeError%":RangeError,"%ReferenceError%":ReferenceError,"%Reflect%":"undefined"==typeof Reflect?r:Reflect,"%RegExp%":RegExp,"%Set%":"undefined"==typeof Set?r:Set,"%SetIteratorPrototype%":"undefined"!=typeof Set&&h?d((new Set)[Symbol.iterator]()):r,"%SharedArrayBuffer%":"undefined"==typeof SharedArrayBuffer?r:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":h?d(""[Symbol.iterator]()):r,"%Symbol%":h?Symbol:r,"%SyntaxError%":i,"%ThrowTypeError%":u,"%TypedArray%":f,"%TypeError%":a,"%Uint8Array%":"undefined"==typeof Uint8Array?r:Uint8Array,"%Uint8ClampedArray%":"undefined"==typeof Uint8ClampedArray?r:Uint8ClampedArray,"%Uint16Array%":"undefined"==typeof Uint16Array?r:Uint16Array,"%Uint32Array%":"undefined"==typeof Uint32Array?r:Uint32Array,"%URIError%":URIError,"%WeakMap%":"undefined"==typeof WeakMap?r:WeakMap,"%WeakRef%":"undefined"==typeof WeakRef?r:WeakRef,"%WeakSet%":"undefined"==typeof WeakSet?r:WeakSet},g=function e(t){var n;if("%AsyncFunction%"===t)n=o("async function () {}");else if("%GeneratorFunction%"===t)n=o("function* () {}");else if("%AsyncGeneratorFunction%"===t)n=o("async function* () {}");else if("%AsyncGenerator%"===t){var r=e("%AsyncGeneratorFunction%");r&&(n=r.prototype)}else if("%AsyncIteratorPrototype%"===t){var i=e("%AsyncGenerator%");i&&(n=d(i.prototype))}return m[t]=n,n},y={"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},v=n(8612),x=n(7642),b=v.call(Function.call,Array.prototype.concat),w=v.call(Function.apply,Array.prototype.splice),_=v.call(Function.call,String.prototype.replace),S=v.call(Function.call,String.prototype.slice),M=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,T=/\\(\\)?/g,E=function(e){var t=S(e,0,1),n=S(e,-1);if("%"===t&&"%"!==n)throw new i("invalid intrinsic syntax, expected closing `%`");if("%"===n&&"%"!==t)throw new i("invalid intrinsic syntax, expected opening `%`");var r=[];return _(e,M,(function(e,t,n,i){r[r.length]=n?_(i,T,"$1"):t||e})),r},A=function(e,t){var n,r=e;if(x(y,r)&&(r="%"+(n=y[r])[0]+"%"),x(m,r)){var s=m[r];if(s===p&&(s=g(r)),void 0===s&&!t)throw new a("intrinsic "+e+" exists, but is not available. Please file an issue!");return{alias:n,name:r,value:s}}throw new i("intrinsic "+e+" does not exist!")};e.exports=function(e,t){if("string"!=typeof e||0===e.length)throw new a("intrinsic name must be a non-empty string");if(arguments.length>1&&"boolean"!=typeof t)throw new a('"allowMissing" argument must be a boolean');var n=E(e),r=n.length>0?n[0]:"",s=A("%"+r+"%",t),o=s.name,c=s.value,u=!1,h=s.alias;h&&(r=h[0],w(n,b([0,1],h)));for(var d=1,p=!0;d<n.length;d+=1){var f=n[d],g=S(f,0,1),y=S(f,-1);if(('"'===g||"'"===g||"`"===g||'"'===y||"'"===y||"`"===y)&&g!==y)throw new i("property names with quotes must have matching quotes");if("constructor"!==f&&p||(u=!0),x(m,o="%"+(r+="."+f)+"%"))c=m[o];else if(null!=c){if(!(f in c)){if(!t)throw new a("base intrinsic for "+e+" exists, but the property is not available.");return}if(l&&d+1>=n.length){var v=l(c,f);c=(p=!!v)&&"get"in v&&!("originalValue"in v.get)?v.get:c[f]}else p=x(c,f),c=c[f];p&&!u&&(m[o]=c)}}return c}},5295:(e,t,n)=>{"use strict";var r="undefined"!=typeof Symbol&&Symbol,i=n(5419);e.exports=function(){return"function"==typeof r&&"function"==typeof Symbol&&"symbol"==typeof r("foo")&&"symbol"==typeof Symbol("bar")&&i()}},5419:e=>{"use strict";e.exports=function(){if("function"!=typeof Symbol||"function"!=typeof Object.getOwnPropertySymbols)return!1;if("symbol"==typeof Symbol.iterator)return!0;var e={},t=Symbol("test"),n=Object(t);if("string"==typeof t)return!1;if("[object Symbol]"!==Object.prototype.toString.call(t))return!1;if("[object Symbol]"!==Object.prototype.toString.call(n))return!1;for(t in e[t]=42,e)return!1;if("function"==typeof Object.keys&&0!==Object.keys(e).length)return!1;if("function"==typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(e).length)return!1;var r=Object.getOwnPropertySymbols(e);if(1!==r.length||r[0]!==t)return!1;if(!Object.prototype.propertyIsEnumerable.call(e,t))return!1;if("function"==typeof Object.getOwnPropertyDescriptor){var i=Object.getOwnPropertyDescriptor(e,t);if(42!==i.value||!0!==i.enumerable)return!1}return!0}},6410:(e,t,n)=>{"use strict";var r=n(5419);e.exports=function(){return r()&&!!Symbol.toStringTag}},7642:(e,t,n)=>{"use strict";var r=n(8612);e.exports=r.call(Function.call,Object.prototype.hasOwnProperty)},5717:e=>{"function"==typeof Object.create?e.exports=function(e,t){t&&(e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}))}:e.exports=function(e,t){if(t){e.super_=t;var n=function(){};n.prototype=t.prototype,e.prototype=new n,e.prototype.constructor=e}}},2584:(e,t,n)=>{"use strict";var r=n(6410)(),i=n(1924)("Object.prototype.toString"),s=function(e){return!(r&&e&&"object"==typeof e&&Symbol.toStringTag in e)&&"[object Arguments]"===i(e)},a=function(e){return!!s(e)||null!==e&&"object"==typeof e&&"number"==typeof e.length&&e.length>=0&&"[object Array]"!==i(e)&&"[object Function]"===i(e.callee)},o=function(){return s(arguments)}();s.isLegacyArguments=a,e.exports=o?s:a},5320:e=>{"use strict";var t,n,r=Function.prototype.toString,i="object"==typeof Reflect&&null!==Reflect&&Reflect.apply;if("function"==typeof i&&"function"==typeof Object.defineProperty)try{t=Object.defineProperty({},"length",{get:function(){throw n}}),n={},i((function(){throw 42}),null,t)}catch(e){e!==n&&(i=null)}else i=null;var s=/^\s*class\b/,a=function(e){try{var t=r.call(e);return s.test(t)}catch(e){return!1}},o=Object.prototype.toString,l="function"==typeof Symbol&&!!Symbol.toStringTag,c="object"==typeof document&&void 0===document.all&&void 0!==document.all?document.all:{};e.exports=i?function(e){if(e===c)return!0;if(!e)return!1;if("function"!=typeof e&&"object"!=typeof e)return!1;if("function"==typeof e&&!e.prototype)return!0;try{i(e,null,t)}catch(e){if(e!==n)return!1}return!a(e)}:function(e){if(e===c)return!0;if(!e)return!1;if("function"!=typeof e&&"object"!=typeof e)return!1;if("function"==typeof e&&!e.prototype)return!0;if(l)return function(e){try{return!a(e)&&(r.call(e),!0)}catch(e){return!1}}(e);if(a(e))return!1;var t=o.call(e);return"[object Function]"===t||"[object GeneratorFunction]"===t}},8662:(e,t,n)=>{"use strict";var r,i=Object.prototype.toString,s=Function.prototype.toString,a=/^\s*(?:function)?\*/,o=n(6410)(),l=Object.getPrototypeOf;e.exports=function(e){if("function"!=typeof e)return!1;if(a.test(s.call(e)))return!0;if(!o)return"[object GeneratorFunction]"===i.call(e);if(!l)return!1;if(void 0===r){var t=function(){if(!o)return!1;try{return Function("return function*() {}")()}catch(e){}}();r=!!t&&l(t)}return l(e)===r}},5692:(e,t,n)=>{"use strict";var r=n(4029),i=n(3083),s=n(1924),a=s("Object.prototype.toString"),o=n(6410)(),l="undefined"==typeof globalThis?n.g:globalThis,c=i(),u=s("Array.prototype.indexOf",!0)||function(e,t){for(var n=0;n<e.length;n+=1)if(e[n]===t)return n;return-1},h=s("String.prototype.slice"),d={},p=n(882),f=Object.getPrototypeOf;o&&p&&f&&r(c,(function(e){var t=new l[e];if(Symbol.toStringTag in t){var n=f(t),r=p(n,Symbol.toStringTag);if(!r){var i=f(n);r=p(i,Symbol.toStringTag)}d[e]=r.get}})),e.exports=function(e){if(!e||"object"!=typeof e)return!1;if(!o||!(Symbol.toStringTag in e)){var t=h(a(e),8,-1);return u(c,t)>-1}return!!p&&function(e){var t=!1;return r(d,(function(n,r){if(!t)try{t=n.call(e)===r}catch(e){}})),t}(e)}},3720:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var i={},s={};function a(e,t){var n,r,a;return t?(a=0<=(e>>>=0)&&e<256)&&(r=s[e])?r:(n=l(e,(0|e)<0?-1:0,!0),a&&(s[e]=n),n):(a=-128<=(e|=0)&&e<128)&&(r=i[e])?r:(n=l(e,e<0?-1:0,!1),a&&(i[e]=n),n)}function o(e,t){if(isNaN(e))return t?y:g;if(t){if(e<0)return y;if(e>=p)return _}else{if(e<=-f)return S;if(e+1>=f)return w}return e<0?o(-e,t).neg():l(e%d|0,e/d|0,t)}function l(e,t,r){return new n(e,t,r)}n.fromInt=a,n.fromNumber=o,n.fromBits=l;var c=Math.pow;function u(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return u(e.substring(1),t,n).neg();for(var i=o(c(n,8)),s=g,a=0;a<e.length;a+=8){var l=Math.min(8,e.length-a),h=parseInt(e.substring(a,a+l),n);if(l<8){var d=o(c(n,l));s=s.mul(d).add(o(h))}else s=(s=s.mul(i)).add(o(h))}return s.unsigned=t,s}function h(e,t){return"number"==typeof e?o(e,t):"string"==typeof e?u(e,t):l(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}n.fromString=u,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,m=a(1<<24),g=a(0);n.ZERO=g;var y=a(0,!0);n.UZERO=y;var v=a(1);n.ONE=v;var x=a(1,!0);n.UONE=x;var b=a(-1);n.NEG_ONE=b;var w=l(-1,2147483647,!1);n.MAX_VALUE=w;var _=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=_;var S=l(0,-2147483648,!1);n.MIN_VALUE=S;var M=n.prototype;M.toInt=function(){return this.unsigned?this.low>>>0:this.low},M.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},M.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=o(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var i=o(c(e,6),this.unsigned),s=this,a="";;){var l=s.div(i),u=(s.sub(l.mul(i)).toInt()>>>0).toString(e);if((s=l).isZero())return u+a;for(;u.length<6;)u="0"+u;a=""+u+a}},M.getHighBits=function(){return this.high},M.getHighBitsUnsigned=function(){return this.high>>>0},M.getLowBits=function(){return this.low},M.getLowBitsUnsigned=function(){return this.low>>>0},M.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},M.isZero=function(){return 0===this.high&&0===this.low},M.eqz=M.isZero,M.isNegative=function(){return!this.unsigned&&this.high<0},M.isPositive=function(){return this.unsigned||this.high>=0},M.isOdd=function(){return 1==(1&this.low)},M.isEven=function(){return 0==(1&this.low)},M.equals=function(e){return r(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},M.eq=M.equals,M.notEquals=function(e){return!this.eq(e)},M.neq=M.notEquals,M.ne=M.notEquals,M.lessThan=function(e){return this.comp(e)<0},M.lt=M.lessThan,M.lessThanOrEqual=function(e){return this.comp(e)<=0},M.lte=M.lessThanOrEqual,M.le=M.lessThanOrEqual,M.greaterThan=function(e){return this.comp(e)>0},M.gt=M.greaterThan,M.greaterThanOrEqual=function(e){return this.comp(e)>=0},M.gte=M.greaterThanOrEqual,M.ge=M.greaterThanOrEqual,M.compare=function(e){if(r(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},M.comp=M.compare,M.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(v)},M.neg=M.negate,M.add=function(e){r(e)||(e=h(e));var t=this.high>>>16,n=65535&this.high,i=this.low>>>16,s=65535&this.low,a=e.high>>>16,o=65535&e.high,c=e.low>>>16,u=0,d=0,p=0,f=0;return p+=(f+=s+(65535&e.low))>>>16,d+=(p+=i+c)>>>16,u+=(d+=n+o)>>>16,u+=t+a,l((p&=65535)<<16|(f&=65535),(u&=65535)<<16|(d&=65535),this.unsigned)},M.subtract=function(e){return r(e)||(e=h(e)),this.add(e.neg())},M.sub=M.subtract,M.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=h(e)),t)return l(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(S))return e.isOdd()?S:g;if(e.eq(S))return this.isOdd()?S:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return o(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,i=65535&this.high,s=this.low>>>16,a=65535&this.low,c=e.high>>>16,u=65535&e.high,d=e.low>>>16,p=65535&e.low,f=0,y=0,v=0,x=0;return v+=(x+=a*p)>>>16,y+=(v+=s*p)>>>16,v&=65535,y+=(v+=a*d)>>>16,f+=(y+=i*p)>>>16,y&=65535,f+=(y+=s*d)>>>16,y&=65535,f+=(y+=a*u)>>>16,f+=n*p+i*d+s*u+a*c,l((v&=65535)<<16|(x&=65535),(f&=65535)<<16|(y&=65535),this.unsigned)},M.mul=M.multiply,M.divide=function(e){if(r(e)||(e=h(e)),e.isZero())throw Error("division by zero");var n,i,s;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?l((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return x;s=y}else{if(this.eq(S))return e.eq(v)||e.eq(b)?S:e.eq(S)?v:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?v:b:(i=this.sub(e.mul(n)),s=n.add(i.div(e)));if(e.eq(S))return this.unsigned?y:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=g}for(i=this;i.gte(e);){n=Math.max(1,Math.floor(i.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),u=a<=48?1:c(2,a-48),d=o(n),p=d.mul(e);p.isNegative()||p.gt(i);)p=(d=o(n-=u,this.unsigned)).mul(e);d.isZero()&&(d=v),s=s.add(d),i=i.sub(p)}return s},M.div=M.divide,M.modulo=function(e){return r(e)||(e=h(e)),t?l((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},M.mod=M.modulo,M.rem=M.modulo,M.not=function(){return l(~this.low,~this.high,this.unsigned)},M.and=function(e){return r(e)||(e=h(e)),l(this.low&e.low,this.high&e.high,this.unsigned)},M.or=function(e){return r(e)||(e=h(e)),l(this.low|e.low,this.high|e.high,this.unsigned)},M.xor=function(e){return r(e)||(e=h(e)),l(this.low^e.low,this.high^e.high,this.unsigned)},M.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?l(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):l(0,this.low<<e-32,this.unsigned)},M.shl=M.shiftLeft,M.shiftRight=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?l(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):l(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},M.shr=M.shiftRight,M.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?l(this.low>>>e|t<<32-e,t>>>e,this.unsigned):l(32===e?t:t>>>e-32,0,this.unsigned)},M.shru=M.shiftRightUnsigned,M.shr_u=M.shiftRightUnsigned,M.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},M.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},M.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},M.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},M.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},4155:e=>{var t,n,r=e.exports={};function i(){throw new Error("setTimeout has not been defined")}function s(){throw new Error("clearTimeout has not been defined")}function a(e){if(t===setTimeout)return setTimeout(e,0);if((t===i||!t)&&setTimeout)return t=setTimeout,setTimeout(e,0);try{return t(e,0)}catch(n){try{return t.call(null,e,0)}catch(n){return t.call(this,e,0)}}}!function(){try{t="function"==typeof setTimeout?setTimeout:i}catch(e){t=i}try{n="function"==typeof clearTimeout?clearTimeout:s}catch(e){n=s}}();var o,l=[],c=!1,u=-1;function h(){c&&o&&(c=!1,o.length?l=o.concat(l):u=-1,l.length&&d())}function d(){if(!c){var e=a(h);c=!0;for(var t=l.length;t;){for(o=l,l=[];++u<t;)o&&o[u].run();u=-1,t=l.length}o=null,c=!1,function(e){if(n===clearTimeout)return clearTimeout(e);if((n===s||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(e);try{n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}(e)}}function p(e,t){this.fun=e,this.array=t}function f(){}r.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)t[n-1]=arguments[n];l.push(new p(e,t)),1!==l.length||c||a(d)},p.prototype.run=function(){this.fun.apply(null,this.array)},r.title="browser",r.browser=!0,r.env={},r.argv=[],r.version="",r.versions={},r.on=f,r.addListener=f,r.once=f,r.off=f,r.removeListener=f,r.removeAllListeners=f,r.emit=f,r.prependListener=f,r.prependOnceListener=f,r.listeners=function(e){return[]},r.binding=function(e){throw new Error("process.binding is not supported")},r.cwd=function(){return"/"},r.chdir=function(e){throw new Error("process.chdir is not supported")},r.umask=function(){return 0}},6377:(e,t,n)=>{var r=n(4832),i=n(8652),s=n(801),a=n(2030),o=n(3618),l=n(9049),c=n(1971);c.alea=r,c.xor128=i,c.xorwow=s,c.xorshift7=a,c.xor4096=o,c.tychei=l,e.exports=c},4832:function(e,t,n){var r;!function(e,i,s){function a(e){var t,n=this,r=(t=4022871197,function(e){e=e.toString();for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function o(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function l(e,t){var n=new a(e),r=t&&t.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,r&&("object"==typeof r&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.alea=l}(0,e=n.nmd(e),n.amdD)},9049:function(e,t,n){var r;!function(e,i,s){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,i=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^i,i=i-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^i,t.a=i-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function o(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function l(e,t){var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.tychei=l}(0,e=n.nmd(e),n.amdD)},8652:function(e,t,n){var r;!function(e,i,s){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function o(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function l(e,t){var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.xor128=l}(0,e=n.nmd(e),n.amdD)},3618:function(e,t,n){var r;!function(e,i,s){function a(e){var t=this;t.next=function(){var e,n,r=t.w,i=t.X,s=t.i;return t.w=r=r+1640531527|0,n=i[s+34&127],e=i[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=i[s]=n^e,t.i=s,n+(r^r>>>16)|0},function(e,t){var n,r,i,s,a,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),i=0,s=-32;s<l;++s)t&&(r^=t.charCodeAt((s+32)%t.length)),0===s&&(a=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(a=a+1640531527|0,i=0==(n=o[127&s]^=r+a)?i+1:0);for(i>=128&&(o[127&(t&&t.length||0)]=-1),i=127,s=512;s>0;--s)r=o[i+34&127],n=o[i=i+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[i]=r^n;e.w=a,e.X=o,e.i=i}(t,e)}function o(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function l(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,r&&(r.X&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.xor4096=l}(0,e=n.nmd(e),n.amdD)},2030:function(e,t,n){var r;!function(e,i,s){function a(e){var t=this;t.next=function(){var e,n,r=t.x,i=t.i;return e=r[i],n=(e^=e>>>7)^e<<24,n^=(e=r[i+1&7])^e>>>10,n^=(e=r[i+3&7])^e>>>3,n^=(e=r[i+4&7])^e<<7,e=r[i+7&7],n^=(e^=e<<13)^e<<9,r[i]=n,t.i=i+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function o(e,t){return t.x=e.x.slice(),t.i=e.i,t}function l(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,r&&(r.x&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.xorshift7=l}(0,e=n.nmd(e),n.amdD)},801:function(e,t,n){var r;!function(e,i,s){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function o(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function l(e,t){var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&o(r,n),i.state=function(){return o(n,{})}),i}i&&i.exports?i.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,i))||(i.exports=r):this.xorwow=l}(0,e=n.nmd(e),n.amdD)},1971:(e,t,n)=>{var r;!function(i,s){var a,o=(0,eval)("this"),l=256,c=s.pow(l,6),u=s.pow(2,52),h=2*u,d=255;function p(e,t,n){var r=[],d=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,v(i)]:null==e?function(){try{var e;return a&&(e=a.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),v(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,v(i)]}}():e,3),r),p=new f(r),x=function(){for(var e=p.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=p.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|p.g(4)},x.quick=function(){return p.g(4)/4294967296},x.double=x,y(v(p.S),i),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(s.random=e,t):e})(x,d,"global"in t?t.global:this==s,t.state)}function f(e){var t,n=e.length,r=this,i=0,s=r.i=r.j=0,a=r.S=[];for(n||(e=[n++]);i<l;)a[i]=i++;for(i=0;i<l;i++)a[i]=a[s=d&s+e[i%n]+(t=a[i])],a[s]=t;(r.g=function(e){for(var t,n=0,i=r.i,s=r.j,a=r.S;e--;)t=a[i=d&i+1],n=n*l+a[d&(a[i]=a[s=d&s+t])+(a[s]=t)];return r.i=i,r.j=s,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],i=typeof e;if(t&&"object"==i)for(n in e)try{r.push(g(e[n],t-1))}catch(e){}return r.length?r:"string"==i?e:e+"\0"}function y(e,t){for(var n,r=e+"",i=0;i<r.length;)t[d&i]=d&(n^=19*t[d&i])+r.charCodeAt(i++);return v(t)}function v(e){return String.fromCharCode.apply(0,e)}if(s.seedrandom=p,y(s.random(),i),e.exports){e.exports=p;try{a=n(5042)}catch(e){}}else void 0===(r=function(){return p}.call(t,n,t,e))||(e.exports=r)}([],Math)},7654:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>y});var r=n(3379),i=n.n(r),s=n(7795),a=n.n(s),o=n(569),l=n.n(o),c=n(3565),u=n.n(c),h=n(9216),d=n.n(h),p=n(4589),f=n.n(p),m=n(5426),g={};g.styleTagTransform=f(),g.setAttributes=u(),g.insert=l().bind(null,"head"),g.domAPI=a(),g.insertStyleElement=d(),i()(m.Z,g);const y=m.Z&&m.Z.locals?m.Z.locals:void 0},3379:e=>{"use strict";var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var s={},a=[],o=0;o<e.length;o++){var l=e[o],c=r.base?l[0]+r.base:l[0],u=s[c]||0,h="".concat(c," ").concat(u);s[c]=u+1;var d=n(h),p={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==d)t[d].references++,t[d].updater(p);else{var f=i(p,r);r.byIndex=o,t.splice(o,0,{identifier:h,updater:f,references:1})}a.push(h)}return a}function i(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,i){var s=r(e=e||[],i=i||{});return function(e){e=e||[];for(var a=0;a<s.length;a++){var o=n(s[a]);t[o].references--}for(var l=r(e,i),c=0;c<s.length;c++){var u=n(s[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}s=l}}},569:e=>{"use strict";var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},9216:e=>{"use strict";e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},3565:(e,t,n)=>{"use strict";e.exports=function(e){var t=n.nc;t&&e.setAttribute("nonce",t)}},7795:e=>{"use strict";e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var i=void 0!==n.layer;i&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,i&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var s=n.sourceMap;s&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(s))))," */")),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},4589:e=>{"use strict";e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},7580:(e,t,n)=>{"use strict";t.__esModule=!0;var r=n(5232),i=n(3687),s=function(){function e(e,t,n){this._particleMaterial=new r.PointsMaterial,this.tmpVec0=new i.Vec3,this.tmpVec1=new i.Vec3,this.tmpVec2=new i.Vec3,this.tmpQuat0=new i.Quaternion,n=n||{},this.scene=e,this.world=t,this._meshes=[],this._material=new r.MeshBasicMaterial({color:65280,wireframe:!0}),this._particleMaterial=new r.PointsMaterial({color:16711680,size:10,sizeAttenuation:!1,depthTest:!1}),this._sphereGeometry=new r.SphereGeometry(1),this._boxGeometry=new r.BoxGeometry(1,1,1),this._cylinderGeometry=new r.CylinderGeometry(1,1,2,8),this._planeGeometry=new r.PlaneGeometry(10,10,10,10),this._particleGeometry=new r.BufferGeometry,this._particleGeometry.setFromPoints([new r.Vector3(0,0,0)])}return e.prototype.update=function(){for(var e=this.world.bodies,t=this._meshes,n=this.tmpVec0,r=this.tmpQuat0,i=0,s=0;s!==e.length;s++)for(var a=e[s],o=0;o!==a.shapes.length;o++){var l=a.shapes[o];this._updateMesh(i,a,l),(c=t[i])&&(a.quaternion.vmult(a.shapeOffsets[o],n),a.position.vadd(n,n),a.quaternion.mult(a.shapeOrientations[o],r),c.position.x=n.x,c.position.y=n.y,c.position.z=n.z,c.quaternion.x=r.x,c.quaternion.y=r.y,c.quaternion.z=r.z,c.quaternion.w=r.w),i++}for(s=i;s<t.length;s++){var c;(c=t[s])&&this.scene.remove(c)}t.length=i},e.prototype._updateMesh=function(e,t,n){var r=this._meshes[e];this._typeMatch(r,n)||(r&&this.scene.remove(r),r=this._meshes[e]=this._createMesh(n)),this._scaleMesh(r,n)},e.prototype._typeMatch=function(e,t){if(!e)return!1;var n=e.geometry;return n instanceof r.SphereGeometry&&t instanceof i.Sphere||n instanceof r.BoxGeometry&&t instanceof i.Box||n instanceof r.CylinderGeometry&&t instanceof i.Cylinder||n instanceof r.PlaneGeometry&&t instanceof i.Plane||t instanceof i.ConvexPolyhedron||n.id===t.id&&t instanceof i.Trimesh||n.id===t.id&&t instanceof i.Heightfield},e.prototype._createMesh=function(e){var t,n,s,a,o,l=this._material,c=[];switch(e.type){case i.Shape.types.SPHERE:t=new r.Mesh(this._sphereGeometry,l);break;case i.Shape.types.BOX:t=new r.Mesh(this._boxGeometry,l);break;case i.Shape.types.CYLINDER:n=new r.CylinderGeometry(e.radiusTop,e.radiusBottom,e.height,e.numSegments),t=new r.Mesh(n,l);break;case i.Shape.types.PLANE:t=new r.Mesh(this._planeGeometry,l);break;case i.Shape.types.PARTICLE:t=new r.Points(this._particleGeometry,this._particleMaterial);break;case i.Shape.types.CONVEXPOLYHEDRON:n=new r.BufferGeometry,e.id=n.id,c=[];for(var u=0;u<e.vertices.length;u+=1){var h=e.vertices[u];c.push(new r.Vector3(h.x,h.y,h.z))}n.setFromPoints(c);var d=[];for(u=0;u<e.faces.length;u++)for(var p=e.faces[u],f=p[0],m=1;m<p.length-1;m++){var g=p[m],y=p[m+1];d.push(f,g,y)}n.setIndex(d),t=new r.Mesh(n,l);break;case i.Shape.types.TRIMESH:for(n=new r.BufferGeometry,e.id=n.id,c=[],u=0;u<e.vertices.length;u+=3)c.push(new r.Vector3(e.vertices[u],e.vertices[u+1],e.vertices[u+2]));n.setFromPoints(c),t=new r.Mesh(n,l);break;case i.Shape.types.HEIGHTFIELD:n=new r.BufferGeometry,s=this.tmpVec0,a=this.tmpVec1,o=this.tmpVec2;for(var v=0;v<e.data.length-1;v++)for(var x=0;x<e.data[v].length-1;x++)for(var b=0;b<2;b++)e.getConvexTrianglePillar(v,x,0===b),s.copy(e.pillarConvex.vertices[0]),a.copy(e.pillarConvex.vertices[1]),o.copy(e.pillarConvex.vertices[2]),s.vadd(e.pillarOffset,s),a.vadd(e.pillarOffset,a),o.vadd(e.pillarOffset,o),c.push(new r.Vector3(s.x,s.y,s.z),new r.Vector3(a.x,a.y,a.z),new r.Vector3(o.x,o.y,o.z));n.setFromPoints(c),t=new r.Mesh(n,l),e.id=n.id;break;default:t=new r.Mesh}return t&&t.geometry&&this.scene.add(t),t},e.prototype._scaleMesh=function(e,t){var n,s,a;switch(t.type){case i.Shape.types.SPHERE:n=t.radius,e.scale.set(n,n,n);break;case i.Shape.types.BOX:s=t.halfExtents,e.scale.copy(new r.Vector3(s.x,s.y,s.z)),e.scale.multiplyScalar(2);break;case i.Shape.types.CONVEXPOLYHEDRON:e.scale.set(1,1,1);break;case i.Shape.types.TRIMESH:a=t.scale,e.scale.copy(new r.Vector3(a.x,a.y,a.z));break;case i.Shape.types.HEIGHTFIELD:e.scale.set(1,1,1)}},e}();t.default=s},4662:(e,t)=>{"use strict";t.__esModule=!0,t.getRandomInt=void 0,t.getRandomInt=function(e,t){return e=Math.ceil(e),t=Math.floor(t),Math.floor(Math.random()*(t-e)+e)}},8929:(e,t,n)=>{"use strict";n(7654);var r,i,s,a,o,l,c=n(5232),u=n(3687),h=n(5629),d=n(5079),p=n(4662),f=n(7580),m=n(2417);function g(e){r=e}l=(0,d.default)(),document.body.appendChild(l.dom);var y=!1,v=!1,x=!1,b=!1,w=performance.now(),_=new c.Vector3,S=new c.Vector3,M=new u.World;M.gravity.set(0,-9.82,0);var T,E=[],A=[],C=!1,I=[];function N(){i.aspect=window.innerWidth/window.innerHeight,i.updateProjectionMatrix(),a.setSize(window.innerWidth,window.innerHeight)}!function(){(0,m.recognizeSounds)(g),(i=new c.PerspectiveCamera(30,window.innerWidth/window.innerHeight,1,5e3)).position.set(0,1.5,20),(s=new c.Scene).add(new c.AxesHelper(50)),s.background=new c.Color("skyblue"),(a=new c.WebGLRenderer({antialias:!0})).shadowMap.enabled=!0,a.setPixelRatio(window.devicePixelRatio),a.setSize(window.innerWidth,window.innerHeight),document.body.appendChild(a.domElement),o=new h.PointerLockControls(i,a.domElement);var e=document.getElementById("blocker"),t=document.getElementById("instructions"),n=document.getElementById("aim");e&&t&&n&&(t.addEventListener("click",(function(){o.lock()})),o.addEventListener("lock",(function(){t.style.display="none",e.style.display="none",n.style.display="block"})),o.addEventListener("unlock",(function(){e.style.display="block",t.style.display="",n.style.display="none"}))),s.add(o.getObject()),document.addEventListener("keydown",(function(e){switch(e.code){case"KeyQ":D();break;case"ArrowUp":case"KeyW":y=!0;break;case"ArrowLeft":case"KeyA":x=!0;break;case"ArrowDown":case"KeyS":v=!0;break;case"ArrowRight":case"KeyD":b=!0}})),document.addEventListener("keyup",(function(e){switch(e.code){case"ArrowUp":case"KeyW":y=!1;break;case"ArrowLeft":case"KeyA":x=!1;break;case"ArrowDown":case"KeyS":v=!1;break;case"ArrowRight":case"KeyD":b=!1}}));var r=new c.AmbientLight(16711680,.5);s.add(r);var l=new c.DirectionalLight(16777215,1);l.position.set(-5,15,-5),l.castShadow=!0,l.shadow.mapSize.width=2048,l.shadow.mapSize.height=2048,s.add(l);var d=new c.DirectionalLightHelper(l,1);s.add(d);var w=new c.PlaneGeometry(100,100),_=new c.MeshLambertMaterial({color:8421504}),S=new c.Mesh(w,_);S.rotation.x=-Math.PI/2,S.receiveShadow=!0,s.add(S);var I=new u.Plane,k=new u.Body({mass:0});k.addShape(I),k.quaternion.setFromAxisAngle(new u.Vec3(1,0,0),-Math.PI/2),M.addBody(k);var R=new c.BoxBufferGeometry(1,1,1),L=R.parameters.width,F=R.parameters.height,P=R.parameters.depth,O=new c.MeshPhysicalMaterial({color:65280}),z=new c.Mesh(R,O);z.castShadow=!0;for(var B=0;B<50;B++){var U=z.clone();U.position.x=(0,p.getRandomInt)(-5,6),U.position.y=10,U.position.z=(0,p.getRandomInt)(-5,6),s.add(U),E.push(U);var $=new u.Box(new u.Vec3(L/2,F/2,P/2)),V=new u.Body({mass:1});V.addShape($),V.position.x=U.position.x,V.position.y=U.position.y,V.position.z=U.position.z,M.addBody(V),A.push(V)}C=!0,T=new f.default(s,M),window.addEventListener("resize",N,!1)}(),function e(){var t=null==r?void 0:r.filter((function(e){return"Blow"===e.label}));t&&t[0].isActive&&D(),requestAnimationFrame(e),R&&(k=Math.min(R.getDelta(),.1),M.step(k)),T.update();var n=performance.now();if(C&&E.forEach((function(e,t){e.position.set(A[t].position.x,A[t].position.y,A[t].position.z),e.quaternion.set(A[t].quaternion.x,A[t].quaternion.y,A[t].quaternion.z,A[t].quaternion.w)})),!0===o.isLocked){var c=(n-w)/1e3;_.x-=10*_.x*c,_.z-=10*_.z*c,S.z=Number(y)-Number(v),S.x=Number(b)-Number(x),S.normalize(),(y||v)&&(_.z-=100*S.z*c),(x||b)&&(_.x-=100*S.x*c),o.moveRight(-_.x*c),o.moveForward(-_.z*c),o.getObject().position.y+=_.y*c}w=n;for(var u=0;u<I.length;u++)void 0!==I[u]&&(!1!==I[u].isAlive||I.splice(u,1));a.render(s,i),l.update()}();var k,R=new c.Clock,D=function(){var e={shape:new u.Sphere(.3),body:new u.Body({mass:1}),isAlive:!0};e.body.addShape(e.shape);var t=new c.Vector3;i.getWorldPosition(t),e.body.position.set(t.x,t.y,t.z);var n=new c.Vector3;i.getWorldDirection(n),e.body.velocity=new u.Vec3(45*n.x,45*n.y,45*n.z),setTimeout((function(){M.removeBody(e.body),e.isAlive=!1}),2e3),I.push(e),M.addBody(e.body)}},2417:function(e,t,n){"use strict";var r=this&&this.__awaiter||function(e,t,n,r){return new(n||(n=Promise))((function(i,s){function a(e){try{l(r.next(e))}catch(e){s(e)}}function o(e){try{l(r.throw(e))}catch(e){s(e)}}function l(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(a,o)}l((r=r.apply(e,t||[])).next())}))},i=this&&this.__generator||function(e,t){var n,r,i,s,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return s={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function o(s){return function(o){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(i=2&s[0]?r.return:s[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,s[1])).done)return i;switch(r=0,i&&(s=[2&s[0],i.value]),s[0]){case 0:case 1:i=s;break;case 4:return a.label++,{value:s[1],done:!1};case 5:a.label++,r=s[1],s=[0];continue;case 7:s=a.ops.pop(),a.trys.pop();continue;default:if(!((i=(i=a.trys).length>0&&i[i.length-1])||6!==s[0]&&2!==s[0])){a=0;continue}if(3===s[0]&&(!i||s[1]>i[0]&&s[1]<i[3])){a.label=s[1];break}if(6===s[0]&&a.label<i[1]){a.label=i[1],i=s;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(s);break}i[2]&&a.ops.pop(),a.trys.pop();continue}s=t.call(e,a)}catch(e){s=[6,e],r=0}finally{n=i=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,o])}}};t.__esModule=!0,t.recognizeSounds=void 0;var s=n(6452),a=n(9327);s.getBackend();function o(){return r(this,void 0,void 0,(function(){var e;return i(this,(function(t){switch(t.label){case 0:return[4,(e=a.create("BROWSER_FFT",void 0,"https://teachablemachine.withgoogle.com/models/CpusitpNa/model.json","https://teachablemachine.withgoogle.com/models/CpusitpNa/metadata.json")).ensureModelLoaded()];case 1:return t.sent(),[2,e]}}))}))}t.recognizeSounds=function(e){return r(this,void 0,void 0,(function(){var t,n,s,a=this;return i(this,(function(l){switch(l.label){case 0:return console.log("Recognizing sounds."),[4,o()];case 1:return t=l.sent(),n=t.wordLabels(),s=n.map((function(e){return{label:e,confidence:0,isActive:!1}})),console.log("sounds:",s),t.listen((function(e){return r(a,void 0,void 0,(function(){var t;return i(this,(function(n){return t=e.scores,s.forEach((function(e,n){e.confidence=t[n],e.isActive=t[n]>.8})),[2]}))}))}),{includeSpectrogram:!0,probabilityThreshold:.75,invokeCallbackOnNoiseAndUnknown:!0,overlapFactor:.5}),e(s),[2]}}))}))}},384:e=>{e.exports=function(e){return e&&"object"==typeof e&&"function"==typeof e.copy&&"function"==typeof e.fill&&"function"==typeof e.readUInt8}},5955:(e,t,n)=>{"use strict";var r=n(2584),i=n(8662),s=n(6430),a=n(5692);function o(e){return e.call.bind(e)}var l="undefined"!=typeof BigInt,c="undefined"!=typeof Symbol,u=o(Object.prototype.toString),h=o(Number.prototype.valueOf),d=o(String.prototype.valueOf),p=o(Boolean.prototype.valueOf);if(l)var f=o(BigInt.prototype.valueOf);if(c)var m=o(Symbol.prototype.valueOf);function g(e,t){if("object"!=typeof e)return!1;try{return t(e),!0}catch(e){return!1}}function y(e){return"[object Map]"===u(e)}function v(e){return"[object Set]"===u(e)}function x(e){return"[object WeakMap]"===u(e)}function b(e){return"[object WeakSet]"===u(e)}function w(e){return"[object ArrayBuffer]"===u(e)}function _(e){return"undefined"!=typeof ArrayBuffer&&(w.working?w(e):e instanceof ArrayBuffer)}function S(e){return"[object DataView]"===u(e)}function M(e){return"undefined"!=typeof DataView&&(S.working?S(e):e instanceof DataView)}t.isArgumentsObject=r,t.isGeneratorFunction=i,t.isTypedArray=a,t.isPromise=function(e){return"undefined"!=typeof Promise&&e instanceof Promise||null!==e&&"object"==typeof e&&"function"==typeof e.then&&"function"==typeof e.catch},t.isArrayBufferView=function(e){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(e):a(e)||M(e)},t.isUint8Array=function(e){return"Uint8Array"===s(e)},t.isUint8ClampedArray=function(e){return"Uint8ClampedArray"===s(e)},t.isUint16Array=function(e){return"Uint16Array"===s(e)},t.isUint32Array=function(e){return"Uint32Array"===s(e)},t.isInt8Array=function(e){return"Int8Array"===s(e)},t.isInt16Array=function(e){return"Int16Array"===s(e)},t.isInt32Array=function(e){return"Int32Array"===s(e)},t.isFloat32Array=function(e){return"Float32Array"===s(e)},t.isFloat64Array=function(e){return"Float64Array"===s(e)},t.isBigInt64Array=function(e){return"BigInt64Array"===s(e)},t.isBigUint64Array=function(e){return"BigUint64Array"===s(e)},y.working="undefined"!=typeof Map&&y(new Map),t.isMap=function(e){return"undefined"!=typeof Map&&(y.working?y(e):e instanceof Map)},v.working="undefined"!=typeof Set&&v(new Set),t.isSet=function(e){return"undefined"!=typeof Set&&(v.working?v(e):e instanceof Set)},x.working="undefined"!=typeof WeakMap&&x(new WeakMap),t.isWeakMap=function(e){return"undefined"!=typeof WeakMap&&(x.working?x(e):e instanceof WeakMap)},b.working="undefined"!=typeof WeakSet&&b(new WeakSet),t.isWeakSet=function(e){return b(e)},w.working="undefined"!=typeof ArrayBuffer&&w(new ArrayBuffer),t.isArrayBuffer=_,S.working="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof DataView&&S(new DataView(new ArrayBuffer(1),0,1)),t.isDataView=M;var T="undefined"!=typeof SharedArrayBuffer?SharedArrayBuffer:void 0;function E(e){return"[object SharedArrayBuffer]"===u(e)}function A(e){return void 0!==T&&(void 0===E.working&&(E.working=E(new T)),E.working?E(e):e instanceof T)}function C(e){return g(e,h)}function I(e){return g(e,d)}function N(e){return g(e,p)}function k(e){return l&&g(e,f)}function R(e){return c&&g(e,m)}t.isSharedArrayBuffer=A,t.isAsyncFunction=function(e){return"[object AsyncFunction]"===u(e)},t.isMapIterator=function(e){return"[object Map Iterator]"===u(e)},t.isSetIterator=function(e){return"[object Set Iterator]"===u(e)},t.isGeneratorObject=function(e){return"[object Generator]"===u(e)},t.isWebAssemblyCompiledModule=function(e){return"[object WebAssembly.Module]"===u(e)},t.isNumberObject=C,t.isStringObject=I,t.isBooleanObject=N,t.isBigIntObject=k,t.isSymbolObject=R,t.isBoxedPrimitive=function(e){return C(e)||I(e)||N(e)||k(e)||R(e)},t.isAnyArrayBuffer=function(e){return"undefined"!=typeof Uint8Array&&(_(e)||A(e))},["isProxy","isExternal","isModuleNamespaceObject"].forEach((function(e){Object.defineProperty(t,e,{enumerable:!1,value:function(){throw new Error(e+" is not supported in userland")}})}))},9539:(e,t,n)=>{var r=n(4155),i=Object.getOwnPropertyDescriptors||function(e){for(var t=Object.keys(e),n={},r=0;r<t.length;r++)n[t[r]]=Object.getOwnPropertyDescriptor(e,t[r]);return n},s=/%[sdj%]/g;t.format=function(e){if(!x(e)){for(var t=[],n=0;n<arguments.length;n++)t.push(c(arguments[n]));return t.join(" ")}n=1;for(var r=arguments,i=r.length,a=String(e).replace(s,(function(e){if("%%"===e)return"%";if(n>=i)return e;switch(e){case"%s":return String(r[n++]);case"%d":return Number(r[n++]);case"%j":try{return JSON.stringify(r[n++])}catch(e){return"[Circular]"}default:return e}})),o=r[n];n<i;o=r[++n])y(o)||!_(o)?a+=" "+o:a+=" "+c(o);return a},t.deprecate=function(e,n){if(void 0!==r&&!0===r.noDeprecation)return e;if(void 0===r)return function(){return t.deprecate(e,n).apply(this,arguments)};var i=!1;return function(){if(!i){if(r.throwDeprecation)throw new Error(n);r.traceDeprecation?console.trace(n):console.error(n),i=!0}return e.apply(this,arguments)}};var a={},o=/^$/;if(r.env.NODE_DEBUG){var l=r.env.NODE_DEBUG;l=l.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".*").replace(/,/g,"$|^").toUpperCase(),o=new RegExp("^"+l+"$","i")}function c(e,n){var r={seen:[],stylize:h};return arguments.length>=3&&(r.depth=arguments[2]),arguments.length>=4&&(r.colors=arguments[3]),g(n)?r.showHidden=n:n&&t._extend(r,n),b(r.showHidden)&&(r.showHidden=!1),b(r.depth)&&(r.depth=2),b(r.colors)&&(r.colors=!1),b(r.customInspect)&&(r.customInspect=!0),r.colors&&(r.stylize=u),d(r,e,r.depth)}function u(e,t){var n=c.styles[t];return n?"["+c.colors[n][0]+"m"+e+"["+c.colors[n][1]+"m":e}function h(e,t){return e}function d(e,n,r){if(e.customInspect&&n&&T(n.inspect)&&n.inspect!==t.inspect&&(!n.constructor||n.constructor.prototype!==n)){var i=n.inspect(r,e);return x(i)||(i=d(e,i,r)),i}var s=function(e,t){if(b(t))return e.stylize("undefined","undefined");if(x(t)){var n="'"+JSON.stringify(t).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return e.stylize(n,"string")}return v(t)?e.stylize(""+t,"number"):g(t)?e.stylize(""+t,"boolean"):y(t)?e.stylize("null","null"):void 0}(e,n);if(s)return s;var a=Object.keys(n),o=function(e){var t={};return e.forEach((function(e,n){t[e]=!0})),t}(a);if(e.showHidden&&(a=Object.getOwnPropertyNames(n)),M(n)&&(a.indexOf("message")>=0||a.indexOf("description")>=0))return p(n);if(0===a.length){if(T(n)){var l=n.name?": "+n.name:"";return e.stylize("[Function"+l+"]","special")}if(w(n))return e.stylize(RegExp.prototype.toString.call(n),"regexp");if(S(n))return e.stylize(Date.prototype.toString.call(n),"date");if(M(n))return p(n)}var c,u="",h=!1,_=["{","}"];return m(n)&&(h=!0,_=["[","]"]),T(n)&&(u=" [Function"+(n.name?": "+n.name:"")+"]"),w(n)&&(u=" "+RegExp.prototype.toString.call(n)),S(n)&&(u=" "+Date.prototype.toUTCString.call(n)),M(n)&&(u=" "+p(n)),0!==a.length||h&&0!=n.length?r<0?w(n)?e.stylize(RegExp.prototype.toString.call(n),"regexp"):e.stylize("[Object]","special"):(e.seen.push(n),c=h?function(e,t,n,r,i){for(var s=[],a=0,o=t.length;a<o;++a)N(t,String(a))?s.push(f(e,t,n,r,String(a),!0)):s.push("");return i.forEach((function(i){i.match(/^\d+$/)||s.push(f(e,t,n,r,i,!0))})),s}(e,n,r,o,a):a.map((function(t){return f(e,n,r,o,t,h)})),e.seen.pop(),function(e,t,n){return e.reduce((function(e,t){return t.indexOf("\n"),e+t.replace(/\u001b\[\d\d?m/g,"").length+1}),0)>60?n[0]+(""===t?"":t+"\n ")+" "+e.join(",\n  ")+" "+n[1]:n[0]+t+" "+e.join(", ")+" "+n[1]}(c,u,_)):_[0]+u+_[1]}function p(e){return"["+Error.prototype.toString.call(e)+"]"}function f(e,t,n,r,i,s){var a,o,l;if((l=Object.getOwnPropertyDescriptor(t,i)||{value:t[i]}).get?o=l.set?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):l.set&&(o=e.stylize("[Setter]","special")),N(r,i)||(a="["+i+"]"),o||(e.seen.indexOf(l.value)<0?(o=y(n)?d(e,l.value,null):d(e,l.value,n-1)).indexOf("\n")>-1&&(o=s?o.split("\n").map((function(e){return"  "+e})).join("\n").substr(2):"\n"+o.split("\n").map((function(e){return"   "+e})).join("\n")):o=e.stylize("[Circular]","special")),b(a)){if(s&&i.match(/^\d+$/))return o;(a=JSON.stringify(""+i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(a=a.substr(1,a.length-2),a=e.stylize(a,"name")):(a=a.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),a=e.stylize(a,"string"))}return a+": "+o}function m(e){return Array.isArray(e)}function g(e){return"boolean"==typeof e}function y(e){return null===e}function v(e){return"number"==typeof e}function x(e){return"string"==typeof e}function b(e){return void 0===e}function w(e){return _(e)&&"[object RegExp]"===E(e)}function _(e){return"object"==typeof e&&null!==e}function S(e){return _(e)&&"[object Date]"===E(e)}function M(e){return _(e)&&("[object Error]"===E(e)||e instanceof Error)}function T(e){return"function"==typeof e}function E(e){return Object.prototype.toString.call(e)}function A(e){return e<10?"0"+e.toString(10):e.toString(10)}t.debuglog=function(e){if(e=e.toUpperCase(),!a[e])if(o.test(e)){var n=r.pid;a[e]=function(){var r=t.format.apply(t,arguments);console.error("%s %d: %s",e,n,r)}}else a[e]=function(){};return a[e]},t.inspect=c,c.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},c.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},t.types=n(5955),t.isArray=m,t.isBoolean=g,t.isNull=y,t.isNullOrUndefined=function(e){return null==e},t.isNumber=v,t.isString=x,t.isSymbol=function(e){return"symbol"==typeof e},t.isUndefined=b,t.isRegExp=w,t.types.isRegExp=w,t.isObject=_,t.isDate=S,t.types.isDate=S,t.isError=M,t.types.isNativeError=M,t.isFunction=T,t.isPrimitive=function(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||void 0===e},t.isBuffer=n(384);var C=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function I(){var e=new Date,t=[A(e.getHours()),A(e.getMinutes()),A(e.getSeconds())].join(":");return[e.getDate(),C[e.getMonth()],t].join(" ")}function N(e,t){return Object.prototype.hasOwnProperty.call(e,t)}t.log=function(){console.log("%s - %s",I(),t.format.apply(t,arguments))},t.inherits=n(5717),t._extend=function(e,t){if(!t||!_(t))return e;for(var n=Object.keys(t),r=n.length;r--;)e[n[r]]=t[n[r]];return e};var k="undefined"!=typeof Symbol?Symbol("util.promisify.custom"):void 0;function R(e,t){if(!e){var n=new Error("Promise was rejected with a falsy value");n.reason=e,e=n}return t(e)}t.promisify=function(e){if("function"!=typeof e)throw new TypeError('The "original" argument must be of type Function');if(k&&e[k]){var t;if("function"!=typeof(t=e[k]))throw new TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(t,k,{value:t,enumerable:!1,writable:!1,configurable:!0}),t}function t(){for(var t,n,r=new Promise((function(e,r){t=e,n=r})),i=[],s=0;s<arguments.length;s++)i.push(arguments[s]);i.push((function(e,r){e?n(e):t(r)}));try{e.apply(this,i)}catch(e){n(e)}return r}return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),k&&Object.defineProperty(t,k,{value:t,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(t,i(e))},t.promisify.custom=k,t.callbackify=function(e){if("function"!=typeof e)throw new TypeError('The "original" argument must be of type Function');function t(){for(var t=[],n=0;n<arguments.length;n++)t.push(arguments[n]);var i=t.pop();if("function"!=typeof i)throw new TypeError("The last argument must be of type Function");var s=this,a=function(){return i.apply(s,arguments)};e.apply(this,t).then((function(e){r.nextTick(a.bind(null,null,e))}),(function(e){r.nextTick(R.bind(null,e,a))}))}return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),Object.defineProperties(t,i(e)),t}},6430:(e,t,n)=>{"use strict";var r=n(4029),i=n(3083),s=n(1924),a=s("Object.prototype.toString"),o=n(6410)(),l="undefined"==typeof globalThis?n.g:globalThis,c=i(),u=s("String.prototype.slice"),h={},d=n(882),p=Object.getPrototypeOf;o&&d&&p&&r(c,(function(e){if("function"==typeof l[e]){var t=new l[e];if(Symbol.toStringTag in t){var n=p(t),r=d(n,Symbol.toStringTag);if(!r){var i=p(n);r=d(i,Symbol.toStringTag)}h[e]=r.get}}}));var f=n(5692);e.exports=function(e){return!!f(e)&&(o&&Symbol.toStringTag in e?function(e){var t=!1;return r(h,(function(n,r){if(!t)try{var i=n.call(e);i===r&&(t=i)}catch(e){}})),t}(e):u(a(e),8,-1))}},9127:()=>{},914:()=>{},5410:()=>{},8628:()=>{},5778:()=>{},1601:()=>{},7792:()=>{},4977:()=>{},5042:()=>{},3083:(e,t,n)=>{"use strict";var r=["BigInt64Array","BigUint64Array","Float32Array","Float64Array","Int16Array","Int32Array","Int8Array","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray"],i="undefined"==typeof globalThis?n.g:globalThis;e.exports=function(){for(var e=[],t=0;t<r.length;t++)"function"==typeof i[r[t]]&&(e[e.length]=r[t]);return e}},882:(e,t,n)=>{"use strict";var r=n(210)("%Object.getOwnPropertyDescriptor%",!0);if(r)try{r([],"length")}catch(e){r=null}e.exports=r},5232:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n="141",r=100,i=300,s=301,a=302,o=303,l=304,c=306,u=1e3,h=1001,d=1002,p=1003,f=1004,m=1005,g=1006,y=1007,v=1008,x=1009,b=1012,w=1014,_=1015,S=1016,M=1020,T=1023,E=1026,A=1027,C=33776,I=33777,N=33778,k=33779,R=35840,D=35841,L=35842,F=35843,P=37492,O=37496,z=37808,B=37809,U=37810,$=37811,V=37812,W=37813,G=37814,H=37815,j=37816,q=37817,X=37818,Y=37819,K=37820,Z=37821,J=36492,Q=2300,ee=2301,te=2302,ne=2400,re=2401,ie=2402,se=2501,ae=3e3,oe=3001,le="srgb",ce="srgb-linear",ue=7680,he=35044,de="300 es",pe=1035;class fe{addEventListener(e,t){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[e]&&(n[e]=[]),-1===n[e].indexOf(t)&&n[e].push(t)}hasEventListener(e,t){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[e]&&-1!==n[e].indexOf(t)}removeEventListener(e,t){if(void 0===this._listeners)return;const n=this._listeners[e];if(void 0!==n){const e=n.indexOf(t);-1!==e&&n.splice(e,1)}}dispatchEvent(e){if(void 0===this._listeners)return;const t=this._listeners[e.type];if(void 0!==t){e.target=this;const n=t.slice(0);for(let t=0,r=n.length;t<r;t++)n[t].call(this,e);e.target=null}}}const me=[];for(let e=0;e<256;e++)me[e]=(e<16?"0":"")+e.toString(16);let ge=1234567;const ye=Math.PI/180,ve=180/Math.PI;function xe(){const e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,n=4294967295*Math.random()|0,r=4294967295*Math.random()|0;return(me[255&e]+me[e>>8&255]+me[e>>16&255]+me[e>>24&255]+"-"+me[255&t]+me[t>>8&255]+"-"+me[t>>16&15|64]+me[t>>24&255]+"-"+me[63&n|128]+me[n>>8&255]+"-"+me[n>>16&255]+me[n>>24&255]+me[255&r]+me[r>>8&255]+me[r>>16&255]+me[r>>24&255]).toLowerCase()}function be(e,t,n){return Math.max(t,Math.min(n,e))}function we(e,t){return(e%t+t)%t}function _e(e,t,n){return(1-n)*e+n*t}function Se(e){return 0==(e&e-1)&&0!==e}function Me(e){return Math.pow(2,Math.ceil(Math.log(e)/Math.LN2))}function Te(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))}var Ee=Object.freeze({__proto__:null,DEG2RAD:ye,RAD2DEG:ve,generateUUID:xe,clamp:be,euclideanModulo:we,mapLinear:function(e,t,n,r,i){return r+(e-t)*(i-r)/(n-t)},inverseLerp:function(e,t,n){return e!==t?(n-e)/(t-e):0},lerp:_e,damp:function(e,t,n,r){return _e(e,t,1-Math.exp(-n*r))},pingpong:function(e,t=1){return t-Math.abs(we(e,2*t)-t)},smoothstep:function(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t))*e*(3-2*e)},smootherstep:function(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t))*e*e*(e*(6*e-15)+10)},randInt:function(e,t){return e+Math.floor(Math.random()*(t-e+1))},randFloat:function(e,t){return e+Math.random()*(t-e)},randFloatSpread:function(e){return e*(.5-Math.random())},seededRandom:function(e){void 0!==e&&(ge=e);let t=ge+=1831565813;return t=Math.imul(t^t>>>15,1|t),t^=t+Math.imul(t^t>>>7,61|t),((t^t>>>14)>>>0)/4294967296},degToRad:function(e){return e*ye},radToDeg:function(e){return e*ve},isPowerOfTwo:Se,ceilPowerOfTwo:Me,floorPowerOfTwo:Te,setQuaternionFromProperEuler:function(e,t,n,r,i){const s=Math.cos,a=Math.sin,o=s(n/2),l=a(n/2),c=s((t+r)/2),u=a((t+r)/2),h=s((t-r)/2),d=a((t-r)/2),p=s((r-t)/2),f=a((r-t)/2);switch(i){case"XYX":e.set(o*u,l*h,l*d,o*c);break;case"YZY":e.set(l*d,o*u,l*h,o*c);break;case"ZXZ":e.set(l*h,l*d,o*u,o*c);break;case"XZX":e.set(o*u,l*f,l*p,o*c);break;case"YXY":e.set(l*p,o*u,l*f,o*c);break;case"ZYZ":e.set(l*f,l*p,o*u,o*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}},normalize:function(e,t){switch(t.constructor){case Float32Array:return e;case Uint16Array:return Math.round(65535*e);case Uint8Array:return Math.round(255*e);case Int16Array:return Math.round(32767*e);case Int8Array:return Math.round(127*e);default:throw new Error("Invalid component type.")}},denormalize:function(e,t){switch(t.constructor){case Float32Array:return e;case Uint16Array:return e/65535;case Uint8Array:return e/255;case Int16Array:return Math.max(e/32767,-1);case Int8Array:return Math.max(e/127,-1);default:throw new Error("Invalid component type.")}}});class Ae{constructor(e=0,t=0){this.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,r=e.elements;return this.x=r[0]*t+r[3]*n+r[6],this.y=r[1]*t+r[4]*n+r[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,n){return void 0!==n&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),r=Math.sin(t),i=this.x-e.x,s=this.y-e.y;return this.x=i*n-s*r+e.x,this.y=i*r+s*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Ce{constructor(){this.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,r,i,s,a,o,l){const c=this.elements;return c[0]=e,c[1]=r,c[2]=a,c[3]=t,c[4]=i,c[5]=o,c[6]=n,c[7]=s,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,r=t.elements,i=this.elements,s=n[0],a=n[3],o=n[6],l=n[1],c=n[4],u=n[7],h=n[2],d=n[5],p=n[8],f=r[0],m=r[3],g=r[6],y=r[1],v=r[4],x=r[7],b=r[2],w=r[5],_=r[8];return i[0]=s*f+a*y+o*b,i[3]=s*m+a*v+o*w,i[6]=s*g+a*x+o*_,i[1]=l*f+c*y+u*b,i[4]=l*m+c*v+u*w,i[7]=l*g+c*x+u*_,i[2]=h*f+d*y+p*b,i[5]=h*m+d*v+p*w,i[8]=h*g+d*x+p*_,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],a=e[5],o=e[6],l=e[7],c=e[8];return t*s*c-t*a*l-n*i*c+n*a*o+r*i*l-r*s*o}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],a=e[5],o=e[6],l=e[7],c=e[8],u=c*s-a*l,h=a*o-c*i,d=l*i-s*o,p=t*u+n*h+r*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const f=1/p;return e[0]=u*f,e[1]=(r*l-c*n)*f,e[2]=(a*n-r*s)*f,e[3]=h*f,e[4]=(c*t-r*o)*f,e[5]=(r*i-a*t)*f,e[6]=d*f,e[7]=(n*o-l*t)*f,e[8]=(s*t-n*i)*f,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,r,i,s,a){const o=Math.cos(i),l=Math.sin(i);return this.set(n*o,n*l,-n*(o*s+l*a)+s+e,-r*l,r*o,-r*(-l*s+o*a)+a+t,0,0,1),this}scale(e,t){const n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=t,n[4]*=t,n[7]*=t,this}rotate(e){const t=Math.cos(e),n=Math.sin(e),r=this.elements,i=r[0],s=r[3],a=r[6],o=r[1],l=r[4],c=r[7];return r[0]=t*i+n*o,r[3]=t*s+n*l,r[6]=t*a+n*c,r[1]=-n*i+t*o,r[4]=-n*s+t*l,r[7]=-n*a+t*c,this}translate(e,t){const n=this.elements;return n[0]+=e*n[2],n[3]+=e*n[5],n[6]+=e*n[8],n[1]+=t*n[2],n[4]+=t*n[5],n[7]+=t*n[8],this}equals(e){const t=this.elements,n=e.elements;for(let e=0;e<9;e++)if(t[e]!==n[e])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return(new this.constructor).fromArray(this.elements)}}function Ie(e){for(let t=e.length-1;t>=0;--t)if(e[t]>65535)return!0;return!1}const Ne={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function ke(e,t){return new Ne[e](t)}function Re(e){return document.createElementNS("http://www.w3.org/1999/xhtml",e)}function De(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}function Le(e){return e<.0031308?12.92*e:1.055*Math.pow(e,.41666)-.055}const Fe={[le]:{[ce]:De},[ce]:{[le]:Le}},Pe={legacyMode:!0,get workingColorSpace(){return ce},set workingColorSpace(e){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(e,t,n){if(this.legacyMode||t===n||!t||!n)return e;if(Fe[t]&&void 0!==Fe[t][n]){const r=Fe[t][n];return e.r=r(e.r),e.g=r(e.g),e.b=r(e.b),e}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(e,t){return this.convert(e,this.workingColorSpace,t)},toWorkingColorSpace:function(e,t){return this.convert(e,t,this.workingColorSpace)}},Oe={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},ze={r:0,g:0,b:0},Be={h:0,s:0,l:0},Ue={h:0,s:0,l:0};function $e(e,t,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+6*(t-e)*n:n<.5?t:n<2/3?e+6*(t-e)*(2/3-n):e}function Ve(e,t){return t.r=e.r,t.g=e.g,t.b=e.b,t}class We{constructor(e,t,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,void 0===t&&void 0===n?this.set(e):this.setRGB(e,t,n)}set(e){return e&&e.isColor?this.copy(e):"number"==typeof e?this.setHex(e):"string"==typeof e&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t="srgb"){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(255&e)/255,Pe.toWorkingColorSpace(this,t),this}setRGB(e,t,n,r="srgb-linear"){return this.r=e,this.g=t,this.b=n,Pe.toWorkingColorSpace(this,r),this}setHSL(e,t,n,r="srgb-linear"){if(e=we(e,1),t=be(t,0,1),n=be(n,0,1),0===t)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+t):n+t-n*t,i=2*n-r;this.r=$e(i,r,e+1/3),this.g=$e(i,r,e),this.b=$e(i,r,e-1/3)}return Pe.toWorkingColorSpace(this,r),this}setStyle(e,t="srgb"){function n(t){void 0!==t&&parseFloat(t)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let r;if(r=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let e;const i=r[1],s=r[2];switch(i){case"rgb":case"rgba":if(e=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return this.r=Math.min(255,parseInt(e[1],10))/255,this.g=Math.min(255,parseInt(e[2],10))/255,this.b=Math.min(255,parseInt(e[3],10))/255,Pe.toWorkingColorSpace(this,t),n(e[4]),this;if(e=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return this.r=Math.min(100,parseInt(e[1],10))/100,this.g=Math.min(100,parseInt(e[2],10))/100,this.b=Math.min(100,parseInt(e[3],10))/100,Pe.toWorkingColorSpace(this,t),n(e[4]),this;break;case"hsl":case"hsla":if(e=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)){const r=parseFloat(e[1])/360,i=parseInt(e[2],10)/100,s=parseInt(e[3],10)/100;return n(e[4]),this.setHSL(r,i,s,t)}}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(e)){const e=r[1],n=e.length;if(3===n)return this.r=parseInt(e.charAt(0)+e.charAt(0),16)/255,this.g=parseInt(e.charAt(1)+e.charAt(1),16)/255,this.b=parseInt(e.charAt(2)+e.charAt(2),16)/255,Pe.toWorkingColorSpace(this,t),this;if(6===n)return this.r=parseInt(e.charAt(0)+e.charAt(1),16)/255,this.g=parseInt(e.charAt(2)+e.charAt(3),16)/255,this.b=parseInt(e.charAt(4)+e.charAt(5),16)/255,Pe.toWorkingColorSpace(this,t),this}return e&&e.length>0?this.setColorName(e,t):this}setColorName(e,t="srgb"){const n=Oe[e.toLowerCase()];return void 0!==n?this.setHex(n,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=De(e.r),this.g=De(e.g),this.b=De(e.b),this}copyLinearToSRGB(e){return this.r=Le(e.r),this.g=Le(e.g),this.b=Le(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e="srgb"){return Pe.fromWorkingColorSpace(Ve(this,ze),e),be(255*ze.r,0,255)<<16^be(255*ze.g,0,255)<<8^be(255*ze.b,0,255)<<0}getHexString(e="srgb"){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t="srgb-linear"){Pe.fromWorkingColorSpace(Ve(this,ze),t);const n=ze.r,r=ze.g,i=ze.b,s=Math.max(n,r,i),a=Math.min(n,r,i);let o,l;const c=(a+s)/2;if(a===s)o=0,l=0;else{const e=s-a;switch(l=c<=.5?e/(s+a):e/(2-s-a),s){case n:o=(r-i)/e+(r<i?6:0);break;case r:o=(i-n)/e+2;break;case i:o=(n-r)/e+4}o/=6}return e.h=o,e.s=l,e.l=c,e}getRGB(e,t="srgb-linear"){return Pe.fromWorkingColorSpace(Ve(this,ze),t),e.r=ze.r,e.g=ze.g,e.b=ze.b,e}getStyle(e="srgb"){return Pe.fromWorkingColorSpace(Ve(this,ze),e),e!==le?`color(${e} ${ze.r} ${ze.g} ${ze.b})`:`rgb(${255*ze.r|0},${255*ze.g|0},${255*ze.b|0})`}offsetHSL(e,t,n){return this.getHSL(Be),Be.h+=e,Be.s+=t,Be.l+=n,this.setHSL(Be.h,Be.s,Be.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(Be),e.getHSL(Ue);const n=_e(Be.h,Ue.h,t),r=_e(Be.s,Ue.s,t),i=_e(Be.l,Ue.l,t);return this.setHSL(n,r,i),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),!0===e.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}let Ge;We.NAMES=Oe;class He{static getDataURL(e){if(/^data:/i.test(e.src))return e.src;if("undefined"==typeof HTMLCanvasElement)return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{void 0===Ge&&(Ge=Re("canvas")),Ge.width=e.width,Ge.height=e.height;const n=Ge.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=Ge}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap){const t=Re("canvas");t.width=e.width,t.height=e.height;const n=t.getContext("2d");n.drawImage(e,0,0,e.width,e.height);const r=n.getImageData(0,0,e.width,e.height),i=r.data;for(let e=0;e<i.length;e++)i[e]=255*De(i[e]/255);return n.putImageData(r,0,0),t}if(e.data){const t=e.data.slice(0);for(let e=0;e<t.length;e++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[e]=Math.floor(255*De(t[e]/255)):t[e]=De(t[e]);return{data:t,width:e.width,height:e.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}class je{constructor(e=null){this.isSource=!0,this.uuid=xe(),this.data=e,this.version=0}set needsUpdate(e){!0===e&&this.version++}toJSON(e){const t=void 0===e||"string"==typeof e;if(!t&&void 0!==e.images[this.uuid])return e.images[this.uuid];const n={uuid:this.uuid,url:""},r=this.data;if(null!==r){let e;if(Array.isArray(r)){e=[];for(let t=0,n=r.length;t<n;t++)r[t].isDataTexture?e.push(qe(r[t].image)):e.push(qe(r[t]))}else e=qe(r);n.url=e}return t||(e.images[this.uuid]=n),n}}function qe(e){return"undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap?He.getDataURL(e):e.data?{data:Array.prototype.slice.call(e.data),width:e.width,height:e.height,type:e.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Xe=0;class Ye extends fe{constructor(e=Ye.DEFAULT_IMAGE,t=Ye.DEFAULT_MAPPING,n=1001,r=1001,i=1006,s=1008,a=1023,o=1009,l=1,c=3e3){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Xe++}),this.uuid=xe(),this.name="",this.source=new je(e),this.mipmaps=[],this.mapping=t,this.wrapS=n,this.wrapT=r,this.magFilter=i,this.minFilter=s,this.anisotropy=l,this.format=a,this.internalFormat=null,this.type=o,this.offset=new Ae(0,0),this.repeat=new Ae(1,1),this.center=new Ae(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Ce,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=void 0===e||"string"==typeof e;if(!t&&void 0!==e.textures[this.uuid])return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==i)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case u:e.x=e.x-Math.floor(e.x);break;case h:e.x=e.x<0?0:1;break;case d:1===Math.abs(Math.floor(e.x)%2)?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x)}if(e.y<0||e.y>1)switch(this.wrapT){case u:e.y=e.y-Math.floor(e.y);break;case h:e.y=e.y<0?0:1;break;case d:1===Math.abs(Math.floor(e.y)%2)?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y)}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){!0===e&&(this.version++,this.source.needsUpdate=!0)}}Ye.DEFAULT_IMAGE=null,Ye.DEFAULT_MAPPING=i;class Ke{constructor(e=0,t=0,n=0,r=1){this.isVector4=!0,this.x=e,this.y=t,this.z=n,this.w=r}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,r){return this.x=e,this.y=t,this.z=n,this.w=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=void 0!==e.w?e.w:1,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,r=this.z,i=this.w,s=e.elements;return this.x=s[0]*t+s[4]*n+s[8]*r+s[12]*i,this.y=s[1]*t+s[5]*n+s[9]*r+s[13]*i,this.z=s[2]*t+s[6]*n+s[10]*r+s[14]*i,this.w=s[3]*t+s[7]*n+s[11]*r+s[15]*i,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,r,i;const s=.01,a=.1,o=e.elements,l=o[0],c=o[4],u=o[8],h=o[1],d=o[5],p=o[9],f=o[2],m=o[6],g=o[10];if(Math.abs(c-h)<s&&Math.abs(u-f)<s&&Math.abs(p-m)<s){if(Math.abs(c+h)<a&&Math.abs(u+f)<a&&Math.abs(p+m)<a&&Math.abs(l+d+g-3)<a)return this.set(1,0,0,0),this;t=Math.PI;const e=(l+1)/2,o=(d+1)/2,y=(g+1)/2,v=(c+h)/4,x=(u+f)/4,b=(p+m)/4;return e>o&&e>y?e<s?(n=0,r=.707106781,i=.707106781):(n=Math.sqrt(e),r=v/n,i=x/n):o>y?o<s?(n=.707106781,r=0,i=.707106781):(r=Math.sqrt(o),n=v/r,i=b/r):y<s?(n=.707106781,r=.707106781,i=0):(i=Math.sqrt(y),n=x/i,r=b/i),this.set(n,r,i,t),this}let y=Math.sqrt((m-p)*(m-p)+(u-f)*(u-f)+(h-c)*(h-c));return Math.abs(y)<.001&&(y=1),this.x=(m-p)/y,this.y=(u-f)/y,this.z=(h-c)/y,this.w=Math.acos((l+d+g-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,n){return void 0!==n&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class Ze extends fe{constructor(e,t,n={}){super(),this.isWebGLRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new Ke(0,0,e,t),this.scissorTest=!1,this.viewport=new Ke(0,0,e,t);const r={width:e,height:t,depth:1};this.texture=new Ye(r,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.internalFormat=void 0!==n.internalFormat?n.internalFormat:null,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:g,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null,this.samples=void 0!==n.samples?n.samples:0}setSize(e,t,n=1){this.width===e&&this.height===t&&this.depth===n||(this.width=e,this.height=t,this.depth=n,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return(new this.constructor).copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new je(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,null!==e.depthTexture&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Je extends Ye{constructor(e=null,t=1,n=1,r=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:n,depth:r},this.magFilter=p,this.minFilter=p,this.wrapR=h,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Qe extends Ye{constructor(e=null,t=1,n=1,r=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:n,depth:r},this.magFilter=p,this.minFilter=p,this.wrapR=h,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class et{constructor(e=0,t=0,n=0,r=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=n,this._w=r}static slerp(e,t,n,r){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(e,t,r)}static slerpFlat(e,t,n,r,i,s,a){let o=n[r+0],l=n[r+1],c=n[r+2],u=n[r+3];const h=i[s+0],d=i[s+1],p=i[s+2],f=i[s+3];if(0===a)return e[t+0]=o,e[t+1]=l,e[t+2]=c,void(e[t+3]=u);if(1===a)return e[t+0]=h,e[t+1]=d,e[t+2]=p,void(e[t+3]=f);if(u!==f||o!==h||l!==d||c!==p){let e=1-a;const t=o*h+l*d+c*p+u*f,n=t>=0?1:-1,r=1-t*t;if(r>Number.EPSILON){const i=Math.sqrt(r),s=Math.atan2(i,t*n);e=Math.sin(e*s)/i,a=Math.sin(a*s)/i}const i=a*n;if(o=o*e+h*i,l=l*e+d*i,c=c*e+p*i,u=u*e+f*i,e===1-a){const e=1/Math.sqrt(o*o+l*l+c*c+u*u);o*=e,l*=e,c*=e,u*=e}}e[t]=o,e[t+1]=l,e[t+2]=c,e[t+3]=u}static multiplyQuaternionsFlat(e,t,n,r,i,s){const a=n[r],o=n[r+1],l=n[r+2],c=n[r+3],u=i[s],h=i[s+1],d=i[s+2],p=i[s+3];return e[t]=a*p+c*u+o*d-l*h,e[t+1]=o*p+c*h+l*u-a*d,e[t+2]=l*p+c*d+a*h-o*u,e[t+3]=c*p-a*u-o*h-l*d,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,r){return this._x=e,this._y=t,this._z=n,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!e||!e.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=e._x,r=e._y,i=e._z,s=e._order,a=Math.cos,o=Math.sin,l=a(n/2),c=a(r/2),u=a(i/2),h=o(n/2),d=o(r/2),p=o(i/2);switch(s){case"XYZ":this._x=h*c*u+l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u-h*d*p;break;case"YXZ":this._x=h*c*u+l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u+h*d*p;break;case"ZXY":this._x=h*c*u-l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u-h*d*p;break;case"ZYX":this._x=h*c*u-l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u+h*d*p;break;case"YZX":this._x=h*c*u+l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u-h*d*p;break;case"XZY":this._x=h*c*u-l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u+h*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!1!==t&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,r=Math.sin(n);return this._x=e.x*r,this._y=e.y*r,this._z=e.z*r,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],r=t[4],i=t[8],s=t[1],a=t[5],o=t[9],l=t[2],c=t[6],u=t[10],h=n+a+u;if(h>0){const e=.5/Math.sqrt(h+1);this._w=.25/e,this._x=(c-o)*e,this._y=(i-l)*e,this._z=(s-r)*e}else if(n>a&&n>u){const e=2*Math.sqrt(1+n-a-u);this._w=(c-o)/e,this._x=.25*e,this._y=(r+s)/e,this._z=(i+l)/e}else if(a>u){const e=2*Math.sqrt(1+a-n-u);this._w=(i-l)/e,this._x=(r+s)/e,this._y=.25*e,this._z=(o+c)/e}else{const e=2*Math.sqrt(1+u-n-a);this._w=(s-r)/e,this._x=(i+l)/e,this._y=(o+c)/e,this._z=.25*e}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(be(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(0===n)return this;const r=Math.min(1,t/n);return this.slerp(e,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return 0===e?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return void 0!==t?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,r=e._y,i=e._z,s=e._w,a=t._x,o=t._y,l=t._z,c=t._w;return this._x=n*c+s*a+r*l-i*o,this._y=r*c+s*o+i*a-n*l,this._z=i*c+s*l+n*o-r*a,this._w=s*c-n*a-r*o-i*l,this._onChangeCallback(),this}slerp(e,t){if(0===t)return this;if(1===t)return this.copy(e);const n=this._x,r=this._y,i=this._z,s=this._w;let a=s*e._w+n*e._x+r*e._y+i*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=s,this._x=n,this._y=r,this._z=i,this;const o=1-a*a;if(o<=Number.EPSILON){const e=1-t;return this._w=e*s+t*this._w,this._x=e*n+t*this._x,this._y=e*r+t*this._y,this._z=e*i+t*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(o),c=Math.atan2(l,a),u=Math.sin((1-t)*c)/l,h=Math.sin(t*c)/l;return this._w=s*u+this._w*h,this._x=n*u+this._x*h,this._y=r*u+this._y*h,this._z=i*u+this._z*h,this._onChangeCallback(),this}slerpQuaternions(e,t,n){return this.copy(e).slerp(t,n)}random(){const e=Math.random(),t=Math.sqrt(1-e),n=Math.sqrt(e),r=2*Math.PI*Math.random(),i=2*Math.PI*Math.random();return this.set(t*Math.cos(r),n*Math.sin(i),n*Math.cos(i),t*Math.sin(r))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class tt{constructor(e=0,t=0,n=0){this.isVector3=!0,this.x=e,this.y=t,this.z=n}set(e,t,n){return void 0===n&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return void 0!==t?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(rt.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(rt.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,r=this.z,i=e.elements;return this.x=i[0]*t+i[3]*n+i[6]*r,this.y=i[1]*t+i[4]*n+i[7]*r,this.z=i[2]*t+i[5]*n+i[8]*r,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,r=this.z,i=e.elements,s=1/(i[3]*t+i[7]*n+i[11]*r+i[15]);return this.x=(i[0]*t+i[4]*n+i[8]*r+i[12])*s,this.y=(i[1]*t+i[5]*n+i[9]*r+i[13])*s,this.z=(i[2]*t+i[6]*n+i[10]*r+i[14])*s,this}applyQuaternion(e){const t=this.x,n=this.y,r=this.z,i=e.x,s=e.y,a=e.z,o=e.w,l=o*t+s*r-a*n,c=o*n+a*t-i*r,u=o*r+i*n-s*t,h=-i*t-s*n-a*r;return this.x=l*o+h*-i+c*-a-u*-s,this.y=c*o+h*-s+u*-i-l*-a,this.z=u*o+h*-a+l*-s-c*-i,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,r=this.z,i=e.elements;return this.x=i[0]*t+i[4]*n+i[8]*r,this.y=i[1]*t+i[5]*n+i[9]*r,this.z=i[2]*t+i[6]*n+i[10]*r,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e,t){return void 0!==t?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,r=e.y,i=e.z,s=t.x,a=t.y,o=t.z;return this.x=r*o-i*a,this.y=i*s-n*o,this.z=n*a-r*s,this}projectOnVector(e){const t=e.lengthSq();if(0===t)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return nt.copy(this).projectOnVector(e),this.sub(nt)}reflect(e){return this.sub(nt.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(0===t)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(be(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,r=this.z-e.z;return t*t+n*n+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const r=Math.sin(t)*e;return this.x=r*Math.sin(n),this.y=Math.cos(t)*e,this.z=r*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),r=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=r,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,4*t)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,3*t)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,n){return void 0!==n&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=2*(Math.random()-.5),t=Math.random()*Math.PI*2,n=Math.sqrt(1-e**2);return this.x=n*Math.cos(t),this.y=n*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const nt=new tt,rt=new et;class it{constructor(e=new tt(1/0,1/0,1/0),t=new tt(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,n=1/0,r=1/0,i=-1/0,s=-1/0,a=-1/0;for(let o=0,l=e.length;o<l;o+=3){const l=e[o],c=e[o+1],u=e[o+2];l<t&&(t=l),c<n&&(n=c),u<r&&(r=u),l>i&&(i=l),c>s&&(s=c),u>a&&(a=u)}return this.min.set(t,n,r),this.max.set(i,s,a),this}setFromBufferAttribute(e){let t=1/0,n=1/0,r=1/0,i=-1/0,s=-1/0,a=-1/0;for(let o=0,l=e.count;o<l;o++){const l=e.getX(o),c=e.getY(o),u=e.getZ(o);l<t&&(t=l),c<n&&(n=c),u<r&&(r=u),l>i&&(i=l),c>s&&(s=c),u>a&&(a=u)}return this.min.set(t,n,r),this.max.set(i,s,a),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=at.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return(new this.constructor).copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const n=e.geometry;if(void 0!==n)if(t&&null!=n.attributes&&void 0!==n.attributes.position){const t=n.attributes.position;for(let n=0,r=t.count;n<r;n++)at.fromBufferAttribute(t,n).applyMatrix4(e.matrixWorld),this.expandByPoint(at)}else null===n.boundingBox&&n.computeBoundingBox(),ot.copy(n.boundingBox),ot.applyMatrix4(e.matrixWorld),this.union(ot);const r=e.children;for(let e=0,n=r.length;e<n;e++)this.expandByObject(r[e],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,at),at.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(ft),mt.subVectors(this.max,ft),lt.subVectors(e.a,ft),ct.subVectors(e.b,ft),ut.subVectors(e.c,ft),ht.subVectors(ct,lt),dt.subVectors(ut,ct),pt.subVectors(lt,ut);let t=[0,-ht.z,ht.y,0,-dt.z,dt.y,0,-pt.z,pt.y,ht.z,0,-ht.x,dt.z,0,-dt.x,pt.z,0,-pt.x,-ht.y,ht.x,0,-dt.y,dt.x,0,-pt.y,pt.x,0];return!!vt(t,lt,ct,ut,mt)&&(t=[1,0,0,0,1,0,0,0,1],!!vt(t,lt,ct,ut,mt)&&(gt.crossVectors(ht,dt),t=[gt.x,gt.y,gt.z],vt(t,lt,ct,ut,mt)))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return at.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=.5*this.getSize(at).length(),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()||(st[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),st[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),st[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),st[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),st[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),st[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),st[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),st[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(st)),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const st=[new tt,new tt,new tt,new tt,new tt,new tt,new tt,new tt],at=new tt,ot=new it,lt=new tt,ct=new tt,ut=new tt,ht=new tt,dt=new tt,pt=new tt,ft=new tt,mt=new tt,gt=new tt,yt=new tt;function vt(e,t,n,r,i){for(let s=0,a=e.length-3;s<=a;s+=3){yt.fromArray(e,s);const a=i.x*Math.abs(yt.x)+i.y*Math.abs(yt.y)+i.z*Math.abs(yt.z),o=t.dot(yt),l=n.dot(yt),c=r.dot(yt);if(Math.max(-Math.max(o,l,c),Math.min(o,l,c))>a)return!1}return!0}const xt=new it,bt=new tt,wt=new tt,_t=new tt;class St{constructor(e=new tt,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;void 0!==t?n.copy(t):xt.setFromPoints(e).getCenter(n);let r=0;for(let t=0,i=e.length;t<i;t++)r=Math.max(r,n.distanceToSquared(e[t]));return this.radius=Math.sqrt(r),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){_t.subVectors(e,this.center);const t=_t.lengthSq();if(t>this.radius*this.radius){const e=Math.sqrt(t),n=.5*(e-this.radius);this.center.add(_t.multiplyScalar(n/e)),this.radius+=n}return this}union(e){return!0===this.center.equals(e.center)?wt.set(0,0,1).multiplyScalar(e.radius):wt.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(bt.copy(e.center).add(wt)),this.expandByPoint(bt.copy(e.center).sub(wt)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const Mt=new tt,Tt=new tt,Et=new tt,At=new tt,Ct=new tt,It=new tt,Nt=new tt;class kt{constructor(e=new tt,t=new tt(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Mt)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=Mt.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(Mt.copy(this.direction).multiplyScalar(t).add(this.origin),Mt.distanceToSquared(e))}distanceSqToSegment(e,t,n,r){Tt.copy(e).add(t).multiplyScalar(.5),Et.copy(t).sub(e).normalize(),At.copy(this.origin).sub(Tt);const i=.5*e.distanceTo(t),s=-this.direction.dot(Et),a=At.dot(this.direction),o=-At.dot(Et),l=At.lengthSq(),c=Math.abs(1-s*s);let u,h,d,p;if(c>0)if(u=s*o-a,h=s*a-o,p=i*c,u>=0)if(h>=-p)if(h<=p){const e=1/c;u*=e,h*=e,d=u*(u+s*h+2*a)+h*(s*u+h+2*o)+l}else h=i,u=Math.max(0,-(s*h+a)),d=-u*u+h*(h+2*o)+l;else h=-i,u=Math.max(0,-(s*h+a)),d=-u*u+h*(h+2*o)+l;else h<=-p?(u=Math.max(0,-(-s*i+a)),h=u>0?-i:Math.min(Math.max(-i,-o),i),d=-u*u+h*(h+2*o)+l):h<=p?(u=0,h=Math.min(Math.max(-i,-o),i),d=h*(h+2*o)+l):(u=Math.max(0,-(s*i+a)),h=u>0?i:Math.min(Math.max(-i,-o),i),d=-u*u+h*(h+2*o)+l);else h=s>0?-i:i,u=Math.max(0,-(s*h+a)),d=-u*u+h*(h+2*o)+l;return n&&n.copy(this.direction).multiplyScalar(u).add(this.origin),r&&r.copy(Et).multiplyScalar(h).add(Tt),d}intersectSphere(e,t){Mt.subVectors(e.center,this.origin);const n=Mt.dot(this.direction),r=Mt.dot(Mt)-n*n,i=e.radius*e.radius;if(r>i)return null;const s=Math.sqrt(i-r),a=n-s,o=n+s;return a<0&&o<0?null:a<0?this.at(o,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(0===t)return 0===e.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return null===n?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return 0===t||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,r,i,s,a,o;const l=1/this.direction.x,c=1/this.direction.y,u=1/this.direction.z,h=this.origin;return l>=0?(n=(e.min.x-h.x)*l,r=(e.max.x-h.x)*l):(n=(e.max.x-h.x)*l,r=(e.min.x-h.x)*l),c>=0?(i=(e.min.y-h.y)*c,s=(e.max.y-h.y)*c):(i=(e.max.y-h.y)*c,s=(e.min.y-h.y)*c),n>s||i>r?null:((i>n||n!=n)&&(n=i),(s<r||r!=r)&&(r=s),u>=0?(a=(e.min.z-h.z)*u,o=(e.max.z-h.z)*u):(a=(e.max.z-h.z)*u,o=(e.min.z-h.z)*u),n>o||a>r?null:((a>n||n!=n)&&(n=a),(o<r||r!=r)&&(r=o),r<0?null:this.at(n>=0?n:r,t)))}intersectsBox(e){return null!==this.intersectBox(e,Mt)}intersectTriangle(e,t,n,r,i){Ct.subVectors(t,e),It.subVectors(n,e),Nt.crossVectors(Ct,It);let s,a=this.direction.dot(Nt);if(a>0){if(r)return null;s=1}else{if(!(a<0))return null;s=-1,a=-a}At.subVectors(this.origin,e);const o=s*this.direction.dot(It.crossVectors(At,It));if(o<0)return null;const l=s*this.direction.dot(Ct.cross(At));if(l<0)return null;if(o+l>a)return null;const c=-s*At.dot(Nt);return c<0?null:this.at(c/a,i)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class Rt{constructor(){this.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,r,i,s,a,o,l,c,u,h,d,p,f,m){const g=this.elements;return g[0]=e,g[4]=t,g[8]=n,g[12]=r,g[1]=i,g[5]=s,g[9]=a,g[13]=o,g[2]=l,g[6]=c,g[10]=u,g[14]=h,g[3]=d,g[7]=p,g[11]=f,g[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Rt).fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,r=1/Dt.setFromMatrixColumn(e,0).length(),i=1/Dt.setFromMatrixColumn(e,1).length(),s=1/Dt.setFromMatrixColumn(e,2).length();return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=0,t[4]=n[4]*i,t[5]=n[5]*i,t[6]=n[6]*i,t[7]=0,t[8]=n[8]*s,t[9]=n[9]*s,t[10]=n[10]*s,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,n=e.x,r=e.y,i=e.z,s=Math.cos(n),a=Math.sin(n),o=Math.cos(r),l=Math.sin(r),c=Math.cos(i),u=Math.sin(i);if("XYZ"===e.order){const e=s*c,n=s*u,r=a*c,i=a*u;t[0]=o*c,t[4]=-o*u,t[8]=l,t[1]=n+r*l,t[5]=e-i*l,t[9]=-a*o,t[2]=i-e*l,t[6]=r+n*l,t[10]=s*o}else if("YXZ"===e.order){const e=o*c,n=o*u,r=l*c,i=l*u;t[0]=e+i*a,t[4]=r*a-n,t[8]=s*l,t[1]=s*u,t[5]=s*c,t[9]=-a,t[2]=n*a-r,t[6]=i+e*a,t[10]=s*o}else if("ZXY"===e.order){const e=o*c,n=o*u,r=l*c,i=l*u;t[0]=e-i*a,t[4]=-s*u,t[8]=r+n*a,t[1]=n+r*a,t[5]=s*c,t[9]=i-e*a,t[2]=-s*l,t[6]=a,t[10]=s*o}else if("ZYX"===e.order){const e=s*c,n=s*u,r=a*c,i=a*u;t[0]=o*c,t[4]=r*l-n,t[8]=e*l+i,t[1]=o*u,t[5]=i*l+e,t[9]=n*l-r,t[2]=-l,t[6]=a*o,t[10]=s*o}else if("YZX"===e.order){const e=s*o,n=s*l,r=a*o,i=a*l;t[0]=o*c,t[4]=i-e*u,t[8]=r*u+n,t[1]=u,t[5]=s*c,t[9]=-a*c,t[2]=-l*c,t[6]=n*u+r,t[10]=e-i*u}else if("XZY"===e.order){const e=s*o,n=s*l,r=a*o,i=a*l;t[0]=o*c,t[4]=-u,t[8]=l*c,t[1]=e*u+i,t[5]=s*c,t[9]=n*u-r,t[2]=r*u-n,t[6]=a*c,t[10]=i*u+e}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Ft,e,Pt)}lookAt(e,t,n){const r=this.elements;return Bt.subVectors(e,t),0===Bt.lengthSq()&&(Bt.z=1),Bt.normalize(),Ot.crossVectors(n,Bt),0===Ot.lengthSq()&&(1===Math.abs(n.z)?Bt.x+=1e-4:Bt.z+=1e-4,Bt.normalize(),Ot.crossVectors(n,Bt)),Ot.normalize(),zt.crossVectors(Bt,Ot),r[0]=Ot.x,r[4]=zt.x,r[8]=Bt.x,r[1]=Ot.y,r[5]=zt.y,r[9]=Bt.y,r[2]=Ot.z,r[6]=zt.z,r[10]=Bt.z,this}multiply(e,t){return void 0!==t?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,r=t.elements,i=this.elements,s=n[0],a=n[4],o=n[8],l=n[12],c=n[1],u=n[5],h=n[9],d=n[13],p=n[2],f=n[6],m=n[10],g=n[14],y=n[3],v=n[7],x=n[11],b=n[15],w=r[0],_=r[4],S=r[8],M=r[12],T=r[1],E=r[5],A=r[9],C=r[13],I=r[2],N=r[6],k=r[10],R=r[14],D=r[3],L=r[7],F=r[11],P=r[15];return i[0]=s*w+a*T+o*I+l*D,i[4]=s*_+a*E+o*N+l*L,i[8]=s*S+a*A+o*k+l*F,i[12]=s*M+a*C+o*R+l*P,i[1]=c*w+u*T+h*I+d*D,i[5]=c*_+u*E+h*N+d*L,i[9]=c*S+u*A+h*k+d*F,i[13]=c*M+u*C+h*R+d*P,i[2]=p*w+f*T+m*I+g*D,i[6]=p*_+f*E+m*N+g*L,i[10]=p*S+f*A+m*k+g*F,i[14]=p*M+f*C+m*R+g*P,i[3]=y*w+v*T+x*I+b*D,i[7]=y*_+v*E+x*N+b*L,i[11]=y*S+v*A+x*k+b*F,i[15]=y*M+v*C+x*R+b*P,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],r=e[8],i=e[12],s=e[1],a=e[5],o=e[9],l=e[13],c=e[2],u=e[6],h=e[10],d=e[14];return e[3]*(+i*o*u-r*l*u-i*a*h+n*l*h+r*a*d-n*o*d)+e[7]*(+t*o*d-t*l*h+i*s*h-r*s*d+r*l*c-i*o*c)+e[11]*(+t*l*u-t*a*d-i*s*u+n*s*d+i*a*c-n*l*c)+e[15]*(-r*a*c-t*o*u+t*a*h+r*s*u-n*s*h+n*o*c)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const r=this.elements;return e.isVector3?(r[12]=e.x,r[13]=e.y,r[14]=e.z):(r[12]=e,r[13]=t,r[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],a=e[5],o=e[6],l=e[7],c=e[8],u=e[9],h=e[10],d=e[11],p=e[12],f=e[13],m=e[14],g=e[15],y=u*m*l-f*h*l+f*o*d-a*m*d-u*o*g+a*h*g,v=p*h*l-c*m*l-p*o*d+s*m*d+c*o*g-s*h*g,x=c*f*l-p*u*l+p*a*d-s*f*d-c*a*g+s*u*g,b=p*u*o-c*f*o-p*a*h+s*f*h+c*a*m-s*u*m,w=t*y+n*v+r*x+i*b;if(0===w)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const _=1/w;return e[0]=y*_,e[1]=(f*h*i-u*m*i-f*r*d+n*m*d+u*r*g-n*h*g)*_,e[2]=(a*m*i-f*o*i+f*r*l-n*m*l-a*r*g+n*o*g)*_,e[3]=(u*o*i-a*h*i-u*r*l+n*h*l+a*r*d-n*o*d)*_,e[4]=v*_,e[5]=(c*m*i-p*h*i+p*r*d-t*m*d-c*r*g+t*h*g)*_,e[6]=(p*o*i-s*m*i-p*r*l+t*m*l+s*r*g-t*o*g)*_,e[7]=(s*h*i-c*o*i+c*r*l-t*h*l-s*r*d+t*o*d)*_,e[8]=x*_,e[9]=(p*u*i-c*f*i-p*n*d+t*f*d+c*n*g-t*u*g)*_,e[10]=(s*f*i-p*a*i+p*n*l-t*f*l-s*n*g+t*a*g)*_,e[11]=(c*a*i-s*u*i-c*n*l+t*u*l+s*n*d-t*a*d)*_,e[12]=b*_,e[13]=(c*f*r-p*u*r+p*n*h-t*f*h-c*n*m+t*u*m)*_,e[14]=(p*a*r-s*f*r-p*n*o+t*f*o+s*n*m-t*a*m)*_,e[15]=(s*u*r-c*a*r+c*n*o-t*u*o-s*n*h+t*a*h)*_,this}scale(e){const t=this.elements,n=e.x,r=e.y,i=e.z;return t[0]*=n,t[4]*=r,t[8]*=i,t[1]*=n,t[5]*=r,t[9]*=i,t[2]*=n,t[6]*=r,t[10]*=i,t[3]*=n,t[7]*=r,t[11]*=i,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,r))}makeTranslation(e,t,n){return this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),r=Math.sin(t),i=1-n,s=e.x,a=e.y,o=e.z,l=i*s,c=i*a;return this.set(l*s+n,l*a-r*o,l*o+r*a,0,l*a+r*o,c*a+n,c*o-r*s,0,l*o-r*a,c*o+r*s,i*o*o+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n,r,i,s){return this.set(1,n,i,0,e,1,s,0,t,r,1,0,0,0,0,1),this}compose(e,t,n){const r=this.elements,i=t._x,s=t._y,a=t._z,o=t._w,l=i+i,c=s+s,u=a+a,h=i*l,d=i*c,p=i*u,f=s*c,m=s*u,g=a*u,y=o*l,v=o*c,x=o*u,b=n.x,w=n.y,_=n.z;return r[0]=(1-(f+g))*b,r[1]=(d+x)*b,r[2]=(p-v)*b,r[3]=0,r[4]=(d-x)*w,r[5]=(1-(h+g))*w,r[6]=(m+y)*w,r[7]=0,r[8]=(p+v)*_,r[9]=(m-y)*_,r[10]=(1-(h+f))*_,r[11]=0,r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=1,this}decompose(e,t,n){const r=this.elements;let i=Dt.set(r[0],r[1],r[2]).length();const s=Dt.set(r[4],r[5],r[6]).length(),a=Dt.set(r[8],r[9],r[10]).length();this.determinant()<0&&(i=-i),e.x=r[12],e.y=r[13],e.z=r[14],Lt.copy(this);const o=1/i,l=1/s,c=1/a;return Lt.elements[0]*=o,Lt.elements[1]*=o,Lt.elements[2]*=o,Lt.elements[4]*=l,Lt.elements[5]*=l,Lt.elements[6]*=l,Lt.elements[8]*=c,Lt.elements[9]*=c,Lt.elements[10]*=c,t.setFromRotationMatrix(Lt),n.x=i,n.y=s,n.z=a,this}makePerspective(e,t,n,r,i,s){void 0===s&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,o=2*i/(t-e),l=2*i/(n-r),c=(t+e)/(t-e),u=(n+r)/(n-r),h=-(s+i)/(s-i),d=-2*s*i/(s-i);return a[0]=o,a[4]=0,a[8]=c,a[12]=0,a[1]=0,a[5]=l,a[9]=u,a[13]=0,a[2]=0,a[6]=0,a[10]=h,a[14]=d,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(e,t,n,r,i,s){const a=this.elements,o=1/(t-e),l=1/(n-r),c=1/(s-i),u=(t+e)*o,h=(n+r)*l,d=(s+i)*c;return a[0]=2*o,a[4]=0,a[8]=0,a[12]=-u,a[1]=0,a[5]=2*l,a[9]=0,a[13]=-h,a[2]=0,a[6]=0,a[10]=-2*c,a[14]=-d,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let e=0;e<16;e++)if(t[e]!==n[e])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}const Dt=new tt,Lt=new Rt,Ft=new tt(0,0,0),Pt=new tt(1,1,1),Ot=new tt,zt=new tt,Bt=new tt,Ut=new Rt,$t=new et;class Vt{constructor(e=0,t=0,n=0,r=Vt.DefaultOrder){this.isEuler=!0,this._x=e,this._y=t,this._z=n,this._order=r}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,r=this._order){return this._x=e,this._y=t,this._z=n,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,n=!0){const r=e.elements,i=r[0],s=r[4],a=r[8],o=r[1],l=r[5],c=r[9],u=r[2],h=r[6],d=r[10];switch(t){case"XYZ":this._y=Math.asin(be(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-c,d),this._z=Math.atan2(-s,i)):(this._x=Math.atan2(h,l),this._z=0);break;case"YXZ":this._x=Math.asin(-be(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(a,d),this._z=Math.atan2(o,l)):(this._y=Math.atan2(-u,i),this._z=0);break;case"ZXY":this._x=Math.asin(be(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(-u,d),this._z=Math.atan2(-s,l)):(this._y=0,this._z=Math.atan2(o,i));break;case"ZYX":this._y=Math.asin(-be(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(h,d),this._z=Math.atan2(o,i)):(this._x=0,this._z=Math.atan2(-s,l));break;case"YZX":this._z=Math.asin(be(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-c,l),this._y=Math.atan2(-u,i)):(this._x=0,this._y=Math.atan2(a,d));break;case"XZY":this._z=Math.asin(-be(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(h,l),this._y=Math.atan2(a,i)):(this._x=Math.atan2(-c,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,!0===n&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return Ut.makeRotationFromQuaternion(e),this.setFromRotationMatrix(Ut,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return $t.setFromEuler(this),this.setFromQuaternion($t,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],void 0!==e[3]&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}toVector3(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}Vt.DefaultOrder="XYZ",Vt.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Wt{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return 0!=(this.mask&e.mask)}isEnabled(e){return 0!=(this.mask&(1<<e|0))}}let Gt=0;const Ht=new tt,jt=new et,qt=new Rt,Xt=new tt,Yt=new tt,Kt=new tt,Zt=new et,Jt=new tt(1,0,0),Qt=new tt(0,1,0),en=new tt(0,0,1),tn={type:"added"},nn={type:"removed"};class rn extends fe{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:Gt++}),this.uuid=xe(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=rn.DefaultUp.clone();const e=new tt,t=new Vt,n=new et,r=new tt(1,1,1);t._onChange((function(){n.setFromEuler(t,!1)})),n._onChange((function(){t.setFromQuaternion(n,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new Rt},normalMatrix:{value:new Ce}}),this.matrix=new Rt,this.matrixWorld=new Rt,this.matrixAutoUpdate=rn.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Wt,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return jt.setFromAxisAngle(e,t),this.quaternion.multiply(jt),this}rotateOnWorldAxis(e,t){return jt.setFromAxisAngle(e,t),this.quaternion.premultiply(jt),this}rotateX(e){return this.rotateOnAxis(Jt,e)}rotateY(e){return this.rotateOnAxis(Qt,e)}rotateZ(e){return this.rotateOnAxis(en,e)}translateOnAxis(e,t){return Ht.copy(e).applyQuaternion(this.quaternion),this.position.add(Ht.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(Jt,e)}translateY(e){return this.translateOnAxis(Qt,e)}translateZ(e){return this.translateOnAxis(en,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(qt.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?Xt.copy(e):Xt.set(e,t,n);const r=this.parent;this.updateWorldMatrix(!0,!1),Yt.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?qt.lookAt(Yt,Xt,this.up):qt.lookAt(Xt,Yt,this.up),this.quaternion.setFromRotationMatrix(qt),r&&(qt.extractRotation(r.matrixWorld),jt.setFromRotationMatrix(qt),this.quaternion.premultiply(jt.invert()))}add(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(null!==e.parent&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(tn)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}const t=this.children.indexOf(e);return-1!==t&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(nn)),this}removeFromParent(){const e=this.parent;return null!==e&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(nn)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),qt.copy(this.matrixWorld).invert(),null!==e.parent&&(e.parent.updateWorldMatrix(!0,!1),qt.multiply(e.parent.matrixWorld)),e.applyMatrix4(qt),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,r=this.children.length;n<r;n++){const r=this.children[n].getObjectByProperty(e,t);if(void 0!==r)return r}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Yt,e,Kt),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Yt,Zt,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].traverse(e)}traverseVisible(e){if(!1===this.visible)return;e(this);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;null!==t&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].updateMatrixWorld(e)}updateWorldMatrix(e,t){const n=this.parent;if(!0===e&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===t){const e=this.children;for(let t=0,n=e.length;t<n;t++)e[t].updateWorldMatrix(!1,!0)}}toJSON(e){const t=void 0===e||"string"==typeof e,n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};function i(t,n){return void 0===t[n.uuid]&&(t[n.uuid]=n.toJSON(e)),n.uuid}if(r.uuid=this.uuid,r.type=this.type,""!==this.name&&(r.name=this.name),!0===this.castShadow&&(r.castShadow=!0),!0===this.receiveShadow&&(r.receiveShadow=!0),!1===this.visible&&(r.visible=!1),!1===this.frustumCulled&&(r.frustumCulled=!1),0!==this.renderOrder&&(r.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(r.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&(r.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=i(e.geometries,this.geometry);const t=this.geometry.parameters;if(void 0!==t&&void 0!==t.shapes){const n=t.shapes;if(Array.isArray(n))for(let t=0,r=n.length;t<r;t++){const r=n[t];i(e.shapes,r)}else i(e.shapes,n)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(i(e.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const t=[];for(let n=0,r=this.material.length;n<r;n++)t.push(i(e.materials,this.material[n]));r.material=t}else r.material=i(e.materials,this.material);if(this.children.length>0){r.children=[];for(let t=0;t<this.children.length;t++)r.children.push(this.children[t].toJSON(e).object)}if(this.animations.length>0){r.animations=[];for(let t=0;t<this.animations.length;t++){const n=this.animations[t];r.animations.push(i(e.animations,n))}}if(t){const t=s(e.geometries),r=s(e.materials),i=s(e.textures),a=s(e.images),o=s(e.shapes),l=s(e.skeletons),c=s(e.animations),u=s(e.nodes);t.length>0&&(n.geometries=t),r.length>0&&(n.materials=r),i.length>0&&(n.textures=i),a.length>0&&(n.images=a),o.length>0&&(n.shapes=o),l.length>0&&(n.skeletons=l),c.length>0&&(n.animations=c),u.length>0&&(n.nodes=u)}return n.object=r,n;function s(e){const t=[];for(const n in e){const r=e[n];delete r.metadata,t.push(r)}return t}}clone(e){return(new this.constructor).copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),!0===t)for(let t=0;t<e.children.length;t++){const n=e.children[t];this.add(n.clone())}return this}}rn.DefaultUp=new tt(0,1,0),rn.DefaultMatrixAutoUpdate=!0;const sn=new tt,an=new tt,on=new tt,ln=new tt,cn=new tt,un=new tt,hn=new tt,dn=new tt,pn=new tt,fn=new tt;class mn{constructor(e=new tt,t=new tt,n=new tt){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,r){r.subVectors(n,t),sn.subVectors(e,t),r.cross(sn);const i=r.lengthSq();return i>0?r.multiplyScalar(1/Math.sqrt(i)):r.set(0,0,0)}static getBarycoord(e,t,n,r,i){sn.subVectors(r,t),an.subVectors(n,t),on.subVectors(e,t);const s=sn.dot(sn),a=sn.dot(an),o=sn.dot(on),l=an.dot(an),c=an.dot(on),u=s*l-a*a;if(0===u)return i.set(-2,-1,-1);const h=1/u,d=(l*o-a*c)*h,p=(s*c-a*o)*h;return i.set(1-d-p,p,d)}static containsPoint(e,t,n,r){return this.getBarycoord(e,t,n,r,ln),ln.x>=0&&ln.y>=0&&ln.x+ln.y<=1}static getUV(e,t,n,r,i,s,a,o){return this.getBarycoord(e,t,n,r,ln),o.set(0,0),o.addScaledVector(i,ln.x),o.addScaledVector(s,ln.y),o.addScaledVector(a,ln.z),o}static isFrontFacing(e,t,n,r){return sn.subVectors(n,t),an.subVectors(e,t),sn.cross(an).dot(r)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,r){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[r]),this}setFromAttributeAndIndices(e,t,n,r){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,n),this.c.fromBufferAttribute(e,r),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return sn.subVectors(this.c,this.b),an.subVectors(this.a,this.b),.5*sn.cross(an).length()}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return mn.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return mn.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,r,i){return mn.getUV(e,this.a,this.b,this.c,t,n,r,i)}containsPoint(e){return mn.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return mn.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const n=this.a,r=this.b,i=this.c;let s,a;cn.subVectors(r,n),un.subVectors(i,n),dn.subVectors(e,n);const o=cn.dot(dn),l=un.dot(dn);if(o<=0&&l<=0)return t.copy(n);pn.subVectors(e,r);const c=cn.dot(pn),u=un.dot(pn);if(c>=0&&u<=c)return t.copy(r);const h=o*u-c*l;if(h<=0&&o>=0&&c<=0)return s=o/(o-c),t.copy(n).addScaledVector(cn,s);fn.subVectors(e,i);const d=cn.dot(fn),p=un.dot(fn);if(p>=0&&d<=p)return t.copy(i);const f=d*l-o*p;if(f<=0&&l>=0&&p<=0)return a=l/(l-p),t.copy(n).addScaledVector(un,a);const m=c*p-d*u;if(m<=0&&u-c>=0&&d-p>=0)return hn.subVectors(i,r),a=(u-c)/(u-c+(d-p)),t.copy(r).addScaledVector(hn,a);const g=1/(m+f+h);return s=f*g,a=h*g,t.copy(n).addScaledVector(cn,s).addScaledVector(un,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let gn=0;class yn extends fe{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:gn++}),this.uuid=xe(),this.name="",this.type="Material",this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=r,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=ue,this.stencilZFail=ue,this.stencilZPass=ue,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(void 0!==e)for(const t in e){const n=e[t];if(void 0===n){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if("shading"===t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===n;continue}const r=this[t];void 0!==r?r&&r.isColor?r.set(n):r&&r.isVector3&&n&&n.isVector3?r.copy(n):this[t]=n:console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.")}}toJSON(e){const t=void 0===e||"string"==typeof e;t&&(e={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function r(e){const t=[];for(const n in e){const r=e[n];delete r.metadata,t.push(r)}return t}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),void 0!==this.sheen&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),void 0!==this.iridescence&&(n.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(n.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,void 0!==this.combine&&(n.combine=this.combine)),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(n.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),void 0!==this.transmission&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid),void 0!==this.thickness&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid),void 0!==this.attenuationDistance&&(n.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(n.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(n.size=this.size),null!==this.shadowSide&&(n.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(n.blending=this.blending),0!==this.side&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),!0===this.transparent&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,void 0!==this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(n.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(n.flatShading=this.flatShading),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),!1===this.fog&&(n.fog=!1),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),t){const t=r(e.textures),i=r(e.images);t.length>0&&(n.textures=t),i.length>0&&(n.images=i)}return n}clone(){return(new this.constructor).copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(null!==t){const e=t.length;n=new Array(e);for(let r=0;r!==e;++r)n[r]=t[r].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){!0===e&&this.version++}get vertexTangents(){return console.warn("THREE."+this.type+": .vertexTangents has been removed."),!1}set vertexTangents(e){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}yn.fromType=function(){return null};class vn extends yn{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new We(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const xn=new tt,bn=new Ae;class wn{constructor(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=void 0!==e?e.length/t:0,this.normalized=!0===n,this.usage=he,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){!0===e&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let r=0,i=this.itemSize;r<i;r++)this.array[e+r]=t.array[n+r];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){const t=this.array;let n=0;for(let r=0,i=e.length;r<i;r++){let i=e[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),i=new We),t[n++]=i.r,t[n++]=i.g,t[n++]=i.b}return this}copyVector2sArray(e){const t=this.array;let n=0;for(let r=0,i=e.length;r<i;r++){let i=e[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),i=new Ae),t[n++]=i.x,t[n++]=i.y}return this}copyVector3sArray(e){const t=this.array;let n=0;for(let r=0,i=e.length;r<i;r++){let i=e[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),i=new tt),t[n++]=i.x,t[n++]=i.y,t[n++]=i.z}return this}copyVector4sArray(e){const t=this.array;let n=0;for(let r=0,i=e.length;r<i;r++){let i=e[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),i=new Ke),t[n++]=i.x,t[n++]=i.y,t[n++]=i.z,t[n++]=i.w}return this}applyMatrix3(e){if(2===this.itemSize)for(let t=0,n=this.count;t<n;t++)bn.fromBufferAttribute(this,t),bn.applyMatrix3(e),this.setXY(t,bn.x,bn.y);else if(3===this.itemSize)for(let t=0,n=this.count;t<n;t++)xn.fromBufferAttribute(this,t),xn.applyMatrix3(e),this.setXYZ(t,xn.x,xn.y,xn.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)xn.fromBufferAttribute(this,t),xn.applyMatrix4(e),this.setXYZ(t,xn.x,xn.y,xn.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)xn.fromBufferAttribute(this,t),xn.applyNormalMatrix(e),this.setXYZ(t,xn.x,xn.y,xn.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)xn.fromBufferAttribute(this,t),xn.transformDirection(e),this.setXYZ(t,xn.x,xn.y,xn.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=r,this}setXYZW(e,t,n,r,i){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=r,this.array[e+3]=i,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return""!==this.name&&(e.name=this.name),this.usage!==he&&(e.usage=this.usage),0===this.updateRange.offset&&-1===this.updateRange.count||(e.updateRange=this.updateRange),e}}class _n extends wn{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class Sn extends wn{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class Mn extends wn{constructor(e,t,n){super(new Float32Array(e),t,n)}}let Tn=0;const En=new Rt,An=new rn,Cn=new tt,In=new it,Nn=new it,kn=new tt;class Rn extends fe{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Tn++}),this.uuid=xe(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(Ie(e)?Sn:_n)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return void 0!==this.attributes[e]}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;void 0!==t&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const t=(new Ce).getNormalMatrix(e);n.applyNormalMatrix(t),n.needsUpdate=!0}const r=this.attributes.tangent;return void 0!==r&&(r.transformDirection(e),r.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(e){return En.makeRotationFromQuaternion(e),this.applyMatrix4(En),this}rotateX(e){return En.makeRotationX(e),this.applyMatrix4(En),this}rotateY(e){return En.makeRotationY(e),this.applyMatrix4(En),this}rotateZ(e){return En.makeRotationZ(e),this.applyMatrix4(En),this}translate(e,t,n){return En.makeTranslation(e,t,n),this.applyMatrix4(En),this}scale(e,t,n){return En.makeScale(e,t,n),this.applyMatrix4(En),this}lookAt(e){return An.lookAt(e),An.updateMatrix(),this.applyMatrix4(An.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Cn).negate(),this.translate(Cn.x,Cn.y,Cn.z),this}setFromPoints(e){const t=[];for(let n=0,r=e.length;n<r;n++){const r=e[n];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new Mn(t,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new it);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new tt(-1/0,-1/0,-1/0),new tt(1/0,1/0,1/0));if(void 0!==e){if(this.boundingBox.setFromBufferAttribute(e),t)for(let e=0,n=t.length;e<n;e++){const n=t[e];In.setFromBufferAttribute(n),this.morphTargetsRelative?(kn.addVectors(this.boundingBox.min,In.min),this.boundingBox.expandByPoint(kn),kn.addVectors(this.boundingBox.max,In.max),this.boundingBox.expandByPoint(kn)):(this.boundingBox.expandByPoint(In.min),this.boundingBox.expandByPoint(In.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new St);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new tt,1/0);if(e){const n=this.boundingSphere.center;if(In.setFromBufferAttribute(e),t)for(let e=0,n=t.length;e<n;e++){const n=t[e];Nn.setFromBufferAttribute(n),this.morphTargetsRelative?(kn.addVectors(In.min,Nn.min),In.expandByPoint(kn),kn.addVectors(In.max,Nn.max),In.expandByPoint(kn)):(In.expandByPoint(Nn.min),In.expandByPoint(Nn.max))}In.getCenter(n);let r=0;for(let t=0,i=e.count;t<i;t++)kn.fromBufferAttribute(e,t),r=Math.max(r,n.distanceToSquared(kn));if(t)for(let i=0,s=t.length;i<s;i++){const s=t[i],a=this.morphTargetsRelative;for(let t=0,i=s.count;t<i;t++)kn.fromBufferAttribute(s,t),a&&(Cn.fromBufferAttribute(e,t),kn.add(Cn)),r=Math.max(r,n.distanceToSquared(kn))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(null===e||void 0===t.position||void 0===t.normal||void 0===t.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=e.array,r=t.position.array,i=t.normal.array,s=t.uv.array,a=r.length/3;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new wn(new Float32Array(4*a),4));const o=this.getAttribute("tangent").array,l=[],c=[];for(let e=0;e<a;e++)l[e]=new tt,c[e]=new tt;const u=new tt,h=new tt,d=new tt,p=new Ae,f=new Ae,m=new Ae,g=new tt,y=new tt;function v(e,t,n){u.fromArray(r,3*e),h.fromArray(r,3*t),d.fromArray(r,3*n),p.fromArray(s,2*e),f.fromArray(s,2*t),m.fromArray(s,2*n),h.sub(u),d.sub(u),f.sub(p),m.sub(p);const i=1/(f.x*m.y-m.x*f.y);isFinite(i)&&(g.copy(h).multiplyScalar(m.y).addScaledVector(d,-f.y).multiplyScalar(i),y.copy(d).multiplyScalar(f.x).addScaledVector(h,-m.x).multiplyScalar(i),l[e].add(g),l[t].add(g),l[n].add(g),c[e].add(y),c[t].add(y),c[n].add(y))}let x=this.groups;0===x.length&&(x=[{start:0,count:n.length}]);for(let e=0,t=x.length;e<t;++e){const t=x[e],r=t.start;for(let e=r,i=r+t.count;e<i;e+=3)v(n[e+0],n[e+1],n[e+2])}const b=new tt,w=new tt,_=new tt,S=new tt;function M(e){_.fromArray(i,3*e),S.copy(_);const t=l[e];b.copy(t),b.sub(_.multiplyScalar(_.dot(t))).normalize(),w.crossVectors(S,t);const n=w.dot(c[e])<0?-1:1;o[4*e]=b.x,o[4*e+1]=b.y,o[4*e+2]=b.z,o[4*e+3]=n}for(let e=0,t=x.length;e<t;++e){const t=x[e],r=t.start;for(let e=r,i=r+t.count;e<i;e+=3)M(n[e+0]),M(n[e+1]),M(n[e+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(void 0!==t){let n=this.getAttribute("normal");if(void 0===n)n=new wn(new Float32Array(3*t.count),3),this.setAttribute("normal",n);else for(let e=0,t=n.count;e<t;e++)n.setXYZ(e,0,0,0);const r=new tt,i=new tt,s=new tt,a=new tt,o=new tt,l=new tt,c=new tt,u=new tt;if(e)for(let h=0,d=e.count;h<d;h+=3){const d=e.getX(h+0),p=e.getX(h+1),f=e.getX(h+2);r.fromBufferAttribute(t,d),i.fromBufferAttribute(t,p),s.fromBufferAttribute(t,f),c.subVectors(s,i),u.subVectors(r,i),c.cross(u),a.fromBufferAttribute(n,d),o.fromBufferAttribute(n,p),l.fromBufferAttribute(n,f),a.add(c),o.add(c),l.add(c),n.setXYZ(d,a.x,a.y,a.z),n.setXYZ(p,o.x,o.y,o.z),n.setXYZ(f,l.x,l.y,l.z)}else for(let e=0,a=t.count;e<a;e+=3)r.fromBufferAttribute(t,e+0),i.fromBufferAttribute(t,e+1),s.fromBufferAttribute(t,e+2),c.subVectors(s,i),u.subVectors(r,i),c.cross(u),n.setXYZ(e+0,c.x,c.y,c.z),n.setXYZ(e+1,c.x,c.y,c.z),n.setXYZ(e+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(e,t){if(!e||!e.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);void 0===t&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const r in n){if(void 0===e.attributes[r])continue;const i=n[r].array,s=e.attributes[r],a=s.array,o=s.itemSize*t,l=Math.min(a.length,i.length-o);for(let e=0,t=o;e<l;e++,t++)i[t]=a[e]}return this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)kn.fromBufferAttribute(e,t),kn.normalize(),e.setXYZ(t,kn.x,kn.y,kn.z)}toNonIndexed(){function e(e,t){const n=e.array,r=e.itemSize,i=e.normalized,s=new n.constructor(t.length*r);let a=0,o=0;for(let i=0,l=t.length;i<l;i++){a=e.isInterleavedBufferAttribute?t[i]*e.data.stride+e.offset:t[i]*r;for(let e=0;e<r;e++)s[o++]=n[a++]}return new wn(s,r,i)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Rn,n=this.index.array,r=this.attributes;for(const i in r){const s=e(r[i],n);t.setAttribute(i,s)}const i=this.morphAttributes;for(const r in i){const s=[],a=i[r];for(let t=0,r=a.length;t<r;t++){const r=e(a[t],n);s.push(r)}t.morphAttributes[r]=s}t.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let e=0,n=s.length;e<n;e++){const n=s[e];t.addGroup(n.start,n.count,n.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),void 0!==this.parameters){const t=this.parameters;for(const n in t)void 0!==t[n]&&(e[n]=t[n]);return e}e.data={attributes:{}};const t=this.index;null!==t&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const t in n){const r=n[t];e.data.attributes[t]=r.toJSON(e.data)}const r={};let i=!1;for(const t in this.morphAttributes){const n=this.morphAttributes[t],s=[];for(let t=0,r=n.length;t<r;t++){const r=n[t];s.push(r.toJSON(e.data))}s.length>0&&(r[t]=s,i=!0)}i&&(e.data.morphAttributes=r,e.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(e.data.groups=JSON.parse(JSON.stringify(s)));const a=this.boundingSphere;return null!==a&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return(new this.constructor).copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;null!==n&&this.setIndex(n.clone(t));const r=e.attributes;for(const e in r){const n=r[e];this.setAttribute(e,n.clone(t))}const i=e.morphAttributes;for(const e in i){const n=[],r=i[e];for(let e=0,i=r.length;e<i;e++)n.push(r[e].clone(t));this.morphAttributes[e]=n}this.morphTargetsRelative=e.morphTargetsRelative;const s=e.groups;for(let e=0,t=s.length;e<t;e++){const t=s[e];this.addGroup(t.start,t.count,t.materialIndex)}const a=e.boundingBox;null!==a&&(this.boundingBox=a.clone());const o=e.boundingSphere;return null!==o&&(this.boundingSphere=o.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,void 0!==e.parameters&&(this.parameters=Object.assign({},e.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}const Dn=new Rt,Ln=new kt,Fn=new St,Pn=new tt,On=new tt,zn=new tt,Bn=new tt,Un=new tt,$n=new tt,Vn=new tt,Wn=new tt,Gn=new tt,Hn=new Ae,jn=new Ae,qn=new Ae,Xn=new tt,Yn=new tt;class Kn extends rn{constructor(e=new Rn,t=new vn){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),void 0!==e.morphTargetInfluences&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),void 0!==e.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){const n=e[t[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,t=n.length;e<t;e++){const t=n[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[t]=e}}}}raycast(e,t){const n=this.geometry,r=this.material,i=this.matrixWorld;if(void 0===r)return;if(null===n.boundingSphere&&n.computeBoundingSphere(),Fn.copy(n.boundingSphere),Fn.applyMatrix4(i),!1===e.ray.intersectsSphere(Fn))return;if(Dn.copy(i).invert(),Ln.copy(e.ray).applyMatrix4(Dn),null!==n.boundingBox&&!1===Ln.intersectsBox(n.boundingBox))return;let s;const a=n.index,o=n.attributes.position,l=n.morphAttributes.position,c=n.morphTargetsRelative,u=n.attributes.uv,h=n.attributes.uv2,d=n.groups,p=n.drawRange;if(null!==a)if(Array.isArray(r))for(let n=0,i=d.length;n<i;n++){const i=d[n],f=r[i.materialIndex];for(let n=Math.max(i.start,p.start),r=Math.min(a.count,Math.min(i.start+i.count,p.start+p.count));n<r;n+=3){const r=a.getX(n),d=a.getX(n+1),p=a.getX(n+2);s=Zn(this,f,e,Ln,o,l,c,u,h,r,d,p),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=i.materialIndex,t.push(s))}}else for(let n=Math.max(0,p.start),i=Math.min(a.count,p.start+p.count);n<i;n+=3){const i=a.getX(n),d=a.getX(n+1),p=a.getX(n+2);s=Zn(this,r,e,Ln,o,l,c,u,h,i,d,p),s&&(s.faceIndex=Math.floor(n/3),t.push(s))}else if(void 0!==o)if(Array.isArray(r))for(let n=0,i=d.length;n<i;n++){const i=d[n],a=r[i.materialIndex];for(let n=Math.max(i.start,p.start),r=Math.min(o.count,Math.min(i.start+i.count,p.start+p.count));n<r;n+=3)s=Zn(this,a,e,Ln,o,l,c,u,h,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=i.materialIndex,t.push(s))}else for(let n=Math.max(0,p.start),i=Math.min(o.count,p.start+p.count);n<i;n+=3)s=Zn(this,r,e,Ln,o,l,c,u,h,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),t.push(s))}}function Zn(e,t,n,r,i,s,a,o,l,c,u,h){Pn.fromBufferAttribute(i,c),On.fromBufferAttribute(i,u),zn.fromBufferAttribute(i,h);const d=e.morphTargetInfluences;if(s&&d){Vn.set(0,0,0),Wn.set(0,0,0),Gn.set(0,0,0);for(let e=0,t=s.length;e<t;e++){const t=d[e],n=s[e];0!==t&&(Bn.fromBufferAttribute(n,c),Un.fromBufferAttribute(n,u),$n.fromBufferAttribute(n,h),a?(Vn.addScaledVector(Bn,t),Wn.addScaledVector(Un,t),Gn.addScaledVector($n,t)):(Vn.addScaledVector(Bn.sub(Pn),t),Wn.addScaledVector(Un.sub(On),t),Gn.addScaledVector($n.sub(zn),t)))}Pn.add(Vn),On.add(Wn),zn.add(Gn)}e.isSkinnedMesh&&(e.boneTransform(c,Pn),e.boneTransform(u,On),e.boneTransform(h,zn));const p=function(e,t,n,r,i,s,a,o){let l;if(l=1===t.side?r.intersectTriangle(a,s,i,!0,o):r.intersectTriangle(i,s,a,2!==t.side,o),null===l)return null;Yn.copy(o),Yn.applyMatrix4(e.matrixWorld);const c=n.ray.origin.distanceTo(Yn);return c<n.near||c>n.far?null:{distance:c,point:Yn.clone(),object:e}}(e,t,n,r,Pn,On,zn,Xn);if(p){o&&(Hn.fromBufferAttribute(o,c),jn.fromBufferAttribute(o,u),qn.fromBufferAttribute(o,h),p.uv=mn.getUV(Xn,Pn,On,zn,Hn,jn,qn,new Ae)),l&&(Hn.fromBufferAttribute(l,c),jn.fromBufferAttribute(l,u),qn.fromBufferAttribute(l,h),p.uv2=mn.getUV(Xn,Pn,On,zn,Hn,jn,qn,new Ae));const e={a:c,b:u,c:h,normal:new tt,materialIndex:0};mn.getNormal(Pn,On,zn,e.normal),p.face=e}return p}class Jn extends Rn{constructor(e=1,t=1,n=1,r=1,i=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:r,heightSegments:i,depthSegments:s};const a=this;r=Math.floor(r),i=Math.floor(i),s=Math.floor(s);const o=[],l=[],c=[],u=[];let h=0,d=0;function p(e,t,n,r,i,s,p,f,m,g,y){const v=s/m,x=p/g,b=s/2,w=p/2,_=f/2,S=m+1,M=g+1;let T=0,E=0;const A=new tt;for(let s=0;s<M;s++){const a=s*x-w;for(let o=0;o<S;o++){const h=o*v-b;A[e]=h*r,A[t]=a*i,A[n]=_,l.push(A.x,A.y,A.z),A[e]=0,A[t]=0,A[n]=f>0?1:-1,c.push(A.x,A.y,A.z),u.push(o/m),u.push(1-s/g),T+=1}}for(let e=0;e<g;e++)for(let t=0;t<m;t++){const n=h+t+S*e,r=h+t+S*(e+1),i=h+(t+1)+S*(e+1),s=h+(t+1)+S*e;o.push(n,r,s),o.push(r,i,s),E+=6}a.addGroup(d,E,y),d+=E,h+=T}p("z","y","x",-1,-1,n,t,e,s,i,0),p("z","y","x",1,-1,n,t,-e,s,i,1),p("x","z","y",1,1,e,n,t,r,s,2),p("x","z","y",1,-1,e,n,-t,r,s,3),p("x","y","z",1,-1,e,t,n,r,i,4),p("x","y","z",-1,-1,e,t,-n,r,i,5),this.setIndex(o),this.setAttribute("position",new Mn(l,3)),this.setAttribute("normal",new Mn(c,3)),this.setAttribute("uv",new Mn(u,2))}static fromJSON(e){return new Jn(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function Qn(e){const t={};for(const n in e){t[n]={};for(const r in e[n]){const i=e[n][r];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?t[n][r]=i.clone():Array.isArray(i)?t[n][r]=i.slice():t[n][r]=i}}return t}function er(e){const t={};for(let n=0;n<e.length;n++){const r=Qn(e[n]);for(const e in r)t[e]=r[e]}return t}const tr={clone:Qn,merge:er};class nr extends yn{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==e&&(void 0!==e.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=Qn(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const n in this.uniforms){const r=this.uniforms[n].value;r&&r.isTexture?t.uniforms[n]={type:"t",value:r.toJSON(e).uuid}:r&&r.isColor?t.uniforms[n]={type:"c",value:r.getHex()}:r&&r.isVector2?t.uniforms[n]={type:"v2",value:r.toArray()}:r&&r.isVector3?t.uniforms[n]={type:"v3",value:r.toArray()}:r&&r.isVector4?t.uniforms[n]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?t.uniforms[n]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?t.uniforms[n]={type:"m4",value:r.toArray()}:t.uniforms[n]={value:r}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const n={};for(const e in this.extensions)!0===this.extensions[e]&&(n[e]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}}class rr extends rn{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Rt,this.projectionMatrix=new Rt,this.projectionMatrixInverse=new Rt}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}class ir extends rr{constructor(e=50,t=1,n=.1,r=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=r,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=null===e.view?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=2*ve*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(.5*ye*this.fov);return.5*this.getFilmHeight()/e}getEffectiveFOV(){return 2*ve*Math.atan(Math.tan(.5*ye*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,n,r,i,s){this.aspect=e/t,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=r,this.view.width=i,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(.5*ye*this.fov)/this.zoom,n=2*t,r=this.aspect*n,i=-.5*r;const s=this.view;if(null!==this.view&&this.view.enabled){const e=s.fullWidth,a=s.fullHeight;i+=s.offsetX*r/e,t-=s.offsetY*n/a,r*=s.width/e,n*=s.height/a}const a=this.filmOffset;0!==a&&(i+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(i,i+r,t,t-n,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,null!==this.view&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const sr=90;class ar extends rn{constructor(e,t,n){if(super(),this.type="CubeCamera",!0!==n.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const r=new ir(sr,1,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new tt(1,0,0)),this.add(r);const i=new ir(sr,1,e,t);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new tt(-1,0,0)),this.add(i);const s=new ir(sr,1,e,t);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new tt(0,1,0)),this.add(s);const a=new ir(sr,1,e,t);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new tt(0,-1,0)),this.add(a);const o=new ir(sr,1,e,t);o.layers=this.layers,o.up.set(0,-1,0),o.lookAt(new tt(0,0,1)),this.add(o);const l=new ir(sr,1,e,t);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new tt(0,0,-1)),this.add(l)}update(e,t){null===this.parent&&this.updateMatrixWorld();const n=this.renderTarget,[r,i,s,a,o,l]=this.children,c=e.getRenderTarget(),u=e.toneMapping,h=e.xr.enabled;e.toneMapping=0,e.xr.enabled=!1;const d=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0),e.render(t,r),e.setRenderTarget(n,1),e.render(t,i),e.setRenderTarget(n,2),e.render(t,s),e.setRenderTarget(n,3),e.render(t,a),e.setRenderTarget(n,4),e.render(t,o),n.texture.generateMipmaps=d,e.setRenderTarget(n,5),e.render(t,l),e.setRenderTarget(c),e.toneMapping=u,e.xr.enabled=h,n.texture.needsPMREMUpdate=!0}}class or extends Ye{constructor(e,t,n,r,i,a,o,l,c,u){super(e=void 0!==e?e:[],t=void 0!==t?t:s,n,r,i,a,o,l,c,u),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class lr extends Ze{constructor(e,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const n={width:e,height:e,depth:1},r=[n,n,n,n,n,n];this.texture=new or(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==t.generateMipmaps&&t.generateMipmaps,this.texture.minFilter=void 0!==t.minFilter?t.minFilter:g}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={tEquirect:{value:null}},r="\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",i="\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",s=new Jn(5,5,5),a=new nr({name:"CubemapFromEquirect",uniforms:Qn(n),vertexShader:r,fragmentShader:i,side:1,blending:0});a.uniforms.tEquirect.value=t;const o=new Kn(s,a),l=t.minFilter;return t.minFilter===v&&(t.minFilter=g),new ar(1,10,this).update(e,o),t.minFilter=l,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,n,r){const i=e.getRenderTarget();for(let i=0;i<6;i++)e.setRenderTarget(this,i),e.clear(t,n,r);e.setRenderTarget(i)}}const cr=new tt,ur=new tt,hr=new Ce;class dr{constructor(e=new tt(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,r){return this.normal.set(e,t,n),this.constant=r,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const r=cr.subVectors(n,t).cross(ur.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(r,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){const n=e.delta(cr),r=this.normal.dot(n);if(0===r)return 0===this.distanceToPoint(e.start)?t.copy(e.start):null;const i=-(e.start.dot(this.normal)+this.constant)/r;return i<0||i>1?null:t.copy(n).multiplyScalar(i).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||hr.getNormalMatrix(e),r=this.coplanarPoint(cr).applyMatrix4(e),i=this.normal.applyMatrix3(n).normalize();return this.constant=-r.dot(i),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return(new this.constructor).copy(this)}}const pr=new St,fr=new tt;class mr{constructor(e=new dr,t=new dr,n=new dr,r=new dr,i=new dr,s=new dr){this.planes=[e,t,n,r,i,s]}set(e,t,n,r,i,s){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(n),a[3].copy(r),a[4].copy(i),a[5].copy(s),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e){const t=this.planes,n=e.elements,r=n[0],i=n[1],s=n[2],a=n[3],o=n[4],l=n[5],c=n[6],u=n[7],h=n[8],d=n[9],p=n[10],f=n[11],m=n[12],g=n[13],y=n[14],v=n[15];return t[0].setComponents(a-r,u-o,f-h,v-m).normalize(),t[1].setComponents(a+r,u+o,f+h,v+m).normalize(),t[2].setComponents(a+i,u+l,f+d,v+g).normalize(),t[3].setComponents(a-i,u-l,f-d,v-g).normalize(),t[4].setComponents(a-s,u-c,f-p,v-y).normalize(),t[5].setComponents(a+s,u+c,f+p,v+y).normalize(),this}intersectsObject(e){const t=e.geometry;return null===t.boundingSphere&&t.computeBoundingSphere(),pr.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(pr)}intersectsSprite(e){return pr.center.set(0,0,0),pr.radius=.7071067811865476,pr.applyMatrix4(e.matrixWorld),this.intersectsSphere(pr)}intersectsSphere(e){const t=this.planes,n=e.center,r=-e.radius;for(let e=0;e<6;e++)if(t[e].distanceToPoint(n)<r)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const r=t[n];if(fr.x=r.normal.x>0?e.max.x:e.min.x,fr.y=r.normal.y>0?e.max.y:e.min.y,fr.z=r.normal.z>0?e.max.z:e.min.z,r.distanceToPoint(fr)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}function gr(){let e=null,t=!1,n=null,r=null;function i(t,s){n(t,s),r=e.requestAnimationFrame(i)}return{start:function(){!0!==t&&null!==n&&(r=e.requestAnimationFrame(i),t=!0)},stop:function(){e.cancelAnimationFrame(r),t=!1},setAnimationLoop:function(e){n=e},setContext:function(t){e=t}}}function yr(e,t){const n=t.isWebGL2,r=new WeakMap;return{get:function(e){return e.isInterleavedBufferAttribute&&(e=e.data),r.get(e)},remove:function(t){t.isInterleavedBufferAttribute&&(t=t.data);const n=r.get(t);n&&(e.deleteBuffer(n.buffer),r.delete(t))},update:function(t,i){if(t.isGLBufferAttribute){const e=r.get(t);return void((!e||e.version<t.version)&&r.set(t,{buffer:t.buffer,type:t.type,bytesPerElement:t.elementSize,version:t.version}))}t.isInterleavedBufferAttribute&&(t=t.data);const s=r.get(t);void 0===s?r.set(t,function(t,r){const i=t.array,s=t.usage,a=e.createBuffer();let o;if(e.bindBuffer(r,a),e.bufferData(r,i,s),t.onUploadCallback(),i instanceof Float32Array)o=e.FLOAT;else if(i instanceof Uint16Array)if(t.isFloat16BufferAttribute){if(!n)throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");o=e.HALF_FLOAT}else o=e.UNSIGNED_SHORT;else if(i instanceof Int16Array)o=e.SHORT;else if(i instanceof Uint32Array)o=e.UNSIGNED_INT;else if(i instanceof Int32Array)o=e.INT;else if(i instanceof Int8Array)o=e.BYTE;else if(i instanceof Uint8Array)o=e.UNSIGNED_BYTE;else{if(!(i instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+i);o=e.UNSIGNED_BYTE}return{buffer:a,type:o,bytesPerElement:i.BYTES_PER_ELEMENT,version:t.version}}(t,i)):s.version<t.version&&(function(t,r,i){const s=r.array,a=r.updateRange;e.bindBuffer(i,t),-1===a.count?e.bufferSubData(i,0,s):(n?e.bufferSubData(i,a.offset*s.BYTES_PER_ELEMENT,s,a.offset,a.count):e.bufferSubData(i,a.offset*s.BYTES_PER_ELEMENT,s.subarray(a.offset,a.offset+a.count)),a.count=-1)}(s.buffer,t,i),s.version=t.version)}}}class vr extends Rn{constructor(e=1,t=1,n=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:r};const i=e/2,s=t/2,a=Math.floor(n),o=Math.floor(r),l=a+1,c=o+1,u=e/a,h=t/o,d=[],p=[],f=[],m=[];for(let e=0;e<c;e++){const t=e*h-s;for(let n=0;n<l;n++){const r=n*u-i;p.push(r,-t,0),f.push(0,0,1),m.push(n/a),m.push(1-e/o)}}for(let e=0;e<o;e++)for(let t=0;t<a;t++){const n=t+l*e,r=t+l*(e+1),i=t+1+l*(e+1),s=t+1+l*e;d.push(n,r,s),d.push(r,i,s)}this.setIndex(d),this.setAttribute("position",new Mn(p,3)),this.setAttribute("normal",new Mn(f,3)),this.setAttribute("uv",new Mn(m,2))}static fromJSON(e){return new vr(e.width,e.height,e.widthSegments,e.heightSegments)}}const xr={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n\t\tfloat x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n\t\tfloat x2 = x * x;\n\t\tfloat x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n\t\treturn ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\nvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",iridescence_fragment:"#ifdef USE_IRIDESCENCE\nconst mat3 XYZ_TO_REC709 = mat3(\n\t\t3.2404542, -0.9692660,\t0.0556434,\n\t -1.5371385,\t1.8760108, -0.2040259,\n\t -0.4985314,\t0.0415560,\t1.0572252\n);\nvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t vec3 sqrtF0 = sqrt( fresnel0 );\n\t return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n}\nvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n}\nfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n}\nvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t float phase = 2.0 * PI * OPD * 1.0e-9;\n\t vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );\n\t xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );\n\t xyz /= 1.0685e-7;\n\t vec3 srgb = XYZ_TO_REC709 * xyz;\n\t return srgb;\n}\nvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t vec3 I;\n\t float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t float cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t if ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t }\n\t float cosTheta2 = sqrt( cosTheta2Sq );\n\t float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t float R21 = R12;\n\t float T121 = 1.0 - R12;\n\t float phi12 = 0.0;\n\t if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t float phi21 = PI - phi12;\n\t vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t vec3 phi23 = vec3( 0.0 );\n\t if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;\n\t if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;\n\t if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;\n\t float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t vec3 phi = vec3( phi21 ) + phi23;\n\t vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t vec3 r123 = sqrt( R123 );\n\t vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t vec3 C0 = R12 + Rs;\n\t I = C0;\n\t vec3 Cm = Rs - T121;\n\t for ( int m = 1; m <= 2; ++m ) {\n\t\t\t Cm *= r123;\n\t\t\t vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\t I += Cm * Sm;\n\t }\n\t return max( I, vec3( 0.0 ) );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(\t\t0, 1,\t\t0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\nfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\nif ( material.iridescenceThickness == 0.0 ) {\n\tmaterial.iridescence = 0.0;\n} else {\n\tmaterial.iridescence = saturate( material.iridescence );\n}\nif ( material.iridescence > 0.0 ) {\n\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",iridescence_pars_fragment:"#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(\t1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,\t1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,\t1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"},br={common:{diffuse:{value:new We(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Ce},uv2Transform:{value:new Ce},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Ae(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new We(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new We(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Ce}},sprite:{diffuse:{value:new We(16777215)},opacity:{value:1},center:{value:new Ae(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Ce}}},wr={basic:{uniforms:er([br.common,br.specularmap,br.envmap,br.aomap,br.lightmap,br.fog]),vertexShader:xr.meshbasic_vert,fragmentShader:xr.meshbasic_frag},lambert:{uniforms:er([br.common,br.specularmap,br.envmap,br.aomap,br.lightmap,br.emissivemap,br.fog,br.lights,{emissive:{value:new We(0)}}]),vertexShader:xr.meshlambert_vert,fragmentShader:xr.meshlambert_frag},phong:{uniforms:er([br.common,br.specularmap,br.envmap,br.aomap,br.lightmap,br.emissivemap,br.bumpmap,br.normalmap,br.displacementmap,br.fog,br.lights,{emissive:{value:new We(0)},specular:{value:new We(1118481)},shininess:{value:30}}]),vertexShader:xr.meshphong_vert,fragmentShader:xr.meshphong_frag},standard:{uniforms:er([br.common,br.envmap,br.aomap,br.lightmap,br.emissivemap,br.bumpmap,br.normalmap,br.displacementmap,br.roughnessmap,br.metalnessmap,br.fog,br.lights,{emissive:{value:new We(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:xr.meshphysical_vert,fragmentShader:xr.meshphysical_frag},toon:{uniforms:er([br.common,br.aomap,br.lightmap,br.emissivemap,br.bumpmap,br.normalmap,br.displacementmap,br.gradientmap,br.fog,br.lights,{emissive:{value:new We(0)}}]),vertexShader:xr.meshtoon_vert,fragmentShader:xr.meshtoon_frag},matcap:{uniforms:er([br.common,br.bumpmap,br.normalmap,br.displacementmap,br.fog,{matcap:{value:null}}]),vertexShader:xr.meshmatcap_vert,fragmentShader:xr.meshmatcap_frag},points:{uniforms:er([br.points,br.fog]),vertexShader:xr.points_vert,fragmentShader:xr.points_frag},dashed:{uniforms:er([br.common,br.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:xr.linedashed_vert,fragmentShader:xr.linedashed_frag},depth:{uniforms:er([br.common,br.displacementmap]),vertexShader:xr.depth_vert,fragmentShader:xr.depth_frag},normal:{uniforms:er([br.common,br.bumpmap,br.normalmap,br.displacementmap,{opacity:{value:1}}]),vertexShader:xr.meshnormal_vert,fragmentShader:xr.meshnormal_frag},sprite:{uniforms:er([br.sprite,br.fog]),vertexShader:xr.sprite_vert,fragmentShader:xr.sprite_frag},background:{uniforms:{uvTransform:{value:new Ce},t2D:{value:null}},vertexShader:xr.background_vert,fragmentShader:xr.background_frag},cube:{uniforms:er([br.envmap,{opacity:{value:1}}]),vertexShader:xr.cube_vert,fragmentShader:xr.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:xr.equirect_vert,fragmentShader:xr.equirect_frag},distanceRGBA:{uniforms:er([br.common,br.displacementmap,{referencePosition:{value:new tt},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:xr.distanceRGBA_vert,fragmentShader:xr.distanceRGBA_frag},shadow:{uniforms:er([br.lights,br.fog,{color:{value:new We(0)},opacity:{value:1}}]),vertexShader:xr.shadow_vert,fragmentShader:xr.shadow_frag}};function _r(e,t,n,r,i,s){const a=new We(0);let o,l,u=!0===i?0:1,h=null,d=0,p=null;function f(e,t){n.buffers.color.setClear(e.r,e.g,e.b,t,s)}return{getClearColor:function(){return a},setClearColor:function(e,t=1){a.set(e),u=t,f(a,u)},getClearAlpha:function(){return u},setClearAlpha:function(e){u=e,f(a,u)},render:function(n,i){let s=!1,m=!0===i.isScene?i.background:null;m&&m.isTexture&&(m=t.get(m));const g=e.xr,y=g.getSession&&g.getSession();y&&"additive"===y.environmentBlendMode&&(m=null),null===m?f(a,u):m&&m.isColor&&(f(m,1),s=!0),(e.autoClear||s)&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),m&&(m.isCubeTexture||m.mapping===c)?(void 0===l&&(l=new Kn(new Jn(1,1,1),new nr({name:"BackgroundCubeMaterial",uniforms:Qn(wr.cube.uniforms),vertexShader:wr.cube.vertexShader,fragmentShader:wr.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(e,t,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(l)),l.material.uniforms.envMap.value=m,l.material.uniforms.flipEnvMap.value=m.isCubeTexture&&!1===m.isRenderTargetTexture?-1:1,h===m&&d===m.version&&p===e.toneMapping||(l.material.needsUpdate=!0,h=m,d=m.version,p=e.toneMapping),l.layers.enableAll(),n.unshift(l,l.geometry,l.material,0,0,null)):m&&m.isTexture&&(void 0===o&&(o=new Kn(new vr(2,2),new nr({name:"BackgroundMaterial",uniforms:Qn(wr.background.uniforms),vertexShader:wr.background.vertexShader,fragmentShader:wr.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(o)),o.material.uniforms.t2D.value=m,!0===m.matrixAutoUpdate&&m.updateMatrix(),o.material.uniforms.uvTransform.value.copy(m.matrix),h===m&&d===m.version&&p===e.toneMapping||(o.material.needsUpdate=!0,h=m,d=m.version,p=e.toneMapping),o.layers.enableAll(),n.unshift(o,o.geometry,o.material,0,0,null))}}}function Sr(e,t,n,r){const i=e.getParameter(e.MAX_VERTEX_ATTRIBS),s=r.isWebGL2?null:t.get("OES_vertex_array_object"),a=r.isWebGL2||null!==s,o={},l=p(null);let c=l,u=!1;function h(t){return r.isWebGL2?e.bindVertexArray(t):s.bindVertexArrayOES(t)}function d(t){return r.isWebGL2?e.deleteVertexArray(t):s.deleteVertexArrayOES(t)}function p(e){const t=[],n=[],r=[];for(let e=0;e<i;e++)t[e]=0,n[e]=0,r[e]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:t,enabledAttributes:n,attributeDivisors:r,object:e,attributes:{},index:null}}function f(){const e=c.newAttributes;for(let t=0,n=e.length;t<n;t++)e[t]=0}function m(e){g(e,0)}function g(n,i){const s=c.newAttributes,a=c.enabledAttributes,o=c.attributeDivisors;s[n]=1,0===a[n]&&(e.enableVertexAttribArray(n),a[n]=1),o[n]!==i&&((r.isWebGL2?e:t.get("ANGLE_instanced_arrays"))[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,i),o[n]=i)}function y(){const t=c.newAttributes,n=c.enabledAttributes;for(let r=0,i=n.length;r<i;r++)n[r]!==t[r]&&(e.disableVertexAttribArray(r),n[r]=0)}function v(t,n,i,s,a,o){!0!==r.isWebGL2||i!==e.INT&&i!==e.UNSIGNED_INT?e.vertexAttribPointer(t,n,i,s,a,o):e.vertexAttribIPointer(t,n,i,a,o)}function x(){b(),u=!0,c!==l&&(c=l,h(c.object))}function b(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(i,l,d,x,b){let w=!1;if(a){const t=function(t,n,i){const a=!0===i.wireframe;let l=o[t.id];void 0===l&&(l={},o[t.id]=l);let c=l[n.id];void 0===c&&(c={},l[n.id]=c);let u=c[a];return void 0===u&&(u=p(r.isWebGL2?e.createVertexArray():s.createVertexArrayOES()),c[a]=u),u}(x,d,l);c!==t&&(c=t,h(c.object)),w=function(e,t,n,r){const i=c.attributes,s=t.attributes;let a=0;const o=n.getAttributes();for(const t in o)if(o[t].location>=0){const n=i[t];let r=s[t];if(void 0===r&&("instanceMatrix"===t&&e.instanceMatrix&&(r=e.instanceMatrix),"instanceColor"===t&&e.instanceColor&&(r=e.instanceColor)),void 0===n)return!0;if(n.attribute!==r)return!0;if(r&&n.data!==r.data)return!0;a++}return c.attributesNum!==a||c.index!==r}(i,x,d,b),w&&function(e,t,n,r){const i={},s=t.attributes;let a=0;const o=n.getAttributes();for(const t in o)if(o[t].location>=0){let n=s[t];void 0===n&&("instanceMatrix"===t&&e.instanceMatrix&&(n=e.instanceMatrix),"instanceColor"===t&&e.instanceColor&&(n=e.instanceColor));const r={};r.attribute=n,n&&n.data&&(r.data=n.data),i[t]=r,a++}c.attributes=i,c.attributesNum=a,c.index=r}(i,x,d,b)}else{const e=!0===l.wireframe;c.geometry===x.id&&c.program===d.id&&c.wireframe===e||(c.geometry=x.id,c.program=d.id,c.wireframe=e,w=!0)}null!==b&&n.update(b,e.ELEMENT_ARRAY_BUFFER),(w||u)&&(u=!1,function(i,s,a,o){if(!1===r.isWebGL2&&(i.isInstancedMesh||o.isInstancedBufferGeometry)&&null===t.get("ANGLE_instanced_arrays"))return;f();const l=o.attributes,c=a.getAttributes(),u=s.defaultAttributeValues;for(const t in c){const r=c[t];if(r.location>=0){let s=l[t];if(void 0===s&&("instanceMatrix"===t&&i.instanceMatrix&&(s=i.instanceMatrix),"instanceColor"===t&&i.instanceColor&&(s=i.instanceColor)),void 0!==s){const t=s.normalized,a=s.itemSize,l=n.get(s);if(void 0===l)continue;const c=l.buffer,u=l.type,h=l.bytesPerElement;if(s.isInterleavedBufferAttribute){const n=s.data,l=n.stride,d=s.offset;if(n.isInstancedInterleavedBuffer){for(let e=0;e<r.locationSize;e++)g(r.location+e,n.meshPerAttribute);!0!==i.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=n.meshPerAttribute*n.count)}else for(let e=0;e<r.locationSize;e++)m(r.location+e);e.bindBuffer(e.ARRAY_BUFFER,c);for(let e=0;e<r.locationSize;e++)v(r.location+e,a/r.locationSize,u,t,l*h,(d+a/r.locationSize*e)*h)}else{if(s.isInstancedBufferAttribute){for(let e=0;e<r.locationSize;e++)g(r.location+e,s.meshPerAttribute);!0!==i.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=s.meshPerAttribute*s.count)}else for(let e=0;e<r.locationSize;e++)m(r.location+e);e.bindBuffer(e.ARRAY_BUFFER,c);for(let e=0;e<r.locationSize;e++)v(r.location+e,a/r.locationSize,u,t,a*h,a/r.locationSize*e*h)}}else if(void 0!==u){const n=u[t];if(void 0!==n)switch(n.length){case 2:e.vertexAttrib2fv(r.location,n);break;case 3:e.vertexAttrib3fv(r.location,n);break;case 4:e.vertexAttrib4fv(r.location,n);break;default:e.vertexAttrib1fv(r.location,n)}}}}y()}(i,l,d,x),null!==b&&e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n.get(b).buffer))},reset:x,resetDefaultState:b,dispose:function(){x();for(const e in o){const t=o[e];for(const e in t){const n=t[e];for(const e in n)d(n[e].object),delete n[e];delete t[e]}delete o[e]}},releaseStatesOfGeometry:function(e){if(void 0===o[e.id])return;const t=o[e.id];for(const e in t){const n=t[e];for(const e in n)d(n[e].object),delete n[e];delete t[e]}delete o[e.id]},releaseStatesOfProgram:function(e){for(const t in o){const n=o[t];if(void 0===n[e.id])continue;const r=n[e.id];for(const e in r)d(r[e].object),delete r[e];delete n[e.id]}},initAttributes:f,enableAttribute:m,disableUnusedAttributes:y}}function Mr(e,t,n,r){const i=r.isWebGL2;let s;this.setMode=function(e){s=e},this.render=function(t,r){e.drawArrays(s,t,r),n.update(r,s,1)},this.renderInstances=function(r,a,o){if(0===o)return;let l,c;if(i)l=e,c="drawArraysInstanced";else if(l=t.get("ANGLE_instanced_arrays"),c="drawArraysInstancedANGLE",null===l)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[c](s,r,a,o),n.update(a,s,o)}}function Tr(e,t,n){let r;function i(t){if("highp"===t){if(e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_FLOAT).precision>0&&e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_FLOAT).precision>0)return"highp";t="mediump"}return"mediump"===t&&e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_FLOAT).precision>0&&e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const s="undefined"!=typeof WebGL2RenderingContext&&e instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&e instanceof WebGL2ComputeRenderingContext;let a=void 0!==n.precision?n.precision:"highp";const o=i(a);o!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",o,"instead."),a=o);const l=s||t.has("WEBGL_draw_buffers"),c=!0===n.logarithmicDepthBuffer,u=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),h=e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),d=e.getParameter(e.MAX_TEXTURE_SIZE),p=e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),f=e.getParameter(e.MAX_VERTEX_ATTRIBS),m=e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),g=e.getParameter(e.MAX_VARYING_VECTORS),y=e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),v=h>0,x=s||t.has("OES_texture_float");return{isWebGL2:s,drawBuffers:l,getMaxAnisotropy:function(){if(void 0!==r)return r;if(!0===t.has("EXT_texture_filter_anisotropic")){const n=t.get("EXT_texture_filter_anisotropic");r=e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else r=0;return r},getMaxPrecision:i,precision:a,logarithmicDepthBuffer:c,maxTextures:u,maxVertexTextures:h,maxTextureSize:d,maxCubemapSize:p,maxAttributes:f,maxVertexUniforms:m,maxVaryings:g,maxFragmentUniforms:y,vertexTextures:v,floatFragmentTextures:x,floatVertexTextures:v&&x,maxSamples:s?e.getParameter(e.MAX_SAMPLES):0}}function Er(e){const t=this;let n=null,r=0,i=!1,s=!1;const a=new dr,o=new Ce,l={value:null,needsUpdate:!1};function c(){l.value!==n&&(l.value=n,l.needsUpdate=r>0),t.numPlanes=r,t.numIntersection=0}function u(e,n,r,i){const s=null!==e?e.length:0;let c=null;if(0!==s){if(c=l.value,!0!==i||null===c){const t=r+4*s,i=n.matrixWorldInverse;o.getNormalMatrix(i),(null===c||c.length<t)&&(c=new Float32Array(t));for(let t=0,n=r;t!==s;++t,n+=4)a.copy(e[t]).applyMatrix4(i,o),a.normal.toArray(c,n),c[n+3]=a.constant}l.value=c,l.needsUpdate=!0}return t.numPlanes=s,t.numIntersection=0,c}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(e,t,s){const a=0!==e.length||t||0!==r||i;return i=t,n=u(e,s,0),r=e.length,a},this.beginShadows=function(){s=!0,u(null)},this.endShadows=function(){s=!1,c()},this.setState=function(t,a,o){const h=t.clippingPlanes,d=t.clipIntersection,p=t.clipShadows,f=e.get(t);if(!i||null===h||0===h.length||s&&!p)s?u(null):c();else{const e=s?0:r,t=4*e;let i=f.clippingState||null;l.value=i,i=u(h,a,t,o);for(let e=0;e!==t;++e)i[e]=n[e];f.clippingState=i,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=e}}}function Ar(e){let t=new WeakMap;function n(e,t){return t===o?e.mapping=s:t===l&&(e.mapping=a),e}function r(e){const n=e.target;n.removeEventListener("dispose",r);const i=t.get(n);void 0!==i&&(t.delete(n),i.dispose())}return{get:function(i){if(i&&i.isTexture&&!1===i.isRenderTargetTexture){const s=i.mapping;if(s===o||s===l){if(t.has(i))return n(t.get(i).texture,i.mapping);{const s=i.image;if(s&&s.height>0){const a=new lr(s.height/2);return a.fromEquirectangularTexture(e,i),t.set(i,a),i.addEventListener("dispose",r),n(a.texture,i.mapping)}return null}}}return i},dispose:function(){t=new WeakMap}}}wr.physical={uniforms:er([wr.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Ae(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new We(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new Ae},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new We(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new We(1,1,1)},specularColorMap:{value:null}}]),vertexShader:xr.meshphysical_vert,fragmentShader:xr.meshphysical_frag};class Cr extends rr{constructor(e=-1,t=1,n=1,r=-1,i=.1,s=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=r,this.near=i,this.far=s,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=null===e.view?null:Object.assign({},e.view),this}setViewOffset(e,t,n,r,i,s){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=r,this.view.width=i,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let i=n-e,s=n+e,a=r+t,o=r-t;if(null!==this.view&&this.view.enabled){const e=(this.right-this.left)/this.view.fullWidth/this.zoom,t=(this.top-this.bottom)/this.view.fullHeight/this.zoom;i+=e*this.view.offsetX,s=i+e*this.view.width,a-=t*this.view.offsetY,o=a-t*this.view.height}this.projectionMatrix.makeOrthographic(i,s,a,o,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,null!==this.view&&(t.object.view=Object.assign({},this.view)),t}}const Ir=[.125,.215,.35,.446,.526,.582],Nr=new Cr,kr=new We;let Rr=null;const Dr=(1+Math.sqrt(5))/2,Lr=1/Dr,Fr=[new tt(1,1,1),new tt(-1,1,1),new tt(1,1,-1),new tt(-1,1,-1),new tt(0,Dr,Lr),new tt(0,Dr,-Lr),new tt(Lr,0,Dr),new tt(-Lr,0,Dr),new tt(Dr,Lr,0),new tt(-Dr,Lr,0)];class Pr{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,r=100){Rr=this._renderer.getRenderTarget(),this._setSize(256);const i=this._allocateTargets();return i.depthBuffer=!0,this._sceneToCubeUV(e,n,r,i),t>0&&this._blur(i,0,0,t),this._applyPMREM(i),this._cleanup(i),i}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=Ur(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=Br(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(Rr),e.scissorTest=!1,zr(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===s||e.mapping===a?this._setSize(0===e.image.length?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),Rr=this._renderer.getRenderTarget();const n=t||this._allocateTargets();return this._textureToCubeUV(e,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,n={magFilter:g,minFilter:g,generateMipmaps:!1,type:S,format:T,encoding:ae,depthBuffer:!1},r=Or(e,t,n);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==e){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=Or(e,t,n);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=function(e){const t=[],n=[],r=[];let i=e;const s=e-4+1+Ir.length;for(let a=0;a<s;a++){const s=Math.pow(2,i);n.push(s);let o=1/s;a>e-4?o=Ir[a-e+4-1]:0===a&&(o=0),r.push(o);const l=1/(s-2),c=-l,u=1+l,h=[c,c,u,c,u,u,c,c,u,u,c,u],d=6,p=6,f=3,m=2,g=1,y=new Float32Array(f*p*d),v=new Float32Array(m*p*d),x=new Float32Array(g*p*d);for(let e=0;e<d;e++){const t=e%3*2/3-1,n=e>2?0:-1,r=[t,n,0,t+2/3,n,0,t+2/3,n+1,0,t,n,0,t+2/3,n+1,0,t,n+1,0];y.set(r,f*p*e),v.set(h,m*p*e);const i=[e,e,e,e,e,e];x.set(i,g*p*e)}const b=new Rn;b.setAttribute("position",new wn(y,f)),b.setAttribute("uv",new wn(v,m)),b.setAttribute("faceIndex",new wn(x,g)),t.push(b),i>4&&i--}return{lodPlanes:t,sizeLods:n,sigmas:r}}(r)),this._blurMaterial=function(e,t,n){const r=new Float32Array(20),i=new tt(0,1,0);return new nr({name:"SphericalGaussianBlur",defines:{n:20,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/n,CUBEUV_MAX_MIP:`${e}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:r},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}(r,e,t)}return r}_compileMaterial(e){const t=new Kn(this._lodPlanes[0],e);this._renderer.compile(t,Nr)}_sceneToCubeUV(e,t,n,r){const i=new ir(90,1,t,n),s=[1,-1,1,1,1,1],a=[1,1,1,-1,-1,-1],o=this._renderer,l=o.autoClear,c=o.toneMapping;o.getClearColor(kr),o.toneMapping=0,o.autoClear=!1;const u=new vn({name:"PMREM.Background",side:1,depthWrite:!1,depthTest:!1}),h=new Kn(new Jn,u);let d=!1;const p=e.background;p?p.isColor&&(u.color.copy(p),e.background=null,d=!0):(u.color.copy(kr),d=!0);for(let t=0;t<6;t++){const n=t%3;0===n?(i.up.set(0,s[t],0),i.lookAt(a[t],0,0)):1===n?(i.up.set(0,0,s[t]),i.lookAt(0,a[t],0)):(i.up.set(0,s[t],0),i.lookAt(0,0,a[t]));const l=this._cubeSize;zr(r,n*l,t>2?l:0,l,l),o.setRenderTarget(r),d&&o.render(h,i),o.render(e,i)}h.geometry.dispose(),h.material.dispose(),o.toneMapping=c,o.autoClear=l,e.background=p}_textureToCubeUV(e,t){const n=this._renderer,r=e.mapping===s||e.mapping===a;r?(null===this._cubemapMaterial&&(this._cubemapMaterial=Ur()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===e.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=Br());const i=r?this._cubemapMaterial:this._equirectMaterial,o=new Kn(this._lodPlanes[0],i);i.uniforms.envMap.value=e;const l=this._cubeSize;zr(t,0,0,3*l,2*l),n.setRenderTarget(t),n.render(o,Nr)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let t=1;t<this._lodPlanes.length;t++){const n=Math.sqrt(this._sigmas[t]*this._sigmas[t]-this._sigmas[t-1]*this._sigmas[t-1]),r=Fr[(t-1)%Fr.length];this._blur(e,t-1,t,n,r)}t.autoClear=n}_blur(e,t,n,r,i){const s=this._pingPongRenderTarget;this._halfBlur(e,s,t,n,r,"latitudinal",i),this._halfBlur(s,e,n,n,r,"longitudinal",i)}_halfBlur(e,t,n,r,i,s,a){const o=this._renderer,l=this._blurMaterial;"latitudinal"!==s&&"longitudinal"!==s&&console.error("blur direction must be either latitudinal or longitudinal!");const c=new Kn(this._lodPlanes[r],l),u=l.uniforms,h=this._sizeLods[n]-1,d=isFinite(i)?Math.PI/(2*h):2*Math.PI/39,p=i/d,f=isFinite(i)?1+Math.floor(3*p):20;f>20&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);const m=[];let g=0;for(let e=0;e<20;++e){const t=e/p,n=Math.exp(-t*t/2);m.push(n),0===e?g+=n:e<f&&(g+=2*n)}for(let e=0;e<m.length;e++)m[e]=m[e]/g;u.envMap.value=e.texture,u.samples.value=f,u.weights.value=m,u.latitudinal.value="latitudinal"===s,a&&(u.poleAxis.value=a);const{_lodMax:y}=this;u.dTheta.value=d,u.mipInt.value=y-n;const v=this._sizeLods[r];zr(t,3*v*(r>y-4?r-y+4:0),4*(this._cubeSize-v),3*v,2*v),o.setRenderTarget(t),o.render(c,Nr)}}function Or(e,t,n){const r=new Ze(e,t,n);return r.texture.mapping=c,r.texture.name="PMREM.cubeUv",r.scissorTest=!0,r}function zr(e,t,n,r,i){e.viewport.set(t,n,r,i),e.scissor.set(t,n,r,i)}function Br(){return new nr({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function Ur(){return new nr({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function $r(e){let t=new WeakMap,n=null;function r(e){const n=e.target;n.removeEventListener("dispose",r);const i=t.get(n);void 0!==i&&(t.delete(n),i.dispose())}return{get:function(i){if(i&&i.isTexture){const c=i.mapping,u=c===o||c===l,h=c===s||c===a;if(u||h){if(i.isRenderTargetTexture&&!0===i.needsPMREMUpdate){i.needsPMREMUpdate=!1;let r=t.get(i);return null===n&&(n=new Pr(e)),r=u?n.fromEquirectangular(i,r):n.fromCubemap(i,r),t.set(i,r),r.texture}if(t.has(i))return t.get(i).texture;{const s=i.image;if(u&&s&&s.height>0||h&&s&&function(e){let t=0;for(let n=0;n<6;n++)void 0!==e[n]&&t++;return 6===t}(s)){null===n&&(n=new Pr(e));const s=u?n.fromEquirectangular(i):n.fromCubemap(i);return t.set(i,s),i.addEventListener("dispose",r),s.texture}return null}}}return i},dispose:function(){t=new WeakMap,null!==n&&(n.dispose(),n=null)}}}function Vr(e){const t={};function n(n){if(void 0!==t[n])return t[n];let r;switch(n){case"WEBGL_depth_texture":r=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=e.getExtension(n)}return t[n]=r,r}return{has:function(e){return null!==n(e)},init:function(e){e.isWebGL2?n("EXT_color_buffer_float"):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture")},get:function(e){const t=n(e);return null===t&&console.warn("THREE.WebGLRenderer: "+e+" extension not supported."),t}}}function Wr(e,t,n,r){const i={},s=new WeakMap;function a(e){const o=e.target;null!==o.index&&t.remove(o.index);for(const e in o.attributes)t.remove(o.attributes[e]);o.removeEventListener("dispose",a),delete i[o.id];const l=s.get(o);l&&(t.remove(l),s.delete(o)),r.releaseStatesOfGeometry(o),!0===o.isInstancedBufferGeometry&&delete o._maxInstanceCount,n.memory.geometries--}function o(e){const n=[],r=e.index,i=e.attributes.position;let a=0;if(null!==r){const e=r.array;a=r.version;for(let t=0,r=e.length;t<r;t+=3){const r=e[t+0],i=e[t+1],s=e[t+2];n.push(r,i,i,s,s,r)}}else{const e=i.array;a=i.version;for(let t=0,r=e.length/3-1;t<r;t+=3){const e=t+0,r=t+1,i=t+2;n.push(e,r,r,i,i,e)}}const o=new(Ie(n)?Sn:_n)(n,1);o.version=a;const l=s.get(e);l&&t.remove(l),s.set(e,o)}return{get:function(e,t){return!0===i[t.id]||(t.addEventListener("dispose",a),i[t.id]=!0,n.memory.geometries++),t},update:function(n){const r=n.attributes;for(const n in r)t.update(r[n],e.ARRAY_BUFFER);const i=n.morphAttributes;for(const n in i){const r=i[n];for(let n=0,i=r.length;n<i;n++)t.update(r[n],e.ARRAY_BUFFER)}},getWireframeAttribute:function(e){const t=s.get(e);if(t){const n=e.index;null!==n&&t.version<n.version&&o(e)}else o(e);return s.get(e)}}}function Gr(e,t,n,r){const i=r.isWebGL2;let s,a,o;this.setMode=function(e){s=e},this.setIndex=function(e){a=e.type,o=e.bytesPerElement},this.render=function(t,r){e.drawElements(s,r,a,t*o),n.update(r,s,1)},this.renderInstances=function(r,l,c){if(0===c)return;let u,h;if(i)u=e,h="drawElementsInstanced";else if(u=t.get("ANGLE_instanced_arrays"),h="drawElementsInstancedANGLE",null===u)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");u[h](s,l,a,r*o,c),n.update(l,s,c)}}function Hr(e){const t={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:t,programs:null,autoReset:!0,reset:function(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0},update:function(n,r,i){switch(t.calls++,r){case e.TRIANGLES:t.triangles+=i*(n/3);break;case e.LINES:t.lines+=i*(n/2);break;case e.LINE_STRIP:t.lines+=i*(n-1);break;case e.LINE_LOOP:t.lines+=i*n;break;case e.POINTS:t.points+=i*n;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",r)}}}}function jr(e,t){return e[0]-t[0]}function qr(e,t){return Math.abs(t[1])-Math.abs(e[1])}function Xr(e,t){let n=1;const r=t.isInterleavedBufferAttribute?t.data.array:t.array;r instanceof Int8Array?n=127:r instanceof Int16Array?n=32767:r instanceof Int32Array?n=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",r),e.divideScalar(n)}function Yr(e,t,n){const r={},i=new Float32Array(8),s=new WeakMap,a=new Ke,o=[];for(let e=0;e<8;e++)o[e]=[e,0];return{update:function(l,c,u,h){const d=l.morphTargetInfluences;if(!0===t.isWebGL2){const p=c.morphAttributes.position||c.morphAttributes.normal||c.morphAttributes.color,f=void 0!==p?p.length:0;let m=s.get(c);if(void 0===m||m.count!==f){void 0!==m&&m.texture.dispose();const v=void 0!==c.morphAttributes.position,x=void 0!==c.morphAttributes.normal,b=void 0!==c.morphAttributes.color,w=c.morphAttributes.position||[],S=c.morphAttributes.normal||[],M=c.morphAttributes.color||[];let T=0;!0===v&&(T=1),!0===x&&(T=2),!0===b&&(T=3);let E=c.attributes.position.count*T,A=1;E>t.maxTextureSize&&(A=Math.ceil(E/t.maxTextureSize),E=t.maxTextureSize);const C=new Float32Array(E*A*4*f),I=new Je(C,E,A,f);I.type=_,I.needsUpdate=!0;const N=4*T;for(let R=0;R<f;R++){const D=w[R],L=S[R],F=M[R],P=E*A*4*R;for(let O=0;O<D.count;O++){const z=O*N;!0===v&&(a.fromBufferAttribute(D,O),!0===D.normalized&&Xr(a,D),C[P+z+0]=a.x,C[P+z+1]=a.y,C[P+z+2]=a.z,C[P+z+3]=0),!0===x&&(a.fromBufferAttribute(L,O),!0===L.normalized&&Xr(a,L),C[P+z+4]=a.x,C[P+z+5]=a.y,C[P+z+6]=a.z,C[P+z+7]=0),!0===b&&(a.fromBufferAttribute(F,O),!0===F.normalized&&Xr(a,F),C[P+z+8]=a.x,C[P+z+9]=a.y,C[P+z+10]=a.z,C[P+z+11]=4===F.itemSize?a.w:1)}}function k(){I.dispose(),s.delete(c),c.removeEventListener("dispose",k)}m={count:f,texture:I,size:new Ae(E,A)},s.set(c,m),c.addEventListener("dispose",k)}let g=0;for(let B=0;B<d.length;B++)g+=d[B];const y=c.morphTargetsRelative?1:1-g;h.getUniforms().setValue(e,"morphTargetBaseInfluence",y),h.getUniforms().setValue(e,"morphTargetInfluences",d),h.getUniforms().setValue(e,"morphTargetsTexture",m.texture,n),h.getUniforms().setValue(e,"morphTargetsTextureSize",m.size)}else{const U=void 0===d?0:d.length;let $=r[c.id];if(void 0===$||$.length!==U){$=[];for(let j=0;j<U;j++)$[j]=[j,0];r[c.id]=$}for(let q=0;q<U;q++){const X=$[q];X[0]=q,X[1]=d[q]}$.sort(qr);for(let Y=0;Y<8;Y++)Y<U&&$[Y][1]?(o[Y][0]=$[Y][0],o[Y][1]=$[Y][1]):(o[Y][0]=Number.MAX_SAFE_INTEGER,o[Y][1]=0);o.sort(jr);const V=c.morphAttributes.position,W=c.morphAttributes.normal;let G=0;for(let K=0;K<8;K++){const Z=o[K],J=Z[0],Q=Z[1];J!==Number.MAX_SAFE_INTEGER&&Q?(V&&c.getAttribute("morphTarget"+K)!==V[J]&&c.setAttribute("morphTarget"+K,V[J]),W&&c.getAttribute("morphNormal"+K)!==W[J]&&c.setAttribute("morphNormal"+K,W[J]),i[K]=Q,G+=Q):(V&&!0===c.hasAttribute("morphTarget"+K)&&c.deleteAttribute("morphTarget"+K),W&&!0===c.hasAttribute("morphNormal"+K)&&c.deleteAttribute("morphNormal"+K),i[K]=0)}const H=c.morphTargetsRelative?1:1-G;h.getUniforms().setValue(e,"morphTargetBaseInfluence",H),h.getUniforms().setValue(e,"morphTargetInfluences",i)}}}}function Kr(e,t,n,r){let i=new WeakMap;function s(e){const t=e.target;t.removeEventListener("dispose",s),n.remove(t.instanceMatrix),null!==t.instanceColor&&n.remove(t.instanceColor)}return{update:function(a){const o=r.render.frame,l=a.geometry,c=t.get(a,l);return i.get(c)!==o&&(t.update(c),i.set(c,o)),a.isInstancedMesh&&(!1===a.hasEventListener("dispose",s)&&a.addEventListener("dispose",s),n.update(a.instanceMatrix,e.ARRAY_BUFFER),null!==a.instanceColor&&n.update(a.instanceColor,e.ARRAY_BUFFER)),c},dispose:function(){i=new WeakMap}}}const Zr=new Ye,Jr=new Je,Qr=new Qe,ei=new or,ti=[],ni=[],ri=new Float32Array(16),ii=new Float32Array(9),si=new Float32Array(4);function ai(e,t,n){const r=e[0];if(r<=0||r>0)return e;const i=t*n;let s=ti[i];if(void 0===s&&(s=new Float32Array(i),ti[i]=s),0!==t){r.toArray(s,0);for(let r=1,i=0;r!==t;++r)i+=n,e[r].toArray(s,i)}return s}function oi(e,t){if(e.length!==t.length)return!1;for(let n=0,r=e.length;n<r;n++)if(e[n]!==t[n])return!1;return!0}function li(e,t){for(let n=0,r=t.length;n<r;n++)e[n]=t[n]}function ci(e,t){let n=ni[t];void 0===n&&(n=new Int32Array(t),ni[t]=n);for(let r=0;r!==t;++r)n[r]=e.allocateTextureUnit();return n}function ui(e,t){const n=this.cache;n[0]!==t&&(e.uniform1f(this.addr,t),n[0]=t)}function hi(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y||(e.uniform2f(this.addr,t.x,t.y),n[0]=t.x,n[1]=t.y);else{if(oi(n,t))return;e.uniform2fv(this.addr,t),li(n,t)}}function di(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z||(e.uniform3f(this.addr,t.x,t.y,t.z),n[0]=t.x,n[1]=t.y,n[2]=t.z);else if(void 0!==t.r)n[0]===t.r&&n[1]===t.g&&n[2]===t.b||(e.uniform3f(this.addr,t.r,t.g,t.b),n[0]=t.r,n[1]=t.g,n[2]=t.b);else{if(oi(n,t))return;e.uniform3fv(this.addr,t),li(n,t)}}function pi(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z&&n[3]===t.w||(e.uniform4f(this.addr,t.x,t.y,t.z,t.w),n[0]=t.x,n[1]=t.y,n[2]=t.z,n[3]=t.w);else{if(oi(n,t))return;e.uniform4fv(this.addr,t),li(n,t)}}function fi(e,t){const n=this.cache,r=t.elements;if(void 0===r){if(oi(n,t))return;e.uniformMatrix2fv(this.addr,!1,t),li(n,t)}else{if(oi(n,r))return;si.set(r),e.uniformMatrix2fv(this.addr,!1,si),li(n,r)}}function mi(e,t){const n=this.cache,r=t.elements;if(void 0===r){if(oi(n,t))return;e.uniformMatrix3fv(this.addr,!1,t),li(n,t)}else{if(oi(n,r))return;ii.set(r),e.uniformMatrix3fv(this.addr,!1,ii),li(n,r)}}function gi(e,t){const n=this.cache,r=t.elements;if(void 0===r){if(oi(n,t))return;e.uniformMatrix4fv(this.addr,!1,t),li(n,t)}else{if(oi(n,r))return;ri.set(r),e.uniformMatrix4fv(this.addr,!1,ri),li(n,r)}}function yi(e,t){const n=this.cache;n[0]!==t&&(e.uniform1i(this.addr,t),n[0]=t)}function vi(e,t){const n=this.cache;oi(n,t)||(e.uniform2iv(this.addr,t),li(n,t))}function xi(e,t){const n=this.cache;oi(n,t)||(e.uniform3iv(this.addr,t),li(n,t))}function bi(e,t){const n=this.cache;oi(n,t)||(e.uniform4iv(this.addr,t),li(n,t))}function wi(e,t){const n=this.cache;n[0]!==t&&(e.uniform1ui(this.addr,t),n[0]=t)}function _i(e,t){const n=this.cache;oi(n,t)||(e.uniform2uiv(this.addr,t),li(n,t))}function Si(e,t){const n=this.cache;oi(n,t)||(e.uniform3uiv(this.addr,t),li(n,t))}function Mi(e,t){const n=this.cache;oi(n,t)||(e.uniform4uiv(this.addr,t),li(n,t))}function Ti(e,t,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(e.uniform1i(this.addr,i),r[0]=i),n.setTexture2D(t||Zr,i)}function Ei(e,t,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(e.uniform1i(this.addr,i),r[0]=i),n.setTexture3D(t||Qr,i)}function Ai(e,t,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(e.uniform1i(this.addr,i),r[0]=i),n.setTextureCube(t||ei,i)}function Ci(e,t,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(e.uniform1i(this.addr,i),r[0]=i),n.setTexture2DArray(t||Jr,i)}function Ii(e,t){e.uniform1fv(this.addr,t)}function Ni(e,t){const n=ai(t,this.size,2);e.uniform2fv(this.addr,n)}function ki(e,t){const n=ai(t,this.size,3);e.uniform3fv(this.addr,n)}function Ri(e,t){const n=ai(t,this.size,4);e.uniform4fv(this.addr,n)}function Di(e,t){const n=ai(t,this.size,4);e.uniformMatrix2fv(this.addr,!1,n)}function Li(e,t){const n=ai(t,this.size,9);e.uniformMatrix3fv(this.addr,!1,n)}function Fi(e,t){const n=ai(t,this.size,16);e.uniformMatrix4fv(this.addr,!1,n)}function Pi(e,t){e.uniform1iv(this.addr,t)}function Oi(e,t){e.uniform2iv(this.addr,t)}function zi(e,t){e.uniform3iv(this.addr,t)}function Bi(e,t){e.uniform4iv(this.addr,t)}function Ui(e,t){e.uniform1uiv(this.addr,t)}function $i(e,t){e.uniform2uiv(this.addr,t)}function Vi(e,t){e.uniform3uiv(this.addr,t)}function Wi(e,t){e.uniform4uiv(this.addr,t)}function Gi(e,t,n){const r=t.length,i=ci(n,r);e.uniform1iv(this.addr,i);for(let e=0;e!==r;++e)n.setTexture2D(t[e]||Zr,i[e])}function Hi(e,t,n){const r=t.length,i=ci(n,r);e.uniform1iv(this.addr,i);for(let e=0;e!==r;++e)n.setTexture3D(t[e]||Qr,i[e])}function ji(e,t,n){const r=t.length,i=ci(n,r);e.uniform1iv(this.addr,i);for(let e=0;e!==r;++e)n.setTextureCube(t[e]||ei,i[e])}function qi(e,t,n){const r=t.length,i=ci(n,r);e.uniform1iv(this.addr,i);for(let e=0;e!==r;++e)n.setTexture2DArray(t[e]||Jr,i[e])}class Xi{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.setValue=function(e){switch(e){case 5126:return ui;case 35664:return hi;case 35665:return di;case 35666:return pi;case 35674:return fi;case 35675:return mi;case 35676:return gi;case 5124:case 35670:return yi;case 35667:case 35671:return vi;case 35668:case 35672:return xi;case 35669:case 35673:return bi;case 5125:return wi;case 36294:return _i;case 36295:return Si;case 36296:return Mi;case 35678:case 36198:case 36298:case 36306:case 35682:return Ti;case 35679:case 36299:case 36307:return Ei;case 35680:case 36300:case 36308:case 36293:return Ai;case 36289:case 36303:case 36311:case 36292:return Ci}}(t.type)}}class Yi{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.size=t.size,this.setValue=function(e){switch(e){case 5126:return Ii;case 35664:return Ni;case 35665:return ki;case 35666:return Ri;case 35674:return Di;case 35675:return Li;case 35676:return Fi;case 5124:case 35670:return Pi;case 35667:case 35671:return Oi;case 35668:case 35672:return zi;case 35669:case 35673:return Bi;case 5125:return Ui;case 36294:return $i;case 36295:return Vi;case 36296:return Wi;case 35678:case 36198:case 36298:case 36306:case 35682:return Gi;case 35679:case 36299:case 36307:return Hi;case 35680:case 36300:case 36308:case 36293:return ji;case 36289:case 36303:case 36311:case 36292:return qi}}(t.type)}}class Ki{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,n){const r=this.seq;for(let i=0,s=r.length;i!==s;++i){const s=r[i];s.setValue(e,t[s.id],n)}}}const Zi=/(\w+)(\])?(\[|\.)?/g;function Ji(e,t){e.seq.push(t),e.map[t.id]=t}function Qi(e,t,n){const r=e.name,i=r.length;for(Zi.lastIndex=0;;){const s=Zi.exec(r),a=Zi.lastIndex;let o=s[1];const l="]"===s[2],c=s[3];if(l&&(o|=0),void 0===c||"["===c&&a+2===i){Ji(n,void 0===c?new Xi(o,e,t):new Yi(o,e,t));break}{let e=n.map[o];void 0===e&&(e=new Ki(o),Ji(n,e)),n=e}}}class es{constructor(e,t){this.seq=[],this.map={};const n=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let r=0;r<n;++r){const n=e.getActiveUniform(t,r);Qi(n,e.getUniformLocation(t,n.name),this)}}setValue(e,t,n,r){const i=this.map[t];void 0!==i&&i.setValue(e,n,r)}setOptional(e,t,n){const r=t[n];void 0!==r&&this.setValue(e,n,r)}static upload(e,t,n,r){for(let i=0,s=t.length;i!==s;++i){const s=t[i],a=n[s.id];!1!==a.needsUpdate&&s.setValue(e,a.value,r)}}static seqWithValue(e,t){const n=[];for(let r=0,i=e.length;r!==i;++r){const i=e[r];i.id in t&&n.push(i)}return n}}function ts(e,t,n){const r=e.createShader(t);return e.shaderSource(r,n),e.compileShader(r),r}let ns=0;function rs(e,t,n){const r=e.getShaderParameter(t,e.COMPILE_STATUS),i=e.getShaderInfoLog(t).trim();if(r&&""===i)return"";const s=/ERROR: 0:(\d+)/.exec(i);if(s){const r=parseInt(s[1]);return n.toUpperCase()+"\n\n"+i+"\n\n"+function(e,t){const n=e.split("\n"),r=[],i=Math.max(t-6,0),s=Math.min(t+6,n.length);for(let e=i;e<s;e++){const i=e+1;r.push(`${i===t?">":" "} ${i}: ${n[e]}`)}return r.join("\n")}(e.getShaderSource(t),r)}return i}function is(e,t){const n=function(e){switch(e){case ae:return["Linear","( value )"];case oe:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",e),["Linear","( value )"]}}(t);return"vec4 "+e+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function ss(e,t){let n;switch(t){case 1:n="Linear";break;case 2:n="Reinhard";break;case 3:n="OptimizedCineon";break;case 4:n="ACESFilmic";break;case 5:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),n="Linear"}return"vec3 "+e+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function as(e){return""!==e}function os(e,t){return e.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function ls(e,t){return e.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const cs=/^[ \t]*#include +<([\w\d./]+)>/gm;function us(e){return e.replace(cs,hs)}function hs(e,t){const n=xr[t];if(void 0===n)throw new Error("Can not resolve #include <"+t+">");return us(n)}const ds=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,ps=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function fs(e){return e.replace(ps,gs).replace(ds,ms)}function ms(e,t,n,r){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),gs(0,t,n,r)}function gs(e,t,n,r){let i="";for(let e=parseInt(t);e<parseInt(n);e++)i+=r.replace(/\[\s*i\s*\]/g,"[ "+e+" ]").replace(/UNROLLED_LOOP_INDEX/g,e);return i}function ys(e){let t="precision "+e.precision+" float;\nprecision "+e.precision+" int;";return"highp"===e.precision?t+="\n#define HIGH_PRECISION":"mediump"===e.precision?t+="\n#define MEDIUM_PRECISION":"lowp"===e.precision&&(t+="\n#define LOW_PRECISION"),t}function vs(e,t,n,r){const i=e.getContext(),o=n.defines;let l=n.vertexShader,u=n.fragmentShader;const h=function(e){let t="SHADOWMAP_TYPE_BASIC";return 1===e.shadowMapType?t="SHADOWMAP_TYPE_PCF":2===e.shadowMapType?t="SHADOWMAP_TYPE_PCF_SOFT":3===e.shadowMapType&&(t="SHADOWMAP_TYPE_VSM"),t}(n),d=function(e){let t="ENVMAP_TYPE_CUBE";if(e.envMap)switch(e.envMapMode){case s:case a:t="ENVMAP_TYPE_CUBE";break;case c:t="ENVMAP_TYPE_CUBE_UV"}return t}(n),p=function(e){let t="ENVMAP_MODE_REFLECTION";return e.envMap&&e.envMapMode===a&&(t="ENVMAP_MODE_REFRACTION"),t}(n),f=function(e){let t="ENVMAP_BLENDING_NONE";if(e.envMap)switch(e.combine){case 0:t="ENVMAP_BLENDING_MULTIPLY";break;case 1:t="ENVMAP_BLENDING_MIX";break;case 2:t="ENVMAP_BLENDING_ADD"}return t}(n),m=function(e){const t=e.envMapCubeUVHeight;if(null===t)return null;const n=Math.log2(t)-2,r=1/t;return{texelWidth:1/(3*Math.max(Math.pow(2,n),112)),texelHeight:r,maxMip:n}}(n),g=n.isWebGL2?"":function(e){return[e.extensionDerivatives||e.envMapCubeUVHeight||e.bumpMap||e.tangentSpaceNormalMap||e.clearcoatNormalMap||e.flatShading||"physical"===e.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(e.extensionFragDepth||e.logarithmicDepthBuffer)&&e.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",e.extensionDrawBuffers&&e.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(e.extensionShaderTextureLOD||e.envMap||e.transmission)&&e.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(as).join("\n")}(n),y=function(e){const t=[];for(const n in e){const r=e[n];!1!==r&&t.push("#define "+n+" "+r)}return t.join("\n")}(o),v=i.createProgram();let x,b,w=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(x=[y].filter(as).join("\n"),x.length>0&&(x+="\n"),b=[g,y].filter(as).join("\n"),b.length>0&&(b+="\n")):(x=[ys(n),"#define SHADER_NAME "+n.shaderName,y,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"",n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+p:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularColorMap?"#define USE_SPECULARCOLORMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.sheenColorMap?"#define USE_SHEENCOLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.morphColors&&n.isWebGL2?"#define USE_MORPHCOLORS":"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+n.morphTextureStride:"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+h:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(as).join("\n"),b=[g,ys(n),"#define SHADER_NAME "+n.shaderName,y,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+d:"",n.envMap?"#define "+p:"",n.envMap?"#define "+f:"",m?"#define CUBEUV_TEXEL_WIDTH "+m.texelWidth:"",m?"#define CUBEUV_TEXEL_HEIGHT "+m.texelHeight:"",m?"#define CUBEUV_MAX_MIP "+m.maxMip+".0":"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescence?"#define USE_IRIDESCENCE":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularColorMap?"#define USE_SPECULARCOLORMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.sheen?"#define USE_SHEEN":"",n.sheenColorMap?"#define USE_SHEENCOLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+h:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==n.toneMapping?"#define TONE_MAPPING":"",0!==n.toneMapping?xr.tonemapping_pars_fragment:"",0!==n.toneMapping?ss("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.opaque?"#define OPAQUE":"",xr.encodings_pars_fragment,is("linearToOutputTexel",n.outputEncoding),n.useDepthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(as).join("\n")),l=us(l),l=os(l,n),l=ls(l,n),u=us(u),u=os(u,n),u=ls(u,n),l=fs(l),u=fs(u),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(w="#version 300 es\n",x=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+x,b=["#define varying in",n.glslVersion===de?"":"layout(location = 0) out highp vec4 pc_fragColor;",n.glslVersion===de?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+b);const _=w+x+l,S=w+b+u,M=ts(i,i.VERTEX_SHADER,_),T=ts(i,i.FRAGMENT_SHADER,S);if(i.attachShader(v,M),i.attachShader(v,T),void 0!==n.index0AttributeName?i.bindAttribLocation(v,0,n.index0AttributeName):!0===n.morphTargets&&i.bindAttribLocation(v,0,"position"),i.linkProgram(v),e.debug.checkShaderErrors){const e=i.getProgramInfoLog(v).trim(),t=i.getShaderInfoLog(M).trim(),n=i.getShaderInfoLog(T).trim();let r=!0,s=!0;if(!1===i.getProgramParameter(v,i.LINK_STATUS)){r=!1;const t=rs(i,M,"vertex"),n=rs(i,T,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(v,i.VALIDATE_STATUS)+"\n\nProgram Info Log: "+e+"\n"+t+"\n"+n)}else""!==e?console.warn("THREE.WebGLProgram: Program Info Log:",e):""!==t&&""!==n||(s=!1);s&&(this.diagnostics={runnable:r,programLog:e,vertexShader:{log:t,prefix:x},fragmentShader:{log:n,prefix:b}})}let E,A;return i.deleteShader(M),i.deleteShader(T),this.getUniforms=function(){return void 0===E&&(E=new es(i,v)),E},this.getAttributes=function(){return void 0===A&&(A=function(e,t){const n={},r=e.getProgramParameter(t,e.ACTIVE_ATTRIBUTES);for(let i=0;i<r;i++){const r=e.getActiveAttrib(t,i),s=r.name;let a=1;r.type===e.FLOAT_MAT2&&(a=2),r.type===e.FLOAT_MAT3&&(a=3),r.type===e.FLOAT_MAT4&&(a=4),n[s]={type:r.type,location:e.getAttribLocation(t,s),locationSize:a}}return n}(i,v)),A},this.destroy=function(){r.releaseStatesOfProgram(this),i.deleteProgram(v),this.program=void 0},this.name=n.shaderName,this.id=ns++,this.cacheKey=t,this.usedTimes=1,this.program=v,this.vertexShader=M,this.fragmentShader=T,this}let xs=0;class bs{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,n=e.fragmentShader,r=this._getShaderStage(t),i=this._getShaderStage(n),s=this._getShaderCacheForMaterial(e);return!1===s.has(r)&&(s.add(r),r.usedTimes++),!1===s.has(i)&&(s.add(i),i.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const e of t)e.usedTimes--,0===e.usedTimes&&this.shaderCache.delete(e.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;return!1===t.has(e)&&t.set(e,new Set),t.get(e)}_getShaderStage(e){const t=this.shaderCache;if(!1===t.has(e)){const n=new ws(e);t.set(e,n)}return t.get(e)}}class ws{constructor(e){this.id=xs++,this.code=e,this.usedTimes=0}}function _s(e,t,n,r,i,s,a){const o=new Wt,l=new bs,u=[],h=i.isWebGL2,d=i.logarithmicDepthBuffer,p=i.vertexTextures;let f=i.precision;const m={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};return{getParameters:function(s,o,u,g,y){const v=g.fog,x=y.geometry,b=s.isMeshStandardMaterial?g.environment:null,w=(s.isMeshStandardMaterial?n:t).get(s.envMap||b),_=w&&w.mapping===c?w.image.height:null,S=m[s.type];null!==s.precision&&(f=i.getMaxPrecision(s.precision),f!==s.precision&&console.warn("THREE.WebGLProgram.getParameters:",s.precision,"not supported, using",f,"instead."));const M=x.morphAttributes.position||x.morphAttributes.normal||x.morphAttributes.color,T=void 0!==M?M.length:0;let E,A,C,I,N=0;if(void 0!==x.morphAttributes.position&&(N=1),void 0!==x.morphAttributes.normal&&(N=2),void 0!==x.morphAttributes.color&&(N=3),S){const e=wr[S];E=e.vertexShader,A=e.fragmentShader}else E=s.vertexShader,A=s.fragmentShader,l.update(s),C=l.getVertexShaderID(s),I=l.getFragmentShaderID(s);const k=e.getRenderTarget(),R=s.alphaTest>0,D=s.clearcoat>0,L=s.iridescence>0;return{isWebGL2:h,shaderID:S,shaderName:s.type,vertexShader:E,fragmentShader:A,defines:s.defines,customVertexShaderID:C,customFragmentShaderID:I,isRawShaderMaterial:!0===s.isRawShaderMaterial,glslVersion:s.glslVersion,precision:f,instancing:!0===y.isInstancedMesh,instancingColor:!0===y.isInstancedMesh&&null!==y.instanceColor,supportsVertexTextures:p,outputEncoding:null===k?e.outputEncoding:!0===k.isXRRenderTarget?k.texture.encoding:ae,map:!!s.map,matcap:!!s.matcap,envMap:!!w,envMapMode:w&&w.mapping,envMapCubeUVHeight:_,lightMap:!!s.lightMap,aoMap:!!s.aoMap,emissiveMap:!!s.emissiveMap,bumpMap:!!s.bumpMap,normalMap:!!s.normalMap,objectSpaceNormalMap:1===s.normalMapType,tangentSpaceNormalMap:0===s.normalMapType,decodeVideoTexture:!!s.map&&!0===s.map.isVideoTexture&&s.map.encoding===oe,clearcoat:D,clearcoatMap:D&&!!s.clearcoatMap,clearcoatRoughnessMap:D&&!!s.clearcoatRoughnessMap,clearcoatNormalMap:D&&!!s.clearcoatNormalMap,iridescence:L,iridescenceMap:L&&!!s.iridescenceMap,iridescenceThicknessMap:L&&!!s.iridescenceThicknessMap,displacementMap:!!s.displacementMap,roughnessMap:!!s.roughnessMap,metalnessMap:!!s.metalnessMap,specularMap:!!s.specularMap,specularIntensityMap:!!s.specularIntensityMap,specularColorMap:!!s.specularColorMap,opaque:!1===s.transparent&&1===s.blending,alphaMap:!!s.alphaMap,alphaTest:R,gradientMap:!!s.gradientMap,sheen:s.sheen>0,sheenColorMap:!!s.sheenColorMap,sheenRoughnessMap:!!s.sheenRoughnessMap,transmission:s.transmission>0,transmissionMap:!!s.transmissionMap,thicknessMap:!!s.thicknessMap,combine:s.combine,vertexTangents:!!s.normalMap&&!!x.attributes.tangent,vertexColors:s.vertexColors,vertexAlphas:!0===s.vertexColors&&!!x.attributes.color&&4===x.attributes.color.itemSize,vertexUvs:!!(s.map||s.bumpMap||s.normalMap||s.specularMap||s.alphaMap||s.emissiveMap||s.roughnessMap||s.metalnessMap||s.clearcoatMap||s.clearcoatRoughnessMap||s.clearcoatNormalMap||s.iridescenceMap||s.iridescenceThicknessMap||s.displacementMap||s.transmissionMap||s.thicknessMap||s.specularIntensityMap||s.specularColorMap||s.sheenColorMap||s.sheenRoughnessMap),uvsVertexOnly:!(s.map||s.bumpMap||s.normalMap||s.specularMap||s.alphaMap||s.emissiveMap||s.roughnessMap||s.metalnessMap||s.clearcoatNormalMap||s.iridescenceMap||s.iridescenceThicknessMap||s.transmission>0||s.transmissionMap||s.thicknessMap||s.specularIntensityMap||s.specularColorMap||s.sheen>0||s.sheenColorMap||s.sheenRoughnessMap||!s.displacementMap),fog:!!v,useFog:!0===s.fog,fogExp2:v&&v.isFogExp2,flatShading:!!s.flatShading,sizeAttenuation:s.sizeAttenuation,logarithmicDepthBuffer:d,skinning:!0===y.isSkinnedMesh,morphTargets:void 0!==x.morphAttributes.position,morphNormals:void 0!==x.morphAttributes.normal,morphColors:void 0!==x.morphAttributes.color,morphTargetsCount:T,morphTextureStride:N,numDirLights:o.directional.length,numPointLights:o.point.length,numSpotLights:o.spot.length,numRectAreaLights:o.rectArea.length,numHemiLights:o.hemi.length,numDirLightShadows:o.directionalShadowMap.length,numPointLightShadows:o.pointShadowMap.length,numSpotLightShadows:o.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:s.dithering,shadowMapEnabled:e.shadowMap.enabled&&u.length>0,shadowMapType:e.shadowMap.type,toneMapping:s.toneMapped?e.toneMapping:0,physicallyCorrectLights:e.physicallyCorrectLights,premultipliedAlpha:s.premultipliedAlpha,doubleSided:2===s.side,flipSided:1===s.side,useDepthPacking:!!s.depthPacking,depthPacking:s.depthPacking||0,index0AttributeName:s.index0AttributeName,extensionDerivatives:s.extensions&&s.extensions.derivatives,extensionFragDepth:s.extensions&&s.extensions.fragDepth,extensionDrawBuffers:s.extensions&&s.extensions.drawBuffers,extensionShaderTextureLOD:s.extensions&&s.extensions.shaderTextureLOD,rendererExtensionFragDepth:h||r.has("EXT_frag_depth"),rendererExtensionDrawBuffers:h||r.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:h||r.has("EXT_shader_texture_lod"),customProgramCacheKey:s.customProgramCacheKey()}},getProgramCacheKey:function(t){const n=[];if(t.shaderID?n.push(t.shaderID):(n.push(t.customVertexShaderID),n.push(t.customFragmentShaderID)),void 0!==t.defines)for(const e in t.defines)n.push(e),n.push(t.defines[e]);return!1===t.isRawShaderMaterial&&(function(e,t){e.push(t.precision),e.push(t.outputEncoding),e.push(t.envMapMode),e.push(t.envMapCubeUVHeight),e.push(t.combine),e.push(t.vertexUvs),e.push(t.fogExp2),e.push(t.sizeAttenuation),e.push(t.morphTargetsCount),e.push(t.morphAttributeCount),e.push(t.numDirLights),e.push(t.numPointLights),e.push(t.numSpotLights),e.push(t.numHemiLights),e.push(t.numRectAreaLights),e.push(t.numDirLightShadows),e.push(t.numPointLightShadows),e.push(t.numSpotLightShadows),e.push(t.shadowMapType),e.push(t.toneMapping),e.push(t.numClippingPlanes),e.push(t.numClipIntersection),e.push(t.depthPacking)}(n,t),function(e,t){o.disableAll(),t.isWebGL2&&o.enable(0),t.supportsVertexTextures&&o.enable(1),t.instancing&&o.enable(2),t.instancingColor&&o.enable(3),t.map&&o.enable(4),t.matcap&&o.enable(5),t.envMap&&o.enable(6),t.lightMap&&o.enable(7),t.aoMap&&o.enable(8),t.emissiveMap&&o.enable(9),t.bumpMap&&o.enable(10),t.normalMap&&o.enable(11),t.objectSpaceNormalMap&&o.enable(12),t.tangentSpaceNormalMap&&o.enable(13),t.clearcoat&&o.enable(14),t.clearcoatMap&&o.enable(15),t.clearcoatRoughnessMap&&o.enable(16),t.clearcoatNormalMap&&o.enable(17),t.iridescence&&o.enable(18),t.iridescenceMap&&o.enable(19),t.iridescenceThicknessMap&&o.enable(20),t.displacementMap&&o.enable(21),t.specularMap&&o.enable(22),t.roughnessMap&&o.enable(23),t.metalnessMap&&o.enable(24),t.gradientMap&&o.enable(25),t.alphaMap&&o.enable(26),t.alphaTest&&o.enable(27),t.vertexColors&&o.enable(28),t.vertexAlphas&&o.enable(29),t.vertexUvs&&o.enable(30),t.vertexTangents&&o.enable(31),t.uvsVertexOnly&&o.enable(32),t.fog&&o.enable(33),e.push(o.mask),o.disableAll(),t.useFog&&o.enable(0),t.flatShading&&o.enable(1),t.logarithmicDepthBuffer&&o.enable(2),t.skinning&&o.enable(3),t.morphTargets&&o.enable(4),t.morphNormals&&o.enable(5),t.morphColors&&o.enable(6),t.premultipliedAlpha&&o.enable(7),t.shadowMapEnabled&&o.enable(8),t.physicallyCorrectLights&&o.enable(9),t.doubleSided&&o.enable(10),t.flipSided&&o.enable(11),t.useDepthPacking&&o.enable(12),t.dithering&&o.enable(13),t.specularIntensityMap&&o.enable(14),t.specularColorMap&&o.enable(15),t.transmission&&o.enable(16),t.transmissionMap&&o.enable(17),t.thicknessMap&&o.enable(18),t.sheen&&o.enable(19),t.sheenColorMap&&o.enable(20),t.sheenRoughnessMap&&o.enable(21),t.decodeVideoTexture&&o.enable(22),t.opaque&&o.enable(23),e.push(o.mask)}(n,t),n.push(e.outputEncoding)),n.push(t.customProgramCacheKey),n.join()},getUniforms:function(e){const t=m[e.type];let n;if(t){const e=wr[t];n=tr.clone(e.uniforms)}else n=e.uniforms;return n},acquireProgram:function(t,n){let r;for(let e=0,t=u.length;e<t;e++){const t=u[e];if(t.cacheKey===n){r=t,++r.usedTimes;break}}return void 0===r&&(r=new vs(e,n,t,s),u.push(r)),r},releaseProgram:function(e){if(0==--e.usedTimes){const t=u.indexOf(e);u[t]=u[u.length-1],u.pop(),e.destroy()}},releaseShaderCache:function(e){l.remove(e)},programs:u,dispose:function(){l.dispose()}}}function Ss(){let e=new WeakMap;return{get:function(t){let n=e.get(t);return void 0===n&&(n={},e.set(t,n)),n},remove:function(t){e.delete(t)},update:function(t,n,r){e.get(t)[n]=r},dispose:function(){e=new WeakMap}}}function Ms(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id}function Ts(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id}function Es(){const e=[];let t=0;const n=[],r=[],i=[];function s(n,r,i,s,a,o){let l=e[t];return void 0===l?(l={id:n.id,object:n,geometry:r,material:i,groupOrder:s,renderOrder:n.renderOrder,z:a,group:o},e[t]=l):(l.id=n.id,l.object=n,l.geometry=r,l.material=i,l.groupOrder=s,l.renderOrder=n.renderOrder,l.z=a,l.group=o),t++,l}return{opaque:n,transmissive:r,transparent:i,init:function(){t=0,n.length=0,r.length=0,i.length=0},push:function(e,t,a,o,l,c){const u=s(e,t,a,o,l,c);a.transmission>0?r.push(u):!0===a.transparent?i.push(u):n.push(u)},unshift:function(e,t,a,o,l,c){const u=s(e,t,a,o,l,c);a.transmission>0?r.unshift(u):!0===a.transparent?i.unshift(u):n.unshift(u)},finish:function(){for(let n=t,r=e.length;n<r;n++){const t=e[n];if(null===t.id)break;t.id=null,t.object=null,t.geometry=null,t.material=null,t.group=null}},sort:function(e,t){n.length>1&&n.sort(e||Ms),r.length>1&&r.sort(t||Ts),i.length>1&&i.sort(t||Ts)}}}function As(){let e=new WeakMap;return{get:function(t,n){let r;return!1===e.has(t)?(r=new Es,e.set(t,[r])):n>=e.get(t).length?(r=new Es,e.get(t).push(r)):r=e.get(t)[n],r},dispose:function(){e=new WeakMap}}}function Cs(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":n={direction:new tt,color:new We};break;case"SpotLight":n={position:new tt,direction:new tt,color:new We,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new tt,color:new We,distance:0,decay:0};break;case"HemisphereLight":n={direction:new tt,skyColor:new We,groundColor:new We};break;case"RectAreaLight":n={color:new We,position:new tt,halfWidth:new tt,halfHeight:new tt}}return e[t.id]=n,n}}}let Is=0;function Ns(e,t){return(t.castShadow?1:0)-(e.castShadow?1:0)}function ks(e,t){const n=new Cs,r=function(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ae};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ae,shadowCameraNear:1,shadowCameraFar:1e3}}return e[t.id]=n,n}}}(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let e=0;e<9;e++)i.probe.push(new tt);const s=new tt,a=new Rt,o=new Rt;return{setup:function(s,a){let o=0,l=0,c=0;for(let e=0;e<9;e++)i.probe[e].set(0,0,0);let u=0,h=0,d=0,p=0,f=0,m=0,g=0,y=0;s.sort(Ns);const v=!0!==a?Math.PI:1;for(let e=0,t=s.length;e<t;e++){const t=s[e],a=t.color,x=t.intensity,b=t.distance,w=t.shadow&&t.shadow.map?t.shadow.map.texture:null;if(t.isAmbientLight)o+=a.r*x*v,l+=a.g*x*v,c+=a.b*x*v;else if(t.isLightProbe)for(let e=0;e<9;e++)i.probe[e].addScaledVector(t.sh.coefficients[e],x);else if(t.isDirectionalLight){const e=n.get(t);if(e.color.copy(t.color).multiplyScalar(t.intensity*v),t.castShadow){const e=t.shadow,n=r.get(t);n.shadowBias=e.bias,n.shadowNormalBias=e.normalBias,n.shadowRadius=e.radius,n.shadowMapSize=e.mapSize,i.directionalShadow[u]=n,i.directionalShadowMap[u]=w,i.directionalShadowMatrix[u]=t.shadow.matrix,m++}i.directional[u]=e,u++}else if(t.isSpotLight){const e=n.get(t);if(e.position.setFromMatrixPosition(t.matrixWorld),e.color.copy(a).multiplyScalar(x*v),e.distance=b,e.coneCos=Math.cos(t.angle),e.penumbraCos=Math.cos(t.angle*(1-t.penumbra)),e.decay=t.decay,t.castShadow){const e=t.shadow,n=r.get(t);n.shadowBias=e.bias,n.shadowNormalBias=e.normalBias,n.shadowRadius=e.radius,n.shadowMapSize=e.mapSize,i.spotShadow[d]=n,i.spotShadowMap[d]=w,i.spotShadowMatrix[d]=t.shadow.matrix,y++}i.spot[d]=e,d++}else if(t.isRectAreaLight){const e=n.get(t);e.color.copy(a).multiplyScalar(x),e.halfWidth.set(.5*t.width,0,0),e.halfHeight.set(0,.5*t.height,0),i.rectArea[p]=e,p++}else if(t.isPointLight){const e=n.get(t);if(e.color.copy(t.color).multiplyScalar(t.intensity*v),e.distance=t.distance,e.decay=t.decay,t.castShadow){const e=t.shadow,n=r.get(t);n.shadowBias=e.bias,n.shadowNormalBias=e.normalBias,n.shadowRadius=e.radius,n.shadowMapSize=e.mapSize,n.shadowCameraNear=e.camera.near,n.shadowCameraFar=e.camera.far,i.pointShadow[h]=n,i.pointShadowMap[h]=w,i.pointShadowMatrix[h]=t.shadow.matrix,g++}i.point[h]=e,h++}else if(t.isHemisphereLight){const e=n.get(t);e.skyColor.copy(t.color).multiplyScalar(x*v),e.groundColor.copy(t.groundColor).multiplyScalar(x*v),i.hemi[f]=e,f++}}p>0&&(t.isWebGL2||!0===e.has("OES_texture_float_linear")?(i.rectAreaLTC1=br.LTC_FLOAT_1,i.rectAreaLTC2=br.LTC_FLOAT_2):!0===e.has("OES_texture_half_float_linear")?(i.rectAreaLTC1=br.LTC_HALF_1,i.rectAreaLTC2=br.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=o,i.ambient[1]=l,i.ambient[2]=c;const x=i.hash;x.directionalLength===u&&x.pointLength===h&&x.spotLength===d&&x.rectAreaLength===p&&x.hemiLength===f&&x.numDirectionalShadows===m&&x.numPointShadows===g&&x.numSpotShadows===y||(i.directional.length=u,i.spot.length=d,i.rectArea.length=p,i.point.length=h,i.hemi.length=f,i.directionalShadow.length=m,i.directionalShadowMap.length=m,i.pointShadow.length=g,i.pointShadowMap.length=g,i.spotShadow.length=y,i.spotShadowMap.length=y,i.directionalShadowMatrix.length=m,i.pointShadowMatrix.length=g,i.spotShadowMatrix.length=y,x.directionalLength=u,x.pointLength=h,x.spotLength=d,x.rectAreaLength=p,x.hemiLength=f,x.numDirectionalShadows=m,x.numPointShadows=g,x.numSpotShadows=y,i.version=Is++)},setupView:function(e,t){let n=0,r=0,l=0,c=0,u=0;const h=t.matrixWorldInverse;for(let t=0,d=e.length;t<d;t++){const d=e[t];if(d.isDirectionalLight){const e=i.directional[n];e.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),e.direction.sub(s),e.direction.transformDirection(h),n++}else if(d.isSpotLight){const e=i.spot[l];e.position.setFromMatrixPosition(d.matrixWorld),e.position.applyMatrix4(h),e.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),e.direction.sub(s),e.direction.transformDirection(h),l++}else if(d.isRectAreaLight){const e=i.rectArea[c];e.position.setFromMatrixPosition(d.matrixWorld),e.position.applyMatrix4(h),o.identity(),a.copy(d.matrixWorld),a.premultiply(h),o.extractRotation(a),e.halfWidth.set(.5*d.width,0,0),e.halfHeight.set(0,.5*d.height,0),e.halfWidth.applyMatrix4(o),e.halfHeight.applyMatrix4(o),c++}else if(d.isPointLight){const e=i.point[r];e.position.setFromMatrixPosition(d.matrixWorld),e.position.applyMatrix4(h),r++}else if(d.isHemisphereLight){const e=i.hemi[u];e.direction.setFromMatrixPosition(d.matrixWorld),e.direction.transformDirection(h),u++}}},state:i}}function Rs(e,t){const n=new ks(e,t),r=[],i=[];return{init:function(){r.length=0,i.length=0},state:{lightsArray:r,shadowsArray:i,lights:n},setupLights:function(e){n.setup(r,e)},setupLightsView:function(e){n.setupView(r,e)},pushLight:function(e){r.push(e)},pushShadow:function(e){i.push(e)}}}function Ds(e,t){let n=new WeakMap;return{get:function(r,i=0){let s;return!1===n.has(r)?(s=new Rs(e,t),n.set(r,[s])):i>=n.get(r).length?(s=new Rs(e,t),n.get(r).push(s)):s=n.get(r)[i],s},dispose:function(){n=new WeakMap}}}class Ls extends yn{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class Fs extends yn{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.referencePosition=new tt,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}function Ps(e,t,n){let r=new mr;const i=new Ae,s=new Ae,a=new Ke,o=new Ls({depthPacking:3201}),l=new Fs,c={},u=n.maxTextureSize,h={0:1,1:0,2:2},d=new nr({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Ae},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),f=d.clone();f.defines.HORIZONTAL_PASS=1;const m=new Rn;m.setAttribute("position",new wn(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const g=new Kn(m,d),y=this;function v(n,r){const i=t.update(g);d.defines.VSM_SAMPLES!==n.blurSamples&&(d.defines.VSM_SAMPLES=n.blurSamples,f.defines.VSM_SAMPLES=n.blurSamples,d.needsUpdate=!0,f.needsUpdate=!0),d.uniforms.shadow_pass.value=n.map.texture,d.uniforms.resolution.value=n.mapSize,d.uniforms.radius.value=n.radius,e.setRenderTarget(n.mapPass),e.clear(),e.renderBufferDirect(r,null,i,d,g,null),f.uniforms.shadow_pass.value=n.mapPass.texture,f.uniforms.resolution.value=n.mapSize,f.uniforms.radius.value=n.radius,e.setRenderTarget(n.map),e.clear(),e.renderBufferDirect(r,null,i,f,g,null)}function x(t,n,r,i,s,a){let u=null;const d=!0===r.isPointLight?t.customDistanceMaterial:t.customDepthMaterial;if(u=void 0!==d?d:!0===r.isPointLight?l:o,e.localClippingEnabled&&!0===n.clipShadows&&0!==n.clippingPlanes.length||n.displacementMap&&0!==n.displacementScale||n.alphaMap&&n.alphaTest>0){const e=u.uuid,t=n.uuid;let r=c[e];void 0===r&&(r={},c[e]=r);let i=r[t];void 0===i&&(i=u.clone(),r[t]=i),u=i}return u.visible=n.visible,u.wireframe=n.wireframe,u.side=3===a?null!==n.shadowSide?n.shadowSide:n.side:null!==n.shadowSide?n.shadowSide:h[n.side],u.alphaMap=n.alphaMap,u.alphaTest=n.alphaTest,u.clipShadows=n.clipShadows,u.clippingPlanes=n.clippingPlanes,u.clipIntersection=n.clipIntersection,u.displacementMap=n.displacementMap,u.displacementScale=n.displacementScale,u.displacementBias=n.displacementBias,u.wireframeLinewidth=n.wireframeLinewidth,u.linewidth=n.linewidth,!0===r.isPointLight&&!0===u.isMeshDistanceMaterial&&(u.referencePosition.setFromMatrixPosition(r.matrixWorld),u.nearDistance=i,u.farDistance=s),u}function b(n,i,s,a,o){if(!1===n.visible)return;if(n.layers.test(i.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&3===o)&&(!n.frustumCulled||r.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,n.matrixWorld);const r=t.update(n),i=n.material;if(Array.isArray(i)){const t=r.groups;for(let l=0,c=t.length;l<c;l++){const c=t[l],u=i[c.materialIndex];if(u&&u.visible){const t=x(n,u,a,s.near,s.far,o);e.renderBufferDirect(s,null,r,t,n,c)}}}else if(i.visible){const t=x(n,i,a,s.near,s.far,o);e.renderBufferDirect(s,null,r,t,n,null)}}const l=n.children;for(let e=0,t=l.length;e<t;e++)b(l[e],i,s,a,o)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(t,n,o){if(!1===y.enabled)return;if(!1===y.autoUpdate&&!1===y.needsUpdate)return;if(0===t.length)return;const l=e.getRenderTarget(),c=e.getActiveCubeFace(),h=e.getActiveMipmapLevel(),d=e.state;d.setBlending(0),d.buffers.color.setClear(1,1,1,1),d.buffers.depth.setTest(!0),d.setScissorTest(!1);for(let l=0,c=t.length;l<c;l++){const c=t[l],h=c.shadow;if(void 0===h){console.warn("THREE.WebGLShadowMap:",c,"has no shadow.");continue}if(!1===h.autoUpdate&&!1===h.needsUpdate)continue;i.copy(h.mapSize);const f=h.getFrameExtents();if(i.multiply(f),s.copy(h.mapSize),(i.x>u||i.y>u)&&(i.x>u&&(s.x=Math.floor(u/f.x),i.x=s.x*f.x,h.mapSize.x=s.x),i.y>u&&(s.y=Math.floor(u/f.y),i.y=s.y*f.y,h.mapSize.y=s.y)),null!==h.map||h.isPointLightShadow||3!==this.type||(h.map=new Ze(i.x,i.y),h.map.texture.name=c.name+".shadowMap",h.mapPass=new Ze(i.x,i.y),h.camera.updateProjectionMatrix()),null===h.map){const e={minFilter:p,magFilter:p,format:T};h.map=new Ze(i.x,i.y,e),h.map.texture.name=c.name+".shadowMap",h.camera.updateProjectionMatrix()}e.setRenderTarget(h.map),e.clear();const m=h.getViewportCount();for(let e=0;e<m;e++){const t=h.getViewport(e);a.set(s.x*t.x,s.y*t.y,s.x*t.z,s.y*t.w),d.viewport(a),h.updateMatrices(c,e),r=h.getFrustum(),b(n,o,h.camera,c,this.type)}h.isPointLightShadow||3!==this.type||v(h,o),h.needsUpdate=!1}y.needsUpdate=!1,e.setRenderTarget(l,c,h)}}function Os(e,t,n){const i=n.isWebGL2,s=new function(){let t=!1;const n=new Ke;let r=null;const i=new Ke(0,0,0,0);return{setMask:function(n){r===n||t||(e.colorMask(n,n,n,n),r=n)},setLocked:function(e){t=e},setClear:function(t,r,s,a,o){!0===o&&(t*=a,r*=a,s*=a),n.set(t,r,s,a),!1===i.equals(n)&&(e.clearColor(t,r,s,a),i.copy(n))},reset:function(){t=!1,r=null,i.set(-1,0,0,0)}}},a=new function(){let t=!1,n=null,r=null,i=null;return{setTest:function(t){t?B(e.DEPTH_TEST):U(e.DEPTH_TEST)},setMask:function(r){n===r||t||(e.depthMask(r),n=r)},setFunc:function(t){if(r!==t){if(t)switch(t){case 0:e.depthFunc(e.NEVER);break;case 1:e.depthFunc(e.ALWAYS);break;case 2:e.depthFunc(e.LESS);break;case 3:default:e.depthFunc(e.LEQUAL);break;case 4:e.depthFunc(e.EQUAL);break;case 5:e.depthFunc(e.GEQUAL);break;case 6:e.depthFunc(e.GREATER);break;case 7:e.depthFunc(e.NOTEQUAL)}else e.depthFunc(e.LEQUAL);r=t}},setLocked:function(e){t=e},setClear:function(t){i!==t&&(e.clearDepth(t),i=t)},reset:function(){t=!1,n=null,r=null,i=null}}},o=new function(){let t=!1,n=null,r=null,i=null,s=null,a=null,o=null,l=null,c=null;return{setTest:function(n){t||(n?B(e.STENCIL_TEST):U(e.STENCIL_TEST))},setMask:function(r){n===r||t||(e.stencilMask(r),n=r)},setFunc:function(t,n,a){r===t&&i===n&&s===a||(e.stencilFunc(t,n,a),r=t,i=n,s=a)},setOp:function(t,n,r){a===t&&o===n&&l===r||(e.stencilOp(t,n,r),a=t,o=n,l=r)},setLocked:function(e){t=e},setClear:function(t){c!==t&&(e.clearStencil(t),c=t)},reset:function(){t=!1,n=null,r=null,i=null,s=null,a=null,o=null,l=null,c=null}}};let l={},c={},u=new WeakMap,h=[],d=null,p=!1,f=null,m=null,g=null,y=null,v=null,x=null,b=null,w=!1,_=null,S=null,M=null,T=null,E=null;const A=e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let C=!1,I=0;const N=e.getParameter(e.VERSION);-1!==N.indexOf("WebGL")?(I=parseFloat(/^WebGL (\d)/.exec(N)[1]),C=I>=1):-1!==N.indexOf("OpenGL ES")&&(I=parseFloat(/^OpenGL ES (\d)/.exec(N)[1]),C=I>=2);let k=null,R={};const D=e.getParameter(e.SCISSOR_BOX),L=e.getParameter(e.VIEWPORT),F=(new Ke).fromArray(D),P=(new Ke).fromArray(L);function O(t,n,r){const i=new Uint8Array(4),s=e.createTexture();e.bindTexture(t,s),e.texParameteri(t,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(t,e.TEXTURE_MAG_FILTER,e.NEAREST);for(let t=0;t<r;t++)e.texImage2D(n+t,0,e.RGBA,1,1,0,e.RGBA,e.UNSIGNED_BYTE,i);return s}const z={};function B(t){!0!==l[t]&&(e.enable(t),l[t]=!0)}function U(t){!1!==l[t]&&(e.disable(t),l[t]=!1)}z[e.TEXTURE_2D]=O(e.TEXTURE_2D,e.TEXTURE_2D,1),z[e.TEXTURE_CUBE_MAP]=O(e.TEXTURE_CUBE_MAP,e.TEXTURE_CUBE_MAP_POSITIVE_X,6),s.setClear(0,0,0,1),a.setClear(1),o.setClear(0),B(e.DEPTH_TEST),a.setFunc(3),G(!1),H(1),B(e.CULL_FACE),W(0);const $={[r]:e.FUNC_ADD,101:e.FUNC_SUBTRACT,102:e.FUNC_REVERSE_SUBTRACT};if(i)$[103]=e.MIN,$[104]=e.MAX;else{const e=t.get("EXT_blend_minmax");null!==e&&($[103]=e.MIN_EXT,$[104]=e.MAX_EXT)}const V={200:e.ZERO,201:e.ONE,202:e.SRC_COLOR,204:e.SRC_ALPHA,210:e.SRC_ALPHA_SATURATE,208:e.DST_COLOR,206:e.DST_ALPHA,203:e.ONE_MINUS_SRC_COLOR,205:e.ONE_MINUS_SRC_ALPHA,209:e.ONE_MINUS_DST_COLOR,207:e.ONE_MINUS_DST_ALPHA};function W(t,n,i,s,a,o,l,c){if(0!==t){if(!1===p&&(B(e.BLEND),p=!0),5===t)a=a||n,o=o||i,l=l||s,n===m&&a===v||(e.blendEquationSeparate($[n],$[a]),m=n,v=a),i===g&&s===y&&o===x&&l===b||(e.blendFuncSeparate(V[i],V[s],V[o],V[l]),g=i,y=s,x=o,b=l),f=t,w=null;else if(t!==f||c!==w){if(m===r&&v===r||(e.blendEquation(e.FUNC_ADD),m=r,v=r),c)switch(t){case 1:e.blendFuncSeparate(e.ONE,e.ONE_MINUS_SRC_ALPHA,e.ONE,e.ONE_MINUS_SRC_ALPHA);break;case 2:e.blendFunc(e.ONE,e.ONE);break;case 3:e.blendFuncSeparate(e.ZERO,e.ONE_MINUS_SRC_COLOR,e.ZERO,e.ONE);break;case 4:e.blendFuncSeparate(e.ZERO,e.SRC_COLOR,e.ZERO,e.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}else switch(t){case 1:e.blendFuncSeparate(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA,e.ONE,e.ONE_MINUS_SRC_ALPHA);break;case 2:e.blendFunc(e.SRC_ALPHA,e.ONE);break;case 3:e.blendFuncSeparate(e.ZERO,e.ONE_MINUS_SRC_COLOR,e.ZERO,e.ONE);break;case 4:e.blendFunc(e.ZERO,e.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}g=null,y=null,x=null,b=null,f=t,w=c}}else!0===p&&(U(e.BLEND),p=!1)}function G(t){_!==t&&(t?e.frontFace(e.CW):e.frontFace(e.CCW),_=t)}function H(t){0!==t?(B(e.CULL_FACE),t!==S&&(1===t?e.cullFace(e.BACK):2===t?e.cullFace(e.FRONT):e.cullFace(e.FRONT_AND_BACK))):U(e.CULL_FACE),S=t}function j(t,n,r){t?(B(e.POLYGON_OFFSET_FILL),T===n&&E===r||(e.polygonOffset(n,r),T=n,E=r)):U(e.POLYGON_OFFSET_FILL)}function q(t){void 0===t&&(t=e.TEXTURE0+A-1),k!==t&&(e.activeTexture(t),k=t)}return{buffers:{color:s,depth:a,stencil:o},enable:B,disable:U,bindFramebuffer:function(t,n){return c[t]!==n&&(e.bindFramebuffer(t,n),c[t]=n,i&&(t===e.DRAW_FRAMEBUFFER&&(c[e.FRAMEBUFFER]=n),t===e.FRAMEBUFFER&&(c[e.DRAW_FRAMEBUFFER]=n)),!0)},drawBuffers:function(r,i){let s=h,a=!1;if(r)if(s=u.get(i),void 0===s&&(s=[],u.set(i,s)),r.isWebGLMultipleRenderTargets){const t=r.texture;if(s.length!==t.length||s[0]!==e.COLOR_ATTACHMENT0){for(let n=0,r=t.length;n<r;n++)s[n]=e.COLOR_ATTACHMENT0+n;s.length=t.length,a=!0}}else s[0]!==e.COLOR_ATTACHMENT0&&(s[0]=e.COLOR_ATTACHMENT0,a=!0);else s[0]!==e.BACK&&(s[0]=e.BACK,a=!0);a&&(n.isWebGL2?e.drawBuffers(s):t.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))},useProgram:function(t){return d!==t&&(e.useProgram(t),d=t,!0)},setBlending:W,setMaterial:function(t,n){2===t.side?U(e.CULL_FACE):B(e.CULL_FACE);let r=1===t.side;n&&(r=!r),G(r),1===t.blending&&!1===t.transparent?W(0):W(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.premultipliedAlpha),a.setFunc(t.depthFunc),a.setTest(t.depthTest),a.setMask(t.depthWrite),s.setMask(t.colorWrite);const i=t.stencilWrite;o.setTest(i),i&&(o.setMask(t.stencilWriteMask),o.setFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask),o.setOp(t.stencilFail,t.stencilZFail,t.stencilZPass)),j(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits),!0===t.alphaToCoverage?B(e.SAMPLE_ALPHA_TO_COVERAGE):U(e.SAMPLE_ALPHA_TO_COVERAGE)},setFlipSided:G,setCullFace:H,setLineWidth:function(t){t!==M&&(C&&e.lineWidth(t),M=t)},setPolygonOffset:j,setScissorTest:function(t){t?B(e.SCISSOR_TEST):U(e.SCISSOR_TEST)},activeTexture:q,bindTexture:function(t,n){null===k&&q();let r=R[k];void 0===r&&(r={type:void 0,texture:void 0},R[k]=r),r.type===t&&r.texture===n||(e.bindTexture(t,n||z[t]),r.type=t,r.texture=n)},unbindTexture:function(){const t=R[k];void 0!==t&&void 0!==t.type&&(e.bindTexture(t.type,null),t.type=void 0,t.texture=void 0)},compressedTexImage2D:function(){try{e.compressedTexImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage2D:function(){try{e.texImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage3D:function(){try{e.texImage3D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texStorage2D:function(){try{e.texStorage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texStorage3D:function(){try{e.texStorage3D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texSubImage2D:function(){try{e.texSubImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texSubImage3D:function(){try{e.texSubImage3D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},compressedTexSubImage2D:function(){try{e.compressedTexSubImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},scissor:function(t){!1===F.equals(t)&&(e.scissor(t.x,t.y,t.z,t.w),F.copy(t))},viewport:function(t){!1===P.equals(t)&&(e.viewport(t.x,t.y,t.z,t.w),P.copy(t))},reset:function(){e.disable(e.BLEND),e.disable(e.CULL_FACE),e.disable(e.DEPTH_TEST),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SCISSOR_TEST),e.disable(e.STENCIL_TEST),e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),e.blendEquation(e.FUNC_ADD),e.blendFunc(e.ONE,e.ZERO),e.blendFuncSeparate(e.ONE,e.ZERO,e.ONE,e.ZERO),e.colorMask(!0,!0,!0,!0),e.clearColor(0,0,0,0),e.depthMask(!0),e.depthFunc(e.LESS),e.clearDepth(1),e.stencilMask(4294967295),e.stencilFunc(e.ALWAYS,0,4294967295),e.stencilOp(e.KEEP,e.KEEP,e.KEEP),e.clearStencil(0),e.cullFace(e.BACK),e.frontFace(e.CCW),e.polygonOffset(0,0),e.activeTexture(e.TEXTURE0),e.bindFramebuffer(e.FRAMEBUFFER,null),!0===i&&(e.bindFramebuffer(e.DRAW_FRAMEBUFFER,null),e.bindFramebuffer(e.READ_FRAMEBUFFER,null)),e.useProgram(null),e.lineWidth(1),e.scissor(0,0,e.canvas.width,e.canvas.height),e.viewport(0,0,e.canvas.width,e.canvas.height),l={},k=null,R={},c={},u=new WeakMap,h=[],d=null,p=!1,f=null,m=null,g=null,y=null,v=null,x=null,b=null,w=!1,_=null,S=null,M=null,T=null,E=null,F.set(0,0,e.canvas.width,e.canvas.height),P.set(0,0,e.canvas.width,e.canvas.height),s.reset(),a.reset(),o.reset()}}}function zs(e,t,n,r,i,s,a){const o=i.isWebGL2,l=i.maxTextures,c=i.maxCubemapSize,C=i.maxTextureSize,I=i.maxSamples,N=t.has("WEBGL_multisampled_render_to_texture")?t.get("WEBGL_multisampled_render_to_texture"):null,k=/OculusBrowser/g.test(navigator.userAgent),R=new WeakMap;let D;const L=new WeakMap;let F=!1;try{F="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(e){}function P(e,t){return F?new OffscreenCanvas(e,t):Re("canvas")}function O(e,t,n,r){let i=1;if((e.width>r||e.height>r)&&(i=r/Math.max(e.width,e.height)),i<1||!0===t){if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap){const r=t?Te:Math.floor,s=r(i*e.width),a=r(i*e.height);void 0===D&&(D=P(s,a));const o=n?P(s,a):D;return o.width=s,o.height=a,o.getContext("2d").drawImage(e,0,0,s,a),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+e.width+"x"+e.height+") to ("+s+"x"+a+")."),o}return"data"in e&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+e.width+"x"+e.height+")."),e}return e}function z(e){return Se(e.width)&&Se(e.height)}function B(e,t){return e.generateMipmaps&&t&&e.minFilter!==p&&e.minFilter!==g}function U(t){e.generateMipmap(t)}function $(n,r,i,s,a=!1){if(!1===o)return r;if(null!==n){if(void 0!==e[n])return e[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let l=r;return r===e.RED&&(i===e.FLOAT&&(l=e.R32F),i===e.HALF_FLOAT&&(l=e.R16F),i===e.UNSIGNED_BYTE&&(l=e.R8)),r===e.RG&&(i===e.FLOAT&&(l=e.RG32F),i===e.HALF_FLOAT&&(l=e.RG16F),i===e.UNSIGNED_BYTE&&(l=e.RG8)),r===e.RGBA&&(i===e.FLOAT&&(l=e.RGBA32F),i===e.HALF_FLOAT&&(l=e.RGBA16F),i===e.UNSIGNED_BYTE&&(l=s===oe&&!1===a?e.SRGB8_ALPHA8:e.RGBA8),i===e.UNSIGNED_SHORT_4_4_4_4&&(l=e.RGBA4),i===e.UNSIGNED_SHORT_5_5_5_1&&(l=e.RGB5_A1)),l!==e.R16F&&l!==e.R32F&&l!==e.RG16F&&l!==e.RG32F&&l!==e.RGBA16F&&l!==e.RGBA32F||t.get("EXT_color_buffer_float"),l}function V(e,t,n){return!0===B(e,n)||e.isFramebufferTexture&&e.minFilter!==p&&e.minFilter!==g?Math.log2(Math.max(t.width,t.height))+1:void 0!==e.mipmaps&&e.mipmaps.length>0?e.mipmaps.length:e.isCompressedTexture&&Array.isArray(e.image)?t.mipmaps.length:1}function W(t){return t===p||t===f||t===m?e.NEAREST:e.LINEAR}function G(e){const t=e.target;t.removeEventListener("dispose",G),function(e){const t=r.get(e);if(void 0===t.__webglInit)return;const n=e.source,i=L.get(n);if(i){const r=i[t.__cacheKey];r.usedTimes--,0===r.usedTimes&&j(e),0===Object.keys(i).length&&L.delete(n)}r.remove(e)}(t),t.isVideoTexture&&R.delete(t)}function H(t){const n=t.target;n.removeEventListener("dispose",H),function(t){const n=t.texture,i=r.get(t),s=r.get(n);if(void 0!==s.__webglTexture&&(e.deleteTexture(s.__webglTexture),a.memory.textures--),t.depthTexture&&t.depthTexture.dispose(),t.isWebGLCubeRenderTarget)for(let t=0;t<6;t++)e.deleteFramebuffer(i.__webglFramebuffer[t]),i.__webglDepthbuffer&&e.deleteRenderbuffer(i.__webglDepthbuffer[t]);else{if(e.deleteFramebuffer(i.__webglFramebuffer),i.__webglDepthbuffer&&e.deleteRenderbuffer(i.__webglDepthbuffer),i.__webglMultisampledFramebuffer&&e.deleteFramebuffer(i.__webglMultisampledFramebuffer),i.__webglColorRenderbuffer)for(let t=0;t<i.__webglColorRenderbuffer.length;t++)i.__webglColorRenderbuffer[t]&&e.deleteRenderbuffer(i.__webglColorRenderbuffer[t]);i.__webglDepthRenderbuffer&&e.deleteRenderbuffer(i.__webglDepthRenderbuffer)}if(t.isWebGLMultipleRenderTargets)for(let t=0,i=n.length;t<i;t++){const i=r.get(n[t]);i.__webglTexture&&(e.deleteTexture(i.__webglTexture),a.memory.textures--),r.remove(n[t])}r.remove(n),r.remove(t)}(n)}function j(t){const n=r.get(t);e.deleteTexture(n.__webglTexture);const i=t.source;delete L.get(i)[n.__cacheKey],a.memory.textures--}let q=0;function X(t,i){const s=r.get(t);if(t.isVideoTexture&&function(e){const t=a.render.frame;R.get(e)!==t&&(R.set(e,t),e.update())}(t),!1===t.isRenderTargetTexture&&t.version>0&&s.__version!==t.version){const e=t.image;if(null===e)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else{if(!1!==e.complete)return void Q(s,t,i);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(e.TEXTURE0+i),n.bindTexture(e.TEXTURE_2D,s.__webglTexture)}const Y={[u]:e.REPEAT,[h]:e.CLAMP_TO_EDGE,[d]:e.MIRRORED_REPEAT},K={[p]:e.NEAREST,[f]:e.NEAREST_MIPMAP_NEAREST,[m]:e.NEAREST_MIPMAP_LINEAR,[g]:e.LINEAR,[y]:e.LINEAR_MIPMAP_NEAREST,[v]:e.LINEAR_MIPMAP_LINEAR};function Z(n,s,a){if(a?(e.texParameteri(n,e.TEXTURE_WRAP_S,Y[s.wrapS]),e.texParameteri(n,e.TEXTURE_WRAP_T,Y[s.wrapT]),n!==e.TEXTURE_3D&&n!==e.TEXTURE_2D_ARRAY||e.texParameteri(n,e.TEXTURE_WRAP_R,Y[s.wrapR]),e.texParameteri(n,e.TEXTURE_MAG_FILTER,K[s.magFilter]),e.texParameteri(n,e.TEXTURE_MIN_FILTER,K[s.minFilter])):(e.texParameteri(n,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(n,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),n!==e.TEXTURE_3D&&n!==e.TEXTURE_2D_ARRAY||e.texParameteri(n,e.TEXTURE_WRAP_R,e.CLAMP_TO_EDGE),s.wrapS===h&&s.wrapT===h||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),e.texParameteri(n,e.TEXTURE_MAG_FILTER,W(s.magFilter)),e.texParameteri(n,e.TEXTURE_MIN_FILTER,W(s.minFilter)),s.minFilter!==p&&s.minFilter!==g&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===t.has("EXT_texture_filter_anisotropic")){const a=t.get("EXT_texture_filter_anisotropic");if(s.type===_&&!1===t.has("OES_texture_float_linear"))return;if(!1===o&&s.type===S&&!1===t.has("OES_texture_half_float_linear"))return;(s.anisotropy>1||r.get(s).__currentAnisotropy)&&(e.texParameterf(n,a.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(s.anisotropy,i.getMaxAnisotropy())),r.get(s).__currentAnisotropy=s.anisotropy)}}function J(t,n){let r=!1;void 0===t.__webglInit&&(t.__webglInit=!0,n.addEventListener("dispose",G));const i=n.source;let s=L.get(i);void 0===s&&(s={},L.set(i,s));const o=function(e){const t=[];return t.push(e.wrapS),t.push(e.wrapT),t.push(e.magFilter),t.push(e.minFilter),t.push(e.anisotropy),t.push(e.internalFormat),t.push(e.format),t.push(e.type),t.push(e.generateMipmaps),t.push(e.premultiplyAlpha),t.push(e.flipY),t.push(e.unpackAlignment),t.push(e.encoding),t.join()}(n);if(o!==t.__cacheKey){void 0===s[o]&&(s[o]={texture:e.createTexture(),usedTimes:0},a.memory.textures++,r=!0),s[o].usedTimes++;const i=s[t.__cacheKey];void 0!==i&&(s[t.__cacheKey].usedTimes--,0===i.usedTimes&&j(n)),t.__cacheKey=o,t.__webglTexture=s[o].texture}return r}function Q(t,r,i){let a=e.TEXTURE_2D;r.isDataArrayTexture&&(a=e.TEXTURE_2D_ARRAY),r.isData3DTexture&&(a=e.TEXTURE_3D);const l=J(t,r),c=r.source;if(n.activeTexture(e.TEXTURE0+i),n.bindTexture(a,t.__webglTexture),c.version!==c.__currentVersion||!0===l){e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,r.flipY),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r.premultiplyAlpha),e.pixelStorei(e.UNPACK_ALIGNMENT,r.unpackAlignment),e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL,e.NONE);const t=function(e){return!o&&(e.wrapS!==h||e.wrapT!==h||e.minFilter!==p&&e.minFilter!==g)}(r)&&!1===z(r.image);let i=O(r.image,t,!1,C);i=se(r,i);const u=z(i)||o,d=s.convert(r.format,r.encoding);let f,m=s.convert(r.type),y=$(r.internalFormat,d,m,r.encoding,r.isVideoTexture);Z(a,r,u);const v=r.mipmaps,x=o&&!0!==r.isVideoTexture,S=void 0===c.__currentVersion||!0===l,I=V(r,i,u);if(r.isDepthTexture)y=e.DEPTH_COMPONENT,o?y=r.type===_?e.DEPTH_COMPONENT32F:r.type===w?e.DEPTH_COMPONENT24:r.type===M?e.DEPTH24_STENCIL8:e.DEPTH_COMPONENT16:r.type===_&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),r.format===E&&y===e.DEPTH_COMPONENT&&r.type!==b&&r.type!==w&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),r.type=w,m=s.convert(r.type)),r.format===A&&y===e.DEPTH_COMPONENT&&(y=e.DEPTH_STENCIL,r.type!==M&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),r.type=M,m=s.convert(r.type))),S&&(x?n.texStorage2D(e.TEXTURE_2D,1,y,i.width,i.height):n.texImage2D(e.TEXTURE_2D,0,y,i.width,i.height,0,d,m,null));else if(r.isDataTexture)if(v.length>0&&u){x&&S&&n.texStorage2D(e.TEXTURE_2D,I,y,v[0].width,v[0].height);for(let t=0,r=v.length;t<r;t++)f=v[t],x?n.texSubImage2D(e.TEXTURE_2D,t,0,0,f.width,f.height,d,m,f.data):n.texImage2D(e.TEXTURE_2D,t,y,f.width,f.height,0,d,m,f.data);r.generateMipmaps=!1}else x?(S&&n.texStorage2D(e.TEXTURE_2D,I,y,i.width,i.height),n.texSubImage2D(e.TEXTURE_2D,0,0,0,i.width,i.height,d,m,i.data)):n.texImage2D(e.TEXTURE_2D,0,y,i.width,i.height,0,d,m,i.data);else if(r.isCompressedTexture){x&&S&&n.texStorage2D(e.TEXTURE_2D,I,y,v[0].width,v[0].height);for(let t=0,i=v.length;t<i;t++)f=v[t],r.format!==T?null!==d?x?n.compressedTexSubImage2D(e.TEXTURE_2D,t,0,0,f.width,f.height,d,f.data):n.compressedTexImage2D(e.TEXTURE_2D,t,y,f.width,f.height,0,f.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):x?n.texSubImage2D(e.TEXTURE_2D,t,0,0,f.width,f.height,d,m,f.data):n.texImage2D(e.TEXTURE_2D,t,y,f.width,f.height,0,d,m,f.data)}else if(r.isDataArrayTexture)x?(S&&n.texStorage3D(e.TEXTURE_2D_ARRAY,I,y,i.width,i.height,i.depth),n.texSubImage3D(e.TEXTURE_2D_ARRAY,0,0,0,0,i.width,i.height,i.depth,d,m,i.data)):n.texImage3D(e.TEXTURE_2D_ARRAY,0,y,i.width,i.height,i.depth,0,d,m,i.data);else if(r.isData3DTexture)x?(S&&n.texStorage3D(e.TEXTURE_3D,I,y,i.width,i.height,i.depth),n.texSubImage3D(e.TEXTURE_3D,0,0,0,0,i.width,i.height,i.depth,d,m,i.data)):n.texImage3D(e.TEXTURE_3D,0,y,i.width,i.height,i.depth,0,d,m,i.data);else if(r.isFramebufferTexture){if(S)if(x)n.texStorage2D(e.TEXTURE_2D,I,y,i.width,i.height);else{let t=i.width,r=i.height;for(let i=0;i<I;i++)n.texImage2D(e.TEXTURE_2D,i,y,t,r,0,d,m,null),t>>=1,r>>=1}}else if(v.length>0&&u){x&&S&&n.texStorage2D(e.TEXTURE_2D,I,y,v[0].width,v[0].height);for(let t=0,r=v.length;t<r;t++)f=v[t],x?n.texSubImage2D(e.TEXTURE_2D,t,0,0,d,m,f):n.texImage2D(e.TEXTURE_2D,t,y,d,m,f);r.generateMipmaps=!1}else x?(S&&n.texStorage2D(e.TEXTURE_2D,I,y,i.width,i.height),n.texSubImage2D(e.TEXTURE_2D,0,0,0,d,m,i)):n.texImage2D(e.TEXTURE_2D,0,y,d,m,i);B(r,u)&&U(a),c.__currentVersion=c.version,r.onUpdate&&r.onUpdate(r)}t.__version=r.version}function ee(t,i,a,o,l){const c=s.convert(a.format,a.encoding),u=s.convert(a.type),h=$(a.internalFormat,c,u,a.encoding);r.get(i).__hasExternalTextures||(l===e.TEXTURE_3D||l===e.TEXTURE_2D_ARRAY?n.texImage3D(l,0,h,i.width,i.height,i.depth,0,c,u,null):n.texImage2D(l,0,h,i.width,i.height,0,c,u,null)),n.bindFramebuffer(e.FRAMEBUFFER,t),ie(i)?N.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER,o,l,r.get(a).__webglTexture,0,re(i)):e.framebufferTexture2D(e.FRAMEBUFFER,o,l,r.get(a).__webglTexture,0),n.bindFramebuffer(e.FRAMEBUFFER,null)}function te(t,n,r){if(e.bindRenderbuffer(e.RENDERBUFFER,t),n.depthBuffer&&!n.stencilBuffer){let i=e.DEPTH_COMPONENT16;if(r||ie(n)){const t=n.depthTexture;t&&t.isDepthTexture&&(t.type===_?i=e.DEPTH_COMPONENT32F:t.type===w&&(i=e.DEPTH_COMPONENT24));const r=re(n);ie(n)?N.renderbufferStorageMultisampleEXT(e.RENDERBUFFER,r,i,n.width,n.height):e.renderbufferStorageMultisample(e.RENDERBUFFER,r,i,n.width,n.height)}else e.renderbufferStorage(e.RENDERBUFFER,i,n.width,n.height);e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,t)}else if(n.depthBuffer&&n.stencilBuffer){const i=re(n);r&&!1===ie(n)?e.renderbufferStorageMultisample(e.RENDERBUFFER,i,e.DEPTH24_STENCIL8,n.width,n.height):ie(n)?N.renderbufferStorageMultisampleEXT(e.RENDERBUFFER,i,e.DEPTH24_STENCIL8,n.width,n.height):e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_STENCIL,n.width,n.height),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_STENCIL_ATTACHMENT,e.RENDERBUFFER,t)}else{const t=!0===n.isWebGLMultipleRenderTargets?n.texture:[n.texture];for(let i=0;i<t.length;i++){const a=t[i],o=s.convert(a.format,a.encoding),l=s.convert(a.type),c=$(a.internalFormat,o,l,a.encoding),u=re(n);r&&!1===ie(n)?e.renderbufferStorageMultisample(e.RENDERBUFFER,u,c,n.width,n.height):ie(n)?N.renderbufferStorageMultisampleEXT(e.RENDERBUFFER,u,c,n.width,n.height):e.renderbufferStorage(e.RENDERBUFFER,c,n.width,n.height)}}e.bindRenderbuffer(e.RENDERBUFFER,null)}function ne(t){const i=r.get(t),s=!0===t.isWebGLCubeRenderTarget;if(t.depthTexture&&!i.__autoAllocateDepthBuffer){if(s)throw new Error("target.depthTexture not supported in Cube render targets");!function(t,i){if(i&&i.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(e.FRAMEBUFFER,t),!i.depthTexture||!i.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");r.get(i.depthTexture).__webglTexture&&i.depthTexture.image.width===i.width&&i.depthTexture.image.height===i.height||(i.depthTexture.image.width=i.width,i.depthTexture.image.height=i.height,i.depthTexture.needsUpdate=!0),X(i.depthTexture,0);const s=r.get(i.depthTexture).__webglTexture,a=re(i);if(i.depthTexture.format===E)ie(i)?N.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,s,0,a):e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,s,0);else{if(i.depthTexture.format!==A)throw new Error("Unknown depthTexture format");ie(i)?N.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER,e.DEPTH_STENCIL_ATTACHMENT,e.TEXTURE_2D,s,0,a):e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_STENCIL_ATTACHMENT,e.TEXTURE_2D,s,0)}}(i.__webglFramebuffer,t)}else if(s){i.__webglDepthbuffer=[];for(let r=0;r<6;r++)n.bindFramebuffer(e.FRAMEBUFFER,i.__webglFramebuffer[r]),i.__webglDepthbuffer[r]=e.createRenderbuffer(),te(i.__webglDepthbuffer[r],t,!1)}else n.bindFramebuffer(e.FRAMEBUFFER,i.__webglFramebuffer),i.__webglDepthbuffer=e.createRenderbuffer(),te(i.__webglDepthbuffer,t,!1);n.bindFramebuffer(e.FRAMEBUFFER,null)}function re(e){return Math.min(I,e.samples)}function ie(e){const n=r.get(e);return o&&e.samples>0&&!0===t.has("WEBGL_multisampled_render_to_texture")&&!1!==n.__useRenderToTexture}function se(e,n){const r=e.encoding,i=e.format,s=e.type;return!0===e.isCompressedTexture||!0===e.isVideoTexture||e.format===pe||r!==ae&&(r===oe?!1===o?!0===t.has("EXT_sRGB")&&i===T?(e.format=pe,e.minFilter=g,e.generateMipmaps=!1):n=He.sRGBToLinear(n):i===T&&s===x||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",r)),n}this.allocateTextureUnit=function(){const e=q;return e>=l&&console.warn("THREE.WebGLTextures: Trying to use "+e+" texture units while this GPU supports only "+l),q+=1,e},this.resetTextureUnits=function(){q=0},this.setTexture2D=X,this.setTexture2DArray=function(t,i){const s=r.get(t);t.version>0&&s.__version!==t.version?Q(s,t,i):(n.activeTexture(e.TEXTURE0+i),n.bindTexture(e.TEXTURE_2D_ARRAY,s.__webglTexture))},this.setTexture3D=function(t,i){const s=r.get(t);t.version>0&&s.__version!==t.version?Q(s,t,i):(n.activeTexture(e.TEXTURE0+i),n.bindTexture(e.TEXTURE_3D,s.__webglTexture))},this.setTextureCube=function(t,i){const a=r.get(t);t.version>0&&a.__version!==t.version?function(t,r,i){if(6!==r.image.length)return;const a=J(t,r),l=r.source;if(n.activeTexture(e.TEXTURE0+i),n.bindTexture(e.TEXTURE_CUBE_MAP,t.__webglTexture),l.version!==l.__currentVersion||!0===a){e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,r.flipY),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r.premultiplyAlpha),e.pixelStorei(e.UNPACK_ALIGNMENT,r.unpackAlignment),e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL,e.NONE);const t=r.isCompressedTexture||r.image[0].isCompressedTexture,i=r.image[0]&&r.image[0].isDataTexture,u=[];for(let e=0;e<6;e++)u[e]=t||i?i?r.image[e].image:r.image[e]:O(r.image[e],!1,!0,c),u[e]=se(r,u[e]);const h=u[0],d=z(h)||o,p=s.convert(r.format,r.encoding),f=s.convert(r.type),m=$(r.internalFormat,p,f,r.encoding),g=o&&!0!==r.isVideoTexture,y=void 0===l.__currentVersion||!0===a;let v,x=V(r,h,d);if(Z(e.TEXTURE_CUBE_MAP,r,d),t){g&&y&&n.texStorage2D(e.TEXTURE_CUBE_MAP,x,m,h.width,h.height);for(let t=0;t<6;t++){v=u[t].mipmaps;for(let i=0;i<v.length;i++){const s=v[i];r.format!==T?null!==p?g?n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,i,0,0,s.width,s.height,p,s.data):n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,i,m,s.width,s.height,0,s.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):g?n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,i,0,0,s.width,s.height,p,f,s.data):n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,i,m,s.width,s.height,0,p,f,s.data)}}}else{v=r.mipmaps,g&&y&&(v.length>0&&x++,n.texStorage2D(e.TEXTURE_CUBE_MAP,x,m,u[0].width,u[0].height));for(let t=0;t<6;t++)if(i){g?n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,0,0,u[t].width,u[t].height,p,f,u[t].data):n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,m,u[t].width,u[t].height,0,p,f,u[t].data);for(let r=0;r<v.length;r++){const i=v[r].image[t].image;g?n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,r+1,0,0,i.width,i.height,p,f,i.data):n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,r+1,m,i.width,i.height,0,p,f,i.data)}}else{g?n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,0,0,p,f,u[t]):n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,m,p,f,u[t]);for(let r=0;r<v.length;r++){const i=v[r];g?n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,r+1,0,0,p,f,i.image[t]):n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,r+1,m,p,f,i.image[t])}}}B(r,d)&&U(e.TEXTURE_CUBE_MAP),l.__currentVersion=l.version,r.onUpdate&&r.onUpdate(r)}t.__version=r.version}(a,t,i):(n.activeTexture(e.TEXTURE0+i),n.bindTexture(e.TEXTURE_CUBE_MAP,a.__webglTexture))},this.rebindTextures=function(t,n,i){const s=r.get(t);void 0!==n&&ee(s.__webglFramebuffer,t,t.texture,e.COLOR_ATTACHMENT0,e.TEXTURE_2D),void 0!==i&&ne(t)},this.setupRenderTarget=function(t){const l=t.texture,c=r.get(t),u=r.get(l);t.addEventListener("dispose",H),!0!==t.isWebGLMultipleRenderTargets&&(void 0===u.__webglTexture&&(u.__webglTexture=e.createTexture()),u.__version=l.version,a.memory.textures++);const h=!0===t.isWebGLCubeRenderTarget,d=!0===t.isWebGLMultipleRenderTargets,p=z(t)||o;if(h){c.__webglFramebuffer=[];for(let t=0;t<6;t++)c.__webglFramebuffer[t]=e.createFramebuffer()}else{if(c.__webglFramebuffer=e.createFramebuffer(),d)if(i.drawBuffers){const n=t.texture;for(let t=0,i=n.length;t<i;t++){const i=r.get(n[t]);void 0===i.__webglTexture&&(i.__webglTexture=e.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(o&&t.samples>0&&!1===ie(t)){const r=d?l:[l];c.__webglMultisampledFramebuffer=e.createFramebuffer(),c.__webglColorRenderbuffer=[],n.bindFramebuffer(e.FRAMEBUFFER,c.__webglMultisampledFramebuffer);for(let n=0;n<r.length;n++){const i=r[n];c.__webglColorRenderbuffer[n]=e.createRenderbuffer(),e.bindRenderbuffer(e.RENDERBUFFER,c.__webglColorRenderbuffer[n]);const a=s.convert(i.format,i.encoding),o=s.convert(i.type),l=$(i.internalFormat,a,o,i.encoding),u=re(t);e.renderbufferStorageMultisample(e.RENDERBUFFER,u,l,t.width,t.height),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0+n,e.RENDERBUFFER,c.__webglColorRenderbuffer[n])}e.bindRenderbuffer(e.RENDERBUFFER,null),t.depthBuffer&&(c.__webglDepthRenderbuffer=e.createRenderbuffer(),te(c.__webglDepthRenderbuffer,t,!0)),n.bindFramebuffer(e.FRAMEBUFFER,null)}}if(h){n.bindTexture(e.TEXTURE_CUBE_MAP,u.__webglTexture),Z(e.TEXTURE_CUBE_MAP,l,p);for(let n=0;n<6;n++)ee(c.__webglFramebuffer[n],t,l,e.COLOR_ATTACHMENT0,e.TEXTURE_CUBE_MAP_POSITIVE_X+n);B(l,p)&&U(e.TEXTURE_CUBE_MAP),n.unbindTexture()}else if(d){const i=t.texture;for(let s=0,a=i.length;s<a;s++){const a=i[s],o=r.get(a);n.bindTexture(e.TEXTURE_2D,o.__webglTexture),Z(e.TEXTURE_2D,a,p),ee(c.__webglFramebuffer,t,a,e.COLOR_ATTACHMENT0+s,e.TEXTURE_2D),B(a,p)&&U(e.TEXTURE_2D)}n.unbindTexture()}else{let r=e.TEXTURE_2D;(t.isWebGL3DRenderTarget||t.isWebGLArrayRenderTarget)&&(o?r=t.isWebGL3DRenderTarget?e.TEXTURE_3D:e.TEXTURE_2D_ARRAY:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),n.bindTexture(r,u.__webglTexture),Z(r,l,p),ee(c.__webglFramebuffer,t,l,e.COLOR_ATTACHMENT0,r),B(l,p)&&U(r),n.unbindTexture()}t.depthBuffer&&ne(t)},this.updateRenderTargetMipmap=function(t){const i=z(t)||o,s=!0===t.isWebGLMultipleRenderTargets?t.texture:[t.texture];for(let a=0,o=s.length;a<o;a++){const o=s[a];if(B(o,i)){const i=t.isWebGLCubeRenderTarget?e.TEXTURE_CUBE_MAP:e.TEXTURE_2D,s=r.get(o).__webglTexture;n.bindTexture(i,s),U(i),n.unbindTexture()}}},this.updateMultisampleRenderTarget=function(t){if(o&&t.samples>0&&!1===ie(t)){const i=t.isWebGLMultipleRenderTargets?t.texture:[t.texture],s=t.width,a=t.height;let o=e.COLOR_BUFFER_BIT;const l=[],c=t.stencilBuffer?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT,u=r.get(t),h=!0===t.isWebGLMultipleRenderTargets;if(h)for(let t=0;t<i.length;t++)n.bindFramebuffer(e.FRAMEBUFFER,u.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0+t,e.RENDERBUFFER,null),n.bindFramebuffer(e.FRAMEBUFFER,u.__webglFramebuffer),e.framebufferTexture2D(e.DRAW_FRAMEBUFFER,e.COLOR_ATTACHMENT0+t,e.TEXTURE_2D,null,0);n.bindFramebuffer(e.READ_FRAMEBUFFER,u.__webglMultisampledFramebuffer),n.bindFramebuffer(e.DRAW_FRAMEBUFFER,u.__webglFramebuffer);for(let n=0;n<i.length;n++){l.push(e.COLOR_ATTACHMENT0+n),t.depthBuffer&&l.push(c);const d=void 0!==u.__ignoreDepthValues&&u.__ignoreDepthValues;if(!1===d&&(t.depthBuffer&&(o|=e.DEPTH_BUFFER_BIT),t.stencilBuffer&&(o|=e.STENCIL_BUFFER_BIT)),h&&e.framebufferRenderbuffer(e.READ_FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.RENDERBUFFER,u.__webglColorRenderbuffer[n]),!0===d&&(e.invalidateFramebuffer(e.READ_FRAMEBUFFER,[c]),e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER,[c])),h){const t=r.get(i[n]).__webglTexture;e.framebufferTexture2D(e.DRAW_FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)}e.blitFramebuffer(0,0,s,a,0,0,s,a,o,e.NEAREST),k&&e.invalidateFramebuffer(e.READ_FRAMEBUFFER,l)}if(n.bindFramebuffer(e.READ_FRAMEBUFFER,null),n.bindFramebuffer(e.DRAW_FRAMEBUFFER,null),h)for(let t=0;t<i.length;t++){n.bindFramebuffer(e.FRAMEBUFFER,u.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0+t,e.RENDERBUFFER,u.__webglColorRenderbuffer[t]);const s=r.get(i[t]).__webglTexture;n.bindFramebuffer(e.FRAMEBUFFER,u.__webglFramebuffer),e.framebufferTexture2D(e.DRAW_FRAMEBUFFER,e.COLOR_ATTACHMENT0+t,e.TEXTURE_2D,s,0)}n.bindFramebuffer(e.DRAW_FRAMEBUFFER,u.__webglMultisampledFramebuffer)}},this.setupDepthRenderbuffer=ne,this.setupFrameBufferTexture=ee,this.useMultisampledRTT=ie}function Bs(e,t,n){const r=n.isWebGL2;return{convert:function(n,i=null){let s;if(n===x)return e.UNSIGNED_BYTE;if(1017===n)return e.UNSIGNED_SHORT_4_4_4_4;if(1018===n)return e.UNSIGNED_SHORT_5_5_5_1;if(1010===n)return e.BYTE;if(1011===n)return e.SHORT;if(n===b)return e.UNSIGNED_SHORT;if(1013===n)return e.INT;if(n===w)return e.UNSIGNED_INT;if(n===_)return e.FLOAT;if(n===S)return r?e.HALF_FLOAT:(s=t.get("OES_texture_half_float"),null!==s?s.HALF_FLOAT_OES:null);if(1021===n)return e.ALPHA;if(n===T)return e.RGBA;if(1024===n)return e.LUMINANCE;if(1025===n)return e.LUMINANCE_ALPHA;if(n===E)return e.DEPTH_COMPONENT;if(n===A)return e.DEPTH_STENCIL;if(1028===n)return e.RED;if(1022===n)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),e.RGBA;if(n===pe)return s=t.get("EXT_sRGB"),null!==s?s.SRGB_ALPHA_EXT:null;if(1029===n)return e.RED_INTEGER;if(1030===n)return e.RG;if(1031===n)return e.RG_INTEGER;if(1033===n)return e.RGBA_INTEGER;if(n===C||n===I||n===N||n===k)if(i===oe){if(s=t.get("WEBGL_compressed_texture_s3tc_srgb"),null===s)return null;if(n===C)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(n===I)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(n===N)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(n===k)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(s=t.get("WEBGL_compressed_texture_s3tc"),null===s)return null;if(n===C)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===I)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===N)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===k)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(n===R||n===D||n===L||n===F){if(s=t.get("WEBGL_compressed_texture_pvrtc"),null===s)return null;if(n===R)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(n===D)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(n===L)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(n===F)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(36196===n)return s=t.get("WEBGL_compressed_texture_etc1"),null!==s?s.COMPRESSED_RGB_ETC1_WEBGL:null;if(n===P||n===O){if(s=t.get("WEBGL_compressed_texture_etc"),null===s)return null;if(n===P)return i===oe?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(n===O)return i===oe?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}if(n===z||n===B||n===U||n===$||n===V||n===W||n===G||n===H||n===j||n===q||n===X||n===Y||n===K||n===Z){if(s=t.get("WEBGL_compressed_texture_astc"),null===s)return null;if(n===z)return i===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(n===B)return i===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(n===U)return i===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(n===$)return i===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(n===V)return i===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(n===W)return i===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(n===G)return i===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(n===H)return i===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(n===j)return i===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(n===q)return i===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(n===X)return i===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(n===Y)return i===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(n===K)return i===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(n===Z)return i===oe?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}if(n===J){if(s=t.get("EXT_texture_compression_bptc"),null===s)return null;if(n===J)return i===oe?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT}return n===M?r?e.UNSIGNED_INT_24_8:(s=t.get("WEBGL_depth_texture"),null!==s?s.UNSIGNED_INT_24_8_WEBGL:null):void 0!==e[n]?e[n]:null}}}class Us extends ir{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}class $s extends rn{constructor(){super(),this.isGroup=!0,this.type="Group"}}const Vs={type:"move"};class Ws{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new $s,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new $s,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new tt,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new tt),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new $s,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new tt,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new tt),this._grip}dispatchEvent(e){return null!==this._targetRay&&this._targetRay.dispatchEvent(e),null!==this._grip&&this._grip.dispatchEvent(e),null!==this._hand&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(e,t,n){let r=null,i=null,s=null;const a=this._targetRay,o=this._grip,l=this._hand;if(e&&"visible-blurred"!==t.session.visibilityState)if(null!==a&&(r=t.getPose(e.targetRaySpace,n),null!==r&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),r.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(r.linearVelocity)):a.hasLinearVelocity=!1,r.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(r.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(Vs))),l&&e.hand){s=!0;for(const r of e.hand.values()){const e=t.getJointPose(r,n);if(void 0===l.joints[r.jointName]){const e=new $s;e.matrixAutoUpdate=!1,e.visible=!1,l.joints[r.jointName]=e,l.add(e)}const i=l.joints[r.jointName];null!==e&&(i.matrix.fromArray(e.transform.matrix),i.matrix.decompose(i.position,i.rotation,i.scale),i.jointRadius=e.radius),i.visible=null!==e}const r=l.joints["index-finger-tip"],i=l.joints["thumb-tip"],a=r.position.distanceTo(i.position),o=.02,c=.005;l.inputState.pinching&&a>o+c?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!l.inputState.pinching&&a<=o-c&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else null!==o&&e.gripSpace&&(i=t.getPose(e.gripSpace,n),null!==i&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),i.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(i.linearVelocity)):o.hasLinearVelocity=!1,i.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(i.angularVelocity)):o.hasAngularVelocity=!1));return null!==a&&(a.visible=null!==r),null!==o&&(o.visible=null!==i),null!==l&&(l.visible=null!==s),this}}class Gs extends Ye{constructor(e,t,n,r,i,s,a,o,l,c){if((c=void 0!==c?c:E)!==E&&c!==A)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&c===E&&(n=w),void 0===n&&c===A&&(n=M),super(null,r,i,s,a,o,c,n,l),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=void 0!==a?a:p,this.minFilter=void 0!==o?o:p,this.flipY=!1,this.generateMipmaps=!1}}class Hs extends fe{constructor(e,t){super();const n=this;let r=null,i=1,s=null,a="local-floor",o=null,l=null,c=null,u=null,h=null,d=null;const p=t.getContextAttributes();let f=null,m=null;const g=[],y=new Map,v=new ir;v.layers.enable(1),v.viewport=new Ke;const b=new ir;b.layers.enable(2),b.viewport=new Ke;const _=[v,b],S=new Us;S.layers.enable(1),S.layers.enable(2);let C=null,I=null;function N(e){const t=y.get(e.inputSource);void 0!==t&&t.dispatchEvent({type:e.type,data:e.inputSource})}function k(){r.removeEventListener("select",N),r.removeEventListener("selectstart",N),r.removeEventListener("selectend",N),r.removeEventListener("squeeze",N),r.removeEventListener("squeezestart",N),r.removeEventListener("squeezeend",N),r.removeEventListener("end",k),r.removeEventListener("inputsourceschange",R),y.forEach((function(e,t){void 0!==e&&e.disconnect(t)})),y.clear(),C=null,I=null,e.setRenderTarget(f),h=null,u=null,c=null,r=null,m=null,O.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function R(e){const t=r.inputSources;for(let e=0;e<t.length;e++){const n="right"===t[e].handedness?1:0;y.set(t[e],g[n])}for(let t=0;t<e.removed.length;t++){const n=e.removed[t],r=y.get(n);r&&(r.dispatchEvent({type:"disconnected",data:n}),y.delete(n))}for(let t=0;t<e.added.length;t++){const n=e.added[t],r=y.get(n);r&&r.dispatchEvent({type:"connected",data:n})}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(e){let t=g[e];return void 0===t&&(t=new Ws,g[e]=t),t.getTargetRaySpace()},this.getControllerGrip=function(e){let t=g[e];return void 0===t&&(t=new Ws,g[e]=t),t.getGripSpace()},this.getHand=function(e){let t=g[e];return void 0===t&&(t=new Ws,g[e]=t),t.getHandSpace()},this.setFramebufferScaleFactor=function(e){i=e,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(e){a=e,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return o||s},this.setReferenceSpace=function(e){o=e},this.getBaseLayer=function(){return null!==u?u:h},this.getBinding=function(){return c},this.getFrame=function(){return d},this.getSession=function(){return r},this.setSession=async function(l){if(r=l,null!==r){if(f=e.getRenderTarget(),r.addEventListener("select",N),r.addEventListener("selectstart",N),r.addEventListener("selectend",N),r.addEventListener("squeeze",N),r.addEventListener("squeezestart",N),r.addEventListener("squeezeend",N),r.addEventListener("end",k),r.addEventListener("inputsourceschange",R),!0!==p.xrCompatible&&await t.makeXRCompatible(),void 0===r.renderState.layers||!1===e.capabilities.isWebGL2){const n={antialias:void 0!==r.renderState.layers||p.antialias,alpha:p.alpha,depth:p.depth,stencil:p.stencil,framebufferScaleFactor:i};h=new XRWebGLLayer(r,t,n),r.updateRenderState({baseLayer:h}),m=new Ze(h.framebufferWidth,h.framebufferHeight,{format:T,type:x,encoding:e.outputEncoding})}else{let n=null,s=null,a=null;p.depth&&(a=p.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,n=p.stencil?A:E,s=p.stencil?M:w);const o={colorFormat:e.outputEncoding===oe?t.SRGB8_ALPHA8:t.RGBA8,depthFormat:a,scaleFactor:i};c=new XRWebGLBinding(r,t),u=c.createProjectionLayer(o),r.updateRenderState({layers:[u]}),m=new Ze(u.textureWidth,u.textureHeight,{format:T,type:x,depthTexture:new Gs(u.textureWidth,u.textureHeight,s,void 0,void 0,void 0,void 0,void 0,void 0,n),stencilBuffer:p.stencil,encoding:e.outputEncoding,samples:p.antialias?4:0}),e.properties.get(m).__ignoreDepthValues=u.ignoreDepthValues}m.isXRRenderTarget=!0,this.setFoveation(1),o=null,s=await r.requestReferenceSpace(a),O.setContext(r),O.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};const D=new tt,L=new tt;function F(e,t){null===t?e.matrixWorld.copy(e.matrix):e.matrixWorld.multiplyMatrices(t.matrixWorld,e.matrix),e.matrixWorldInverse.copy(e.matrixWorld).invert()}this.updateCamera=function(e){if(null===r)return;S.near=b.near=v.near=e.near,S.far=b.far=v.far=e.far,C===S.near&&I===S.far||(r.updateRenderState({depthNear:S.near,depthFar:S.far}),C=S.near,I=S.far);const t=e.parent,n=S.cameras;F(S,t);for(let e=0;e<n.length;e++)F(n[e],t);S.matrixWorld.decompose(S.position,S.quaternion,S.scale),e.position.copy(S.position),e.quaternion.copy(S.quaternion),e.scale.copy(S.scale),e.matrix.copy(S.matrix),e.matrixWorld.copy(S.matrixWorld);const i=e.children;for(let e=0,t=i.length;e<t;e++)i[e].updateMatrixWorld(!0);2===n.length?function(e,t,n){D.setFromMatrixPosition(t.matrixWorld),L.setFromMatrixPosition(n.matrixWorld);const r=D.distanceTo(L),i=t.projectionMatrix.elements,s=n.projectionMatrix.elements,a=i[14]/(i[10]-1),o=i[14]/(i[10]+1),l=(i[9]+1)/i[5],c=(i[9]-1)/i[5],u=(i[8]-1)/i[0],h=(s[8]+1)/s[0],d=a*u,p=a*h,f=r/(-u+h),m=f*-u;t.matrixWorld.decompose(e.position,e.quaternion,e.scale),e.translateX(m),e.translateZ(f),e.matrixWorld.compose(e.position,e.quaternion,e.scale),e.matrixWorldInverse.copy(e.matrixWorld).invert();const g=a+f,y=o+f,v=d-m,x=p+(r-m),b=l*o/y*g,w=c*o/y*g;e.projectionMatrix.makePerspective(v,x,b,w,g,y)}(S,v,b):S.projectionMatrix.copy(v.projectionMatrix)},this.getCamera=function(){return S},this.getFoveation=function(){return null!==u?u.fixedFoveation:null!==h?h.fixedFoveation:void 0},this.setFoveation=function(e){null!==u&&(u.fixedFoveation=e),null!==h&&void 0!==h.fixedFoveation&&(h.fixedFoveation=e)};let P=null;const O=new gr;O.setAnimationLoop((function(t,n){if(l=n.getViewerPose(o||s),d=n,null!==l){const t=l.views;null!==h&&(e.setRenderTargetFramebuffer(m,h.framebuffer),e.setRenderTarget(m));let n=!1;t.length!==S.cameras.length&&(S.cameras.length=0,n=!0);for(let r=0;r<t.length;r++){const i=t[r];let s=null;if(null!==h)s=h.getViewport(i);else{const t=c.getViewSubImage(u,i);s=t.viewport,0===r&&(e.setRenderTargetTextures(m,t.colorTexture,u.ignoreDepthValues?void 0:t.depthStencilTexture),e.setRenderTarget(m))}let a=_[r];void 0===a&&(a=new ir,a.layers.enable(r),a.viewport=new Ke,_[r]=a),a.matrix.fromArray(i.transform.matrix),a.projectionMatrix.fromArray(i.projectionMatrix),a.viewport.set(s.x,s.y,s.width,s.height),0===r&&S.matrix.copy(a.matrix),!0===n&&S.cameras.push(a)}}const i=r.inputSources;for(let e=0;e<g.length;e++){const t=i[e],r=y.get(t);void 0!==r&&r.update(t,n,o||s)}P&&P(t,n),d=null})),this.setAnimationLoop=function(e){P=e},this.dispose=function(){}}}function js(e,t){function n(n,r){n.opacity.value=r.opacity,r.color&&n.diffuse.value.copy(r.color),r.emissive&&n.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),r.map&&(n.map.value=r.map),r.alphaMap&&(n.alphaMap.value=r.alphaMap),r.bumpMap&&(n.bumpMap.value=r.bumpMap,n.bumpScale.value=r.bumpScale,1===r.side&&(n.bumpScale.value*=-1)),r.displacementMap&&(n.displacementMap.value=r.displacementMap,n.displacementScale.value=r.displacementScale,n.displacementBias.value=r.displacementBias),r.emissiveMap&&(n.emissiveMap.value=r.emissiveMap),r.normalMap&&(n.normalMap.value=r.normalMap,n.normalScale.value.copy(r.normalScale),1===r.side&&n.normalScale.value.negate()),r.specularMap&&(n.specularMap.value=r.specularMap),r.alphaTest>0&&(n.alphaTest.value=r.alphaTest);const i=t.get(r).envMap;if(i&&(n.envMap.value=i,n.flipEnvMap.value=i.isCubeTexture&&!1===i.isRenderTargetTexture?-1:1,n.reflectivity.value=r.reflectivity,n.ior.value=r.ior,n.refractionRatio.value=r.refractionRatio),r.lightMap){n.lightMap.value=r.lightMap;const t=!0!==e.physicallyCorrectLights?Math.PI:1;n.lightMapIntensity.value=r.lightMapIntensity*t}let s,a;r.aoMap&&(n.aoMap.value=r.aoMap,n.aoMapIntensity.value=r.aoMapIntensity),r.map?s=r.map:r.specularMap?s=r.specularMap:r.displacementMap?s=r.displacementMap:r.normalMap?s=r.normalMap:r.bumpMap?s=r.bumpMap:r.roughnessMap?s=r.roughnessMap:r.metalnessMap?s=r.metalnessMap:r.alphaMap?s=r.alphaMap:r.emissiveMap?s=r.emissiveMap:r.clearcoatMap?s=r.clearcoatMap:r.clearcoatNormalMap?s=r.clearcoatNormalMap:r.clearcoatRoughnessMap?s=r.clearcoatRoughnessMap:r.iridescenceMap?s=r.iridescenceMap:r.iridescenceThicknessMap?s=r.iridescenceThicknessMap:r.specularIntensityMap?s=r.specularIntensityMap:r.specularColorMap?s=r.specularColorMap:r.transmissionMap?s=r.transmissionMap:r.thicknessMap?s=r.thicknessMap:r.sheenColorMap?s=r.sheenColorMap:r.sheenRoughnessMap&&(s=r.sheenRoughnessMap),void 0!==s&&(s.isWebGLRenderTarget&&(s=s.texture),!0===s.matrixAutoUpdate&&s.updateMatrix(),n.uvTransform.value.copy(s.matrix)),r.aoMap?a=r.aoMap:r.lightMap&&(a=r.lightMap),void 0!==a&&(a.isWebGLRenderTarget&&(a=a.texture),!0===a.matrixAutoUpdate&&a.updateMatrix(),n.uv2Transform.value.copy(a.matrix))}return{refreshFogUniforms:function(e,t){e.fogColor.value.copy(t.color),t.isFog?(e.fogNear.value=t.near,e.fogFar.value=t.far):t.isFogExp2&&(e.fogDensity.value=t.density)},refreshMaterialUniforms:function(e,r,i,s,a){r.isMeshBasicMaterial||r.isMeshLambertMaterial?n(e,r):r.isMeshToonMaterial?(n(e,r),function(e,t){t.gradientMap&&(e.gradientMap.value=t.gradientMap)}(e,r)):r.isMeshPhongMaterial?(n(e,r),function(e,t){e.specular.value.copy(t.specular),e.shininess.value=Math.max(t.shininess,1e-4)}(e,r)):r.isMeshStandardMaterial?(n(e,r),function(e,n){e.roughness.value=n.roughness,e.metalness.value=n.metalness,n.roughnessMap&&(e.roughnessMap.value=n.roughnessMap),n.metalnessMap&&(e.metalnessMap.value=n.metalnessMap),t.get(n).envMap&&(e.envMapIntensity.value=n.envMapIntensity)}(e,r),r.isMeshPhysicalMaterial&&function(e,t,n){e.ior.value=t.ior,t.sheen>0&&(e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen),e.sheenRoughness.value=t.sheenRoughness,t.sheenColorMap&&(e.sheenColorMap.value=t.sheenColorMap),t.sheenRoughnessMap&&(e.sheenRoughnessMap.value=t.sheenRoughnessMap)),t.clearcoat>0&&(e.clearcoat.value=t.clearcoat,e.clearcoatRoughness.value=t.clearcoatRoughness,t.clearcoatMap&&(e.clearcoatMap.value=t.clearcoatMap),t.clearcoatRoughnessMap&&(e.clearcoatRoughnessMap.value=t.clearcoatRoughnessMap),t.clearcoatNormalMap&&(e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),e.clearcoatNormalMap.value=t.clearcoatNormalMap,1===t.side&&e.clearcoatNormalScale.value.negate())),t.iridescence>0&&(e.iridescence.value=t.iridescence,e.iridescenceIOR.value=t.iridescenceIOR,e.iridescenceThicknessMinimum.value=t.iridescenceThicknessRange[0],e.iridescenceThicknessMaximum.value=t.iridescenceThicknessRange[1],t.iridescenceMap&&(e.iridescenceMap.value=t.iridescenceMap),t.iridescenceThicknessMap&&(e.iridescenceThicknessMap.value=t.iridescenceThicknessMap)),t.transmission>0&&(e.transmission.value=t.transmission,e.transmissionSamplerMap.value=n.texture,e.transmissionSamplerSize.value.set(n.width,n.height),t.transmissionMap&&(e.transmissionMap.value=t.transmissionMap),e.thickness.value=t.thickness,t.thicknessMap&&(e.thicknessMap.value=t.thicknessMap),e.attenuationDistance.value=t.attenuationDistance,e.attenuationColor.value.copy(t.attenuationColor)),e.specularIntensity.value=t.specularIntensity,e.specularColor.value.copy(t.specularColor),t.specularIntensityMap&&(e.specularIntensityMap.value=t.specularIntensityMap),t.specularColorMap&&(e.specularColorMap.value=t.specularColorMap)}(e,r,a)):r.isMeshMatcapMaterial?(n(e,r),function(e,t){t.matcap&&(e.matcap.value=t.matcap)}(e,r)):r.isMeshDepthMaterial?n(e,r):r.isMeshDistanceMaterial?(n(e,r),function(e,t){e.referencePosition.value.copy(t.referencePosition),e.nearDistance.value=t.nearDistance,e.farDistance.value=t.farDistance}(e,r)):r.isMeshNormalMaterial?n(e,r):r.isLineBasicMaterial?(function(e,t){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity}(e,r),r.isLineDashedMaterial&&function(e,t){e.dashSize.value=t.dashSize,e.totalSize.value=t.dashSize+t.gapSize,e.scale.value=t.scale}(e,r)):r.isPointsMaterial?function(e,t,n,r){let i;e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.size.value=t.size*n,e.scale.value=.5*r,t.map&&(e.map.value=t.map),t.alphaMap&&(e.alphaMap.value=t.alphaMap),t.alphaTest>0&&(e.alphaTest.value=t.alphaTest),t.map?i=t.map:t.alphaMap&&(i=t.alphaMap),void 0!==i&&(!0===i.matrixAutoUpdate&&i.updateMatrix(),e.uvTransform.value.copy(i.matrix))}(e,r,i,s):r.isSpriteMaterial?function(e,t){let n;e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.rotation.value=t.rotation,t.map&&(e.map.value=t.map),t.alphaMap&&(e.alphaMap.value=t.alphaMap),t.alphaTest>0&&(e.alphaTest.value=t.alphaTest),t.map?n=t.map:t.alphaMap&&(n=t.alphaMap),void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),e.uvTransform.value.copy(n.matrix))}(e,r):r.isShadowMaterial?(e.color.value.copy(r.color),e.opacity.value=r.opacity):r.isShaderMaterial&&(r.uniformsNeedUpdate=!1)}}}function qs(e={}){this.isWebGLRenderer=!0;const t=void 0!==e.canvas?e.canvas:function(){const e=Re("canvas");return e.style.display="block",e}(),n=void 0!==e.context?e.context:null,r=void 0===e.depth||e.depth,i=void 0===e.stencil||e.stencil,s=void 0!==e.antialias&&e.antialias,a=void 0===e.premultipliedAlpha||e.premultipliedAlpha,o=void 0!==e.preserveDrawingBuffer&&e.preserveDrawingBuffer,l=void 0!==e.powerPreference?e.powerPreference:"default",c=void 0!==e.failIfMajorPerformanceCaveat&&e.failIfMajorPerformanceCaveat;let u;u=null!==n?n.getContextAttributes().alpha:void 0!==e.alpha&&e.alpha;let h=null,d=null;const p=[],f=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=ae,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1,Object.defineProperties(this,{gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});const m=this;let g=!1,y=0,b=0,w=null,M=-1,E=null;const A=new Ke,C=new Ke;let I=null,N=t.width,k=t.height,R=1,D=null,L=null;const F=new Ke(0,0,N,k),P=new Ke(0,0,N,k);let O=!1;const z=new mr;let B=!1,U=!1,$=null;const V=new Rt,W=new Ae,G=new tt,H={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function j(){return null===w?R:1}let q,X,Y,K,Z,J,Q,ee,te,ne,re,ie,se,oe,le,ce,ue,he,de,pe,fe,me,ge,ye=n;function ve(e,n){for(let r=0;r<e.length;r++){const i=e[r],s=t.getContext(i,n);if(null!==s)return s}return null}try{const e={alpha:!0,depth:r,stencil:i,antialias:s,premultipliedAlpha:a,preserveDrawingBuffer:o,powerPreference:l,failIfMajorPerformanceCaveat:c};if("setAttribute"in t&&t.setAttribute("data-engine","three.js r141"),t.addEventListener("webglcontextlost",we,!1),t.addEventListener("webglcontextrestored",_e,!1),t.addEventListener("webglcontextcreationerror",Se,!1),null===ye){const t=["webgl2","webgl","experimental-webgl"];if(!0===m.isWebGL1Renderer&&t.shift(),ye=ve(t,e),null===ye)throw ve(t)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===ye.getShaderPrecisionFormat&&(ye.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(e){throw console.error("THREE.WebGLRenderer: "+e.message),e}function xe(){q=new Vr(ye),X=new Tr(ye,q,e),q.init(X),me=new Bs(ye,q,X),Y=new Os(ye,q,X),K=new Hr(ye),Z=new Ss,J=new zs(ye,q,Y,Z,X,me,K),Q=new Ar(m),ee=new $r(m),te=new yr(ye,X),ge=new Sr(ye,q,te,X),ne=new Wr(ye,te,K,ge),re=new Kr(ye,ne,te,K),de=new Yr(ye,X,J),ce=new Er(Z),ie=new _s(m,Q,ee,q,X,ge,ce),se=new js(m,Z),oe=new As,le=new Ds(q,X),he=new _r(m,Q,Y,re,u,a),ue=new Ps(m,re,X),pe=new Mr(ye,q,K,X),fe=new Gr(ye,q,K,X),K.programs=ie.programs,m.capabilities=X,m.extensions=q,m.properties=Z,m.renderLists=oe,m.shadowMap=ue,m.state=Y,m.info=K}xe();const be=new Hs(m,ye);function we(e){e.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),g=!0}function _e(){console.log("THREE.WebGLRenderer: Context Restored."),g=!1;const e=K.autoReset,t=ue.enabled,n=ue.autoUpdate,r=ue.needsUpdate,i=ue.type;xe(),K.autoReset=e,ue.enabled=t,ue.autoUpdate=n,ue.needsUpdate=r,ue.type=i}function Se(e){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",e.statusMessage)}function Me(e){const t=e.target;t.removeEventListener("dispose",Me),function(e){(function(e){const t=Z.get(e).programs;void 0!==t&&(t.forEach((function(e){ie.releaseProgram(e)})),e.isShaderMaterial&&ie.releaseShaderCache(e))})(e),Z.remove(e)}(t)}this.xr=be,this.getContext=function(){return ye},this.getContextAttributes=function(){return ye.getContextAttributes()},this.forceContextLoss=function(){const e=q.get("WEBGL_lose_context");e&&e.loseContext()},this.forceContextRestore=function(){const e=q.get("WEBGL_lose_context");e&&e.restoreContext()},this.getPixelRatio=function(){return R},this.setPixelRatio=function(e){void 0!==e&&(R=e,this.setSize(N,k,!1))},this.getSize=function(e){return e.set(N,k)},this.setSize=function(e,n,r){be.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(N=e,k=n,t.width=Math.floor(e*R),t.height=Math.floor(n*R),!1!==r&&(t.style.width=e+"px",t.style.height=n+"px"),this.setViewport(0,0,e,n))},this.getDrawingBufferSize=function(e){return e.set(N*R,k*R).floor()},this.setDrawingBufferSize=function(e,n,r){N=e,k=n,R=r,t.width=Math.floor(e*r),t.height=Math.floor(n*r),this.setViewport(0,0,e,n)},this.getCurrentViewport=function(e){return e.copy(A)},this.getViewport=function(e){return e.copy(F)},this.setViewport=function(e,t,n,r){e.isVector4?F.set(e.x,e.y,e.z,e.w):F.set(e,t,n,r),Y.viewport(A.copy(F).multiplyScalar(R).floor())},this.getScissor=function(e){return e.copy(P)},this.setScissor=function(e,t,n,r){e.isVector4?P.set(e.x,e.y,e.z,e.w):P.set(e,t,n,r),Y.scissor(C.copy(P).multiplyScalar(R).floor())},this.getScissorTest=function(){return O},this.setScissorTest=function(e){Y.setScissorTest(O=e)},this.setOpaqueSort=function(e){D=e},this.setTransparentSort=function(e){L=e},this.getClearColor=function(e){return e.copy(he.getClearColor())},this.setClearColor=function(){he.setClearColor.apply(he,arguments)},this.getClearAlpha=function(){return he.getClearAlpha()},this.setClearAlpha=function(){he.setClearAlpha.apply(he,arguments)},this.clear=function(e=!0,t=!0,n=!0){let r=0;e&&(r|=ye.COLOR_BUFFER_BIT),t&&(r|=ye.DEPTH_BUFFER_BIT),n&&(r|=ye.STENCIL_BUFFER_BIT),ye.clear(r)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",we,!1),t.removeEventListener("webglcontextrestored",_e,!1),t.removeEventListener("webglcontextcreationerror",Se,!1),oe.dispose(),le.dispose(),Z.dispose(),Q.dispose(),ee.dispose(),re.dispose(),ge.dispose(),ie.dispose(),be.dispose(),be.removeEventListener("sessionstart",Ce),be.removeEventListener("sessionend",Ie),$&&($.dispose(),$=null),Ne.stop()},this.renderBufferDirect=function(e,t,n,r,i,s){null===t&&(t=H);const a=i.isMesh&&i.matrixWorld.determinant()<0,o=function(e,t,n,r,i){!0!==t.isScene&&(t=H),J.resetTextureUnits();const s=t.fog,a=r.isMeshStandardMaterial?t.environment:null,o=null===w?m.outputEncoding:!0===w.isXRRenderTarget?w.texture.encoding:ae,l=(r.isMeshStandardMaterial?ee:Q).get(r.envMap||a),c=!0===r.vertexColors&&!!n.attributes.color&&4===n.attributes.color.itemSize,u=!!r.normalMap&&!!n.attributes.tangent,h=!!n.morphAttributes.position,p=!!n.morphAttributes.normal,f=!!n.morphAttributes.color,g=r.toneMapped?m.toneMapping:0,y=n.morphAttributes.position||n.morphAttributes.normal||n.morphAttributes.color,v=void 0!==y?y.length:0,x=Z.get(r),b=d.state.lights;if(!0===B&&(!0===U||e!==E)){const t=e===E&&r.id===M;ce.setState(r,e,t)}let _=!1;r.version===x.__version?x.needsLights&&x.lightsStateVersion!==b.state.version||x.outputEncoding!==o||i.isInstancedMesh&&!1===x.instancing?_=!0:i.isInstancedMesh||!0!==x.instancing?i.isSkinnedMesh&&!1===x.skinning?_=!0:i.isSkinnedMesh||!0!==x.skinning?x.envMap!==l||!0===r.fog&&x.fog!==s?_=!0:void 0===x.numClippingPlanes||x.numClippingPlanes===ce.numPlanes&&x.numIntersection===ce.numIntersection?(x.vertexAlphas!==c||x.vertexTangents!==u||x.morphTargets!==h||x.morphNormals!==p||x.morphColors!==f||x.toneMapping!==g||!0===X.isWebGL2&&x.morphTargetsCount!==v)&&(_=!0):_=!0:_=!0:_=!0:(_=!0,x.__version=r.version);let S=x.currentProgram;!0===_&&(S=Pe(r,t,i));let T=!1,A=!1,C=!1;const I=S.getUniforms(),N=x.uniforms;if(Y.useProgram(S.program)&&(T=!0,A=!0,C=!0),r.id!==M&&(M=r.id,A=!0),T||E!==e){if(I.setValue(ye,"projectionMatrix",e.projectionMatrix),X.logarithmicDepthBuffer&&I.setValue(ye,"logDepthBufFC",2/(Math.log(e.far+1)/Math.LN2)),E!==e&&(E=e,A=!0,C=!0),r.isShaderMaterial||r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshStandardMaterial||r.envMap){const t=I.map.cameraPosition;void 0!==t&&t.setValue(ye,G.setFromMatrixPosition(e.matrixWorld))}(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial)&&I.setValue(ye,"isOrthographic",!0===e.isOrthographicCamera),(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial||r.isShadowMaterial||i.isSkinnedMesh)&&I.setValue(ye,"viewMatrix",e.matrixWorldInverse)}if(i.isSkinnedMesh){I.setOptional(ye,i,"bindMatrix"),I.setOptional(ye,i,"bindMatrixInverse");const e=i.skeleton;e&&(X.floatVertexTextures?(null===e.boneTexture&&e.computeBoneTexture(),I.setValue(ye,"boneTexture",e.boneTexture,J),I.setValue(ye,"boneTextureSize",e.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const D=n.morphAttributes;var L,F;return(void 0!==D.position||void 0!==D.normal||void 0!==D.color&&!0===X.isWebGL2)&&de.update(i,n,r,S),(A||x.receiveShadow!==i.receiveShadow)&&(x.receiveShadow=i.receiveShadow,I.setValue(ye,"receiveShadow",i.receiveShadow)),A&&(I.setValue(ye,"toneMappingExposure",m.toneMappingExposure),x.needsLights&&(F=C,(L=N).ambientLightColor.needsUpdate=F,L.lightProbe.needsUpdate=F,L.directionalLights.needsUpdate=F,L.directionalLightShadows.needsUpdate=F,L.pointLights.needsUpdate=F,L.pointLightShadows.needsUpdate=F,L.spotLights.needsUpdate=F,L.spotLightShadows.needsUpdate=F,L.rectAreaLights.needsUpdate=F,L.hemisphereLights.needsUpdate=F),s&&!0===r.fog&&se.refreshFogUniforms(N,s),se.refreshMaterialUniforms(N,r,R,k,$),es.upload(ye,x.uniformsList,N,J)),r.isShaderMaterial&&!0===r.uniformsNeedUpdate&&(es.upload(ye,x.uniformsList,N,J),r.uniformsNeedUpdate=!1),r.isSpriteMaterial&&I.setValue(ye,"center",i.center),I.setValue(ye,"modelViewMatrix",i.modelViewMatrix),I.setValue(ye,"normalMatrix",i.normalMatrix),I.setValue(ye,"modelMatrix",i.matrixWorld),S}(e,t,n,r,i);Y.setMaterial(r,a);let l=n.index;const c=n.attributes.position;if(null===l){if(void 0===c||0===c.count)return}else if(0===l.count)return;let u,h=1;!0===r.wireframe&&(l=ne.getWireframeAttribute(n),h=2),ge.setup(i,r,o,n,l);let p=pe;null!==l&&(u=te.get(l),p=fe,p.setIndex(u));const f=null!==l?l.count:c.count,g=n.drawRange.start*h,y=n.drawRange.count*h,v=null!==s?s.start*h:0,x=null!==s?s.count*h:1/0,b=Math.max(g,v),_=Math.min(f,g+y,v+x)-1,S=Math.max(0,_-b+1);if(0!==S){if(i.isMesh)!0===r.wireframe?(Y.setLineWidth(r.wireframeLinewidth*j()),p.setMode(ye.LINES)):p.setMode(ye.TRIANGLES);else if(i.isLine){let e=r.linewidth;void 0===e&&(e=1),Y.setLineWidth(e*j()),i.isLineSegments?p.setMode(ye.LINES):i.isLineLoop?p.setMode(ye.LINE_LOOP):p.setMode(ye.LINE_STRIP)}else i.isPoints?p.setMode(ye.POINTS):i.isSprite&&p.setMode(ye.TRIANGLES);if(i.isInstancedMesh)p.renderInstances(b,S,i.count);else if(n.isInstancedBufferGeometry){const e=Math.min(n.instanceCount,n._maxInstanceCount);p.renderInstances(b,S,e)}else p.render(b,S)}},this.compile=function(e,t){d=le.get(e),d.init(),f.push(d),e.traverseVisible((function(e){e.isLight&&e.layers.test(t.layers)&&(d.pushLight(e),e.castShadow&&d.pushShadow(e))})),d.setupLights(m.physicallyCorrectLights),e.traverse((function(t){const n=t.material;if(n)if(Array.isArray(n))for(let r=0;r<n.length;r++)Pe(n[r],e,t);else Pe(n,e,t)})),f.pop(),d=null};let Ee=null;function Ce(){Ne.stop()}function Ie(){Ne.start()}const Ne=new gr;function ke(e,t,n,r){if(!1===e.visible)return;if(e.layers.test(t.layers))if(e.isGroup)n=e.renderOrder;else if(e.isLOD)!0===e.autoUpdate&&e.update(t);else if(e.isLight)d.pushLight(e),e.castShadow&&d.pushShadow(e);else if(e.isSprite){if(!e.frustumCulled||z.intersectsSprite(e)){r&&G.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V);const t=re.update(e),i=e.material;i.visible&&h.push(e,t,i,n,G.z,null)}}else if((e.isMesh||e.isLine||e.isPoints)&&(e.isSkinnedMesh&&e.skeleton.frame!==K.render.frame&&(e.skeleton.update(),e.skeleton.frame=K.render.frame),!e.frustumCulled||z.intersectsObject(e))){r&&G.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V);const t=re.update(e),i=e.material;if(Array.isArray(i)){const r=t.groups;for(let s=0,a=r.length;s<a;s++){const a=r[s],o=i[a.materialIndex];o&&o.visible&&h.push(e,t,o,n,G.z,a)}}else i.visible&&h.push(e,t,i,n,G.z,null)}const i=e.children;for(let e=0,s=i.length;e<s;e++)ke(i[e],t,n,r)}function De(e,t,n,r){const i=e.opaque,a=e.transmissive,o=e.transparent;d.setupLightsView(n),a.length>0&&function(e,t,n){const r=X.isWebGL2;null===$&&($=new Ze(1,1,{generateMipmaps:!0,type:q.has("EXT_color_buffer_half_float")?S:x,minFilter:v,samples:r&&!0===s?4:0})),m.getDrawingBufferSize(W),r?$.setSize(W.x,W.y):$.setSize(Te(W.x),Te(W.y));const i=m.getRenderTarget();m.setRenderTarget($),m.clear();const a=m.toneMapping;m.toneMapping=0,Le(e,t,n),m.toneMapping=a,J.updateMultisampleRenderTarget($),J.updateRenderTargetMipmap($),m.setRenderTarget(i)}(i,t,n),r&&Y.viewport(A.copy(r)),i.length>0&&Le(i,t,n),a.length>0&&Le(a,t,n),o.length>0&&Le(o,t,n),Y.buffers.depth.setTest(!0),Y.buffers.depth.setMask(!0),Y.buffers.color.setMask(!0),Y.setPolygonOffset(!1)}function Le(e,t,n){const r=!0===t.isScene?t.overrideMaterial:null;for(let i=0,s=e.length;i<s;i++){const s=e[i],a=s.object,o=s.geometry,l=null===r?s.material:r,c=s.group;a.layers.test(n.layers)&&Fe(a,t,n,o,l,c)}}function Fe(e,t,n,r,i,s){e.onBeforeRender(m,t,n,r,i,s),e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,e.matrixWorld),e.normalMatrix.getNormalMatrix(e.modelViewMatrix),i.onBeforeRender(m,t,n,r,e,s),!0===i.transparent&&2===i.side?(i.side=1,i.needsUpdate=!0,m.renderBufferDirect(n,t,r,i,e,s),i.side=0,i.needsUpdate=!0,m.renderBufferDirect(n,t,r,i,e,s),i.side=2):m.renderBufferDirect(n,t,r,i,e,s),e.onAfterRender(m,t,n,r,i,s)}function Pe(e,t,n){!0!==t.isScene&&(t=H);const r=Z.get(e),i=d.state.lights,s=d.state.shadowsArray,a=i.state.version,o=ie.getParameters(e,i.state,s,t,n),l=ie.getProgramCacheKey(o);let c=r.programs;r.environment=e.isMeshStandardMaterial?t.environment:null,r.fog=t.fog,r.envMap=(e.isMeshStandardMaterial?ee:Q).get(e.envMap||r.environment),void 0===c&&(e.addEventListener("dispose",Me),c=new Map,r.programs=c);let u=c.get(l);if(void 0!==u){if(r.currentProgram===u&&r.lightsStateVersion===a)return Oe(e,o),u}else o.uniforms=ie.getUniforms(e),e.onBuild(n,o,m),e.onBeforeCompile(o,m),u=ie.acquireProgram(o,l),c.set(l,u),r.uniforms=o.uniforms;const h=r.uniforms;(e.isShaderMaterial||e.isRawShaderMaterial)&&!0!==e.clipping||(h.clippingPlanes=ce.uniform),Oe(e,o),r.needsLights=function(e){return e.isMeshLambertMaterial||e.isMeshToonMaterial||e.isMeshPhongMaterial||e.isMeshStandardMaterial||e.isShadowMaterial||e.isShaderMaterial&&!0===e.lights}(e),r.lightsStateVersion=a,r.needsLights&&(h.ambientLightColor.value=i.state.ambient,h.lightProbe.value=i.state.probe,h.directionalLights.value=i.state.directional,h.directionalLightShadows.value=i.state.directionalShadow,h.spotLights.value=i.state.spot,h.spotLightShadows.value=i.state.spotShadow,h.rectAreaLights.value=i.state.rectArea,h.ltc_1.value=i.state.rectAreaLTC1,h.ltc_2.value=i.state.rectAreaLTC2,h.pointLights.value=i.state.point,h.pointLightShadows.value=i.state.pointShadow,h.hemisphereLights.value=i.state.hemi,h.directionalShadowMap.value=i.state.directionalShadowMap,h.directionalShadowMatrix.value=i.state.directionalShadowMatrix,h.spotShadowMap.value=i.state.spotShadowMap,h.spotShadowMatrix.value=i.state.spotShadowMatrix,h.pointShadowMap.value=i.state.pointShadowMap,h.pointShadowMatrix.value=i.state.pointShadowMatrix);const p=u.getUniforms(),f=es.seqWithValue(p.seq,h);return r.currentProgram=u,r.uniformsList=f,u}function Oe(e,t){const n=Z.get(e);n.outputEncoding=t.outputEncoding,n.instancing=t.instancing,n.skinning=t.skinning,n.morphTargets=t.morphTargets,n.morphNormals=t.morphNormals,n.morphColors=t.morphColors,n.morphTargetsCount=t.morphTargetsCount,n.numClippingPlanes=t.numClippingPlanes,n.numIntersection=t.numClipIntersection,n.vertexAlphas=t.vertexAlphas,n.vertexTangents=t.vertexTangents,n.toneMapping=t.toneMapping}Ne.setAnimationLoop((function(e){Ee&&Ee(e)})),"undefined"!=typeof self&&Ne.setContext(self),this.setAnimationLoop=function(e){Ee=e,be.setAnimationLoop(e),null===e?Ne.stop():Ne.start()},be.addEventListener("sessionstart",Ce),be.addEventListener("sessionend",Ie),this.render=function(e,t){if(void 0!==t&&!0!==t.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===g)return;!0===e.autoUpdate&&e.updateMatrixWorld(),null===t.parent&&t.updateMatrixWorld(),!0===be.enabled&&!0===be.isPresenting&&(!0===be.cameraAutoUpdate&&be.updateCamera(t),t=be.getCamera()),!0===e.isScene&&e.onBeforeRender(m,e,t,w),d=le.get(e,f.length),d.init(),f.push(d),V.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),z.setFromProjectionMatrix(V),U=this.localClippingEnabled,B=ce.init(this.clippingPlanes,U,t),h=oe.get(e,p.length),h.init(),p.push(h),ke(e,t,0,m.sortObjects),h.finish(),!0===m.sortObjects&&h.sort(D,L),!0===B&&ce.beginShadows();const n=d.state.shadowsArray;if(ue.render(n,e,t),!0===B&&ce.endShadows(),!0===this.info.autoReset&&this.info.reset(),he.render(h,e),d.setupLights(m.physicallyCorrectLights),t.isArrayCamera){const n=t.cameras;for(let t=0,r=n.length;t<r;t++){const r=n[t];De(h,e,r,r.viewport)}}else De(h,e,t);null!==w&&(J.updateMultisampleRenderTarget(w),J.updateRenderTargetMipmap(w)),!0===e.isScene&&e.onAfterRender(m,e,t),ge.resetDefaultState(),M=-1,E=null,f.pop(),d=f.length>0?f[f.length-1]:null,p.pop(),h=p.length>0?p[p.length-1]:null},this.getActiveCubeFace=function(){return y},this.getActiveMipmapLevel=function(){return b},this.getRenderTarget=function(){return w},this.setRenderTargetTextures=function(e,t,n){Z.get(e.texture).__webglTexture=t,Z.get(e.depthTexture).__webglTexture=n;const r=Z.get(e);r.__hasExternalTextures=!0,r.__hasExternalTextures&&(r.__autoAllocateDepthBuffer=void 0===n,r.__autoAllocateDepthBuffer||!0===q.has("WEBGL_multisampled_render_to_texture")&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),r.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(e,t){const n=Z.get(e);n.__webglFramebuffer=t,n.__useDefaultFramebuffer=void 0===t},this.setRenderTarget=function(e,t=0,n=0){w=e,y=t,b=n;let r=!0;if(e){const t=Z.get(e);void 0!==t.__useDefaultFramebuffer?(Y.bindFramebuffer(ye.FRAMEBUFFER,null),r=!1):void 0===t.__webglFramebuffer?J.setupRenderTarget(e):t.__hasExternalTextures&&J.rebindTextures(e,Z.get(e.texture).__webglTexture,Z.get(e.depthTexture).__webglTexture)}let i=null,s=!1,a=!1;if(e){const n=e.texture;(n.isData3DTexture||n.isDataArrayTexture)&&(a=!0);const r=Z.get(e).__webglFramebuffer;e.isWebGLCubeRenderTarget?(i=r[t],s=!0):i=X.isWebGL2&&e.samples>0&&!1===J.useMultisampledRTT(e)?Z.get(e).__webglMultisampledFramebuffer:r,A.copy(e.viewport),C.copy(e.scissor),I=e.scissorTest}else A.copy(F).multiplyScalar(R).floor(),C.copy(P).multiplyScalar(R).floor(),I=O;if(Y.bindFramebuffer(ye.FRAMEBUFFER,i)&&X.drawBuffers&&r&&Y.drawBuffers(e,i),Y.viewport(A),Y.scissor(C),Y.setScissorTest(I),s){const r=Z.get(e.texture);ye.framebufferTexture2D(ye.FRAMEBUFFER,ye.COLOR_ATTACHMENT0,ye.TEXTURE_CUBE_MAP_POSITIVE_X+t,r.__webglTexture,n)}else if(a){const r=Z.get(e.texture),i=t||0;ye.framebufferTextureLayer(ye.FRAMEBUFFER,ye.COLOR_ATTACHMENT0,r.__webglTexture,n||0,i)}M=-1},this.readRenderTargetPixels=function(e,t,n,r,i,s,a){if(!e||!e.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let o=Z.get(e).__webglFramebuffer;if(e.isWebGLCubeRenderTarget&&void 0!==a&&(o=o[a]),o){Y.bindFramebuffer(ye.FRAMEBUFFER,o);try{const a=e.texture,o=a.format,l=a.type;if(o!==T&&me.convert(o)!==ye.getParameter(ye.IMPLEMENTATION_COLOR_READ_FORMAT))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const c=l===S&&(q.has("EXT_color_buffer_half_float")||X.isWebGL2&&q.has("EXT_color_buffer_float"));if(!(l===x||me.convert(l)===ye.getParameter(ye.IMPLEMENTATION_COLOR_READ_TYPE)||l===_&&(X.isWebGL2||q.has("OES_texture_float")||q.has("WEBGL_color_buffer_float"))||c))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");t>=0&&t<=e.width-r&&n>=0&&n<=e.height-i&&ye.readPixels(t,n,r,i,me.convert(o),me.convert(l),s)}finally{const e=null!==w?Z.get(w).__webglFramebuffer:null;Y.bindFramebuffer(ye.FRAMEBUFFER,e)}}},this.copyFramebufferToTexture=function(e,t,n=0){const r=Math.pow(2,-n),i=Math.floor(t.image.width*r),s=Math.floor(t.image.height*r);J.setTexture2D(t,0),ye.copyTexSubImage2D(ye.TEXTURE_2D,n,0,0,e.x,e.y,i,s),Y.unbindTexture()},this.copyTextureToTexture=function(e,t,n,r=0){const i=t.image.width,s=t.image.height,a=me.convert(n.format),o=me.convert(n.type);J.setTexture2D(n,0),ye.pixelStorei(ye.UNPACK_FLIP_Y_WEBGL,n.flipY),ye.pixelStorei(ye.UNPACK_PREMULTIPLY_ALPHA_WEBGL,n.premultiplyAlpha),ye.pixelStorei(ye.UNPACK_ALIGNMENT,n.unpackAlignment),t.isDataTexture?ye.texSubImage2D(ye.TEXTURE_2D,r,e.x,e.y,i,s,a,o,t.image.data):t.isCompressedTexture?ye.compressedTexSubImage2D(ye.TEXTURE_2D,r,e.x,e.y,t.mipmaps[0].width,t.mipmaps[0].height,a,t.mipmaps[0].data):ye.texSubImage2D(ye.TEXTURE_2D,r,e.x,e.y,a,o,t.image),0===r&&n.generateMipmaps&&ye.generateMipmap(ye.TEXTURE_2D),Y.unbindTexture()},this.copyTextureToTexture3D=function(e,t,n,r,i=0){if(m.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const s=e.max.x-e.min.x+1,a=e.max.y-e.min.y+1,o=e.max.z-e.min.z+1,l=me.convert(r.format),c=me.convert(r.type);let u;if(r.isData3DTexture)J.setTexture3D(r,0),u=ye.TEXTURE_3D;else{if(!r.isDataArrayTexture)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");J.setTexture2DArray(r,0),u=ye.TEXTURE_2D_ARRAY}ye.pixelStorei(ye.UNPACK_FLIP_Y_WEBGL,r.flipY),ye.pixelStorei(ye.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r.premultiplyAlpha),ye.pixelStorei(ye.UNPACK_ALIGNMENT,r.unpackAlignment);const h=ye.getParameter(ye.UNPACK_ROW_LENGTH),d=ye.getParameter(ye.UNPACK_IMAGE_HEIGHT),p=ye.getParameter(ye.UNPACK_SKIP_PIXELS),f=ye.getParameter(ye.UNPACK_SKIP_ROWS),g=ye.getParameter(ye.UNPACK_SKIP_IMAGES),y=n.isCompressedTexture?n.mipmaps[0]:n.image;ye.pixelStorei(ye.UNPACK_ROW_LENGTH,y.width),ye.pixelStorei(ye.UNPACK_IMAGE_HEIGHT,y.height),ye.pixelStorei(ye.UNPACK_SKIP_PIXELS,e.min.x),ye.pixelStorei(ye.UNPACK_SKIP_ROWS,e.min.y),ye.pixelStorei(ye.UNPACK_SKIP_IMAGES,e.min.z),n.isDataTexture||n.isData3DTexture?ye.texSubImage3D(u,i,t.x,t.y,t.z,s,a,o,l,c,y.data):n.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),ye.compressedTexSubImage3D(u,i,t.x,t.y,t.z,s,a,o,l,y.data)):ye.texSubImage3D(u,i,t.x,t.y,t.z,s,a,o,l,c,y),ye.pixelStorei(ye.UNPACK_ROW_LENGTH,h),ye.pixelStorei(ye.UNPACK_IMAGE_HEIGHT,d),ye.pixelStorei(ye.UNPACK_SKIP_PIXELS,p),ye.pixelStorei(ye.UNPACK_SKIP_ROWS,f),ye.pixelStorei(ye.UNPACK_SKIP_IMAGES,g),0===i&&r.generateMipmaps&&ye.generateMipmap(u),Y.unbindTexture()},this.initTexture=function(e){J.setTexture2D(e,0),Y.unbindTexture()},this.resetState=function(){y=0,b=0,w=null,Y.reset(),ge.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class Xs extends qs{}Xs.prototype.isWebGL1Renderer=!0;class Ys{constructor(e,t=25e-5){this.isFogExp2=!0,this.name="",this.color=new We(e),this.density=t}clone(){return new Ys(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}class Ks{constructor(e,t=1,n=1e3){this.isFog=!0,this.name="",this.color=new We(e),this.near=t,this.far=n}clone(){return new Ks(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class Zs extends rn{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),null!==e.background&&(this.background=e.background.clone()),null!==e.environment&&(this.environment=e.environment.clone()),null!==e.fog&&(this.fog=e.fog.clone()),null!==e.overrideMaterial&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return null!==this.fog&&(t.object.fog=this.fog.toJSON()),t}}class Js{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=void 0!==e?e.length/t:0,this.usage=he,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=xe()}onUploadCallback(){}set needsUpdate(e){!0===e&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,n){e*=this.stride,n*=t.stride;for(let r=0,i=this.stride;r<i;r++)this.array[e+r]=t.array[n+r];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=xe()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(t,this.stride);return n.setUsage(this.usage),n}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=xe()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Qs=new tt;class ea{constructor(e,t,n,r=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=!0===r}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,n=this.data.count;t<n;t++)Qs.fromBufferAttribute(this,t),Qs.applyMatrix4(e),this.setXYZ(t,Qs.x,Qs.y,Qs.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Qs.fromBufferAttribute(this,t),Qs.applyNormalMatrix(e),this.setXYZ(t,Qs.x,Qs.y,Qs.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Qs.fromBufferAttribute(this,t),Qs.transformDirection(e),this.setXYZ(t,Qs.x,Qs.y,Qs.z);return this}setX(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){return this.data.array[e*this.data.stride+this.offset]}getY(e){return this.data.array[e*this.data.stride+this.offset+1]}getZ(e){return this.data.array[e*this.data.stride+this.offset+2]}getW(e){return this.data.array[e*this.data.stride+this.offset+3]}setXY(e,t,n){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this}setXYZ(e,t,n,r){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=r,this}setXYZW(e,t,n,r,i){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=r,this.data.array[e+3]=i,this}clone(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const n=t*this.data.stride+this.offset;for(let t=0;t<this.itemSize;t++)e.push(this.data.array[n+t])}return new wn(new this.array.constructor(e),this.itemSize,this.normalized)}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new ea(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const n=t*this.data.stride+this.offset;for(let t=0;t<this.itemSize;t++)e.push(this.data.array[n+t])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class ta extends yn{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new We(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let na;const ra=new tt,ia=new tt,sa=new tt,aa=new Ae,oa=new Ae,la=new Rt,ca=new tt,ua=new tt,ha=new tt,da=new Ae,pa=new Ae,fa=new Ae;class ma extends rn{constructor(e){if(super(),this.isSprite=!0,this.type="Sprite",void 0===na){na=new Rn;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),t=new Js(e,5);na.setIndex([0,1,2,0,2,3]),na.setAttribute("position",new ea(t,3,0,!1)),na.setAttribute("uv",new ea(t,2,3,!1))}this.geometry=na,this.material=void 0!==e?e:new ta,this.center=new Ae(.5,.5)}raycast(e,t){null===e.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),ia.setFromMatrixScale(this.matrixWorld),la.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),sa.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&ia.multiplyScalar(-sa.z);const n=this.material.rotation;let r,i;0!==n&&(i=Math.cos(n),r=Math.sin(n));const s=this.center;ga(ca.set(-.5,-.5,0),sa,s,ia,r,i),ga(ua.set(.5,-.5,0),sa,s,ia,r,i),ga(ha.set(.5,.5,0),sa,s,ia,r,i),da.set(0,0),pa.set(1,0),fa.set(1,1);let a=e.ray.intersectTriangle(ca,ua,ha,!1,ra);if(null===a&&(ga(ua.set(-.5,.5,0),sa,s,ia,r,i),pa.set(0,1),a=e.ray.intersectTriangle(ca,ha,ua,!1,ra),null===a))return;const o=e.ray.origin.distanceTo(ra);o<e.near||o>e.far||t.push({distance:o,point:ra.clone(),uv:mn.getUV(ra,ca,ua,ha,da,pa,fa,new Ae),face:null,object:this})}copy(e,t){return super.copy(e,t),void 0!==e.center&&this.center.copy(e.center),this.material=e.material,this}}function ga(e,t,n,r,i,s){aa.subVectors(e,n).addScalar(.5).multiply(r),void 0!==i?(oa.x=s*aa.x-i*aa.y,oa.y=i*aa.x+s*aa.y):oa.copy(aa),e.copy(t),e.x+=oa.x,e.y+=oa.y,e.applyMatrix4(la)}const ya=new tt,va=new tt;class xa extends rn{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let e=0,n=t.length;e<n;e++){const n=t[e];this.addLevel(n.object.clone(),n.distance)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0){t=Math.abs(t);const n=this.levels;let r;for(r=0;r<n.length&&!(t<n[r].distance);r++);return n.splice(r,0,{distance:t,object:e}),this.add(e),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let n,r;for(n=1,r=t.length;n<r&&!(e<t[n].distance);n++);return t[n-1].object}return null}raycast(e,t){if(this.levels.length>0){ya.setFromMatrixPosition(this.matrixWorld);const n=e.ray.origin.distanceTo(ya);this.getObjectForDistance(n).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){ya.setFromMatrixPosition(e.matrixWorld),va.setFromMatrixPosition(this.matrixWorld);const n=ya.distanceTo(va)/e.zoom;let r,i;for(t[0].object.visible=!0,r=1,i=t.length;r<i&&n>=t[r].distance;r++)t[r-1].object.visible=!1,t[r].object.visible=!0;for(this._currentLevel=r-1;r<i;r++)t[r].object.visible=!1}}toJSON(e){const t=super.toJSON(e);!1===this.autoUpdate&&(t.object.autoUpdate=!1),t.object.levels=[];const n=this.levels;for(let e=0,r=n.length;e<r;e++){const r=n[e];t.object.levels.push({object:r.object.uuid,distance:r.distance})}return t}}const ba=new tt,wa=new Ke,_a=new Ke,Sa=new tt,Ma=new Rt;class Ta extends Kn{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Rt,this.bindMatrixInverse=new Rt}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this}bind(e,t){this.skeleton=e,void 0===t&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new Ke,t=this.geometry.attributes.skinWeight;for(let n=0,r=t.count;n<r;n++){e.fromBufferAttribute(t,n);const r=1/e.manhattanLength();r!==1/0?e.multiplyScalar(r):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){const n=this.skeleton,r=this.geometry;wa.fromBufferAttribute(r.attributes.skinIndex,e),_a.fromBufferAttribute(r.attributes.skinWeight,e),ba.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let e=0;e<4;e++){const r=_a.getComponent(e);if(0!==r){const i=wa.getComponent(e);Ma.multiplyMatrices(n.bones[i].matrixWorld,n.boneInverses[i]),t.addScaledVector(Sa.copy(ba).applyMatrix4(Ma),r)}}return t.applyMatrix4(this.bindMatrixInverse)}}class Ea extends rn{constructor(){super(),this.isBone=!0,this.type="Bone"}}class Aa extends Ye{constructor(e=null,t=1,n=1,r,i,s,a,o,l=1003,c=1003,u,h){super(null,s,a,o,l,c,r,i,u,h),this.isDataTexture=!0,this.image={data:e,width:t,height:n},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const Ca=new Rt,Ia=new Rt;class Na{constructor(e=[],t=[]){this.uuid=xe(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(16*e.length),0===t.length)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let e=0,t=this.bones.length;e<t;e++)this.boneInverses.push(new Rt)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const t=new Rt;this.bones[e]&&t.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(t)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const t=this.bones[e];t&&t.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const t=this.bones[e];t&&(t.parent&&t.parent.isBone?(t.matrix.copy(t.parent.matrixWorld).invert(),t.matrix.multiply(t.matrixWorld)):t.matrix.copy(t.matrixWorld),t.matrix.decompose(t.position,t.quaternion,t.scale))}}update(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,r=this.boneTexture;for(let r=0,i=e.length;r<i;r++){const i=e[r]?e[r].matrixWorld:Ia;Ca.multiplyMatrices(i,t[r]),Ca.toArray(n,16*r)}null!==r&&(r.needsUpdate=!0)}clone(){return new Na(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(4*this.bones.length);e=Me(e),e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const n=new Aa(t,e,e,T,_);return n.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=n,this.boneTextureSize=e,this}getBoneByName(e){for(let t=0,n=this.bones.length;t<n;t++){const n=this.bones[t];if(n.name===e)return n}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let n=0,r=e.bones.length;n<r;n++){const r=e.bones[n];let i=t[r];void 0===i&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),i=new Ea),this.bones.push(i),this.boneInverses.push((new Rt).fromArray(e.boneInverses[n]))}return this.init(),this}toJSON(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,n=this.boneInverses;for(let r=0,i=t.length;r<i;r++){const i=t[r];e.bones.push(i.uuid);const s=n[r];e.boneInverses.push(s.toArray())}return e}}class ka extends wn{constructor(e,t,n,r=1){"number"==typeof n&&(r=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(e,t,n),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=r}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const Ra=new Rt,Da=new Rt,La=[],Fa=new Kn;class Pa extends Kn{constructor(e,t,n){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new ka(new Float32Array(16*n),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),null!==e.instanceColor&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,this}getColorAt(e,t){t.fromArray(this.instanceColor.array,3*e)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,16*e)}raycast(e,t){const n=this.matrixWorld,r=this.count;if(Fa.geometry=this.geometry,Fa.material=this.material,void 0!==Fa.material)for(let i=0;i<r;i++){this.getMatrixAt(i,Ra),Da.multiplyMatrices(n,Ra),Fa.matrixWorld=Da,Fa.raycast(e,La);for(let e=0,n=La.length;e<n;e++){const n=La[e];n.instanceId=i,n.object=this,t.push(n)}La.length=0}}setColorAt(e,t){null===this.instanceColor&&(this.instanceColor=new ka(new Float32Array(3*this.instanceMatrix.count),3)),t.toArray(this.instanceColor.array,3*e)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,16*e)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}class Oa extends yn{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new We(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const za=new tt,Ba=new tt,Ua=new Rt,$a=new kt,Va=new St;class Wa extends rn{constructor(e=new Rn,t=new Oa){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(null===e.index){const t=e.attributes.position,n=[0];for(let e=1,r=t.count;e<r;e++)za.fromBufferAttribute(t,e-1),Ba.fromBufferAttribute(t,e),n[e]=n[e-1],n[e]+=za.distanceTo(Ba);e.setAttribute("lineDistance",new Mn(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const n=this.geometry,r=this.matrixWorld,i=e.params.Line.threshold,s=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),Va.copy(n.boundingSphere),Va.applyMatrix4(r),Va.radius+=i,!1===e.ray.intersectsSphere(Va))return;Ua.copy(r).invert(),$a.copy(e.ray).applyMatrix4(Ua);const a=i/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a,l=new tt,c=new tt,u=new tt,h=new tt,d=this.isLineSegments?2:1,p=n.index,f=n.attributes.position;if(null!==p)for(let n=Math.max(0,s.start),r=Math.min(p.count,s.start+s.count)-1;n<r;n+=d){const r=p.getX(n),i=p.getX(n+1);if(l.fromBufferAttribute(f,r),c.fromBufferAttribute(f,i),$a.distanceSqToSegment(l,c,h,u)>o)continue;h.applyMatrix4(this.matrixWorld);const s=e.ray.origin.distanceTo(h);s<e.near||s>e.far||t.push({distance:s,point:u.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}else for(let n=Math.max(0,s.start),r=Math.min(f.count,s.start+s.count)-1;n<r;n+=d){if(l.fromBufferAttribute(f,n),c.fromBufferAttribute(f,n+1),$a.distanceSqToSegment(l,c,h,u)>o)continue;h.applyMatrix4(this.matrixWorld);const r=e.ray.origin.distanceTo(h);r<e.near||r>e.far||t.push({distance:r,point:u.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}updateMorphTargets(){const e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){const n=e[t[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,t=n.length;e<t;e++){const t=n[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[t]=e}}}}}const Ga=new tt,Ha=new tt;class ja extends Wa{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(null===e.index){const t=e.attributes.position,n=[];for(let e=0,r=t.count;e<r;e+=2)Ga.fromBufferAttribute(t,e),Ha.fromBufferAttribute(t,e+1),n[e]=0===e?0:n[e-1],n[e+1]=n[e]+Ga.distanceTo(Ha);e.setAttribute("lineDistance",new Mn(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class qa extends Wa{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}class Xa extends yn{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new We(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const Ya=new Rt,Ka=new kt,Za=new St,Ja=new tt;class Qa extends rn{constructor(e=new Rn,t=new Xa){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){const n=this.geometry,r=this.matrixWorld,i=e.params.Points.threshold,s=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),Za.copy(n.boundingSphere),Za.applyMatrix4(r),Za.radius+=i,!1===e.ray.intersectsSphere(Za))return;Ya.copy(r).invert(),Ka.copy(e.ray).applyMatrix4(Ya);const a=i/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a,l=n.index,c=n.attributes.position;if(null!==l)for(let n=Math.max(0,s.start),i=Math.min(l.count,s.start+s.count);n<i;n++){const i=l.getX(n);Ja.fromBufferAttribute(c,i),eo(Ja,i,o,r,e,t,this)}else for(let n=Math.max(0,s.start),i=Math.min(c.count,s.start+s.count);n<i;n++)Ja.fromBufferAttribute(c,n),eo(Ja,n,o,r,e,t,this)}updateMorphTargets(){const e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){const n=e[t[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,t=n.length;e<t;e++){const t=n[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[t]=e}}}}}function eo(e,t,n,r,i,s,a){const o=Ka.distanceSqToPoint(e);if(o<n){const n=new tt;Ka.closestPointToPoint(e,n),n.applyMatrix4(r);const l=i.ray.origin.distanceTo(n);if(l<i.near||l>i.far)return;s.push({distance:l,distanceToRay:Math.sqrt(o),point:n,index:t,face:null,object:a})}}class to extends Ye{constructor(e,t,n,r,i,s,a,o,l,c,u,h){super(null,s,a,o,l,c,r,i,u,h),this.isCompressedTexture=!0,this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}class no{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)}getPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t}getSpacedPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,r=this.getPoint(0),i=0;t.push(0);for(let s=1;s<=e;s++)n=this.getPoint(s/e),i+=n.distanceTo(r),t.push(i),r=n;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const n=this.getLengths();let r=0;const i=n.length;let s;s=t||e*n[i-1];let a,o=0,l=i-1;for(;o<=l;)if(r=Math.floor(o+(l-o)/2),a=n[r]-s,a<0)o=r+1;else{if(!(a>0)){l=r;break}l=r-1}if(r=l,n[r]===s)return r/(i-1);const c=n[r];return(r+(s-c)/(n[r+1]-c))/(i-1)}getTangent(e,t){const n=1e-4;let r=e-n,i=e+n;r<0&&(r=0),i>1&&(i=1);const s=this.getPoint(r),a=this.getPoint(i),o=t||(s.isVector2?new Ae:new tt);return o.copy(a).sub(s).normalize(),o}getTangentAt(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)}computeFrenetFrames(e,t){const n=new tt,r=[],i=[],s=[],a=new tt,o=new Rt;for(let t=0;t<=e;t++){const n=t/e;r[t]=this.getTangentAt(n,new tt)}i[0]=new tt,s[0]=new tt;let l=Number.MAX_VALUE;const c=Math.abs(r[0].x),u=Math.abs(r[0].y),h=Math.abs(r[0].z);c<=l&&(l=c,n.set(1,0,0)),u<=l&&(l=u,n.set(0,1,0)),h<=l&&n.set(0,0,1),a.crossVectors(r[0],n).normalize(),i[0].crossVectors(r[0],a),s[0].crossVectors(r[0],i[0]);for(let t=1;t<=e;t++){if(i[t]=i[t-1].clone(),s[t]=s[t-1].clone(),a.crossVectors(r[t-1],r[t]),a.length()>Number.EPSILON){a.normalize();const e=Math.acos(be(r[t-1].dot(r[t]),-1,1));i[t].applyMatrix4(o.makeRotationAxis(a,e))}s[t].crossVectors(r[t],i[t])}if(!0===t){let t=Math.acos(be(i[0].dot(i[e]),-1,1));t/=e,r[0].dot(a.crossVectors(i[0],i[e]))>0&&(t=-t);for(let n=1;n<=e;n++)i[n].applyMatrix4(o.makeRotationAxis(r[n],t*n)),s[n].crossVectors(r[n],i[n])}return{tangents:r,normals:i,binormals:s}}clone(){return(new this.constructor).copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class ro extends no{constructor(e=0,t=0,n=1,r=1,i=0,s=2*Math.PI,a=!1,o=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=n,this.yRadius=r,this.aStartAngle=i,this.aEndAngle=s,this.aClockwise=a,this.aRotation=o}getPoint(e,t){const n=t||new Ae,r=2*Math.PI;let i=this.aEndAngle-this.aStartAngle;const s=Math.abs(i)<Number.EPSILON;for(;i<0;)i+=r;for(;i>r;)i-=r;i<Number.EPSILON&&(i=s?0:r),!0!==this.aClockwise||s||(i===r?i=-r:i-=r);const a=this.aStartAngle+e*i;let o=this.aX+this.xRadius*Math.cos(a),l=this.aY+this.yRadius*Math.sin(a);if(0!==this.aRotation){const e=Math.cos(this.aRotation),t=Math.sin(this.aRotation),n=o-this.aX,r=l-this.aY;o=n*e-r*t+this.aX,l=n*t+r*e+this.aY}return n.set(o,l)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class io extends ro{constructor(e,t,n,r,i,s){super(e,t,n,n,r,i,s),this.isArcCurve=!0,this.type="ArcCurve"}}function so(){let e=0,t=0,n=0,r=0;function i(i,s,a,o){e=i,t=a,n=-3*i+3*s-2*a-o,r=2*i-2*s+a+o}return{initCatmullRom:function(e,t,n,r,s){i(t,n,s*(n-e),s*(r-t))},initNonuniformCatmullRom:function(e,t,n,r,s,a,o){let l=(t-e)/s-(n-e)/(s+a)+(n-t)/a,c=(n-t)/a-(r-t)/(a+o)+(r-n)/o;l*=a,c*=a,i(t,n,l,c)},calc:function(i){const s=i*i;return e+t*i+n*s+r*(s*i)}}}const ao=new tt,oo=new so,lo=new so,co=new so;class uo extends no{constructor(e=[],t=!1,n="centripetal",r=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=r}getPoint(e,t=new tt){const n=t,r=this.points,i=r.length,s=(i-(this.closed?0:1))*e;let a,o,l=Math.floor(s),c=s-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/i)+1)*i:0===c&&l===i-1&&(l=i-2,c=1),this.closed||l>0?a=r[(l-1)%i]:(ao.subVectors(r[0],r[1]).add(r[0]),a=ao);const u=r[l%i],h=r[(l+1)%i];if(this.closed||l+2<i?o=r[(l+2)%i]:(ao.subVectors(r[i-1],r[i-2]).add(r[i-1]),o=ao),"centripetal"===this.curveType||"chordal"===this.curveType){const e="chordal"===this.curveType?.5:.25;let t=Math.pow(a.distanceToSquared(u),e),n=Math.pow(u.distanceToSquared(h),e),r=Math.pow(h.distanceToSquared(o),e);n<1e-4&&(n=1),t<1e-4&&(t=n),r<1e-4&&(r=n),oo.initNonuniformCatmullRom(a.x,u.x,h.x,o.x,t,n,r),lo.initNonuniformCatmullRom(a.y,u.y,h.y,o.y,t,n,r),co.initNonuniformCatmullRom(a.z,u.z,h.z,o.z,t,n,r)}else"catmullrom"===this.curveType&&(oo.initCatmullRom(a.x,u.x,h.x,o.x,this.tension),lo.initCatmullRom(a.y,u.y,h.y,o.y,this.tension),co.initCatmullRom(a.z,u.z,h.z,o.z,this.tension));return n.set(oo.calc(c),lo.calc(c),co.calc(c)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push(n.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const n=this.points[t];e.points.push(n.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push((new tt).fromArray(n))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function ho(e,t,n,r,i){const s=.5*(r-t),a=.5*(i-n),o=e*e;return(2*n-2*r+s+a)*(e*o)+(-3*n+3*r-2*s-a)*o+s*e+n}function po(e,t,n,r){return function(e,t){const n=1-e;return n*n*t}(e,t)+function(e,t){return 2*(1-e)*e*t}(e,n)+function(e,t){return e*e*t}(e,r)}function fo(e,t,n,r,i){return function(e,t){const n=1-e;return n*n*n*t}(e,t)+function(e,t){const n=1-e;return 3*n*n*e*t}(e,n)+function(e,t){return 3*(1-e)*e*e*t}(e,r)+function(e,t){return e*e*e*t}(e,i)}class mo extends no{constructor(e=new Ae,t=new Ae,n=new Ae,r=new Ae){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=r}getPoint(e,t=new Ae){const n=t,r=this.v0,i=this.v1,s=this.v2,a=this.v3;return n.set(fo(e,r.x,i.x,s.x,a.x),fo(e,r.y,i.y,s.y,a.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class go extends no{constructor(e=new tt,t=new tt,n=new tt,r=new tt){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=r}getPoint(e,t=new tt){const n=t,r=this.v0,i=this.v1,s=this.v2,a=this.v3;return n.set(fo(e,r.x,i.x,s.x,a.x),fo(e,r.y,i.y,s.y,a.y),fo(e,r.z,i.z,s.z,a.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class yo extends no{constructor(e=new Ae,t=new Ae){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new Ae){const n=t;return 1===e?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t){const n=t||new Ae;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class vo extends no{constructor(e=new tt,t=new tt){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=t}getPoint(e,t=new tt){const n=t;return 1===e?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class xo extends no{constructor(e=new Ae,t=new Ae,n=new Ae){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new Ae){const n=t,r=this.v0,i=this.v1,s=this.v2;return n.set(po(e,r.x,i.x,s.x),po(e,r.y,i.y,s.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class bo extends no{constructor(e=new tt,t=new tt,n=new tt){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new tt){const n=t,r=this.v0,i=this.v1,s=this.v2;return n.set(po(e,r.x,i.x,s.x),po(e,r.y,i.y,s.y),po(e,r.z,i.z,s.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class wo extends no{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,t=new Ae){const n=t,r=this.points,i=(r.length-1)*e,s=Math.floor(i),a=i-s,o=r[0===s?s:s-1],l=r[s],c=r[s>r.length-2?r.length-1:s+1],u=r[s>r.length-3?r.length-1:s+2];return n.set(ho(a,o.x,l.x,c.x,u.x),ho(a,o.y,l.y,c.y,u.y)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push(n.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const n=this.points[t];e.points.push(n.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push((new Ae).fromArray(n))}return this}}var _o=Object.freeze({__proto__:null,ArcCurve:io,CatmullRomCurve3:uo,CubicBezierCurve:mo,CubicBezierCurve3:go,EllipseCurve:ro,LineCurve:yo,LineCurve3:vo,QuadraticBezierCurve:xo,QuadraticBezierCurve3:bo,SplineCurve:wo});class So extends no{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new yo(t,e))}getPoint(e,t){const n=e*this.getLength(),r=this.getCurveLengths();let i=0;for(;i<r.length;){if(r[i]>=n){const e=r[i]-n,s=this.curves[i],a=s.getLength(),o=0===a?0:1-e/a;return s.getPointAt(o,t)}i++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,r=this.curves.length;n<r;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let n;for(let r=0,i=this.curves;r<i.length;r++){const s=i[r],a=s.isEllipseCurve?2*e:s.isLineCurve||s.isLineCurve3?1:s.isSplineCurve?e*s.points.length:e,o=s.getPoints(a);for(let e=0;e<o.length;e++){const r=o[e];n&&n.equals(r)||(t.push(r),n=r)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const n=e.curves[t];this.curves.push(n.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const n=this.curves[t];e.curves.push(n.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const n=e.curves[t];this.curves.push((new _o[n.type]).fromJSON(n))}return this}}class Mo extends So{constructor(e){super(),this.type="Path",this.currentPoint=new Ae,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const n=new yo(this.currentPoint.clone(),new Ae(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,n,r){const i=new xo(this.currentPoint.clone(),new Ae(e,t),new Ae(n,r));return this.curves.push(i),this.currentPoint.set(n,r),this}bezierCurveTo(e,t,n,r,i,s){const a=new mo(this.currentPoint.clone(),new Ae(e,t),new Ae(n,r),new Ae(i,s));return this.curves.push(a),this.currentPoint.set(i,s),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),n=new wo(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,n,r,i,s){const a=this.currentPoint.x,o=this.currentPoint.y;return this.absarc(e+a,t+o,n,r,i,s),this}absarc(e,t,n,r,i,s){return this.absellipse(e,t,n,n,r,i,s),this}ellipse(e,t,n,r,i,s,a,o){const l=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(e+l,t+c,n,r,i,s,a,o),this}absellipse(e,t,n,r,i,s,a,o){const l=new ro(e,t,n,r,i,s,a,o);if(this.curves.length>0){const e=l.getPoint(0);e.equals(this.currentPoint)||this.lineTo(e.x,e.y)}this.curves.push(l);const c=l.getPoint(1);return this.currentPoint.copy(c),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class To extends Rn{constructor(e=[new Ae(0,.5),new Ae(.5,0),new Ae(0,-.5)],t=12,n=0,r=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:n,phiLength:r},t=Math.floor(t),r=be(r,0,2*Math.PI);const i=[],s=[],a=[],o=[],l=[],c=1/t,u=new tt,h=new Ae,d=new tt,p=new tt,f=new tt;let m=0,g=0;for(let t=0;t<=e.length-1;t++)switch(t){case 0:m=e[t+1].x-e[t].x,g=e[t+1].y-e[t].y,d.x=1*g,d.y=-m,d.z=0*g,f.copy(d),d.normalize(),o.push(d.x,d.y,d.z);break;case e.length-1:o.push(f.x,f.y,f.z);break;default:m=e[t+1].x-e[t].x,g=e[t+1].y-e[t].y,d.x=1*g,d.y=-m,d.z=0*g,p.copy(d),d.x+=f.x,d.y+=f.y,d.z+=f.z,d.normalize(),o.push(d.x,d.y,d.z),f.copy(p)}for(let i=0;i<=t;i++){const d=n+i*c*r,p=Math.sin(d),f=Math.cos(d);for(let n=0;n<=e.length-1;n++){u.x=e[n].x*p,u.y=e[n].y,u.z=e[n].x*f,s.push(u.x,u.y,u.z),h.x=i/t,h.y=n/(e.length-1),a.push(h.x,h.y);const r=o[3*n+0]*p,c=o[3*n+1],d=o[3*n+0]*f;l.push(r,c,d)}}for(let n=0;n<t;n++)for(let t=0;t<e.length-1;t++){const r=t+n*e.length,s=r,a=r+e.length,o=r+e.length+1,l=r+1;i.push(s,a,l),i.push(o,l,a)}this.setIndex(i),this.setAttribute("position",new Mn(s,3)),this.setAttribute("uv",new Mn(a,2)),this.setAttribute("normal",new Mn(l,3))}static fromJSON(e){return new To(e.points,e.segments,e.phiStart,e.phiLength)}}class Eo extends To{constructor(e=1,t=1,n=4,r=8){const i=new Mo;i.absarc(0,-t/2,e,1.5*Math.PI,0),i.absarc(0,t/2,e,0,.5*Math.PI),super(i.getPoints(n),r),this.type="CapsuleGeometry",this.parameters={radius:e,height:t,capSegments:n,radialSegments:r}}static fromJSON(e){return new Eo(e.radius,e.length,e.capSegments,e.radialSegments)}}class Ao extends Rn{constructor(e=1,t=8,n=0,r=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:n,thetaLength:r},t=Math.max(3,t);const i=[],s=[],a=[],o=[],l=new tt,c=new Ae;s.push(0,0,0),a.push(0,0,1),o.push(.5,.5);for(let i=0,u=3;i<=t;i++,u+=3){const h=n+i/t*r;l.x=e*Math.cos(h),l.y=e*Math.sin(h),s.push(l.x,l.y,l.z),a.push(0,0,1),c.x=(s[u]/e+1)/2,c.y=(s[u+1]/e+1)/2,o.push(c.x,c.y)}for(let e=1;e<=t;e++)i.push(e,e+1,0);this.setIndex(i),this.setAttribute("position",new Mn(s,3)),this.setAttribute("normal",new Mn(a,3)),this.setAttribute("uv",new Mn(o,2))}static fromJSON(e){return new Ao(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class Co extends Rn{constructor(e=1,t=1,n=1,r=8,i=1,s=!1,a=0,o=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:r,heightSegments:i,openEnded:s,thetaStart:a,thetaLength:o};const l=this;r=Math.floor(r),i=Math.floor(i);const c=[],u=[],h=[],d=[];let p=0;const f=[],m=n/2;let g=0;function y(n){const i=p,s=new Ae,f=new tt;let y=0;const v=!0===n?e:t,x=!0===n?1:-1;for(let e=1;e<=r;e++)u.push(0,m*x,0),h.push(0,x,0),d.push(.5,.5),p++;const b=p;for(let e=0;e<=r;e++){const t=e/r*o+a,n=Math.cos(t),i=Math.sin(t);f.x=v*i,f.y=m*x,f.z=v*n,u.push(f.x,f.y,f.z),h.push(0,x,0),s.x=.5*n+.5,s.y=.5*i*x+.5,d.push(s.x,s.y),p++}for(let e=0;e<r;e++){const t=i+e,r=b+e;!0===n?c.push(r,r+1,t):c.push(r+1,r,t),y+=3}l.addGroup(g,y,!0===n?1:2),g+=y}!function(){const s=new tt,y=new tt;let v=0;const x=(t-e)/n;for(let l=0;l<=i;l++){const c=[],g=l/i,v=g*(t-e)+e;for(let e=0;e<=r;e++){const t=e/r,i=t*o+a,l=Math.sin(i),f=Math.cos(i);y.x=v*l,y.y=-g*n+m,y.z=v*f,u.push(y.x,y.y,y.z),s.set(l,x,f).normalize(),h.push(s.x,s.y,s.z),d.push(t,1-g),c.push(p++)}f.push(c)}for(let e=0;e<r;e++)for(let t=0;t<i;t++){const n=f[t][e],r=f[t+1][e],i=f[t+1][e+1],s=f[t][e+1];c.push(n,r,s),c.push(r,i,s),v+=6}l.addGroup(g,v,0),g+=v}(),!1===s&&(e>0&&y(!0),t>0&&y(!1)),this.setIndex(c),this.setAttribute("position",new Mn(u,3)),this.setAttribute("normal",new Mn(h,3)),this.setAttribute("uv",new Mn(d,2))}static fromJSON(e){return new Co(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class Io extends Co{constructor(e=1,t=1,n=8,r=1,i=!1,s=0,a=2*Math.PI){super(0,e,t,n,r,i,s,a),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:n,heightSegments:r,openEnded:i,thetaStart:s,thetaLength:a}}static fromJSON(e){return new Io(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class No extends Rn{constructor(e=[],t=[],n=1,r=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:n,detail:r};const i=[],s=[];function a(e,t,n,r){const i=r+1,s=[];for(let r=0;r<=i;r++){s[r]=[];const a=e.clone().lerp(n,r/i),o=t.clone().lerp(n,r/i),l=i-r;for(let e=0;e<=l;e++)s[r][e]=0===e&&r===i?a:a.clone().lerp(o,e/l)}for(let e=0;e<i;e++)for(let t=0;t<2*(i-e)-1;t++){const n=Math.floor(t/2);t%2==0?(o(s[e][n+1]),o(s[e+1][n]),o(s[e][n])):(o(s[e][n+1]),o(s[e+1][n+1]),o(s[e+1][n]))}}function o(e){i.push(e.x,e.y,e.z)}function l(t,n){const r=3*t;n.x=e[r+0],n.y=e[r+1],n.z=e[r+2]}function c(e,t,n,r){r<0&&1===e.x&&(s[t]=e.x-1),0===n.x&&0===n.z&&(s[t]=r/2/Math.PI+.5)}function u(e){return Math.atan2(e.z,-e.x)}!function(e){const n=new tt,r=new tt,i=new tt;for(let s=0;s<t.length;s+=3)l(t[s+0],n),l(t[s+1],r),l(t[s+2],i),a(n,r,i,e)}(r),function(e){const t=new tt;for(let n=0;n<i.length;n+=3)t.x=i[n+0],t.y=i[n+1],t.z=i[n+2],t.normalize().multiplyScalar(e),i[n+0]=t.x,i[n+1]=t.y,i[n+2]=t.z}(n),function(){const e=new tt;for(let n=0;n<i.length;n+=3){e.x=i[n+0],e.y=i[n+1],e.z=i[n+2];const r=u(e)/2/Math.PI+.5,a=(t=e,Math.atan2(-t.y,Math.sqrt(t.x*t.x+t.z*t.z))/Math.PI+.5);s.push(r,1-a)}var t;(function(){const e=new tt,t=new tt,n=new tt,r=new tt,a=new Ae,o=new Ae,l=new Ae;for(let h=0,d=0;h<i.length;h+=9,d+=6){e.set(i[h+0],i[h+1],i[h+2]),t.set(i[h+3],i[h+4],i[h+5]),n.set(i[h+6],i[h+7],i[h+8]),a.set(s[d+0],s[d+1]),o.set(s[d+2],s[d+3]),l.set(s[d+4],s[d+5]),r.copy(e).add(t).add(n).divideScalar(3);const p=u(r);c(a,d+0,e,p),c(o,d+2,t,p),c(l,d+4,n,p)}})(),function(){for(let e=0;e<s.length;e+=6){const t=s[e+0],n=s[e+2],r=s[e+4],i=Math.max(t,n,r),a=Math.min(t,n,r);i>.9&&a<.1&&(t<.2&&(s[e+0]+=1),n<.2&&(s[e+2]+=1),r<.2&&(s[e+4]+=1))}}()}(),this.setAttribute("position",new Mn(i,3)),this.setAttribute("normal",new Mn(i.slice(),3)),this.setAttribute("uv",new Mn(s,2)),0===r?this.computeVertexNormals():this.normalizeNormals()}static fromJSON(e){return new No(e.vertices,e.indices,e.radius,e.details)}}class ko extends No{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2,r=1/n;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-r,-n,0,-r,n,0,r,-n,0,r,n,-r,-n,0,-r,n,0,r,-n,0,r,n,0,-n,0,-r,n,0,-r,-n,0,r,n,0,r],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new ko(e.radius,e.detail)}}const Ro=new tt,Do=new tt,Lo=new tt,Fo=new mn;class Po extends Rn{constructor(e=null,t=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:t},null!==e){const n=4,r=Math.pow(10,n),i=Math.cos(ye*t),s=e.getIndex(),a=e.getAttribute("position"),o=s?s.count:a.count,l=[0,0,0],c=["a","b","c"],u=new Array(3),h={},d=[];for(let e=0;e<o;e+=3){s?(l[0]=s.getX(e),l[1]=s.getX(e+1),l[2]=s.getX(e+2)):(l[0]=e,l[1]=e+1,l[2]=e+2);const{a:t,b:n,c:o}=Fo;if(t.fromBufferAttribute(a,l[0]),n.fromBufferAttribute(a,l[1]),o.fromBufferAttribute(a,l[2]),Fo.getNormal(Lo),u[0]=`${Math.round(t.x*r)},${Math.round(t.y*r)},${Math.round(t.z*r)}`,u[1]=`${Math.round(n.x*r)},${Math.round(n.y*r)},${Math.round(n.z*r)}`,u[2]=`${Math.round(o.x*r)},${Math.round(o.y*r)},${Math.round(o.z*r)}`,u[0]!==u[1]&&u[1]!==u[2]&&u[2]!==u[0])for(let e=0;e<3;e++){const t=(e+1)%3,n=u[e],r=u[t],s=Fo[c[e]],a=Fo[c[t]],o=`${n}_${r}`,p=`${r}_${n}`;p in h&&h[p]?(Lo.dot(h[p].normal)<=i&&(d.push(s.x,s.y,s.z),d.push(a.x,a.y,a.z)),h[p]=null):o in h||(h[o]={index0:l[e],index1:l[t],normal:Lo.clone()})}}for(const e in h)if(h[e]){const{index0:t,index1:n}=h[e];Ro.fromBufferAttribute(a,t),Do.fromBufferAttribute(a,n),d.push(Ro.x,Ro.y,Ro.z),d.push(Do.x,Do.y,Do.z)}this.setAttribute("position",new Mn(d,3))}}}class Oo extends Mo{constructor(e){super(e),this.uuid=xe(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let n=0,r=this.holes.length;n<r;n++)t[n]=this.holes[n].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const n=e.holes[t];this.holes.push(n.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const n=this.holes[t];e.holes.push(n.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const n=e.holes[t];this.holes.push((new Mo).fromJSON(n))}return this}}function zo(e,t,n,r,i){let s,a;if(i===function(e,t,n,r){let i=0;for(let s=t,a=n-r;s<n;s+=r)i+=(e[a]-e[s])*(e[s+1]+e[a+1]),a=s;return i}(e,t,n,r)>0)for(s=t;s<n;s+=r)a=sl(s,e[s],e[s+1],a);else for(s=n-r;s>=t;s-=r)a=sl(s,e[s],e[s+1],a);return a&&Qo(a,a.next)&&(al(a),a=a.next),a}function Bo(e,t){if(!e)return e;t||(t=e);let n,r=e;do{if(n=!1,r.steiner||!Qo(r,r.next)&&0!==Jo(r.prev,r,r.next))r=r.next;else{if(al(r),r=t=r.prev,r===r.next)break;n=!0}}while(n||r!==t);return t}function Uo(e,t,n,r,i,s,a){if(!e)return;!a&&s&&function(e,t,n,r){let i=e;do{null===i.z&&(i.z=Xo(i.x,i.y,t,n,r)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next}while(i!==e);i.prevZ.nextZ=null,i.prevZ=null,function(e){let t,n,r,i,s,a,o,l,c=1;do{for(n=e,e=null,s=null,a=0;n;){for(a++,r=n,o=0,t=0;t<c&&(o++,r=r.nextZ,r);t++);for(l=c;o>0||l>0&&r;)0!==o&&(0===l||!r||n.z<=r.z)?(i=n,n=n.nextZ,o--):(i=r,r=r.nextZ,l--),s?s.nextZ=i:e=i,i.prevZ=s,s=i;n=r}s.nextZ=null,c*=2}while(a>1)}(i)}(e,r,i,s);let o,l,c=e;for(;e.prev!==e.next;)if(o=e.prev,l=e.next,s?Vo(e,r,i,s):$o(e))t.push(o.i/n),t.push(e.i/n),t.push(l.i/n),al(e),e=l.next,c=l.next;else if((e=l)===c){a?1===a?Uo(e=Wo(Bo(e),t,n),t,n,r,i,s,2):2===a&&Go(e,t,n,r,i,s):Uo(Bo(e),t,n,r,i,s,1);break}}function $o(e){const t=e.prev,n=e,r=e.next;if(Jo(t,n,r)>=0)return!1;let i=e.next.next;for(;i!==e.prev;){if(Ko(t.x,t.y,n.x,n.y,r.x,r.y,i.x,i.y)&&Jo(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function Vo(e,t,n,r){const i=e.prev,s=e,a=e.next;if(Jo(i,s,a)>=0)return!1;const o=i.x<s.x?i.x<a.x?i.x:a.x:s.x<a.x?s.x:a.x,l=i.y<s.y?i.y<a.y?i.y:a.y:s.y<a.y?s.y:a.y,c=i.x>s.x?i.x>a.x?i.x:a.x:s.x>a.x?s.x:a.x,u=i.y>s.y?i.y>a.y?i.y:a.y:s.y>a.y?s.y:a.y,h=Xo(o,l,t,n,r),d=Xo(c,u,t,n,r);let p=e.prevZ,f=e.nextZ;for(;p&&p.z>=h&&f&&f.z<=d;){if(p!==e.prev&&p!==e.next&&Ko(i.x,i.y,s.x,s.y,a.x,a.y,p.x,p.y)&&Jo(p.prev,p,p.next)>=0)return!1;if(p=p.prevZ,f!==e.prev&&f!==e.next&&Ko(i.x,i.y,s.x,s.y,a.x,a.y,f.x,f.y)&&Jo(f.prev,f,f.next)>=0)return!1;f=f.nextZ}for(;p&&p.z>=h;){if(p!==e.prev&&p!==e.next&&Ko(i.x,i.y,s.x,s.y,a.x,a.y,p.x,p.y)&&Jo(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;f&&f.z<=d;){if(f!==e.prev&&f!==e.next&&Ko(i.x,i.y,s.x,s.y,a.x,a.y,f.x,f.y)&&Jo(f.prev,f,f.next)>=0)return!1;f=f.nextZ}return!0}function Wo(e,t,n){let r=e;do{const i=r.prev,s=r.next.next;!Qo(i,s)&&el(i,r,r.next,s)&&rl(i,s)&&rl(s,i)&&(t.push(i.i/n),t.push(r.i/n),t.push(s.i/n),al(r),al(r.next),r=e=s),r=r.next}while(r!==e);return Bo(r)}function Go(e,t,n,r,i,s){let a=e;do{let e=a.next.next;for(;e!==a.prev;){if(a.i!==e.i&&Zo(a,e)){let o=il(a,e);return a=Bo(a,a.next),o=Bo(o,o.next),Uo(a,t,n,r,i,s),void Uo(o,t,n,r,i,s)}e=e.next}a=a.next}while(a!==e)}function Ho(e,t){return e.x-t.x}function jo(e,t){if(t=function(e,t){let n=t;const r=e.x,i=e.y;let s,a=-1/0;do{if(i<=n.y&&i>=n.next.y&&n.next.y!==n.y){const e=n.x+(i-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(e<=r&&e>a){if(a=e,e===r){if(i===n.y)return n;if(i===n.next.y)return n.next}s=n.x<n.next.x?n:n.next}}n=n.next}while(n!==t);if(!s)return null;if(r===a)return s;const o=s,l=s.x,c=s.y;let u,h=1/0;n=s;do{r>=n.x&&n.x>=l&&r!==n.x&&Ko(i<c?r:a,i,l,c,i<c?a:r,i,n.x,n.y)&&(u=Math.abs(i-n.y)/(r-n.x),rl(n,e)&&(u<h||u===h&&(n.x>s.x||n.x===s.x&&qo(s,n)))&&(s=n,h=u)),n=n.next}while(n!==o);return s}(e,t),t){const n=il(t,e);Bo(t,t.next),Bo(n,n.next)}}function qo(e,t){return Jo(e.prev,e,t.prev)<0&&Jo(t.next,e,e.next)<0}function Xo(e,t,n,r,i){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-n)*i)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-r)*i)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function Yo(e){let t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function Ko(e,t,n,r,i,s,a,o){return(i-a)*(t-o)-(e-a)*(s-o)>=0&&(e-a)*(r-o)-(n-a)*(t-o)>=0&&(n-a)*(s-o)-(i-a)*(r-o)>=0}function Zo(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function(e,t){let n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&el(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}(e,t)&&(rl(e,t)&&rl(t,e)&&function(e,t){let n=e,r=!1;const i=(e.x+t.x)/2,s=(e.y+t.y)/2;do{n.y>s!=n.next.y>s&&n.next.y!==n.y&&i<(n.next.x-n.x)*(s-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==e);return r}(e,t)&&(Jo(e.prev,e,t.prev)||Jo(e,t.prev,t))||Qo(e,t)&&Jo(e.prev,e,e.next)>0&&Jo(t.prev,t,t.next)>0)}function Jo(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function Qo(e,t){return e.x===t.x&&e.y===t.y}function el(e,t,n,r){const i=nl(Jo(e,t,n)),s=nl(Jo(e,t,r)),a=nl(Jo(n,r,e)),o=nl(Jo(n,r,t));return i!==s&&a!==o||!(0!==i||!tl(e,n,t))||!(0!==s||!tl(e,r,t))||!(0!==a||!tl(n,e,r))||!(0!==o||!tl(n,t,r))}function tl(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function nl(e){return e>0?1:e<0?-1:0}function rl(e,t){return Jo(e.prev,e,e.next)<0?Jo(e,t,e.next)>=0&&Jo(e,e.prev,t)>=0:Jo(e,t,e.prev)<0||Jo(e,e.next,t)<0}function il(e,t){const n=new ol(e.i,e.x,e.y),r=new ol(t.i,t.x,t.y),i=e.next,s=t.prev;return e.next=t,t.prev=e,n.next=i,i.prev=n,r.next=n,n.prev=r,s.next=r,r.prev=s,r}function sl(e,t,n,r){const i=new ol(e,t,n);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function al(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function ol(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}class ll{static area(e){const t=e.length;let n=0;for(let r=t-1,i=0;i<t;r=i++)n+=e[r].x*e[i].y-e[i].x*e[r].y;return.5*n}static isClockWise(e){return ll.area(e)<0}static triangulateShape(e,t){const n=[],r=[],i=[];cl(e),ul(n,e);let s=e.length;t.forEach(cl);for(let e=0;e<t.length;e++)r.push(s),s+=t[e].length,ul(n,t[e]);const a=function(e,t,n=2){const r=t&&t.length,i=r?t[0]*n:e.length;let s=zo(e,0,i,n,!0);const a=[];if(!s||s.next===s.prev)return a;let o,l,c,u,h,d,p;if(r&&(s=function(e,t,n,r){const i=[];let s,a,o,l,c;for(s=0,a=t.length;s<a;s++)o=t[s]*r,l=s<a-1?t[s+1]*r:e.length,c=zo(e,o,l,r,!1),c===c.next&&(c.steiner=!0),i.push(Yo(c));for(i.sort(Ho),s=0;s<i.length;s++)jo(i[s],n),n=Bo(n,n.next);return n}(e,t,s,n)),e.length>80*n){o=c=e[0],l=u=e[1];for(let t=n;t<i;t+=n)h=e[t],d=e[t+1],h<o&&(o=h),d<l&&(l=d),h>c&&(c=h),d>u&&(u=d);p=Math.max(c-o,u-l),p=0!==p?1/p:0}return Uo(s,a,n,o,l,p),a}(n,r);for(let e=0;e<a.length;e+=3)i.push(a.slice(e,e+3));return i}}function cl(e){const t=e.length;t>2&&e[t-1].equals(e[0])&&e.pop()}function ul(e,t){for(let n=0;n<t.length;n++)e.push(t[n].x),e.push(t[n].y)}class hl extends Rn{constructor(e=new Oo([new Ae(.5,.5),new Ae(-.5,.5),new Ae(-.5,-.5),new Ae(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const n=this,r=[],i=[];for(let t=0,n=e.length;t<n;t++)s(e[t]);function s(e){const s=[],a=void 0!==t.curveSegments?t.curveSegments:12,o=void 0!==t.steps?t.steps:1;let l=void 0!==t.depth?t.depth:1,c=void 0===t.bevelEnabled||t.bevelEnabled,u=void 0!==t.bevelThickness?t.bevelThickness:.2,h=void 0!==t.bevelSize?t.bevelSize:u-.1,d=void 0!==t.bevelOffset?t.bevelOffset:0,p=void 0!==t.bevelSegments?t.bevelSegments:3;const f=t.extrudePath,m=void 0!==t.UVGenerator?t.UVGenerator:dl;void 0!==t.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),l=t.amount);let g,y,v,x,b,w=!1;f&&(g=f.getSpacedPoints(o),w=!0,c=!1,y=f.computeFrenetFrames(o,!1),v=new tt,x=new tt,b=new tt),c||(p=0,u=0,h=0,d=0);const _=e.extractPoints(a);let S=_.shape;const M=_.holes;if(!ll.isClockWise(S)){S=S.reverse();for(let e=0,t=M.length;e<t;e++){const t=M[e];ll.isClockWise(t)&&(M[e]=t.reverse())}}const T=ll.triangulateShape(S,M),E=S;for(let e=0,t=M.length;e<t;e++){const t=M[e];S=S.concat(t)}function A(e,t,n){return t||console.error("THREE.ExtrudeGeometry: vec does not exist"),t.clone().multiplyScalar(n).add(e)}const C=S.length,I=T.length;function N(e,t,n){let r,i,s;const a=e.x-t.x,o=e.y-t.y,l=n.x-e.x,c=n.y-e.y,u=a*a+o*o,h=a*c-o*l;if(Math.abs(h)>Number.EPSILON){const h=Math.sqrt(u),d=Math.sqrt(l*l+c*c),p=t.x-o/h,f=t.y+a/h,m=((n.x-c/d-p)*c-(n.y+l/d-f)*l)/(a*c-o*l);r=p+a*m-e.x,i=f+o*m-e.y;const g=r*r+i*i;if(g<=2)return new Ae(r,i);s=Math.sqrt(g/2)}else{let e=!1;a>Number.EPSILON?l>Number.EPSILON&&(e=!0):a<-Number.EPSILON?l<-Number.EPSILON&&(e=!0):Math.sign(o)===Math.sign(c)&&(e=!0),e?(r=-o,i=a,s=Math.sqrt(u)):(r=a,i=o,s=Math.sqrt(u/2))}return new Ae(r/s,i/s)}const k=[];for(let e=0,t=E.length,n=t-1,r=e+1;e<t;e++,n++,r++)n===t&&(n=0),r===t&&(r=0),k[e]=N(E[e],E[n],E[r]);const R=[];let D,L=k.concat();for(let e=0,t=M.length;e<t;e++){const t=M[e];D=[];for(let e=0,n=t.length,r=n-1,i=e+1;e<n;e++,r++,i++)r===n&&(r=0),i===n&&(i=0),D[e]=N(t[e],t[r],t[i]);R.push(D),L=L.concat(D)}for(let e=0;e<p;e++){const t=e/p,n=u*Math.cos(t*Math.PI/2),r=h*Math.sin(t*Math.PI/2)+d;for(let e=0,t=E.length;e<t;e++){const t=A(E[e],k[e],r);O(t.x,t.y,-n)}for(let e=0,t=M.length;e<t;e++){const t=M[e];D=R[e];for(let e=0,i=t.length;e<i;e++){const i=A(t[e],D[e],r);O(i.x,i.y,-n)}}}const F=h+d;for(let e=0;e<C;e++){const t=c?A(S[e],L[e],F):S[e];w?(x.copy(y.normals[0]).multiplyScalar(t.x),v.copy(y.binormals[0]).multiplyScalar(t.y),b.copy(g[0]).add(x).add(v),O(b.x,b.y,b.z)):O(t.x,t.y,0)}for(let e=1;e<=o;e++)for(let t=0;t<C;t++){const n=c?A(S[t],L[t],F):S[t];w?(x.copy(y.normals[e]).multiplyScalar(n.x),v.copy(y.binormals[e]).multiplyScalar(n.y),b.copy(g[e]).add(x).add(v),O(b.x,b.y,b.z)):O(n.x,n.y,l/o*e)}for(let e=p-1;e>=0;e--){const t=e/p,n=u*Math.cos(t*Math.PI/2),r=h*Math.sin(t*Math.PI/2)+d;for(let e=0,t=E.length;e<t;e++){const t=A(E[e],k[e],r);O(t.x,t.y,l+n)}for(let e=0,t=M.length;e<t;e++){const t=M[e];D=R[e];for(let e=0,i=t.length;e<i;e++){const i=A(t[e],D[e],r);w?O(i.x,i.y+g[o-1].y,g[o-1].x+n):O(i.x,i.y,l+n)}}}function P(e,t){let n=e.length;for(;--n>=0;){const r=n;let i=n-1;i<0&&(i=e.length-1);for(let e=0,n=o+2*p;e<n;e++){const n=C*e,s=C*(e+1);B(t+r+n,t+i+n,t+i+s,t+r+s)}}}function O(e,t,n){s.push(e),s.push(t),s.push(n)}function z(e,t,i){U(e),U(t),U(i);const s=r.length/3,a=m.generateTopUV(n,r,s-3,s-2,s-1);$(a[0]),$(a[1]),$(a[2])}function B(e,t,i,s){U(e),U(t),U(s),U(t),U(i),U(s);const a=r.length/3,o=m.generateSideWallUV(n,r,a-6,a-3,a-2,a-1);$(o[0]),$(o[1]),$(o[3]),$(o[1]),$(o[2]),$(o[3])}function U(e){r.push(s[3*e+0]),r.push(s[3*e+1]),r.push(s[3*e+2])}function $(e){i.push(e.x),i.push(e.y)}!function(){const e=r.length/3;if(c){let e=0,t=C*e;for(let e=0;e<I;e++){const n=T[e];z(n[2]+t,n[1]+t,n[0]+t)}e=o+2*p,t=C*e;for(let e=0;e<I;e++){const n=T[e];z(n[0]+t,n[1]+t,n[2]+t)}}else{for(let e=0;e<I;e++){const t=T[e];z(t[2],t[1],t[0])}for(let e=0;e<I;e++){const t=T[e];z(t[0]+C*o,t[1]+C*o,t[2]+C*o)}}n.addGroup(e,r.length/3-e,0)}(),function(){const e=r.length/3;let t=0;P(E,t),t+=E.length;for(let e=0,n=M.length;e<n;e++){const n=M[e];P(n,t),t+=n.length}n.addGroup(e,r.length/3-e,1)}()}this.setAttribute("position",new Mn(r,3)),this.setAttribute("uv",new Mn(i,2)),this.computeVertexNormals()}toJSON(){const e=super.toJSON();return function(e,t,n){if(n.shapes=[],Array.isArray(e))for(let t=0,r=e.length;t<r;t++){const r=e[t];n.shapes.push(r.uuid)}else n.shapes.push(e.uuid);return n.options=Object.assign({},t),void 0!==t.extrudePath&&(n.options.extrudePath=t.extrudePath.toJSON()),n}(this.parameters.shapes,this.parameters.options,e)}static fromJSON(e,t){const n=[];for(let r=0,i=e.shapes.length;r<i;r++){const i=t[e.shapes[r]];n.push(i)}const r=e.options.extrudePath;return void 0!==r&&(e.options.extrudePath=(new _o[r.type]).fromJSON(r)),new hl(n,e.options)}}const dl={generateTopUV:function(e,t,n,r,i){const s=t[3*n],a=t[3*n+1],o=t[3*r],l=t[3*r+1],c=t[3*i],u=t[3*i+1];return[new Ae(s,a),new Ae(o,l),new Ae(c,u)]},generateSideWallUV:function(e,t,n,r,i,s){const a=t[3*n],o=t[3*n+1],l=t[3*n+2],c=t[3*r],u=t[3*r+1],h=t[3*r+2],d=t[3*i],p=t[3*i+1],f=t[3*i+2],m=t[3*s],g=t[3*s+1],y=t[3*s+2];return Math.abs(o-u)<Math.abs(a-c)?[new Ae(a,1-l),new Ae(c,1-h),new Ae(d,1-f),new Ae(m,1-y)]:[new Ae(o,1-l),new Ae(u,1-h),new Ae(p,1-f),new Ae(g,1-y)]}};class pl extends No{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2;super([-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new pl(e.radius,e.detail)}}class fl extends No{constructor(e=1,t=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new fl(e.radius,e.detail)}}class ml extends Rn{constructor(e=.5,t=1,n=8,r=1,i=0,s=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:n,phiSegments:r,thetaStart:i,thetaLength:s},n=Math.max(3,n);const a=[],o=[],l=[],c=[];let u=e;const h=(t-e)/(r=Math.max(1,r)),d=new tt,p=new Ae;for(let e=0;e<=r;e++){for(let e=0;e<=n;e++){const r=i+e/n*s;d.x=u*Math.cos(r),d.y=u*Math.sin(r),o.push(d.x,d.y,d.z),l.push(0,0,1),p.x=(d.x/t+1)/2,p.y=(d.y/t+1)/2,c.push(p.x,p.y)}u+=h}for(let e=0;e<r;e++){const t=e*(n+1);for(let e=0;e<n;e++){const r=e+t,i=r,s=r+n+1,o=r+n+2,l=r+1;a.push(i,s,l),a.push(s,o,l)}}this.setIndex(a),this.setAttribute("position",new Mn(o,3)),this.setAttribute("normal",new Mn(l,3)),this.setAttribute("uv",new Mn(c,2))}static fromJSON(e){return new ml(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class gl extends Rn{constructor(e=new Oo([new Ae(0,.5),new Ae(-.5,-.5),new Ae(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const n=[],r=[],i=[],s=[];let a=0,o=0;if(!1===Array.isArray(e))l(e);else for(let t=0;t<e.length;t++)l(e[t]),this.addGroup(a,o,t),a+=o,o=0;function l(e){const a=r.length/3,l=e.extractPoints(t);let c=l.shape;const u=l.holes;!1===ll.isClockWise(c)&&(c=c.reverse());for(let e=0,t=u.length;e<t;e++){const t=u[e];!0===ll.isClockWise(t)&&(u[e]=t.reverse())}const h=ll.triangulateShape(c,u);for(let e=0,t=u.length;e<t;e++){const t=u[e];c=c.concat(t)}for(let e=0,t=c.length;e<t;e++){const t=c[e];r.push(t.x,t.y,0),i.push(0,0,1),s.push(t.x,t.y)}for(let e=0,t=h.length;e<t;e++){const t=h[e],r=t[0]+a,i=t[1]+a,s=t[2]+a;n.push(r,i,s),o+=3}}this.setIndex(n),this.setAttribute("position",new Mn(r,3)),this.setAttribute("normal",new Mn(i,3)),this.setAttribute("uv",new Mn(s,2))}toJSON(){const e=super.toJSON();return function(e,t){if(t.shapes=[],Array.isArray(e))for(let n=0,r=e.length;n<r;n++){const r=e[n];t.shapes.push(r.uuid)}else t.shapes.push(e.uuid);return t}(this.parameters.shapes,e)}static fromJSON(e,t){const n=[];for(let r=0,i=e.shapes.length;r<i;r++){const i=t[e.shapes[r]];n.push(i)}return new gl(n,e.curveSegments)}}class yl extends Rn{constructor(e=1,t=32,n=16,r=0,i=2*Math.PI,s=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:r,phiLength:i,thetaStart:s,thetaLength:a},t=Math.max(3,Math.floor(t)),n=Math.max(2,Math.floor(n));const o=Math.min(s+a,Math.PI);let l=0;const c=[],u=new tt,h=new tt,d=[],p=[],f=[],m=[];for(let d=0;d<=n;d++){const g=[],y=d/n;let v=0;0==d&&0==s?v=.5/t:d==n&&o==Math.PI&&(v=-.5/t);for(let n=0;n<=t;n++){const o=n/t;u.x=-e*Math.cos(r+o*i)*Math.sin(s+y*a),u.y=e*Math.cos(s+y*a),u.z=e*Math.sin(r+o*i)*Math.sin(s+y*a),p.push(u.x,u.y,u.z),h.copy(u).normalize(),f.push(h.x,h.y,h.z),m.push(o+v,1-y),g.push(l++)}c.push(g)}for(let e=0;e<n;e++)for(let r=0;r<t;r++){const t=c[e][r+1],i=c[e][r],a=c[e+1][r],l=c[e+1][r+1];(0!==e||s>0)&&d.push(t,i,l),(e!==n-1||o<Math.PI)&&d.push(i,a,l)}this.setIndex(d),this.setAttribute("position",new Mn(p,3)),this.setAttribute("normal",new Mn(f,3)),this.setAttribute("uv",new Mn(m,2))}static fromJSON(e){return new yl(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class vl extends No{constructor(e=1,t=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new vl(e.radius,e.detail)}}class xl extends Rn{constructor(e=1,t=.4,n=8,r=6,i=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:n,tubularSegments:r,arc:i},n=Math.floor(n),r=Math.floor(r);const s=[],a=[],o=[],l=[],c=new tt,u=new tt,h=new tt;for(let s=0;s<=n;s++)for(let d=0;d<=r;d++){const p=d/r*i,f=s/n*Math.PI*2;u.x=(e+t*Math.cos(f))*Math.cos(p),u.y=(e+t*Math.cos(f))*Math.sin(p),u.z=t*Math.sin(f),a.push(u.x,u.y,u.z),c.x=e*Math.cos(p),c.y=e*Math.sin(p),h.subVectors(u,c).normalize(),o.push(h.x,h.y,h.z),l.push(d/r),l.push(s/n)}for(let e=1;e<=n;e++)for(let t=1;t<=r;t++){const n=(r+1)*e+t-1,i=(r+1)*(e-1)+t-1,a=(r+1)*(e-1)+t,o=(r+1)*e+t;s.push(n,i,o),s.push(i,a,o)}this.setIndex(s),this.setAttribute("position",new Mn(a,3)),this.setAttribute("normal",new Mn(o,3)),this.setAttribute("uv",new Mn(l,2))}static fromJSON(e){return new xl(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class bl extends Rn{constructor(e=1,t=.4,n=64,r=8,i=2,s=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:n,radialSegments:r,p:i,q:s},n=Math.floor(n),r=Math.floor(r);const a=[],o=[],l=[],c=[],u=new tt,h=new tt,d=new tt,p=new tt,f=new tt,m=new tt,g=new tt;for(let a=0;a<=n;++a){const v=a/n*i*Math.PI*2;y(v,i,s,e,d),y(v+.01,i,s,e,p),m.subVectors(p,d),g.addVectors(p,d),f.crossVectors(m,g),g.crossVectors(f,m),f.normalize(),g.normalize();for(let e=0;e<=r;++e){const i=e/r*Math.PI*2,s=-t*Math.cos(i),p=t*Math.sin(i);u.x=d.x+(s*g.x+p*f.x),u.y=d.y+(s*g.y+p*f.y),u.z=d.z+(s*g.z+p*f.z),o.push(u.x,u.y,u.z),h.subVectors(u,d).normalize(),l.push(h.x,h.y,h.z),c.push(a/n),c.push(e/r)}}for(let e=1;e<=n;e++)for(let t=1;t<=r;t++){const n=(r+1)*(e-1)+(t-1),i=(r+1)*e+(t-1),s=(r+1)*e+t,o=(r+1)*(e-1)+t;a.push(n,i,o),a.push(i,s,o)}function y(e,t,n,r,i){const s=Math.cos(e),a=Math.sin(e),o=n/t*e,l=Math.cos(o);i.x=r*(2+l)*.5*s,i.y=r*(2+l)*a*.5,i.z=r*Math.sin(o)*.5}this.setIndex(a),this.setAttribute("position",new Mn(o,3)),this.setAttribute("normal",new Mn(l,3)),this.setAttribute("uv",new Mn(c,2))}static fromJSON(e){return new bl(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class wl extends Rn{constructor(e=new bo(new tt(-1,-1,0),new tt(-1,1,0),new tt(1,1,0)),t=64,n=1,r=8,i=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:n,radialSegments:r,closed:i};const s=e.computeFrenetFrames(t,i);this.tangents=s.tangents,this.normals=s.normals,this.binormals=s.binormals;const a=new tt,o=new tt,l=new Ae;let c=new tt;const u=[],h=[],d=[],p=[];function f(i){c=e.getPointAt(i/t,c);const l=s.normals[i],d=s.binormals[i];for(let e=0;e<=r;e++){const t=e/r*Math.PI*2,i=Math.sin(t),s=-Math.cos(t);o.x=s*l.x+i*d.x,o.y=s*l.y+i*d.y,o.z=s*l.z+i*d.z,o.normalize(),h.push(o.x,o.y,o.z),a.x=c.x+n*o.x,a.y=c.y+n*o.y,a.z=c.z+n*o.z,u.push(a.x,a.y,a.z)}}!function(){for(let e=0;e<t;e++)f(e);f(!1===i?t:0),function(){for(let e=0;e<=t;e++)for(let n=0;n<=r;n++)l.x=e/t,l.y=n/r,d.push(l.x,l.y)}(),function(){for(let e=1;e<=t;e++)for(let t=1;t<=r;t++){const n=(r+1)*(e-1)+(t-1),i=(r+1)*e+(t-1),s=(r+1)*e+t,a=(r+1)*(e-1)+t;p.push(n,i,a),p.push(i,s,a)}}()}(),this.setIndex(p),this.setAttribute("position",new Mn(u,3)),this.setAttribute("normal",new Mn(h,3)),this.setAttribute("uv",new Mn(d,2))}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new wl((new _o[e.path.type]).fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class _l extends Rn{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},null!==e){const t=[],n=new Set,r=new tt,i=new tt;if(null!==e.index){const s=e.attributes.position,a=e.index;let o=e.groups;0===o.length&&(o=[{start:0,count:a.count,materialIndex:0}]);for(let e=0,l=o.length;e<l;++e){const l=o[e],c=l.start;for(let e=c,o=c+l.count;e<o;e+=3)for(let o=0;o<3;o++){const l=a.getX(e+o),c=a.getX(e+(o+1)%3);r.fromBufferAttribute(s,l),i.fromBufferAttribute(s,c),!0===Sl(r,i,n)&&(t.push(r.x,r.y,r.z),t.push(i.x,i.y,i.z))}}}else{const s=e.attributes.position;for(let e=0,a=s.count/3;e<a;e++)for(let a=0;a<3;a++){const o=3*e+a,l=3*e+(a+1)%3;r.fromBufferAttribute(s,o),i.fromBufferAttribute(s,l),!0===Sl(r,i,n)&&(t.push(r.x,r.y,r.z),t.push(i.x,i.y,i.z))}}this.setAttribute("position",new Mn(t,3))}}}function Sl(e,t,n){const r=`${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`,i=`${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`;return!0!==n.has(r)&&!0!==n.has(i)&&(n.add(r),n.add(i),!0)}var Ml=Object.freeze({__proto__:null,BoxGeometry:Jn,BoxBufferGeometry:Jn,CapsuleGeometry:Eo,CapsuleBufferGeometry:Eo,CircleGeometry:Ao,CircleBufferGeometry:Ao,ConeGeometry:Io,ConeBufferGeometry:Io,CylinderGeometry:Co,CylinderBufferGeometry:Co,DodecahedronGeometry:ko,DodecahedronBufferGeometry:ko,EdgesGeometry:Po,ExtrudeGeometry:hl,ExtrudeBufferGeometry:hl,IcosahedronGeometry:pl,IcosahedronBufferGeometry:pl,LatheGeometry:To,LatheBufferGeometry:To,OctahedronGeometry:fl,OctahedronBufferGeometry:fl,PlaneGeometry:vr,PlaneBufferGeometry:vr,PolyhedronGeometry:No,PolyhedronBufferGeometry:No,RingGeometry:ml,RingBufferGeometry:ml,ShapeGeometry:gl,ShapeBufferGeometry:gl,SphereGeometry:yl,SphereBufferGeometry:yl,TetrahedronGeometry:vl,TetrahedronBufferGeometry:vl,TorusGeometry:xl,TorusBufferGeometry:xl,TorusKnotGeometry:bl,TorusKnotBufferGeometry:bl,TubeGeometry:wl,TubeBufferGeometry:wl,WireframeGeometry:_l});class Tl extends yn{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new We(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class El extends nr{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class Al extends yn{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new We(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new We(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Ae(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Cl extends Al{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Ae(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return be(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new We(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new We(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new We(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._iridescence=0,this._transmission=0,this.setValues(e)}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class Il extends yn{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new We(16777215),this.specular=new We(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new We(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Ae(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Nl extends yn{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new We(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new We(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Ae(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class kl extends yn{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Ae(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class Rl extends yn{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new We(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new We(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class Dl extends yn{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new We(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Ae(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Ll extends Oa{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}const Fl={ShadowMaterial:Tl,SpriteMaterial:ta,RawShaderMaterial:El,ShaderMaterial:nr,PointsMaterial:Xa,MeshPhysicalMaterial:Cl,MeshStandardMaterial:Al,MeshPhongMaterial:Il,MeshToonMaterial:Nl,MeshNormalMaterial:kl,MeshLambertMaterial:Rl,MeshDepthMaterial:Ls,MeshDistanceMaterial:Fs,MeshBasicMaterial:vn,MeshMatcapMaterial:Dl,LineDashedMaterial:Ll,LineBasicMaterial:Oa,Material:yn};yn.fromType=function(e){return new Fl[e]};const Pl={arraySlice:function(e,t,n){return Pl.isTypedArray(e)?new e.constructor(e.subarray(t,void 0!==n?n:e.length)):e.slice(t,n)},convertArray:function(e,t,n){return!e||!n&&e.constructor===t?e:"number"==typeof t.BYTES_PER_ELEMENT?new t(e):Array.prototype.slice.call(e)},isTypedArray:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)},getKeyframeOrder:function(e){const t=e.length,n=new Array(t);for(let e=0;e!==t;++e)n[e]=e;return n.sort((function(t,n){return e[t]-e[n]})),n},sortedArray:function(e,t,n){const r=e.length,i=new e.constructor(r);for(let s=0,a=0;a!==r;++s){const r=n[s]*t;for(let n=0;n!==t;++n)i[a++]=e[r+n]}return i},flattenJSON:function(e,t,n,r){let i=1,s=e[0];for(;void 0!==s&&void 0===s[r];)s=e[i++];if(void 0===s)return;let a=s[r];if(void 0!==a)if(Array.isArray(a))do{a=s[r],void 0!==a&&(t.push(s.time),n.push.apply(n,a)),s=e[i++]}while(void 0!==s);else if(void 0!==a.toArray)do{a=s[r],void 0!==a&&(t.push(s.time),a.toArray(n,n.length)),s=e[i++]}while(void 0!==s);else do{a=s[r],void 0!==a&&(t.push(s.time),n.push(a)),s=e[i++]}while(void 0!==s)},subclip:function(e,t,n,r,i=30){const s=e.clone();s.name=t;const a=[];for(let e=0;e<s.tracks.length;++e){const t=s.tracks[e],o=t.getValueSize(),l=[],c=[];for(let e=0;e<t.times.length;++e){const s=t.times[e]*i;if(!(s<n||s>=r)){l.push(t.times[e]);for(let n=0;n<o;++n)c.push(t.values[e*o+n])}}0!==l.length&&(t.times=Pl.convertArray(l,t.times.constructor),t.values=Pl.convertArray(c,t.values.constructor),a.push(t))}s.tracks=a;let o=1/0;for(let e=0;e<s.tracks.length;++e)o>s.tracks[e].times[0]&&(o=s.tracks[e].times[0]);for(let e=0;e<s.tracks.length;++e)s.tracks[e].shift(-1*o);return s.resetDuration(),s},makeClipAdditive:function(e,t=0,n=e,r=30){r<=0&&(r=30);const i=n.tracks.length,s=t/r;for(let t=0;t<i;++t){const r=n.tracks[t],i=r.ValueTypeName;if("bool"===i||"string"===i)continue;const a=e.tracks.find((function(e){return e.name===r.name&&e.ValueTypeName===i}));if(void 0===a)continue;let o=0;const l=r.getValueSize();r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(o=l/3);let c=0;const u=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=u/3);const h=r.times.length-1;let d;if(s<=r.times[0]){const e=o,t=l-o;d=Pl.arraySlice(r.values,e,t)}else if(s>=r.times[h]){const e=h*l+o,t=e+l-o;d=Pl.arraySlice(r.values,e,t)}else{const e=r.createInterpolant(),t=o,n=l-o;e.evaluate(s),d=Pl.arraySlice(e.resultBuffer,t,n)}"quaternion"===i&&(new et).fromArray(d).normalize().conjugate().toArray(d);const p=a.times.length;for(let e=0;e<p;++e){const t=e*u+c;if("quaternion"===i)et.multiplyQuaternionsFlat(a.values,t,d,0,a.values,t);else{const e=u-2*c;for(let n=0;n<e;++n)a.values[t+n]-=d[n]}}}return e.blendMode=se,e}};class Ol{constructor(e,t,n,r){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=void 0!==r?r:new t.constructor(n),this.sampleValues=t,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let n=this._cachedIndex,r=t[n],i=t[n-1];e:{t:{let s;n:{r:if(!(e<r)){for(let s=n+2;;){if(void 0===r){if(e<i)break r;return n=t.length,this._cachedIndex=n,this.copySampleValue_(n-1)}if(n===s)break;if(i=r,r=t[++n],e<r)break t}s=t.length;break n}if(e>=i)break e;{const a=t[1];e<a&&(n=2,i=a);for(let s=n-2;;){if(void 0===i)return this._cachedIndex=0,this.copySampleValue_(0);if(n===s)break;if(r=i,i=t[--n-1],e>=i)break t}s=n,n=0}}for(;n<s;){const r=n+s>>>1;e<t[r]?s=r:n=r+1}if(r=t[n],i=t[n-1],void 0===i)return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===r)return n=t.length,this._cachedIndex=n,this.copySampleValue_(n-1)}this._cachedIndex=n,this.intervalChanged_(n,i,r)}return this.interpolate_(n,i,e,r)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,r=this.valueSize,i=e*r;for(let e=0;e!==r;++e)t[e]=n[i+e];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class zl extends Ol{constructor(e,t,n,r){super(e,t,n,r),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:ne,endingEnd:ne}}intervalChanged_(e,t,n){const r=this.parameterPositions;let i=e-2,s=e+1,a=r[i],o=r[s];if(void 0===a)switch(this.getSettings_().endingStart){case re:i=e,a=2*t-n;break;case ie:i=r.length-2,a=t+r[i]-r[i+1];break;default:i=e,a=n}if(void 0===o)switch(this.getSettings_().endingEnd){case re:s=e,o=2*n-t;break;case ie:s=1,o=n+r[1]-r[0];break;default:s=e-1,o=t}const l=.5*(n-t),c=this.valueSize;this._weightPrev=l/(t-a),this._weightNext=l/(o-n),this._offsetPrev=i*c,this._offsetNext=s*c}interpolate_(e,t,n,r){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=e*a,l=o-a,c=this._offsetPrev,u=this._offsetNext,h=this._weightPrev,d=this._weightNext,p=(n-t)/(r-t),f=p*p,m=f*p,g=-h*m+2*h*f-h*p,y=(1+h)*m+(-1.5-2*h)*f+(-.5+h)*p+1,v=(-1-d)*m+(1.5+d)*f+.5*p,x=d*m-d*f;for(let e=0;e!==a;++e)i[e]=g*s[c+e]+y*s[l+e]+v*s[o+e]+x*s[u+e];return i}}class Bl extends Ol{constructor(e,t,n,r){super(e,t,n,r)}interpolate_(e,t,n,r){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=e*a,l=o-a,c=(n-t)/(r-t),u=1-c;for(let e=0;e!==a;++e)i[e]=s[l+e]*u+s[o+e]*c;return i}}class Ul extends Ol{constructor(e,t,n,r){super(e,t,n,r)}interpolate_(e){return this.copySampleValue_(e-1)}}class $l{constructor(e,t,n,r){if(void 0===e)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===t||0===t.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Pl.convertArray(t,this.TimeBufferType),this.values=Pl.convertArray(n,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:Pl.convertArray(e.times,Array),values:Pl.convertArray(e.values,Array)};const t=e.getInterpolation();t!==e.DefaultInterpolation&&(n.interpolation=t)}return n.type=e.ValueTypeName,n}InterpolantFactoryMethodDiscrete(e){return new Ul(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new Bl(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new zl(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case Q:t=this.InterpolantFactoryMethodDiscrete;break;case ee:t=this.InterpolantFactoryMethodLinear;break;case te:t=this.InterpolantFactoryMethodSmooth}if(void 0===t){const t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(e===this.DefaultInterpolation)throw new Error(t);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",t),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Q;case this.InterpolantFactoryMethodLinear:return ee;case this.InterpolantFactoryMethodSmooth:return te}}getValueSize(){return this.values.length/this.times.length}shift(e){if(0!==e){const t=this.times;for(let n=0,r=t.length;n!==r;++n)t[n]+=e}return this}scale(e){if(1!==e){const t=this.times;for(let n=0,r=t.length;n!==r;++n)t[n]*=e}return this}trim(e,t){const n=this.times,r=n.length;let i=0,s=r-1;for(;i!==r&&n[i]<e;)++i;for(;-1!==s&&n[s]>t;)--s;if(++s,0!==i||s!==r){i>=s&&(s=Math.max(s,1),i=s-1);const e=this.getValueSize();this.times=Pl.arraySlice(n,i,s),this.values=Pl.arraySlice(this.values,i*e,s*e)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,r=this.values,i=n.length;0===i&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let s=null;for(let t=0;t!==i;t++){const r=n[t];if("number"==typeof r&&isNaN(r)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,t,r),e=!1;break}if(null!==s&&s>r){console.error("THREE.KeyframeTrack: Out of order keys.",this,t,r,s),e=!1;break}s=r}if(void 0!==r&&Pl.isTypedArray(r))for(let t=0,n=r.length;t!==n;++t){const n=r[t];if(isNaN(n)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,t,n),e=!1;break}}return e}optimize(){const e=Pl.arraySlice(this.times),t=Pl.arraySlice(this.values),n=this.getValueSize(),r=this.getInterpolation()===te,i=e.length-1;let s=1;for(let a=1;a<i;++a){let i=!1;const o=e[a];if(o!==e[a+1]&&(1!==a||o!==e[0]))if(r)i=!0;else{const e=a*n,r=e-n,s=e+n;for(let a=0;a!==n;++a){const n=t[e+a];if(n!==t[r+a]||n!==t[s+a]){i=!0;break}}}if(i){if(a!==s){e[s]=e[a];const r=a*n,i=s*n;for(let e=0;e!==n;++e)t[i+e]=t[r+e]}++s}}if(i>0){e[s]=e[i];for(let e=i*n,r=s*n,a=0;a!==n;++a)t[r+a]=t[e+a];++s}return s!==e.length?(this.times=Pl.arraySlice(e,0,s),this.values=Pl.arraySlice(t,0,s*n)):(this.times=e,this.values=t),this}clone(){const e=Pl.arraySlice(this.times,0),t=Pl.arraySlice(this.values,0),n=new(0,this.constructor)(this.name,e,t);return n.createInterpolant=this.createInterpolant,n}}$l.prototype.TimeBufferType=Float32Array,$l.prototype.ValueBufferType=Float32Array,$l.prototype.DefaultInterpolation=ee;class Vl extends $l{}Vl.prototype.ValueTypeName="bool",Vl.prototype.ValueBufferType=Array,Vl.prototype.DefaultInterpolation=Q,Vl.prototype.InterpolantFactoryMethodLinear=void 0,Vl.prototype.InterpolantFactoryMethodSmooth=void 0;class Wl extends $l{}Wl.prototype.ValueTypeName="color";class Gl extends $l{}Gl.prototype.ValueTypeName="number";class Hl extends Ol{constructor(e,t,n,r){super(e,t,n,r)}interpolate_(e,t,n,r){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=(n-t)/(r-t);let l=e*a;for(let e=l+a;l!==e;l+=4)et.slerpFlat(i,0,s,l-a,s,l,o);return i}}class jl extends $l{InterpolantFactoryMethodLinear(e){return new Hl(this.times,this.values,this.getValueSize(),e)}}jl.prototype.ValueTypeName="quaternion",jl.prototype.DefaultInterpolation=ee,jl.prototype.InterpolantFactoryMethodSmooth=void 0;class ql extends $l{}ql.prototype.ValueTypeName="string",ql.prototype.ValueBufferType=Array,ql.prototype.DefaultInterpolation=Q,ql.prototype.InterpolantFactoryMethodLinear=void 0,ql.prototype.InterpolantFactoryMethodSmooth=void 0;class Xl extends $l{}Xl.prototype.ValueTypeName="vector";class Yl{constructor(e,t=-1,n,r=2500){this.name=e,this.tracks=n,this.duration=t,this.blendMode=r,this.uuid=xe(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],n=e.tracks,r=1/(e.fps||1);for(let e=0,i=n.length;e!==i;++e)t.push(Kl(n[e]).scale(r));const i=new this(e.name,e.duration,t,e.blendMode);return i.uuid=e.uuid,i}static toJSON(e){const t=[],n=e.tracks,r={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let e=0,r=n.length;e!==r;++e)t.push($l.toJSON(n[e]));return r}static CreateFromMorphTargetSequence(e,t,n,r){const i=t.length,s=[];for(let e=0;e<i;e++){let a=[],o=[];a.push((e+i-1)%i,e,(e+1)%i),o.push(0,1,0);const l=Pl.getKeyframeOrder(a);a=Pl.sortedArray(a,1,l),o=Pl.sortedArray(o,1,l),r||0!==a[0]||(a.push(i),o.push(o[0])),s.push(new Gl(".morphTargetInfluences["+t[e].name+"]",a,o).scale(1/n))}return new this(e,-1,s)}static findByName(e,t){let n=e;if(!Array.isArray(e)){const t=e;n=t.geometry&&t.geometry.animations||t.animations}for(let e=0;e<n.length;e++)if(n[e].name===t)return n[e];return null}static CreateClipsFromMorphTargetSequences(e,t,n){const r={},i=/^([\w-]*?)([\d]+)$/;for(let t=0,n=e.length;t<n;t++){const n=e[t],s=n.name.match(i);if(s&&s.length>1){const e=s[1];let t=r[e];t||(r[e]=t=[]),t.push(n)}}const s=[];for(const e in r)s.push(this.CreateFromMorphTargetSequence(e,r[e],t,n));return s}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(e,t,n,r,i){if(0!==n.length){const s=[],a=[];Pl.flattenJSON(n,s,a,r),0!==s.length&&i.push(new e(t,s,a))}},r=[],i=e.name||"default",s=e.fps||30,a=e.blendMode;let o=e.length||-1;const l=e.hierarchy||[];for(let e=0;e<l.length;e++){const i=l[e].keys;if(i&&0!==i.length)if(i[0].morphTargets){const e={};let t;for(t=0;t<i.length;t++)if(i[t].morphTargets)for(let n=0;n<i[t].morphTargets.length;n++)e[i[t].morphTargets[n]]=-1;for(const n in e){const e=[],s=[];for(let r=0;r!==i[t].morphTargets.length;++r){const r=i[t];e.push(r.time),s.push(r.morphTarget===n?1:0)}r.push(new Gl(".morphTargetInfluence["+n+"]",e,s))}o=e.length*s}else{const s=".bones["+t[e].name+"]";n(Xl,s+".position",i,"pos",r),n(jl,s+".quaternion",i,"rot",r),n(Xl,s+".scale",i,"scl",r)}}return 0===r.length?null:new this(i,o,r,a)}resetDuration(){let e=0;for(let t=0,n=this.tracks.length;t!==n;++t){const n=this.tracks[t];e=Math.max(e,n.times[n.times.length-1])}return this.duration=e,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Kl(e){if(void 0===e.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=function(e){switch(e.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Gl;case"vector":case"vector2":case"vector3":case"vector4":return Xl;case"color":return Wl;case"quaternion":return jl;case"bool":case"boolean":return Vl;case"string":return ql}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+e)}(e.type);if(void 0===e.times){const t=[],n=[];Pl.flattenJSON(e.keys,t,n,"value"),e.times=t,e.values=n}return void 0!==t.parse?t.parse(e):new t(e.name,e.times,e.values,e.interpolation)}const Zl={enabled:!1,files:{},add:function(e,t){!1!==this.enabled&&(this.files[e]=t)},get:function(e){if(!1!==this.enabled)return this.files[e]},remove:function(e){delete this.files[e]},clear:function(){this.files={}}};class Jl{constructor(e,t,n){const r=this;let i,s=!1,a=0,o=0;const l=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(e){o++,!1===s&&void 0!==r.onStart&&r.onStart(e,a,o),s=!0},this.itemEnd=function(e){a++,void 0!==r.onProgress&&r.onProgress(e,a,o),a===o&&(s=!1,void 0!==r.onLoad&&r.onLoad())},this.itemError=function(e){void 0!==r.onError&&r.onError(e)},this.resolveURL=function(e){return i?i(e):e},this.setURLModifier=function(e){return i=e,this},this.addHandler=function(e,t){return l.push(e,t),this},this.removeHandler=function(e){const t=l.indexOf(e);return-1!==t&&l.splice(t,2),this},this.getHandler=function(e){for(let t=0,n=l.length;t<n;t+=2){const n=l[t],r=l[t+1];if(n.global&&(n.lastIndex=0),n.test(e))return r}return null}}}const Ql=new Jl;class ec{constructor(e){this.manager=void 0!==e?e:Ql,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const n=this;return new Promise((function(r,i){n.load(e,r,t,i)}))}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}const tc={};class nc extends ec{constructor(e){super(e)}load(e,t,n,r){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const i=Zl.get(e);if(void 0!==i)return this.manager.itemStart(e),setTimeout((()=>{t&&t(i),this.manager.itemEnd(e)}),0),i;if(void 0!==tc[e])return void tc[e].push({onLoad:t,onProgress:n,onError:r});tc[e]=[],tc[e].push({onLoad:t,onProgress:n,onError:r});const s=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,o=this.responseType;fetch(s).then((t=>{if(200===t.status||0===t.status){if(0===t.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),"undefined"==typeof ReadableStream||void 0===t.body||void 0===t.body.getReader)return t;const n=tc[e],r=t.body.getReader(),i=t.headers.get("Content-Length"),s=i?parseInt(i):0,a=0!==s;let o=0;const l=new ReadableStream({start(e){!function t(){r.read().then((({done:r,value:i})=>{if(r)e.close();else{o+=i.byteLength;const r=new ProgressEvent("progress",{lengthComputable:a,loaded:o,total:s});for(let e=0,t=n.length;e<t;e++){const t=n[e];t.onProgress&&t.onProgress(r)}e.enqueue(i),t()}}))}()}});return new Response(l)}throw Error(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`)})).then((e=>{switch(o){case"arraybuffer":return e.arrayBuffer();case"blob":return e.blob();case"document":return e.text().then((e=>(new DOMParser).parseFromString(e,a)));case"json":return e.json();default:if(void 0===a)return e.text();{const t=/charset="?([^;"\s]*)"?/i.exec(a),n=t&&t[1]?t[1].toLowerCase():void 0,r=new TextDecoder(n);return e.arrayBuffer().then((e=>r.decode(e)))}}})).then((t=>{Zl.add(e,t);const n=tc[e];delete tc[e];for(let e=0,r=n.length;e<r;e++){const r=n[e];r.onLoad&&r.onLoad(t)}})).catch((t=>{const n=tc[e];if(void 0===n)throw this.manager.itemError(e),t;delete tc[e];for(let e=0,r=n.length;e<r;e++){const r=n[e];r.onError&&r.onError(t)}this.manager.itemError(e)})).finally((()=>{this.manager.itemEnd(e)})),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class rc extends ec{constructor(e){super(e)}load(e,t,n,r){void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const i=this,s=Zl.get(e);if(void 0!==s)return i.manager.itemStart(e),setTimeout((function(){t&&t(s),i.manager.itemEnd(e)}),0),s;const a=Re("img");function o(){c(),Zl.add(e,this),t&&t(this),i.manager.itemEnd(e)}function l(t){c(),r&&r(t),i.manager.itemError(e),i.manager.itemEnd(e)}function c(){a.removeEventListener("load",o,!1),a.removeEventListener("error",l,!1)}return a.addEventListener("load",o,!1),a.addEventListener("error",l,!1),"data:"!==e.slice(0,5)&&void 0!==this.crossOrigin&&(a.crossOrigin=this.crossOrigin),i.manager.itemStart(e),a.src=e,a}}class ic extends rn{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new We(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,void 0!==this.groundColor&&(t.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(t.object.distance=this.distance),void 0!==this.angle&&(t.object.angle=this.angle),void 0!==this.decay&&(t.object.decay=this.decay),void 0!==this.penumbra&&(t.object.penumbra=this.penumbra),void 0!==this.shadow&&(t.object.shadow=this.shadow.toJSON()),t}}class sc extends ic{constructor(e,t,n){super(e,n),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(rn.DefaultUp),this.updateMatrix(),this.groundColor=new We(t)}copy(e,t){return super.copy(e,t),this.groundColor.copy(e.groundColor),this}}const ac=new Rt,oc=new tt,lc=new tt;class cc{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Ae(512,512),this.map=null,this.mapPass=null,this.matrix=new Rt,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new mr,this._frameExtents=new Ae(1,1),this._viewportCount=1,this._viewports=[new Ke(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,n=this.matrix;oc.setFromMatrixPosition(e.matrixWorld),t.position.copy(oc),lc.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(lc),t.updateMatrixWorld(),ac.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(ac),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(t.projectionMatrix),n.multiply(t.matrixWorldInverse)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const e={};return 0!==this.bias&&(e.bias=this.bias),0!==this.normalBias&&(e.normalBias=this.normalBias),1!==this.radius&&(e.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class uc extends cc{constructor(){super(new ir(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const t=this.camera,n=2*ve*e.angle*this.focus,r=this.mapSize.width/this.mapSize.height,i=e.distance||t.far;n===t.fov&&r===t.aspect&&i===t.far||(t.fov=n,t.aspect=r,t.far=i,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class hc extends ic{constructor(e,t,n=0,r=Math.PI/3,i=0,s=1){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(rn.DefaultUp),this.updateMatrix(),this.target=new rn,this.distance=n,this.angle=r,this.penumbra=i,this.decay=s,this.shadow=new uc}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const dc=new Rt,pc=new tt,fc=new tt;class mc extends cc{constructor(){super(new ir(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Ae(4,2),this._viewportCount=6,this._viewports=[new Ke(2,1,1,1),new Ke(0,1,1,1),new Ke(3,1,1,1),new Ke(1,1,1,1),new Ke(3,0,1,1),new Ke(1,0,1,1)],this._cubeDirections=[new tt(1,0,0),new tt(-1,0,0),new tt(0,0,1),new tt(0,0,-1),new tt(0,1,0),new tt(0,-1,0)],this._cubeUps=[new tt(0,1,0),new tt(0,1,0),new tt(0,1,0),new tt(0,1,0),new tt(0,0,1),new tt(0,0,-1)]}updateMatrices(e,t=0){const n=this.camera,r=this.matrix,i=e.distance||n.far;i!==n.far&&(n.far=i,n.updateProjectionMatrix()),pc.setFromMatrixPosition(e.matrixWorld),n.position.copy(pc),fc.copy(n.position),fc.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(fc),n.updateMatrixWorld(),r.makeTranslation(-pc.x,-pc.y,-pc.z),dc.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(dc)}}class gc extends ic{constructor(e,t,n=0,r=1){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=n,this.decay=r,this.shadow=new mc}get power(){return 4*this.intensity*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class yc extends cc{constructor(){super(new Cr(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class vc extends ic{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(rn.DefaultUp),this.updateMatrix(),this.target=new rn,this.shadow=new yc}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class xc extends ic{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class bc extends ic{constructor(e,t,n=10,r=10){super(e,t),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=n,this.height=r}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}class wc{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new tt)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const n=e.x,r=e.y,i=e.z,s=this.coefficients;return t.copy(s[0]).multiplyScalar(.282095),t.addScaledVector(s[1],.488603*r),t.addScaledVector(s[2],.488603*i),t.addScaledVector(s[3],.488603*n),t.addScaledVector(s[4],n*r*1.092548),t.addScaledVector(s[5],r*i*1.092548),t.addScaledVector(s[6],.315392*(3*i*i-1)),t.addScaledVector(s[7],n*i*1.092548),t.addScaledVector(s[8],.546274*(n*n-r*r)),t}getIrradianceAt(e,t){const n=e.x,r=e.y,i=e.z,s=this.coefficients;return t.copy(s[0]).multiplyScalar(.886227),t.addScaledVector(s[1],1.023328*r),t.addScaledVector(s[2],1.023328*i),t.addScaledVector(s[3],1.023328*n),t.addScaledVector(s[4],.858086*n*r),t.addScaledVector(s[5],.858086*r*i),t.addScaledVector(s[6],.743125*i*i-.247708),t.addScaledVector(s[7],.858086*n*i),t.addScaledVector(s[8],.429043*(n*n-r*r)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(e,t=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].fromArray(e,t+3*r);return this}toArray(e=[],t=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].toArray(e,t+3*r);return e}static getBasisAt(e,t){const n=e.x,r=e.y,i=e.z;t[0]=.282095,t[1]=.488603*r,t[2]=.488603*i,t[3]=.488603*n,t[4]=1.092548*n*r,t[5]=1.092548*r*i,t[6]=.315392*(3*i*i-1),t[7]=1.092548*n*i,t[8]=.546274*(n*n-r*r)}}class _c extends ic{constructor(e=new wc,t=1){super(void 0,t),this.isLightProbe=!0,this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}class Sc extends ec{constructor(e){super(e),this.textures={}}load(e,t,n,r){const i=this,s=new nc(i.manager);s.setPath(i.path),s.setRequestHeader(i.requestHeader),s.setWithCredentials(i.withCredentials),s.load(e,(function(n){try{t(i.parse(JSON.parse(n)))}catch(t){r?r(t):console.error(t),i.manager.itemError(e)}}),n,r)}parse(e){const t=this.textures;function n(e){return void 0===t[e]&&console.warn("THREE.MaterialLoader: Undefined texture",e),t[e]}const r=yn.fromType(e.type);if(void 0!==e.uuid&&(r.uuid=e.uuid),void 0!==e.name&&(r.name=e.name),void 0!==e.color&&void 0!==r.color&&r.color.setHex(e.color),void 0!==e.roughness&&(r.roughness=e.roughness),void 0!==e.metalness&&(r.metalness=e.metalness),void 0!==e.sheen&&(r.sheen=e.sheen),void 0!==e.sheenColor&&(r.sheenColor=(new We).setHex(e.sheenColor)),void 0!==e.sheenRoughness&&(r.sheenRoughness=e.sheenRoughness),void 0!==e.emissive&&void 0!==r.emissive&&r.emissive.setHex(e.emissive),void 0!==e.specular&&void 0!==r.specular&&r.specular.setHex(e.specular),void 0!==e.specularIntensity&&(r.specularIntensity=e.specularIntensity),void 0!==e.specularColor&&void 0!==r.specularColor&&r.specularColor.setHex(e.specularColor),void 0!==e.shininess&&(r.shininess=e.shininess),void 0!==e.clearcoat&&(r.clearcoat=e.clearcoat),void 0!==e.clearcoatRoughness&&(r.clearcoatRoughness=e.clearcoatRoughness),void 0!==e.iridescence&&(r.iridescence=e.iridescence),void 0!==e.iridescenceIOR&&(r.iridescenceIOR=e.iridescenceIOR),void 0!==e.iridescenceThicknessRange&&(r.iridescenceThicknessRange=e.iridescenceThicknessRange),void 0!==e.transmission&&(r.transmission=e.transmission),void 0!==e.thickness&&(r.thickness=e.thickness),void 0!==e.attenuationDistance&&(r.attenuationDistance=e.attenuationDistance),void 0!==e.attenuationColor&&void 0!==r.attenuationColor&&r.attenuationColor.setHex(e.attenuationColor),void 0!==e.fog&&(r.fog=e.fog),void 0!==e.flatShading&&(r.flatShading=e.flatShading),void 0!==e.blending&&(r.blending=e.blending),void 0!==e.combine&&(r.combine=e.combine),void 0!==e.side&&(r.side=e.side),void 0!==e.shadowSide&&(r.shadowSide=e.shadowSide),void 0!==e.opacity&&(r.opacity=e.opacity),void 0!==e.transparent&&(r.transparent=e.transparent),void 0!==e.alphaTest&&(r.alphaTest=e.alphaTest),void 0!==e.depthTest&&(r.depthTest=e.depthTest),void 0!==e.depthWrite&&(r.depthWrite=e.depthWrite),void 0!==e.colorWrite&&(r.colorWrite=e.colorWrite),void 0!==e.stencilWrite&&(r.stencilWrite=e.stencilWrite),void 0!==e.stencilWriteMask&&(r.stencilWriteMask=e.stencilWriteMask),void 0!==e.stencilFunc&&(r.stencilFunc=e.stencilFunc),void 0!==e.stencilRef&&(r.stencilRef=e.stencilRef),void 0!==e.stencilFuncMask&&(r.stencilFuncMask=e.stencilFuncMask),void 0!==e.stencilFail&&(r.stencilFail=e.stencilFail),void 0!==e.stencilZFail&&(r.stencilZFail=e.stencilZFail),void 0!==e.stencilZPass&&(r.stencilZPass=e.stencilZPass),void 0!==e.wireframe&&(r.wireframe=e.wireframe),void 0!==e.wireframeLinewidth&&(r.wireframeLinewidth=e.wireframeLinewidth),void 0!==e.wireframeLinecap&&(r.wireframeLinecap=e.wireframeLinecap),void 0!==e.wireframeLinejoin&&(r.wireframeLinejoin=e.wireframeLinejoin),void 0!==e.rotation&&(r.rotation=e.rotation),1!==e.linewidth&&(r.linewidth=e.linewidth),void 0!==e.dashSize&&(r.dashSize=e.dashSize),void 0!==e.gapSize&&(r.gapSize=e.gapSize),void 0!==e.scale&&(r.scale=e.scale),void 0!==e.polygonOffset&&(r.polygonOffset=e.polygonOffset),void 0!==e.polygonOffsetFactor&&(r.polygonOffsetFactor=e.polygonOffsetFactor),void 0!==e.polygonOffsetUnits&&(r.polygonOffsetUnits=e.polygonOffsetUnits),void 0!==e.dithering&&(r.dithering=e.dithering),void 0!==e.alphaToCoverage&&(r.alphaToCoverage=e.alphaToCoverage),void 0!==e.premultipliedAlpha&&(r.premultipliedAlpha=e.premultipliedAlpha),void 0!==e.visible&&(r.visible=e.visible),void 0!==e.toneMapped&&(r.toneMapped=e.toneMapped),void 0!==e.userData&&(r.userData=e.userData),void 0!==e.vertexColors&&("number"==typeof e.vertexColors?r.vertexColors=e.vertexColors>0:r.vertexColors=e.vertexColors),void 0!==e.uniforms)for(const t in e.uniforms){const i=e.uniforms[t];switch(r.uniforms[t]={},i.type){case"t":r.uniforms[t].value=n(i.value);break;case"c":r.uniforms[t].value=(new We).setHex(i.value);break;case"v2":r.uniforms[t].value=(new Ae).fromArray(i.value);break;case"v3":r.uniforms[t].value=(new tt).fromArray(i.value);break;case"v4":r.uniforms[t].value=(new Ke).fromArray(i.value);break;case"m3":r.uniforms[t].value=(new Ce).fromArray(i.value);break;case"m4":r.uniforms[t].value=(new Rt).fromArray(i.value);break;default:r.uniforms[t].value=i.value}}if(void 0!==e.defines&&(r.defines=e.defines),void 0!==e.vertexShader&&(r.vertexShader=e.vertexShader),void 0!==e.fragmentShader&&(r.fragmentShader=e.fragmentShader),void 0!==e.extensions)for(const t in e.extensions)r.extensions[t]=e.extensions[t];if(void 0!==e.shading&&(r.flatShading=1===e.shading),void 0!==e.size&&(r.size=e.size),void 0!==e.sizeAttenuation&&(r.sizeAttenuation=e.sizeAttenuation),void 0!==e.map&&(r.map=n(e.map)),void 0!==e.matcap&&(r.matcap=n(e.matcap)),void 0!==e.alphaMap&&(r.alphaMap=n(e.alphaMap)),void 0!==e.bumpMap&&(r.bumpMap=n(e.bumpMap)),void 0!==e.bumpScale&&(r.bumpScale=e.bumpScale),void 0!==e.normalMap&&(r.normalMap=n(e.normalMap)),void 0!==e.normalMapType&&(r.normalMapType=e.normalMapType),void 0!==e.normalScale){let t=e.normalScale;!1===Array.isArray(t)&&(t=[t,t]),r.normalScale=(new Ae).fromArray(t)}return void 0!==e.displacementMap&&(r.displacementMap=n(e.displacementMap)),void 0!==e.displacementScale&&(r.displacementScale=e.displacementScale),void 0!==e.displacementBias&&(r.displacementBias=e.displacementBias),void 0!==e.roughnessMap&&(r.roughnessMap=n(e.roughnessMap)),void 0!==e.metalnessMap&&(r.metalnessMap=n(e.metalnessMap)),void 0!==e.emissiveMap&&(r.emissiveMap=n(e.emissiveMap)),void 0!==e.emissiveIntensity&&(r.emissiveIntensity=e.emissiveIntensity),void 0!==e.specularMap&&(r.specularMap=n(e.specularMap)),void 0!==e.specularIntensityMap&&(r.specularIntensityMap=n(e.specularIntensityMap)),void 0!==e.specularColorMap&&(r.specularColorMap=n(e.specularColorMap)),void 0!==e.envMap&&(r.envMap=n(e.envMap)),void 0!==e.envMapIntensity&&(r.envMapIntensity=e.envMapIntensity),void 0!==e.reflectivity&&(r.reflectivity=e.reflectivity),void 0!==e.refractionRatio&&(r.refractionRatio=e.refractionRatio),void 0!==e.lightMap&&(r.lightMap=n(e.lightMap)),void 0!==e.lightMapIntensity&&(r.lightMapIntensity=e.lightMapIntensity),void 0!==e.aoMap&&(r.aoMap=n(e.aoMap)),void 0!==e.aoMapIntensity&&(r.aoMapIntensity=e.aoMapIntensity),void 0!==e.gradientMap&&(r.gradientMap=n(e.gradientMap)),void 0!==e.clearcoatMap&&(r.clearcoatMap=n(e.clearcoatMap)),void 0!==e.clearcoatRoughnessMap&&(r.clearcoatRoughnessMap=n(e.clearcoatRoughnessMap)),void 0!==e.clearcoatNormalMap&&(r.clearcoatNormalMap=n(e.clearcoatNormalMap)),void 0!==e.clearcoatNormalScale&&(r.clearcoatNormalScale=(new Ae).fromArray(e.clearcoatNormalScale)),void 0!==e.iridescenceMap&&(r.iridescenceMap=n(e.iridescenceMap)),void 0!==e.iridescenceThicknessMap&&(r.iridescenceThicknessMap=n(e.iridescenceThicknessMap)),void 0!==e.transmissionMap&&(r.transmissionMap=n(e.transmissionMap)),void 0!==e.thicknessMap&&(r.thicknessMap=n(e.thicknessMap)),void 0!==e.sheenColorMap&&(r.sheenColorMap=n(e.sheenColorMap)),void 0!==e.sheenRoughnessMap&&(r.sheenRoughnessMap=n(e.sheenRoughnessMap)),r}setTextures(e){return this.textures=e,this}}class Mc{static decodeText(e){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(e);let t="";for(let n=0,r=e.length;n<r;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch(e){return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return-1===t?"./":e.slice(0,t+1)}static resolveURL(e,t){return"string"!=typeof e||""===e?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class Tc extends Rn{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}clone(){return(new this.constructor).copy(this)}toJSON(){const e=super.toJSON(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}class Ec extends ec{constructor(e){super(e)}load(e,t,n,r){const i=this,s=new nc(i.manager);s.setPath(i.path),s.setRequestHeader(i.requestHeader),s.setWithCredentials(i.withCredentials),s.load(e,(function(n){try{t(i.parse(JSON.parse(n)))}catch(t){r?r(t):console.error(t),i.manager.itemError(e)}}),n,r)}parse(e){const t={},n={};function r(e,r){if(void 0!==t[r])return t[r];const i=e.interleavedBuffers[r],s=function(e,t){if(void 0!==n[t])return n[t];const r=e.arrayBuffers[t],i=new Uint32Array(r).buffer;return n[t]=i,i}(e,i.buffer),a=ke(i.type,s),o=new Js(a,i.stride);return o.uuid=i.uuid,t[r]=o,o}const i=e.isInstancedBufferGeometry?new Tc:new Rn,s=e.data.index;if(void 0!==s){const e=ke(s.type,s.array);i.setIndex(new wn(e,1))}const a=e.data.attributes;for(const t in a){const n=a[t];let s;if(n.isInterleavedBufferAttribute){const t=r(e.data,n.data);s=new ea(t,n.itemSize,n.offset,n.normalized)}else{const e=ke(n.type,n.array);s=new(n.isInstancedBufferAttribute?ka:wn)(e,n.itemSize,n.normalized)}void 0!==n.name&&(s.name=n.name),void 0!==n.usage&&s.setUsage(n.usage),void 0!==n.updateRange&&(s.updateRange.offset=n.updateRange.offset,s.updateRange.count=n.updateRange.count),i.setAttribute(t,s)}const o=e.data.morphAttributes;if(o)for(const t in o){const n=o[t],s=[];for(let t=0,i=n.length;t<i;t++){const i=n[t];let a;if(i.isInterleavedBufferAttribute){const t=r(e.data,i.data);a=new ea(t,i.itemSize,i.offset,i.normalized)}else{const e=ke(i.type,i.array);a=new wn(e,i.itemSize,i.normalized)}void 0!==i.name&&(a.name=i.name),s.push(a)}i.morphAttributes[t]=s}e.data.morphTargetsRelative&&(i.morphTargetsRelative=!0);const l=e.data.groups||e.data.drawcalls||e.data.offsets;if(void 0!==l)for(let e=0,t=l.length;e!==t;++e){const t=l[e];i.addGroup(t.start,t.count,t.materialIndex)}const c=e.data.boundingSphere;if(void 0!==c){const e=new tt;void 0!==c.center&&e.fromArray(c.center),i.boundingSphere=new St(e,c.radius)}return e.name&&(i.name=e.name),e.userData&&(i.userData=e.userData),i}}const Ac={UVMapping:i,CubeReflectionMapping:s,CubeRefractionMapping:a,EquirectangularReflectionMapping:o,EquirectangularRefractionMapping:l,CubeUVReflectionMapping:c},Cc={RepeatWrapping:u,ClampToEdgeWrapping:h,MirroredRepeatWrapping:d},Ic={NearestFilter:p,NearestMipmapNearestFilter:f,NearestMipmapLinearFilter:m,LinearFilter:g,LinearMipmapNearestFilter:y,LinearMipmapLinearFilter:v};let Nc;const kc={getContext:function(){return void 0===Nc&&(Nc=new(window.AudioContext||window.webkitAudioContext)),Nc},setContext:function(e){Nc=e}},Rc=new Rt,Dc=new Rt,Lc=new Rt;class Fc{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=Pc(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=Pc();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function Pc(){return("undefined"==typeof performance?Date:performance).now()}const Oc=new tt,zc=new et,Bc=new tt,Uc=new tt;class $c extends rn{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),!0===this._connected?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(!1!==this.hasPlaybackControl)return this.playbackRate=e,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(!1!==this.hasPlaybackControl)return this.loop=e,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const Vc=new tt,Wc=new et,Gc=new tt,Hc=new tt;class jc{constructor(e,t,n){let r,i,s;switch(this.binding=e,this.valueSize=n,t){case"quaternion":r=this._slerp,i=this._slerpAdditive,s=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":r=this._select,i=this._select,s=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:r=this._lerp,i=this._lerpAdditive,s=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=i,this._setIdentity=s,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const n=this.buffer,r=this.valueSize,i=e*r+r;let s=this.cumulativeWeight;if(0===s){for(let e=0;e!==r;++e)n[i+e]=n[e];s=t}else{s+=t;const e=t/s;this._mixBufferRegion(n,i,0,e,r)}this.cumulativeWeight=s}accumulateAdditive(e){const t=this.buffer,n=this.valueSize,r=n*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(t,r,0,e,n),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,n=this.buffer,r=e*t+t,i=this.cumulativeWeight,s=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,i<1){const e=t*this._origIndex;this._mixBufferRegion(n,r,e,1-i,t)}s>0&&this._mixBufferRegionAdditive(n,r,this._addIndex*t,1,t);for(let e=t,i=t+t;e!==i;++e)if(n[e]!==n[e+t]){a.setValue(n,r);break}}saveOriginalState(){const e=this.binding,t=this.buffer,n=this.valueSize,r=n*this._origIndex;e.getValue(t,r);for(let e=n,i=r;e!==i;++e)t[e]=t[r+e%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=3*this.valueSize;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]}_select(e,t,n,r,i){if(r>=.5)for(let r=0;r!==i;++r)e[t+r]=e[n+r]}_slerp(e,t,n,r){et.slerpFlat(e,t,e,t,e,n,r)}_slerpAdditive(e,t,n,r,i){const s=this._workIndex*i;et.multiplyQuaternionsFlat(e,s,e,t,e,n),et.slerpFlat(e,t,e,t,e,s,r)}_lerp(e,t,n,r,i){const s=1-r;for(let a=0;a!==i;++a){const i=t+a;e[i]=e[i]*s+e[n+a]*r}}_lerpAdditive(e,t,n,r,i){for(let s=0;s!==i;++s){const i=t+s;e[i]=e[i]+e[n+s]*r}}}const qc=new RegExp("[\\[\\]\\.:\\/]","g"),Xc="[^\\[\\]\\.:\\/]",Yc="[^"+"\\[\\]\\.:\\/".replace("\\.","")+"]",Kc=/((?:WC+[\/:])*)/.source.replace("WC",Xc),Zc=/(WCOD+)?/.source.replace("WCOD",Yc),Jc=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Xc),Qc=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Xc),eu=new RegExp("^"+Kc+Zc+Jc+Qc+"$"),tu=["material","materials","bones"];class nu{constructor(e,t,n){this.path=t,this.parsedPath=n||nu.parseTrackName(t),this.node=nu.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,n){return e&&e.isAnimationObjectGroup?new nu.Composite(e,t,n):new nu(e,t,n)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(qc,"")}static parseTrackName(e){const t=eu.exec(e);if(null===t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},r=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==r&&-1!==r){const e=n.nodeName.substring(r+1);-1!==tu.indexOf(e)&&(n.nodeName=n.nodeName.substring(0,r),n.objectName=e)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n}static findNode(e,t){if(void 0===t||""===t||"."===t||-1===t||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(void 0!==n)return n}if(e.children){const n=function(e){for(let r=0;r<e.length;r++){const i=e[r];if(i.name===t||i.uuid===t)return i;const s=n(i.children);if(s)return s}return null},r=n(e.children);if(r)return r}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)e[t++]=n[r]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,n=t.objectName,r=t.propertyName;let i=t.propertyIndex;if(e||(e=nu.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let r=t.objectIndex;switch(n){case"materials":if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);e=e.material.materials;break;case"bones":if(!e.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);e=e.skeleton.bones;for(let t=0;t<e.length;t++)if(e[t].name===r){r=t;break}break;default:if(void 0===e[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);e=e[n]}if(void 0!==r){if(void 0===e[r])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);e=e[r]}}const s=e[r];if(void 0===s){const n=t.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+n+"."+r+" but it wasn't found.",e)}let a=this.Versioning.None;this.targetObject=e,void 0!==e.needsUpdate?a=this.Versioning.NeedsUpdate:void 0!==e.matrixWorldNeedsUpdate&&(a=this.Versioning.MatrixWorldNeedsUpdate);let o=this.BindingType.Direct;if(void 0!==i){if("morphTargetInfluences"===r){if(!e.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!e.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==e.morphTargetDictionary[i]&&(i=e.morphTargetDictionary[i])}o=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=i}else void 0!==s.fromArray&&void 0!==s.toArray?(o=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(o=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=r;this.getValue=this.GetterByBindingType[o],this.setValue=this.SetterByBindingTypeAndVersioning[o][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}nu.Composite=class{constructor(e,t,n){const r=n||nu.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,r)}getValue(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,r=this._bindings[n];void 0!==r&&r.getValue(e,t)}setValue(e,t){const n=this._bindings;for(let r=this._targetGroup.nCachedObjects_,i=n.length;r!==i;++r)n[r].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}},nu.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},nu.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},nu.prototype.GetterByBindingType=[nu.prototype._getValue_direct,nu.prototype._getValue_array,nu.prototype._getValue_arrayElement,nu.prototype._getValue_toArray],nu.prototype.SetterByBindingTypeAndVersioning=[[nu.prototype._setValue_direct,nu.prototype._setValue_direct_setNeedsUpdate,nu.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[nu.prototype._setValue_array,nu.prototype._setValue_array_setNeedsUpdate,nu.prototype._setValue_array_setMatrixWorldNeedsUpdate],[nu.prototype._setValue_arrayElement,nu.prototype._setValue_arrayElement_setNeedsUpdate,nu.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[nu.prototype._setValue_fromArray,nu.prototype._setValue_fromArray_setNeedsUpdate,nu.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class ru{constructor(e,t,n=null,r=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=n,this.blendMode=r;const i=t.tracks,s=i.length,a=new Array(s),o={endingStart:ne,endingEnd:ne};for(let e=0;e!==s;++e){const t=i[e].createInterpolant(null);a[e]=t,t.settings=o}this._interpolantSettings=o,this._interpolants=a,this._propertyBindings=new Array(s),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,n){if(e.fadeOut(t),this.fadeIn(t),n){const n=this._clip.duration,r=e._clip.duration,i=r/n,s=n/r;e.warp(1,i,t),this.warp(s,1,t)}return this}crossFadeTo(e,t,n){return e.crossFadeFrom(this,t,n)}stopFading(){const e=this._weightInterpolant;return null!==e&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,n){const r=this._mixer,i=r.time,s=this.timeScale;let a=this._timeScaleInterpolant;null===a&&(a=r._lendControlInterpolant(),this._timeScaleInterpolant=a);const o=a.parameterPositions,l=a.sampleValues;return o[0]=i,o[1]=i+n,l[0]=e/s,l[1]=t/s,this}stopWarping(){const e=this._timeScaleInterpolant;return null!==e&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,n,r){if(!this.enabled)return void this._updateWeight(e);const i=this._startTime;if(null!==i){const r=(e-i)*n;if(r<0||0===n)return;this._startTime=null,t=n*r}t*=this._updateTimeScale(e);const s=this._updateTime(t),a=this._updateWeight(e);if(a>0){const e=this._interpolants,t=this._propertyBindings;if(this.blendMode===se)for(let n=0,r=e.length;n!==r;++n)e[n].evaluate(s),t[n].accumulateAdditive(a);else for(let n=0,i=e.length;n!==i;++n)e[n].evaluate(s),t[n].accumulate(r,a)}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const n=this._weightInterpolant;if(null!==n){const r=n.evaluate(e)[0];t*=r,e>n.parameterPositions[1]&&(this.stopFading(),0===r&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const n=this._timeScaleInterpolant;null!==n&&(t*=n.evaluate(e)[0],e>n.parameterPositions[1]&&(this.stopWarping(),0===t?this.paused=!0:this.timeScale=t))}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,n=this.loop;let r=this.time+e,i=this._loopCount;const s=2202===n;if(0===e)return-1===i?r:s&&1==(1&i)?t-r:r;if(2200===n){-1===i&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(r>=t)r=t;else{if(!(r<0)){this.time=r;break e}r=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(-1===i&&(e>=0?(i=0,this._setEndings(!0,0===this.repetitions,s)):this._setEndings(0===this.repetitions,!0,s)),r>=t||r<0){const n=Math.floor(r/t);r-=t*n,i+=Math.abs(n);const a=this.repetitions-i;if(a<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=e>0?t:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(1===a){const t=e<0;this._setEndings(t,!t,s)}else this._setEndings(!1,!1,s);this._loopCount=i,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:n})}}else this.time=r;if(s&&1==(1&i))return t-r}return r}_setEndings(e,t,n){const r=this._interpolantSettings;n?(r.endingStart=re,r.endingEnd=re):(r.endingStart=e?this.zeroSlopeAtStart?re:ne:ie,r.endingEnd=t?this.zeroSlopeAtEnd?re:ne:ie)}_scheduleFading(e,t,n){const r=this._mixer,i=r.time;let s=this._weightInterpolant;null===s&&(s=r._lendControlInterpolant(),this._weightInterpolant=s);const a=s.parameterPositions,o=s.sampleValues;return a[0]=i,o[0]=t,a[1]=i+e,o[1]=n,this}}const iu=new Float32Array(1);class su{constructor(e){"string"==typeof e&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}clone(){return new su(void 0===this.value.clone?this.value:this.value.clone())}}function au(e,t){return e.distance-t.distance}function ou(e,t,n,r){if(e.layers.test(t.layers)&&e.raycast(t,n),!0===r){const r=e.children;for(let e=0,i=r.length;e<i;e++)ou(r[e],t,n,!0)}}const lu=new Ae,cu=new tt,uu=new tt,hu=new tt,du=new tt,pu=new Rt,fu=new Rt;function mu(e){const t=[];!0===e.isBone&&t.push(e);for(let n=0;n<e.children.length;n++)t.push.apply(t,mu(e.children[n]));return t}const gu=new tt,yu=new We,vu=new We,xu=new tt,bu=new tt,wu=new tt,_u=new tt,Su=new rr;function Mu(e,t,n,r,i,s,a){_u.set(i,s,a).unproject(r);const o=t[e];if(void 0!==o){const e=n.getAttribute("position");for(let t=0,n=o.length;t<n;t++)e.setXYZ(o[t],_u.x,_u.y,_u.z)}}const Tu=new it,Eu=new tt;let Au,Cu;const Iu=new ArrayBuffer(4),Nu=new Float32Array(Iu),ku=new Uint32Array(Iu),Ru=new Uint32Array(512),Du=new Uint32Array(512);for(let e=0;e<256;++e){const t=e-127;t<-27?(Ru[e]=0,Ru[256|e]=32768,Du[e]=24,Du[256|e]=24):t<-14?(Ru[e]=1024>>-t-14,Ru[256|e]=1024>>-t-14|32768,Du[e]=-t-1,Du[256|e]=-t-1):t<=15?(Ru[e]=t+15<<10,Ru[256|e]=t+15<<10|32768,Du[e]=13,Du[256|e]=13):t<128?(Ru[e]=31744,Ru[256|e]=64512,Du[e]=24,Du[256|e]=24):(Ru[e]=31744,Ru[256|e]=64512,Du[e]=13,Du[256|e]=13)}const Lu=new Uint32Array(2048),Fu=new Uint32Array(64),Pu=new Uint32Array(64);for(let e=1;e<1024;++e){let t=e<<13,n=0;for(;0==(8388608&t);)t<<=1,n-=8388608;t&=-8388609,n+=947912704,Lu[e]=t|n}for(let e=1024;e<2048;++e)Lu[e]=939524096+(e-1024<<13);for(let e=1;e<31;++e)Fu[e]=e<<23;Fu[31]=1199570944,Fu[32]=2147483648;for(let e=33;e<63;++e)Fu[e]=2147483648+(e-32<<23);Fu[63]=3347054592;for(let e=1;e<64;++e)32!==e&&(Pu[e]=1024);"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:n}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=n),t.ACESFilmicToneMapping=4,t.AddEquation=r,t.AddOperation=2,t.AdditiveAnimationBlendMode=se,t.AdditiveBlending=2,t.AlphaFormat=1021,t.AlwaysDepth=1,t.AlwaysStencilFunc=519,t.AmbientLight=xc,t.AmbientLightProbe=class extends _c{constructor(e,t=1){super(void 0,t),this.isAmbientLightProbe=!0;const n=(new We).set(e);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}},t.AnimationClip=Yl,t.AnimationLoader=class extends ec{constructor(e){super(e)}load(e,t,n,r){const i=this,s=new nc(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(e,(function(n){try{t(i.parse(JSON.parse(n)))}catch(t){r?r(t):console.error(t),i.manager.itemError(e)}}),n,r)}parse(e){const t=[];for(let n=0;n<e.length;n++){const r=Yl.parse(e[n]);t.push(r)}return t}},t.AnimationMixer=class extends fe{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const n=e._localRoot||this._root,r=e._clip.tracks,i=r.length,s=e._propertyBindings,a=e._interpolants,o=n.uuid,l=this._bindingsByRootAndName;let c=l[o];void 0===c&&(c={},l[o]=c);for(let e=0;e!==i;++e){const i=r[e],l=i.name;let u=c[l];if(void 0!==u)++u.referenceCount,s[e]=u;else{if(u=s[e],void 0!==u){null===u._cacheIndex&&(++u.referenceCount,this._addInactiveBinding(u,o,l));continue}const r=t&&t._propertyBindings[e].binding.parsedPath;u=new jc(nu.create(n,l,r),i.ValueTypeName,i.getValueSize()),++u.referenceCount,this._addInactiveBinding(u,o,l),s[e]=u}a[e].resultBuffer=u.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(null===e._cacheIndex){const t=(e._localRoot||this._root).uuid,n=e._clip.uuid,r=this._actionsByClip[n];this._bindAction(e,r&&r.knownActions[0]),this._addInactiveAction(e,n,t)}const t=e._propertyBindings;for(let e=0,n=t.length;e!==n;++e){const n=t[e];0==n.useCount++&&(this._lendBinding(n),n.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let e=0,n=t.length;e!==n;++e){const n=t[e];0==--n.useCount&&(n.restoreOriginalState(),this._takeBackBinding(n))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return null!==t&&t<this._nActiveActions}_addInactiveAction(e,t,n){const r=this._actions,i=this._actionsByClip;let s=i[t];if(void 0===s)s={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,i[t]=s;else{const t=s.knownActions;e._byClipCacheIndex=t.length,t.push(e)}e._cacheIndex=r.length,r.push(e),s.actionByRoot[n]=e}_removeInactiveAction(e){const t=this._actions,n=t[t.length-1],r=e._cacheIndex;n._cacheIndex=r,t[r]=n,t.pop(),e._cacheIndex=null;const i=e._clip.uuid,s=this._actionsByClip,a=s[i],o=a.knownActions,l=o[o.length-1],c=e._byClipCacheIndex;l._byClipCacheIndex=c,o[c]=l,o.pop(),e._byClipCacheIndex=null,delete a.actionByRoot[(e._localRoot||this._root).uuid],0===o.length&&delete s[i],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let e=0,n=t.length;e!==n;++e){const n=t[e];0==--n.referenceCount&&this._removeInactiveBinding(n)}}_lendAction(e){const t=this._actions,n=e._cacheIndex,r=this._nActiveActions++,i=t[r];e._cacheIndex=r,t[r]=e,i._cacheIndex=n,t[n]=i}_takeBackAction(e){const t=this._actions,n=e._cacheIndex,r=--this._nActiveActions,i=t[r];e._cacheIndex=r,t[r]=e,i._cacheIndex=n,t[n]=i}_addInactiveBinding(e,t,n){const r=this._bindingsByRootAndName,i=this._bindings;let s=r[t];void 0===s&&(s={},r[t]=s),s[n]=e,e._cacheIndex=i.length,i.push(e)}_removeInactiveBinding(e){const t=this._bindings,n=e.binding,r=n.rootNode.uuid,i=n.path,s=this._bindingsByRootAndName,a=s[r],o=t[t.length-1],l=e._cacheIndex;o._cacheIndex=l,t[l]=o,t.pop(),delete a[i],0===Object.keys(a).length&&delete s[r]}_lendBinding(e){const t=this._bindings,n=e._cacheIndex,r=this._nActiveBindings++,i=t[r];e._cacheIndex=r,t[r]=e,i._cacheIndex=n,t[n]=i}_takeBackBinding(e){const t=this._bindings,n=e._cacheIndex,r=--this._nActiveBindings,i=t[r];e._cacheIndex=r,t[r]=e,i._cacheIndex=n,t[n]=i}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return void 0===n&&(n=new Bl(new Float32Array(2),new Float32Array(2),1,iu),n.__cacheIndex=t,e[t]=n),n}_takeBackControlInterpolant(e){const t=this._controlInterpolants,n=e.__cacheIndex,r=--this._nActiveControlInterpolants,i=t[r];e.__cacheIndex=r,t[r]=e,i.__cacheIndex=n,t[n]=i}clipAction(e,t,n){const r=t||this._root,i=r.uuid;let s="string"==typeof e?Yl.findByName(r,e):e;const a=null!==s?s.uuid:e,o=this._actionsByClip[a];let l=null;if(void 0===n&&(n=null!==s?s.blendMode:2500),void 0!==o){const e=o.actionByRoot[i];if(void 0!==e&&e.blendMode===n)return e;l=o.knownActions[0],null===s&&(s=l._clip)}if(null===s)return null;const c=new ru(this,s,t,n);return this._bindAction(c,l),this._addInactiveAction(c,a,i),c}existingAction(e,t){const n=t||this._root,r=n.uuid,i="string"==typeof e?Yl.findByName(n,e):e,s=i?i.uuid:e,a=this._actionsByClip[s];return void 0!==a&&a.actionByRoot[r]||null}stopAllAction(){const e=this._actions;for(let t=this._nActiveActions-1;t>=0;--t)e[t].stop();return this}update(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,r=this.time+=e,i=Math.sign(e),s=this._accuIndex^=1;for(let a=0;a!==n;++a)t[a]._update(r,e,i,s);const a=this._bindings,o=this._nActiveBindings;for(let e=0;e!==o;++e)a[e].apply(s);return this}setTime(e){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,n=e.uuid,r=this._actionsByClip,i=r[n];if(void 0!==i){const e=i.knownActions;for(let n=0,r=e.length;n!==r;++n){const r=e[n];this._deactivateAction(r);const i=r._cacheIndex,s=t[t.length-1];r._cacheIndex=null,r._byClipCacheIndex=null,s._cacheIndex=i,t[i]=s,t.pop(),this._removeInactiveBindingsForAction(r)}delete r[n]}}uncacheRoot(e){const t=e.uuid,n=this._actionsByClip;for(const e in n){const r=n[e].actionByRoot[t];void 0!==r&&(this._deactivateAction(r),this._removeInactiveAction(r))}const r=this._bindingsByRootAndName[t];if(void 0!==r)for(const e in r){const t=r[e];t.restoreOriginalState(),this._removeInactiveBinding(t)}}uncacheAction(e,t){const n=this.existingAction(e,t);null!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}},t.AnimationObjectGroup=class{constructor(){this.isAnimationObjectGroup=!0,this.uuid=xe(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let t=0,n=arguments.length;t!==n;++t)e[arguments[t].uuid]=t;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,n=this._paths,r=this._parsedPaths,i=this._bindings,s=i.length;let a,o=e.length,l=this.nCachedObjects_;for(let c=0,u=arguments.length;c!==u;++c){const u=arguments[c],h=u.uuid;let d=t[h];if(void 0===d){d=o++,t[h]=d,e.push(u);for(let e=0,t=s;e!==t;++e)i[e].push(new nu(u,n[e],r[e]))}else if(d<l){a=e[d];const o=--l,c=e[o];t[c.uuid]=d,e[d]=c,t[h]=o,e[o]=u;for(let e=0,t=s;e!==t;++e){const t=i[e],s=t[o];let a=t[d];t[d]=s,void 0===a&&(a=new nu(u,n[e],r[e])),t[o]=a}}else e[d]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l}remove(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,r=n.length;let i=this.nCachedObjects_;for(let s=0,a=arguments.length;s!==a;++s){const a=arguments[s],o=a.uuid,l=t[o];if(void 0!==l&&l>=i){const s=i++,c=e[s];t[c.uuid]=l,e[l]=c,t[o]=s,e[s]=a;for(let e=0,t=r;e!==t;++e){const t=n[e],r=t[s],i=t[l];t[l]=r,t[s]=i}}}this.nCachedObjects_=i}uncache(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,r=n.length;let i=this.nCachedObjects_,s=e.length;for(let a=0,o=arguments.length;a!==o;++a){const o=arguments[a].uuid,l=t[o];if(void 0!==l)if(delete t[o],l<i){const a=--i,o=e[a],c=--s,u=e[c];t[o.uuid]=l,e[l]=o,t[u.uuid]=a,e[a]=u,e.pop();for(let e=0,t=r;e!==t;++e){const t=n[e],r=t[a],i=t[c];t[l]=r,t[a]=i,t.pop()}}else{const i=--s,a=e[i];i>0&&(t[a.uuid]=l),e[l]=a,e.pop();for(let e=0,t=r;e!==t;++e){const t=n[e];t[l]=t[i],t.pop()}}}this.nCachedObjects_=i}subscribe_(e,t){const n=this._bindingsIndicesByPath;let r=n[e];const i=this._bindings;if(void 0!==r)return i[r];const s=this._paths,a=this._parsedPaths,o=this._objects,l=o.length,c=this.nCachedObjects_,u=new Array(l);r=i.length,n[e]=r,s.push(e),a.push(t),i.push(u);for(let n=c,r=o.length;n!==r;++n){const r=o[n];u[n]=new nu(r,e,t)}return u}unsubscribe_(e){const t=this._bindingsIndicesByPath,n=t[e];if(void 0!==n){const r=this._paths,i=this._parsedPaths,s=this._bindings,a=s.length-1,o=s[a];t[e[a]]=n,s[n]=o,s.pop(),i[n]=i[a],i.pop(),r[n]=r[a],r.pop()}}},t.AnimationUtils=Pl,t.ArcCurve=io,t.ArrayCamera=Us,t.ArrowHelper=class extends rn{constructor(e=new tt(0,0,1),t=new tt(0,0,0),n=1,r=16776960,i=.2*n,s=.2*i){super(),this.type="ArrowHelper",void 0===Au&&(Au=new Rn,Au.setAttribute("position",new Mn([0,0,0,0,1,0],3)),Cu=new Co(0,.5,1,5,1),Cu.translate(0,-.5,0)),this.position.copy(t),this.line=new Wa(Au,new Oa({color:r,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Kn(Cu,new vn({color:r,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(n,i,s)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{Eu.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(Eu,t)}}setLength(e,t=.2*e,n=.2*t){this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(n,t,n),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}},t.Audio=$c,t.AudioAnalyser=class{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let n=0;n<t.length;n++)e+=t[n];return e/t.length}},t.AudioContext=kc,t.AudioListener=class extends rn{constructor(){super(),this.type="AudioListener",this.context=kc.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Fc}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,n=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Oc,zc,Bc),Uc.set(0,0,-1).applyQuaternion(zc),t.positionX){const e=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(Oc.x,e),t.positionY.linearRampToValueAtTime(Oc.y,e),t.positionZ.linearRampToValueAtTime(Oc.z,e),t.forwardX.linearRampToValueAtTime(Uc.x,e),t.forwardY.linearRampToValueAtTime(Uc.y,e),t.forwardZ.linearRampToValueAtTime(Uc.z,e),t.upX.linearRampToValueAtTime(n.x,e),t.upY.linearRampToValueAtTime(n.y,e),t.upZ.linearRampToValueAtTime(n.z,e)}else t.setPosition(Oc.x,Oc.y,Oc.z),t.setOrientation(Uc.x,Uc.y,Uc.z,n.x,n.y,n.z)}},t.AudioLoader=class extends ec{constructor(e){super(e)}load(e,t,n,r){const i=this,s=new nc(this.manager);s.setResponseType("arraybuffer"),s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(e,(function(n){try{const e=n.slice(0);kc.getContext().decodeAudioData(e,(function(e){t(e)}))}catch(t){r?r(t):console.error(t),i.manager.itemError(e)}}),n,r)}},t.AxesHelper=class extends ja{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],n=new Rn;n.setAttribute("position",new Mn(t,3)),n.setAttribute("color",new Mn([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3)),super(n,new Oa({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}setColors(e,t,n){const r=new We,i=this.geometry.attributes.color.array;return r.set(e),r.toArray(i,0),r.toArray(i,3),r.set(t),r.toArray(i,6),r.toArray(i,9),r.set(n),r.toArray(i,12),r.toArray(i,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}},t.BackSide=1,t.BasicDepthPacking=3200,t.BasicShadowMap=0,t.Bone=Ea,t.BooleanKeyframeTrack=Vl,t.Box2=class{constructor(e=new Ae(1/0,1/0),t=new Ae(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=lu.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return lu.copy(e).clamp(this.min,this.max).sub(e).length()}intersect(e){return this.min.max(e.min),this.max.min(e.max),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}},t.Box3=it,t.Box3Helper=class extends ja{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Rn;r.setIndex(new wn(n,1)),r.setAttribute("position",new Mn([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(r,new Oa({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}},t.BoxBufferGeometry=Jn,t.BoxGeometry=Jn,t.BoxHelper=class extends ja{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Float32Array(24),i=new Rn;i.setIndex(new wn(n,1)),i.setAttribute("position",new wn(r,3)),super(i,new Oa({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(void 0!==e&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&Tu.setFromObject(this.object),Tu.isEmpty())return;const t=Tu.min,n=Tu.max,r=this.geometry.attributes.position,i=r.array;i[0]=n.x,i[1]=n.y,i[2]=n.z,i[3]=t.x,i[4]=n.y,i[5]=n.z,i[6]=t.x,i[7]=t.y,i[8]=n.z,i[9]=n.x,i[10]=t.y,i[11]=n.z,i[12]=n.x,i[13]=n.y,i[14]=t.z,i[15]=t.x,i[16]=n.y,i[17]=t.z,i[18]=t.x,i[19]=t.y,i[20]=t.z,i[21]=n.x,i[22]=t.y,i[23]=t.z,r.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e,t){return super.copy(e,t),this.object=e.object,this}},t.BufferAttribute=wn,t.BufferGeometry=Rn,t.BufferGeometryLoader=Ec,t.ByteType=1010,t.Cache=Zl,t.Camera=rr,t.CameraHelper=class extends ja{constructor(e){const t=new Rn,n=new Oa({color:16777215,vertexColors:!0,toneMapped:!1}),r=[],i=[],s={},a=new We(16755200),o=new We(16711680),l=new We(43775),c=new We(16777215),u=new We(3355443);function h(e,t,n){d(e,n),d(t,n)}function d(e,t){r.push(0,0,0),i.push(t.r,t.g,t.b),void 0===s[e]&&(s[e]=[]),s[e].push(r.length/3-1)}h("n1","n2",a),h("n2","n4",a),h("n4","n3",a),h("n3","n1",a),h("f1","f2",a),h("f2","f4",a),h("f4","f3",a),h("f3","f1",a),h("n1","f1",a),h("n2","f2",a),h("n3","f3",a),h("n4","f4",a),h("p","n1",o),h("p","n2",o),h("p","n3",o),h("p","n4",o),h("u1","u2",l),h("u2","u3",l),h("u3","u1",l),h("c","t",c),h("p","c",u),h("cn1","cn2",u),h("cn3","cn4",u),h("cf1","cf2",u),h("cf3","cf4",u),t.setAttribute("position",new Mn(r,3)),t.setAttribute("color",new Mn(i,3)),super(t,n),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=s,this.update()}update(){const e=this.geometry,t=this.pointMap;Su.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),Mu("c",t,e,Su,0,0,-1),Mu("t",t,e,Su,0,0,1),Mu("n1",t,e,Su,-1,-1,-1),Mu("n2",t,e,Su,1,-1,-1),Mu("n3",t,e,Su,-1,1,-1),Mu("n4",t,e,Su,1,1,-1),Mu("f1",t,e,Su,-1,-1,1),Mu("f2",t,e,Su,1,-1,1),Mu("f3",t,e,Su,-1,1,1),Mu("f4",t,e,Su,1,1,1),Mu("u1",t,e,Su,.7,1.1,-1),Mu("u2",t,e,Su,-.7,1.1,-1),Mu("u3",t,e,Su,0,2,-1),Mu("cf1",t,e,Su,-1,0,1),Mu("cf2",t,e,Su,1,0,1),Mu("cf3",t,e,Su,0,-1,1),Mu("cf4",t,e,Su,0,1,1),Mu("cn1",t,e,Su,-1,0,-1),Mu("cn2",t,e,Su,1,0,-1),Mu("cn3",t,e,Su,0,-1,-1),Mu("cn4",t,e,Su,0,1,-1),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}},t.CanvasTexture=class extends Ye{constructor(e,t,n,r,i,s,a,o,l){super(e,t,n,r,i,s,a,o,l),this.isCanvasTexture=!0,this.needsUpdate=!0}},t.CapsuleBufferGeometry=Eo,t.CapsuleGeometry=Eo,t.CatmullRomCurve3=uo,t.CineonToneMapping=3,t.CircleBufferGeometry=Ao,t.CircleGeometry=Ao,t.ClampToEdgeWrapping=h,t.Clock=Fc,t.Color=We,t.ColorKeyframeTrack=Wl,t.ColorManagement=Pe,t.CompressedTexture=to,t.CompressedTextureLoader=class extends ec{constructor(e){super(e)}load(e,t,n,r){const i=this,s=[],a=new to,o=new nc(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(i.withCredentials);let l=0;function c(c){o.load(e[c],(function(e){const n=i.parse(e,!0);s[c]={width:n.width,height:n.height,format:n.format,mipmaps:n.mipmaps},l+=1,6===l&&(1===n.mipmapCount&&(a.minFilter=g),a.image=s,a.format=n.format,a.needsUpdate=!0,t&&t(a))}),n,r)}if(Array.isArray(e))for(let t=0,n=e.length;t<n;++t)c(t);else o.load(e,(function(e){const n=i.parse(e,!0);if(n.isCubemap){const e=n.mipmaps.length/n.mipmapCount;for(let t=0;t<e;t++){s[t]={mipmaps:[]};for(let e=0;e<n.mipmapCount;e++)s[t].mipmaps.push(n.mipmaps[t*n.mipmapCount+e]),s[t].format=n.format,s[t].width=n.width,s[t].height=n.height}a.image=s}else a.image.width=n.width,a.image.height=n.height,a.mipmaps=n.mipmaps;1===n.mipmapCount&&(a.minFilter=g),a.format=n.format,a.needsUpdate=!0,t&&t(a)}),n,r);return a}},t.ConeBufferGeometry=Io,t.ConeGeometry=Io,t.CubeCamera=ar,t.CubeReflectionMapping=s,t.CubeRefractionMapping=a,t.CubeTexture=or,t.CubeTextureLoader=class extends ec{constructor(e){super(e)}load(e,t,n,r){const i=new or,s=new rc(this.manager);s.setCrossOrigin(this.crossOrigin),s.setPath(this.path);let a=0;function o(n){s.load(e[n],(function(e){i.images[n]=e,a++,6===a&&(i.needsUpdate=!0,t&&t(i))}),void 0,r)}for(let t=0;t<e.length;++t)o(t);return i}},t.CubeUVReflectionMapping=c,t.CubicBezierCurve=mo,t.CubicBezierCurve3=go,t.CubicInterpolant=zl,t.CullFaceBack=1,t.CullFaceFront=2,t.CullFaceFrontBack=3,t.CullFaceNone=0,t.Curve=no,t.CurvePath=So,t.CustomBlending=5,t.CustomToneMapping=5,t.CylinderBufferGeometry=Co,t.CylinderGeometry=Co,t.Cylindrical=class{constructor(e=1,t=0,n=0){return this.radius=e,this.theta=t,this.y=n,this}set(e,t,n){return this.radius=e,this.theta=t,this.y=n,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+n*n),this.theta=Math.atan2(e,n),this.y=t,this}clone(){return(new this.constructor).copy(this)}},t.Data3DTexture=Qe,t.DataArrayTexture=Je,t.DataTexture=Aa,t.DataTexture2DArray=class extends Je{constructor(e,t,n,r){console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."),super(e,t,n,r)}},t.DataTexture3D=class extends Qe{constructor(e,t,n,r){console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."),super(e,t,n,r)}},t.DataTextureLoader=class extends ec{constructor(e){super(e)}load(e,t,n,r){const i=this,s=new Aa,a=new nc(this.manager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(i.withCredentials),a.load(e,(function(e){const n=i.parse(e);n&&(void 0!==n.image?s.image=n.image:void 0!==n.data&&(s.image.width=n.width,s.image.height=n.height,s.image.data=n.data),s.wrapS=void 0!==n.wrapS?n.wrapS:h,s.wrapT=void 0!==n.wrapT?n.wrapT:h,s.magFilter=void 0!==n.magFilter?n.magFilter:g,s.minFilter=void 0!==n.minFilter?n.minFilter:g,s.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.encoding&&(s.encoding=n.encoding),void 0!==n.flipY&&(s.flipY=n.flipY),void 0!==n.format&&(s.format=n.format),void 0!==n.type&&(s.type=n.type),void 0!==n.mipmaps&&(s.mipmaps=n.mipmaps,s.minFilter=v),1===n.mipmapCount&&(s.minFilter=g),void 0!==n.generateMipmaps&&(s.generateMipmaps=n.generateMipmaps),s.needsUpdate=!0,t&&t(s,n))}),n,r),s}},t.DataUtils=class{static toHalfFloat(e){Math.abs(e)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),e=be(e,-65504,65504),Nu[0]=e;const t=ku[0],n=t>>23&511;return Ru[n]+((8388607&t)>>Du[n])}static fromHalfFloat(e){const t=e>>10;return ku[0]=Lu[Pu[t]+(1023&e)]+Fu[t],Nu[0]}},t.DecrementStencilOp=7683,t.DecrementWrapStencilOp=34056,t.DefaultLoadingManager=Ql,t.DepthFormat=E,t.DepthStencilFormat=A,t.DepthTexture=Gs,t.DirectionalLight=vc,t.DirectionalLightHelper=class extends rn{constructor(e,t,n){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,void 0===t&&(t=1);let r=new Rn;r.setAttribute("position",new Mn([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const i=new Oa({fog:!1,toneMapped:!1});this.lightPlane=new Wa(r,i),this.add(this.lightPlane),r=new Rn,r.setAttribute("position",new Mn([0,0,0,0,0,1],3)),this.targetLine=new Wa(r,i),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){xu.setFromMatrixPosition(this.light.matrixWorld),bu.setFromMatrixPosition(this.light.target.matrixWorld),wu.subVectors(bu,xu),this.lightPlane.lookAt(bu),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(bu),this.targetLine.scale.z=wu.length()}},t.DiscreteInterpolant=Ul,t.DodecahedronBufferGeometry=ko,t.DodecahedronGeometry=ko,t.DoubleSide=2,t.DstAlphaFactor=206,t.DstColorFactor=208,t.DynamicCopyUsage=35050,t.DynamicDrawUsage=35048,t.DynamicReadUsage=35049,t.EdgesGeometry=Po,t.EllipseCurve=ro,t.EqualDepth=4,t.EqualStencilFunc=514,t.EquirectangularReflectionMapping=o,t.EquirectangularRefractionMapping=l,t.Euler=Vt,t.EventDispatcher=fe,t.ExtrudeBufferGeometry=hl,t.ExtrudeGeometry=hl,t.FileLoader=nc,t.FlatShading=1,t.Float16BufferAttribute=class extends wn{constructor(e,t,n){super(new Uint16Array(e),t,n),this.isFloat16BufferAttribute=!0}},t.Float32BufferAttribute=Mn,t.Float64BufferAttribute=class extends wn{constructor(e,t,n){super(new Float64Array(e),t,n)}},t.FloatType=_,t.Fog=Ks,t.FogExp2=Ys,t.Font=function(){console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js")},t.FontLoader=function(){console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js")},t.FramebufferTexture=class extends Ye{constructor(e,t,n){super({width:e,height:t}),this.isFramebufferTexture=!0,this.format=n,this.magFilter=p,this.minFilter=p,this.generateMipmaps=!1,this.needsUpdate=!0}},t.FrontSide=0,t.Frustum=mr,t.GLBufferAttribute=class{constructor(e,t,n,r,i){this.isGLBufferAttribute=!0,this.buffer=e,this.type=t,this.itemSize=n,this.elementSize=r,this.count=i,this.version=0}set needsUpdate(e){!0===e&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}},t.GLSL1="100",t.GLSL3=de,t.GreaterDepth=6,t.GreaterEqualDepth=5,t.GreaterEqualStencilFunc=518,t.GreaterStencilFunc=516,t.GridHelper=class extends ja{constructor(e=10,t=10,n=4473924,r=8947848){n=new We(n),r=new We(r);const i=t/2,s=e/t,a=e/2,o=[],l=[];for(let e=0,c=0,u=-a;e<=t;e++,u+=s){o.push(-a,0,u,a,0,u),o.push(u,0,-a,u,0,a);const t=e===i?n:r;t.toArray(l,c),c+=3,t.toArray(l,c),c+=3,t.toArray(l,c),c+=3,t.toArray(l,c),c+=3}const c=new Rn;c.setAttribute("position",new Mn(o,3)),c.setAttribute("color",new Mn(l,3)),super(c,new Oa({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}},t.Group=$s,t.HalfFloatType=S,t.HemisphereLight=sc,t.HemisphereLightHelper=class extends rn{constructor(e,t,n){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n;const r=new fl(t);r.rotateY(.5*Math.PI),this.material=new vn({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);const i=r.getAttribute("position"),s=new Float32Array(3*i.count);r.setAttribute("color",new wn(s,3)),this.add(new Kn(r,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");yu.copy(this.light.color),vu.copy(this.light.groundColor);for(let e=0,n=t.count;e<n;e++){const r=e<n/2?yu:vu;t.setXYZ(e,r.r,r.g,r.b)}t.needsUpdate=!0}e.lookAt(gu.setFromMatrixPosition(this.light.matrixWorld).negate())}},t.HemisphereLightProbe=class extends _c{constructor(e,t,n=1){super(void 0,n),this.isHemisphereLightProbe=!0;const r=(new We).set(e),i=(new We).set(t),s=new tt(r.r,r.g,r.b),a=new tt(i.r,i.g,i.b),o=Math.sqrt(Math.PI),l=o*Math.sqrt(.75);this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o),this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)}},t.IcosahedronBufferGeometry=pl,t.IcosahedronGeometry=pl,t.ImageBitmapLoader=class extends ec{constructor(e){super(e),this.isImageBitmapLoader=!0,"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,n,r){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const i=this,s=Zl.get(e);if(void 0!==s)return i.manager.itemStart(e),setTimeout((function(){t&&t(s),i.manager.itemEnd(e)}),0),s;const a={};a.credentials="anonymous"===this.crossOrigin?"same-origin":"include",a.headers=this.requestHeader,fetch(e,a).then((function(e){return e.blob()})).then((function(e){return createImageBitmap(e,Object.assign(i.options,{colorSpaceConversion:"none"}))})).then((function(n){Zl.add(e,n),t&&t(n),i.manager.itemEnd(e)})).catch((function(t){r&&r(t),i.manager.itemError(e),i.manager.itemEnd(e)})),i.manager.itemStart(e)}},t.ImageLoader=rc,t.ImageUtils=He,t.ImmediateRenderObject=function(){console.error("THREE.ImmediateRenderObject has been removed.")},t.IncrementStencilOp=7682,t.IncrementWrapStencilOp=34055,t.InstancedBufferAttribute=ka,t.InstancedBufferGeometry=Tc,t.InstancedInterleavedBuffer=class extends Js{constructor(e,t,n=1){super(e,t),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=n}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}},t.InstancedMesh=Pa,t.Int16BufferAttribute=class extends wn{constructor(e,t,n){super(new Int16Array(e),t,n)}},t.Int32BufferAttribute=class extends wn{constructor(e,t,n){super(new Int32Array(e),t,n)}},t.Int8BufferAttribute=class extends wn{constructor(e,t,n){super(new Int8Array(e),t,n)}},t.IntType=1013,t.InterleavedBuffer=Js,t.InterleavedBufferAttribute=ea,t.Interpolant=Ol,t.InterpolateDiscrete=Q,t.InterpolateLinear=ee,t.InterpolateSmooth=te,t.InvertStencilOp=5386,t.KeepStencilOp=ue,t.KeyframeTrack=$l,t.LOD=xa,t.LatheBufferGeometry=To,t.LatheGeometry=To,t.Layers=Wt,t.LessDepth=2,t.LessEqualDepth=3,t.LessEqualStencilFunc=515,t.LessStencilFunc=513,t.Light=ic,t.LightProbe=_c,t.Line=Wa,t.Line3=class{constructor(e=new tt,t=new tt){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){cu.subVectors(e,this.start),uu.subVectors(this.end,this.start);const n=uu.dot(uu);let r=uu.dot(cu)/n;return t&&(r=be(r,0,1)),r}closestPointToPoint(e,t,n){const r=this.closestPointToPointParameter(e,t);return this.delta(n).multiplyScalar(r).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}},t.LineBasicMaterial=Oa,t.LineCurve=yo,t.LineCurve3=vo,t.LineDashedMaterial=Ll,t.LineLoop=qa,t.LineSegments=ja,t.LinearEncoding=ae,t.LinearFilter=g,t.LinearInterpolant=Bl,t.LinearMipMapLinearFilter=1008,t.LinearMipMapNearestFilter=1007,t.LinearMipmapLinearFilter=v,t.LinearMipmapNearestFilter=y,t.LinearSRGBColorSpace=ce,t.LinearToneMapping=1,t.Loader=ec,t.LoaderUtils=Mc,t.LoadingManager=Jl,t.LoopOnce=2200,t.LoopPingPong=2202,t.LoopRepeat=2201,t.LuminanceAlphaFormat=1025,t.LuminanceFormat=1024,t.MOUSE={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},t.Material=yn,t.MaterialLoader=Sc,t.MathUtils=Ee,t.Matrix3=Ce,t.Matrix4=Rt,t.MaxEquation=104,t.Mesh=Kn,t.MeshBasicMaterial=vn,t.MeshDepthMaterial=Ls,t.MeshDistanceMaterial=Fs,t.MeshLambertMaterial=Rl,t.MeshMatcapMaterial=Dl,t.MeshNormalMaterial=kl,t.MeshPhongMaterial=Il,t.MeshPhysicalMaterial=Cl,t.MeshStandardMaterial=Al,t.MeshToonMaterial=Nl,t.MinEquation=103,t.MirroredRepeatWrapping=d,t.MixOperation=1,t.MultiplyBlending=4,t.MultiplyOperation=0,t.NearestFilter=p,t.NearestMipMapLinearFilter=1005,t.NearestMipMapNearestFilter=1004,t.NearestMipmapLinearFilter=m,t.NearestMipmapNearestFilter=f,t.NeverDepth=0,t.NeverStencilFunc=512,t.NoBlending=0,t.NoColorSpace="",t.NoToneMapping=0,t.NormalAnimationBlendMode=2500,t.NormalBlending=1,t.NotEqualDepth=7,t.NotEqualStencilFunc=517,t.NumberKeyframeTrack=Gl,t.Object3D=rn,t.ObjectLoader=class extends ec{constructor(e){super(e)}load(e,t,n,r){const i=this,s=""===this.path?Mc.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||s;const a=new nc(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,(function(n){let s=null;try{s=JSON.parse(n)}catch(t){return void 0!==r&&r(t),void console.error("THREE:ObjectLoader: Can't parse "+e+".",t.message)}const a=s.metadata;void 0!==a&&void 0!==a.type&&"geometry"!==a.type.toLowerCase()?i.parse(s,t):console.error("THREE.ObjectLoader: Can't load "+e)}),n,r)}async loadAsync(e,t){const n=""===this.path?Mc.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||n;const r=new nc(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials);const i=await r.loadAsync(e,t),s=JSON.parse(i),a=s.metadata;if(void 0===a||void 0===a.type||"geometry"===a.type.toLowerCase())throw new Error("THREE.ObjectLoader: Can't load "+e);return await this.parseAsync(s)}parse(e,t){const n=this.parseAnimations(e.animations),r=this.parseShapes(e.shapes),i=this.parseGeometries(e.geometries,r),s=this.parseImages(e.images,(function(){void 0!==t&&t(l)})),a=this.parseTextures(e.textures,s),o=this.parseMaterials(e.materials,a),l=this.parseObject(e.object,i,o,a,n),c=this.parseSkeletons(e.skeletons,l);if(this.bindSkeletons(l,c),void 0!==t){let e=!1;for(const t in s)if(s[t].data instanceof HTMLImageElement){e=!0;break}!1===e&&t(l)}return l}async parseAsync(e){const t=this.parseAnimations(e.animations),n=this.parseShapes(e.shapes),r=this.parseGeometries(e.geometries,n),i=await this.parseImagesAsync(e.images),s=this.parseTextures(e.textures,i),a=this.parseMaterials(e.materials,s),o=this.parseObject(e.object,r,a,s,t),l=this.parseSkeletons(e.skeletons,o);return this.bindSkeletons(o,l),o}parseShapes(e){const t={};if(void 0!==e)for(let n=0,r=e.length;n<r;n++){const r=(new Oo).fromJSON(e[n]);t[r.uuid]=r}return t}parseSkeletons(e,t){const n={},r={};if(t.traverse((function(e){e.isBone&&(r[e.uuid]=e)})),void 0!==e)for(let t=0,i=e.length;t<i;t++){const i=(new Na).fromJSON(e[t],r);n[i.uuid]=i}return n}parseGeometries(e,t){const n={};if(void 0!==e){const r=new Ec;for(let i=0,s=e.length;i<s;i++){let s;const a=e[i];switch(a.type){case"BufferGeometry":case"InstancedBufferGeometry":s=r.parse(a);break;case"Geometry":console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");break;default:a.type in Ml?s=Ml[a.type].fromJSON(a,t):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`)}s.uuid=a.uuid,void 0!==a.name&&(s.name=a.name),!0===s.isBufferGeometry&&void 0!==a.userData&&(s.userData=a.userData),n[a.uuid]=s}}return n}parseMaterials(e,t){const n={},r={};if(void 0!==e){const i=new Sc;i.setTextures(t);for(let t=0,s=e.length;t<s;t++){const s=e[t];if("MultiMaterial"===s.type){const e=[];for(let t=0;t<s.materials.length;t++){const r=s.materials[t];void 0===n[r.uuid]&&(n[r.uuid]=i.parse(r)),e.push(n[r.uuid])}r[s.uuid]=e}else void 0===n[s.uuid]&&(n[s.uuid]=i.parse(s)),r[s.uuid]=n[s.uuid]}}return r}parseAnimations(e){const t={};if(void 0!==e)for(let n=0;n<e.length;n++){const r=e[n],i=Yl.parse(r);t[i.uuid]=i}return t}parseImages(e,t){const n=this,r={};let i;function s(e){if("string"==typeof e){const t=e;return function(e){return n.manager.itemStart(e),i.load(e,(function(){n.manager.itemEnd(e)}),void 0,(function(){n.manager.itemError(e),n.manager.itemEnd(e)}))}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t)?t:n.resourcePath+t)}return e.data?{data:ke(e.type,e.data),width:e.width,height:e.height}:null}if(void 0!==e&&e.length>0){const n=new Jl(t);i=new rc(n),i.setCrossOrigin(this.crossOrigin);for(let t=0,n=e.length;t<n;t++){const n=e[t],i=n.url;if(Array.isArray(i)){const e=[];for(let t=0,n=i.length;t<n;t++){const n=s(i[t]);null!==n&&(n instanceof HTMLImageElement?e.push(n):e.push(new Aa(n.data,n.width,n.height)))}r[n.uuid]=new je(e)}else{const e=s(n.url);r[n.uuid]=new je(e)}}}return r}async parseImagesAsync(e){const t=this,n={};let r;async function i(e){if("string"==typeof e){const n=e,i=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(n)?n:t.resourcePath+n;return await r.loadAsync(i)}return e.data?{data:ke(e.type,e.data),width:e.width,height:e.height}:null}if(void 0!==e&&e.length>0){r=new rc(this.manager),r.setCrossOrigin(this.crossOrigin);for(let t=0,r=e.length;t<r;t++){const r=e[t],s=r.url;if(Array.isArray(s)){const e=[];for(let t=0,n=s.length;t<n;t++){const n=s[t],r=await i(n);null!==r&&(r instanceof HTMLImageElement?e.push(r):e.push(new Aa(r.data,r.width,r.height)))}n[r.uuid]=new je(e)}else{const e=await i(r.url);n[r.uuid]=new je(e)}}}return n}parseTextures(e,t){function n(e,t){return"number"==typeof e?e:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",e),t[e])}const r={};if(void 0!==e)for(let i=0,s=e.length;i<s;i++){const s=e[i];void 0===s.image&&console.warn('THREE.ObjectLoader: No "image" specified for',s.uuid),void 0===t[s.image]&&console.warn("THREE.ObjectLoader: Undefined image",s.image);const a=t[s.image],o=a.data;let l;Array.isArray(o)?(l=new or,6===o.length&&(l.needsUpdate=!0)):(l=o&&o.data?new Aa:new Ye,o&&(l.needsUpdate=!0)),l.source=a,l.uuid=s.uuid,void 0!==s.name&&(l.name=s.name),void 0!==s.mapping&&(l.mapping=n(s.mapping,Ac)),void 0!==s.offset&&l.offset.fromArray(s.offset),void 0!==s.repeat&&l.repeat.fromArray(s.repeat),void 0!==s.center&&l.center.fromArray(s.center),void 0!==s.rotation&&(l.rotation=s.rotation),void 0!==s.wrap&&(l.wrapS=n(s.wrap[0],Cc),l.wrapT=n(s.wrap[1],Cc)),void 0!==s.format&&(l.format=s.format),void 0!==s.type&&(l.type=s.type),void 0!==s.encoding&&(l.encoding=s.encoding),void 0!==s.minFilter&&(l.minFilter=n(s.minFilter,Ic)),void 0!==s.magFilter&&(l.magFilter=n(s.magFilter,Ic)),void 0!==s.anisotropy&&(l.anisotropy=s.anisotropy),void 0!==s.flipY&&(l.flipY=s.flipY),void 0!==s.premultiplyAlpha&&(l.premultiplyAlpha=s.premultiplyAlpha),void 0!==s.unpackAlignment&&(l.unpackAlignment=s.unpackAlignment),void 0!==s.userData&&(l.userData=s.userData),r[s.uuid]=l}return r}parseObject(e,t,n,r,i){let s,a,o;function l(e){return void 0===t[e]&&console.warn("THREE.ObjectLoader: Undefined geometry",e),t[e]}function c(e){if(void 0!==e){if(Array.isArray(e)){const t=[];for(let r=0,i=e.length;r<i;r++){const i=e[r];void 0===n[i]&&console.warn("THREE.ObjectLoader: Undefined material",i),t.push(n[i])}return t}return void 0===n[e]&&console.warn("THREE.ObjectLoader: Undefined material",e),n[e]}}function u(e){return void 0===r[e]&&console.warn("THREE.ObjectLoader: Undefined texture",e),r[e]}switch(e.type){case"Scene":s=new Zs,void 0!==e.background&&(Number.isInteger(e.background)?s.background=new We(e.background):s.background=u(e.background)),void 0!==e.environment&&(s.environment=u(e.environment)),void 0!==e.fog&&("Fog"===e.fog.type?s.fog=new Ks(e.fog.color,e.fog.near,e.fog.far):"FogExp2"===e.fog.type&&(s.fog=new Ys(e.fog.color,e.fog.density)));break;case"PerspectiveCamera":s=new ir(e.fov,e.aspect,e.near,e.far),void 0!==e.focus&&(s.focus=e.focus),void 0!==e.zoom&&(s.zoom=e.zoom),void 0!==e.filmGauge&&(s.filmGauge=e.filmGauge),void 0!==e.filmOffset&&(s.filmOffset=e.filmOffset),void 0!==e.view&&(s.view=Object.assign({},e.view));break;case"OrthographicCamera":s=new Cr(e.left,e.right,e.top,e.bottom,e.near,e.far),void 0!==e.zoom&&(s.zoom=e.zoom),void 0!==e.view&&(s.view=Object.assign({},e.view));break;case"AmbientLight":s=new xc(e.color,e.intensity);break;case"DirectionalLight":s=new vc(e.color,e.intensity);break;case"PointLight":s=new gc(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":s=new bc(e.color,e.intensity,e.width,e.height);break;case"SpotLight":s=new hc(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":s=new sc(e.color,e.groundColor,e.intensity);break;case"LightProbe":s=(new _c).fromJSON(e);break;case"SkinnedMesh":a=l(e.geometry),o=c(e.material),s=new Ta(a,o),void 0!==e.bindMode&&(s.bindMode=e.bindMode),void 0!==e.bindMatrix&&s.bindMatrix.fromArray(e.bindMatrix),void 0!==e.skeleton&&(s.skeleton=e.skeleton);break;case"Mesh":a=l(e.geometry),o=c(e.material),s=new Kn(a,o);break;case"InstancedMesh":a=l(e.geometry),o=c(e.material);const t=e.count,n=e.instanceMatrix,r=e.instanceColor;s=new Pa(a,o,t),s.instanceMatrix=new ka(new Float32Array(n.array),16),void 0!==r&&(s.instanceColor=new ka(new Float32Array(r.array),r.itemSize));break;case"LOD":s=new xa;break;case"Line":s=new Wa(l(e.geometry),c(e.material));break;case"LineLoop":s=new qa(l(e.geometry),c(e.material));break;case"LineSegments":s=new ja(l(e.geometry),c(e.material));break;case"PointCloud":case"Points":s=new Qa(l(e.geometry),c(e.material));break;case"Sprite":s=new ma(c(e.material));break;case"Group":s=new $s;break;case"Bone":s=new Ea;break;default:s=new rn}if(s.uuid=e.uuid,void 0!==e.name&&(s.name=e.name),void 0!==e.matrix?(s.matrix.fromArray(e.matrix),void 0!==e.matrixAutoUpdate&&(s.matrixAutoUpdate=e.matrixAutoUpdate),s.matrixAutoUpdate&&s.matrix.decompose(s.position,s.quaternion,s.scale)):(void 0!==e.position&&s.position.fromArray(e.position),void 0!==e.rotation&&s.rotation.fromArray(e.rotation),void 0!==e.quaternion&&s.quaternion.fromArray(e.quaternion),void 0!==e.scale&&s.scale.fromArray(e.scale)),void 0!==e.castShadow&&(s.castShadow=e.castShadow),void 0!==e.receiveShadow&&(s.receiveShadow=e.receiveShadow),e.shadow&&(void 0!==e.shadow.bias&&(s.shadow.bias=e.shadow.bias),void 0!==e.shadow.normalBias&&(s.shadow.normalBias=e.shadow.normalBias),void 0!==e.shadow.radius&&(s.shadow.radius=e.shadow.radius),void 0!==e.shadow.mapSize&&s.shadow.mapSize.fromArray(e.shadow.mapSize),void 0!==e.shadow.camera&&(s.shadow.camera=this.parseObject(e.shadow.camera))),void 0!==e.visible&&(s.visible=e.visible),void 0!==e.frustumCulled&&(s.frustumCulled=e.frustumCulled),void 0!==e.renderOrder&&(s.renderOrder=e.renderOrder),void 0!==e.userData&&(s.userData=e.userData),void 0!==e.layers&&(s.layers.mask=e.layers),void 0!==e.children){const a=e.children;for(let e=0;e<a.length;e++)s.add(this.parseObject(a[e],t,n,r,i))}if(void 0!==e.animations){const t=e.animations;for(let e=0;e<t.length;e++){const n=t[e];s.animations.push(i[n])}}if("LOD"===e.type){void 0!==e.autoUpdate&&(s.autoUpdate=e.autoUpdate);const t=e.levels;for(let e=0;e<t.length;e++){const n=t[e],r=s.getObjectByProperty("uuid",n.object);void 0!==r&&s.addLevel(r,n.distance)}}return s}bindSkeletons(e,t){0!==Object.keys(t).length&&e.traverse((function(e){if(!0===e.isSkinnedMesh&&void 0!==e.skeleton){const n=t[e.skeleton];void 0===n?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",e.skeleton):e.bind(n,e.bindMatrix)}}))}setTexturePath(e){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(e)}},t.ObjectSpaceNormalMap=1,t.OctahedronBufferGeometry=fl,t.OctahedronGeometry=fl,t.OneFactor=201,t.OneMinusDstAlphaFactor=207,t.OneMinusDstColorFactor=209,t.OneMinusSrcAlphaFactor=205,t.OneMinusSrcColorFactor=203,t.OrthographicCamera=Cr,t.PCFShadowMap=1,t.PCFSoftShadowMap=2,t.PMREMGenerator=Pr,t.ParametricGeometry=class extends Rn{constructor(){console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"),super()}},t.Path=Mo,t.PerspectiveCamera=ir,t.Plane=dr,t.PlaneBufferGeometry=vr,t.PlaneGeometry=vr,t.PlaneHelper=class extends Wa{constructor(e,t=1,n=16776960){const r=n,i=new Rn;i.setAttribute("position",new Mn([1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],3)),i.computeBoundingSphere(),super(i,new Oa({color:r,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const s=new Rn;s.setAttribute("position",new Mn([1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],3)),s.computeBoundingSphere(),this.add(new Kn(s,new vn({color:r,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){let t=-this.plane.constant;Math.abs(t)<1e-8&&(t=1e-8),this.scale.set(.5*this.size,.5*this.size,t),this.children[0].material.side=t<0?1:0,this.lookAt(this.plane.normal),super.updateMatrixWorld(e)}},t.PointLight=gc,t.PointLightHelper=class extends Kn{constructor(e,t,n){super(new yl(t,4,2),new vn({wireframe:!0,fog:!1,toneMapped:!1})),this.light=e,this.light.updateMatrixWorld(),this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}},t.Points=Qa,t.PointsMaterial=Xa,t.PolarGridHelper=class extends ja{constructor(e=10,t=16,n=8,r=64,i=4473924,s=8947848){i=new We(i),s=new We(s);const a=[],o=[];for(let n=0;n<=t;n++){const r=n/t*(2*Math.PI),l=Math.sin(r)*e,c=Math.cos(r)*e;a.push(0,0,0),a.push(l,0,c);const u=1&n?i:s;o.push(u.r,u.g,u.b),o.push(u.r,u.g,u.b)}for(let t=0;t<=n;t++){const l=1&t?i:s,c=e-e/n*t;for(let e=0;e<r;e++){let t=e/r*(2*Math.PI),n=Math.sin(t)*c,i=Math.cos(t)*c;a.push(n,0,i),o.push(l.r,l.g,l.b),t=(e+1)/r*(2*Math.PI),n=Math.sin(t)*c,i=Math.cos(t)*c,a.push(n,0,i),o.push(l.r,l.g,l.b)}}const l=new Rn;l.setAttribute("position",new Mn(a,3)),l.setAttribute("color",new Mn(o,3)),super(l,new Oa({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}},t.PolyhedronBufferGeometry=No,t.PolyhedronGeometry=No,t.PositionalAudio=class extends $c{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,n){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=n,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose(Vc,Wc,Gc),Hc.set(0,0,1).applyQuaternion(Wc);const t=this.panner;if(t.positionX){const e=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(Vc.x,e),t.positionY.linearRampToValueAtTime(Vc.y,e),t.positionZ.linearRampToValueAtTime(Vc.z,e),t.orientationX.linearRampToValueAtTime(Hc.x,e),t.orientationY.linearRampToValueAtTime(Hc.y,e),t.orientationZ.linearRampToValueAtTime(Hc.z,e)}else t.setPosition(Vc.x,Vc.y,Vc.z),t.setOrientation(Hc.x,Hc.y,Hc.z)}},t.PropertyBinding=nu,t.PropertyMixer=jc,t.QuadraticBezierCurve=xo,t.QuadraticBezierCurve3=bo,t.Quaternion=et,t.QuaternionKeyframeTrack=jl,t.QuaternionLinearInterpolant=Hl,t.REVISION=n,t.RGBADepthPacking=3201,t.RGBAFormat=T,t.RGBAIntegerFormat=1033,t.RGBA_ASTC_10x10_Format=Y,t.RGBA_ASTC_10x5_Format=j,t.RGBA_ASTC_10x6_Format=q,t.RGBA_ASTC_10x8_Format=X,t.RGBA_ASTC_12x10_Format=K,t.RGBA_ASTC_12x12_Format=Z,t.RGBA_ASTC_4x4_Format=z,t.RGBA_ASTC_5x4_Format=B,t.RGBA_ASTC_5x5_Format=U,t.RGBA_ASTC_6x5_Format=$,t.RGBA_ASTC_6x6_Format=V,t.RGBA_ASTC_8x5_Format=W,t.RGBA_ASTC_8x6_Format=G,t.RGBA_ASTC_8x8_Format=H,t.RGBA_BPTC_Format=J,t.RGBA_ETC2_EAC_Format=O,t.RGBA_PVRTC_2BPPV1_Format=F,t.RGBA_PVRTC_4BPPV1_Format=L,t.RGBA_S3TC_DXT1_Format=I,t.RGBA_S3TC_DXT3_Format=N,t.RGBA_S3TC_DXT5_Format=k,t.RGBFormat=1022,t.RGB_ETC1_Format=36196,t.RGB_ETC2_Format=P,t.RGB_PVRTC_2BPPV1_Format=D,t.RGB_PVRTC_4BPPV1_Format=R,t.RGB_S3TC_DXT1_Format=C,t.RGFormat=1030,t.RGIntegerFormat=1031,t.RawShaderMaterial=El,t.Ray=kt,t.Raycaster=class{constructor(e,t,n=0,r=1/0){this.ray=new kt(e,t),this.near=n,this.far=r,this.camera=null,this.layers=new Wt,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}intersectObject(e,t=!0,n=[]){return ou(e,this,n,t),n.sort(au),n}intersectObjects(e,t=!0,n=[]){for(let r=0,i=e.length;r<i;r++)ou(e[r],this,n,t);return n.sort(au),n}},t.RectAreaLight=bc,t.RedFormat=1028,t.RedIntegerFormat=1029,t.ReinhardToneMapping=2,t.RepeatWrapping=u,t.ReplaceStencilOp=7681,t.ReverseSubtractEquation=102,t.RingBufferGeometry=ml,t.RingGeometry=ml,t.SRGBColorSpace=le,t.Scene=Zs,t.ShaderChunk=xr,t.ShaderLib=wr,t.ShaderMaterial=nr,t.ShadowMaterial=Tl,t.Shape=Oo,t.ShapeBufferGeometry=gl,t.ShapeGeometry=gl,t.ShapePath=class{constructor(){this.type="ShapePath",this.color=new We,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new Mo,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,n,r){return this.currentPath.quadraticCurveTo(e,t,n,r),this}bezierCurveTo(e,t,n,r,i,s){return this.currentPath.bezierCurveTo(e,t,n,r,i,s),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e,t){function n(e){const t=[];for(let n=0,r=e.length;n<r;n++){const r=e[n],i=new Oo;i.curves=r.curves,t.push(i)}return t}function r(e,t){const n=t.length;let r=!1;for(let i=n-1,s=0;s<n;i=s++){let n=t[i],a=t[s],o=a.x-n.x,l=a.y-n.y;if(Math.abs(l)>Number.EPSILON){if(l<0&&(n=t[s],o=-o,a=t[i],l=-l),e.y<n.y||e.y>a.y)continue;if(e.y===n.y){if(e.x===n.x)return!0}else{const t=l*(e.x-n.x)-o*(e.y-n.y);if(0===t)return!0;if(t<0)continue;r=!r}}else{if(e.y!==n.y)continue;if(a.x<=e.x&&e.x<=n.x||n.x<=e.x&&e.x<=a.x)return!0}}return r}const i=ll.isClockWise,s=this.subPaths;if(0===s.length)return[];if(!0===t)return n(s);let a,o,l;const c=[];if(1===s.length)return o=s[0],l=new Oo,l.curves=o.curves,c.push(l),c;let u=!i(s[0].getPoints());u=e?!u:u;const h=[],d=[];let p,f,m=[],g=0;d[g]=void 0,m[g]=[];for(let t=0,n=s.length;t<n;t++)o=s[t],p=o.getPoints(),a=i(p),a=e?!a:a,a?(!u&&d[g]&&g++,d[g]={s:new Oo,p},d[g].s.curves=o.curves,u&&g++,m[g]=[]):m[g].push({h:o,p:p[0]});if(!d[0])return n(s);if(d.length>1){let e=!1,t=0;for(let e=0,t=d.length;e<t;e++)h[e]=[];for(let n=0,i=d.length;n<i;n++){const i=m[n];for(let s=0;s<i.length;s++){const a=i[s];let o=!0;for(let i=0;i<d.length;i++)r(a.p,d[i].p)&&(n!==i&&t++,o?(o=!1,h[i].push(a)):e=!0);o&&h[n].push(a)}}t>0&&!1===e&&(m=h)}for(let e=0,t=d.length;e<t;e++){l=d[e].s,c.push(l),f=m[e];for(let e=0,t=f.length;e<t;e++)l.holes.push(f[e].h)}return c}},t.ShapeUtils=ll,t.ShortType=1011,t.Skeleton=Na,t.SkeletonHelper=class extends ja{constructor(e){const t=mu(e),n=new Rn,r=[],i=[],s=new We(0,0,1),a=new We(0,1,0);for(let e=0;e<t.length;e++){const n=t[e];n.parent&&n.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),i.push(s.r,s.g,s.b),i.push(a.r,a.g,a.b))}n.setAttribute("position",new Mn(r,3)),n.setAttribute("color",new Mn(i,3)),super(n,new Oa({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,n=this.geometry,r=n.getAttribute("position");fu.copy(this.root.matrixWorld).invert();for(let e=0,n=0;e<t.length;e++){const i=t[e];i.parent&&i.parent.isBone&&(pu.multiplyMatrices(fu,i.matrixWorld),du.setFromMatrixPosition(pu),r.setXYZ(n,du.x,du.y,du.z),pu.multiplyMatrices(fu,i.parent.matrixWorld),du.setFromMatrixPosition(pu),r.setXYZ(n+1,du.x,du.y,du.z),n+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}},t.SkinnedMesh=Ta,t.SmoothShading=2,t.Source=je,t.Sphere=St,t.SphereBufferGeometry=yl,t.SphereGeometry=yl,t.Spherical=class{constructor(e=1,t=0,n=0){return this.radius=e,this.phi=t,this.theta=n,this}set(e,t,n){return this.radius=e,this.phi=t,this.theta=n,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){const e=1e-6;return this.phi=Math.max(e,Math.min(Math.PI-e,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+t*t+n*n),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,n),this.phi=Math.acos(be(t/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}},t.SphericalHarmonics3=wc,t.SplineCurve=wo,t.SpotLight=hc,t.SpotLightHelper=class extends rn{constructor(e,t){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;const n=new Rn,r=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let e=0,t=1,n=32;e<n;e++,t++){const i=e/n*Math.PI*2,s=t/n*Math.PI*2;r.push(Math.cos(i),Math.sin(i),1,Math.cos(s),Math.sin(s),1)}n.setAttribute("position",new Mn(r,3));const i=new Oa({fog:!1,toneMapped:!1});this.cone=new ja(n,i),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),hu.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(hu),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}},t.Sprite=ma,t.SpriteMaterial=ta,t.SrcAlphaFactor=204,t.SrcAlphaSaturateFactor=210,t.SrcColorFactor=202,t.StaticCopyUsage=35046,t.StaticDrawUsage=he,t.StaticReadUsage=35045,t.StereoCamera=class{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new ir,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new ir,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep,Lc.copy(e.projectionMatrix);const n=t.eyeSep/2,r=n*t.near/t.focus,i=t.near*Math.tan(ye*t.fov*.5)/t.zoom;let s,a;Dc.elements[12]=-n,Rc.elements[12]=n,s=-i*t.aspect+r,a=i*t.aspect+r,Lc.elements[0]=2*t.near/(a-s),Lc.elements[8]=(a+s)/(a-s),this.cameraL.projectionMatrix.copy(Lc),s=-i*t.aspect-r,a=i*t.aspect-r,Lc.elements[0]=2*t.near/(a-s),Lc.elements[8]=(a+s)/(a-s),this.cameraR.projectionMatrix.copy(Lc)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Dc),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Rc)}},t.StreamCopyUsage=35042,t.StreamDrawUsage=35040,t.StreamReadUsage=35041,t.StringKeyframeTrack=ql,t.SubtractEquation=101,t.SubtractiveBlending=3,t.TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},t.TangentSpaceNormalMap=0,t.TetrahedronBufferGeometry=vl,t.TetrahedronGeometry=vl,t.TextGeometry=class extends Rn{constructor(){console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"),super()}},t.Texture=Ye,t.TextureLoader=class extends ec{constructor(e){super(e)}load(e,t,n,r){const i=new Ye,s=new rc(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(e,(function(e){i.image=e,i.needsUpdate=!0,void 0!==t&&t(i)}),n,r),i}},t.TorusBufferGeometry=xl,t.TorusGeometry=xl,t.TorusKnotBufferGeometry=bl,t.TorusKnotGeometry=bl,t.Triangle=mn,t.TriangleFanDrawMode=2,t.TriangleStripDrawMode=1,t.TrianglesDrawMode=0,t.TubeBufferGeometry=wl,t.TubeGeometry=wl,t.UVMapping=i,t.Uint16BufferAttribute=_n,t.Uint32BufferAttribute=Sn,t.Uint8BufferAttribute=class extends wn{constructor(e,t,n){super(new Uint8Array(e),t,n)}},t.Uint8ClampedBufferAttribute=class extends wn{constructor(e,t,n){super(new Uint8ClampedArray(e),t,n)}},t.Uniform=su,t.UniformsLib=br,t.UniformsUtils=tr,t.UnsignedByteType=x,t.UnsignedInt248Type=M,t.UnsignedIntType=w,t.UnsignedShort4444Type=1017,t.UnsignedShort5551Type=1018,t.UnsignedShortType=b,t.VSMShadowMap=3,t.Vector2=Ae,t.Vector3=tt,t.Vector4=Ke,t.VectorKeyframeTrack=Xl,t.VideoTexture=class extends Ye{constructor(e,t,n,r,i,s,a,o,l){super(e,t,n,r,i,s,a,o,l),this.isVideoTexture=!0,this.minFilter=void 0!==s?s:g,this.magFilter=void 0!==i?i:g,this.generateMipmaps=!1;const c=this;"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback((function t(){c.needsUpdate=!0,e.requestVideoFrameCallback(t)}))}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;!1=="requestVideoFrameCallback"in e&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}},t.WebGL1Renderer=Xs,t.WebGL3DRenderTarget=class extends Ze{constructor(e,t,n){super(e,t),this.isWebGL3DRenderTarget=!0,this.depth=n,this.texture=new Qe(null,e,t,n),this.texture.isRenderTargetTexture=!0}},t.WebGLArrayRenderTarget=class extends Ze{constructor(e,t,n){super(e,t),this.isWebGLArrayRenderTarget=!0,this.depth=n,this.texture=new Je(null,e,t,n),this.texture.isRenderTargetTexture=!0}},t.WebGLCubeRenderTarget=lr,t.WebGLMultipleRenderTargets=class extends Ze{constructor(e,t,n,r={}){super(e,t,r),this.isWebGLMultipleRenderTargets=!0;const i=this.texture;this.texture=[];for(let e=0;e<n;e++)this.texture[e]=i.clone(),this.texture[e].isRenderTargetTexture=!0}setSize(e,t,n=1){if(this.width!==e||this.height!==t||this.depth!==n){this.width=e,this.height=t,this.depth=n;for(let r=0,i=this.texture.length;r<i;r++)this.texture[r].image.width=e,this.texture[r].image.height=t,this.texture[r].image.depth=n;this.dispose()}return this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t),this}copy(e){this.dispose(),this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,null!==e.depthTexture&&(this.depthTexture=e.depthTexture.clone()),this.texture.length=0;for(let t=0,n=e.texture.length;t<n;t++)this.texture[t]=e.texture[t].clone(),this.texture[t].isRenderTargetTexture=!0;return this}},t.WebGLMultisampleRenderTarget=class extends Ze{constructor(e,t,n){console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'),super(e,t,n),this.samples=4}},t.WebGLRenderTarget=Ze,t.WebGLRenderer=qs,t.WebGLUtils=Bs,t.WireframeGeometry=_l,t.WrapAroundEnding=ie,t.ZeroCurvatureEnding=ne,t.ZeroFactor=200,t.ZeroSlopeEnding=re,t.ZeroStencilOp=0,t._SRGBAFormat=pe,t.sRGBEncoding=oe},5629:(e,t,n)=>{"use strict";n.r(t),n.d(t,{PointerLockControls:()=>Gs});const r=100,i=301,s=302,a=306,o=1e3,l=1001,c=1002,u=1003,h=1006,d=1008,p=1009,f=1014,m=1015,g=1016,y=1020,v=1023,x=1026,b=1027,w=33776,_=33777,S=33778,M=33779,T=2300,E=2301,A=2302,C=3e3,I=3001,N="srgb",k="srgb-linear",R=7680,D="300 es",L=1035;class F{addEventListener(e,t){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[e]&&(n[e]=[]),-1===n[e].indexOf(t)&&n[e].push(t)}hasEventListener(e,t){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[e]&&-1!==n[e].indexOf(t)}removeEventListener(e,t){if(void 0===this._listeners)return;const n=this._listeners[e];if(void 0!==n){const e=n.indexOf(t);-1!==e&&n.splice(e,1)}}dispatchEvent(e){if(void 0===this._listeners)return;const t=this._listeners[e.type];if(void 0!==t){e.target=this;const n=t.slice(0);for(let t=0,r=n.length;t<r;t++)n[t].call(this,e);e.target=null}}}const P=[];for(let e=0;e<256;e++)P[e]=(e<16?"0":"")+e.toString(16);const O=Math.PI/180,z=180/Math.PI;function B(){const e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,n=4294967295*Math.random()|0,r=4294967295*Math.random()|0;return(P[255&e]+P[e>>8&255]+P[e>>16&255]+P[e>>24&255]+"-"+P[255&t]+P[t>>8&255]+"-"+P[t>>16&15|64]+P[t>>24&255]+"-"+P[63&n|128]+P[n>>8&255]+"-"+P[n>>16&255]+P[n>>24&255]+P[255&r]+P[r>>8&255]+P[r>>16&255]+P[r>>24&255]).toLowerCase()}function U(e,t,n){return Math.max(t,Math.min(n,e))}function $(e,t,n){return(1-n)*e+n*t}function V(e){return 0==(e&e-1)&&0!==e}function W(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))}class G{constructor(e=0,t=0){this.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,r=e.elements;return this.x=r[0]*t+r[3]*n+r[6],this.y=r[1]*t+r[4]*n+r[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,n){return void 0!==n&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),r=Math.sin(t),i=this.x-e.x,s=this.y-e.y;return this.x=i*n-s*r+e.x,this.y=i*r+s*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class H{constructor(){this.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,r,i,s,a,o,l){const c=this.elements;return c[0]=e,c[1]=r,c[2]=a,c[3]=t,c[4]=i,c[5]=o,c[6]=n,c[7]=s,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,r=t.elements,i=this.elements,s=n[0],a=n[3],o=n[6],l=n[1],c=n[4],u=n[7],h=n[2],d=n[5],p=n[8],f=r[0],m=r[3],g=r[6],y=r[1],v=r[4],x=r[7],b=r[2],w=r[5],_=r[8];return i[0]=s*f+a*y+o*b,i[3]=s*m+a*v+o*w,i[6]=s*g+a*x+o*_,i[1]=l*f+c*y+u*b,i[4]=l*m+c*v+u*w,i[7]=l*g+c*x+u*_,i[2]=h*f+d*y+p*b,i[5]=h*m+d*v+p*w,i[8]=h*g+d*x+p*_,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],a=e[5],o=e[6],l=e[7],c=e[8];return t*s*c-t*a*l-n*i*c+n*a*o+r*i*l-r*s*o}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],a=e[5],o=e[6],l=e[7],c=e[8],u=c*s-a*l,h=a*o-c*i,d=l*i-s*o,p=t*u+n*h+r*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const f=1/p;return e[0]=u*f,e[1]=(r*l-c*n)*f,e[2]=(a*n-r*s)*f,e[3]=h*f,e[4]=(c*t-r*o)*f,e[5]=(r*i-a*t)*f,e[6]=d*f,e[7]=(n*o-l*t)*f,e[8]=(s*t-n*i)*f,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,r,i,s,a){const o=Math.cos(i),l=Math.sin(i);return this.set(n*o,n*l,-n*(o*s+l*a)+s+e,-r*l,r*o,-r*(-l*s+o*a)+a+t,0,0,1),this}scale(e,t){const n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=t,n[4]*=t,n[7]*=t,this}rotate(e){const t=Math.cos(e),n=Math.sin(e),r=this.elements,i=r[0],s=r[3],a=r[6],o=r[1],l=r[4],c=r[7];return r[0]=t*i+n*o,r[3]=t*s+n*l,r[6]=t*a+n*c,r[1]=-n*i+t*o,r[4]=-n*s+t*l,r[7]=-n*a+t*c,this}translate(e,t){const n=this.elements;return n[0]+=e*n[2],n[3]+=e*n[5],n[6]+=e*n[8],n[1]+=t*n[2],n[4]+=t*n[5],n[7]+=t*n[8],this}equals(e){const t=this.elements,n=e.elements;for(let e=0;e<9;e++)if(t[e]!==n[e])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return(new this.constructor).fromArray(this.elements)}}function j(e){for(let t=e.length-1;t>=0;--t)if(e[t]>65535)return!0;return!1}function q(e){return document.createElementNS("http://www.w3.org/1999/xhtml",e)}function X(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}function Y(e){return e<.0031308?12.92*e:1.055*Math.pow(e,.41666)-.055}Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array;const K={[N]:{[k]:X},[k]:{[N]:Y}},Z={legacyMode:!0,get workingColorSpace(){return k},set workingColorSpace(e){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(e,t,n){if(this.legacyMode||t===n||!t||!n)return e;if(K[t]&&void 0!==K[t][n]){const r=K[t][n];return e.r=r(e.r),e.g=r(e.g),e.b=r(e.b),e}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(e,t){return this.convert(e,this.workingColorSpace,t)},toWorkingColorSpace:function(e,t){return this.convert(e,t,this.workingColorSpace)}},J={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Q={r:0,g:0,b:0},ee={h:0,s:0,l:0},te={h:0,s:0,l:0};function ne(e,t,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+6*(t-e)*n:n<.5?t:n<2/3?e+6*(t-e)*(2/3-n):e}function re(e,t){return t.r=e.r,t.g=e.g,t.b=e.b,t}class ie{constructor(e,t,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,void 0===t&&void 0===n?this.set(e):this.setRGB(e,t,n)}set(e){return e&&e.isColor?this.copy(e):"number"==typeof e?this.setHex(e):"string"==typeof e&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t="srgb"){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(255&e)/255,Z.toWorkingColorSpace(this,t),this}setRGB(e,t,n,r="srgb-linear"){return this.r=e,this.g=t,this.b=n,Z.toWorkingColorSpace(this,r),this}setHSL(e,t,n,r="srgb-linear"){if(e=(e%(i=1)+i)%i,t=U(t,0,1),n=U(n,0,1),0===t)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+t):n+t-n*t,i=2*n-r;this.r=ne(i,r,e+1/3),this.g=ne(i,r,e),this.b=ne(i,r,e-1/3)}var i;return Z.toWorkingColorSpace(this,r),this}setStyle(e,t="srgb"){function n(t){void 0!==t&&parseFloat(t)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let r;if(r=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let e;const i=r[1],s=r[2];switch(i){case"rgb":case"rgba":if(e=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return this.r=Math.min(255,parseInt(e[1],10))/255,this.g=Math.min(255,parseInt(e[2],10))/255,this.b=Math.min(255,parseInt(e[3],10))/255,Z.toWorkingColorSpace(this,t),n(e[4]),this;if(e=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return this.r=Math.min(100,parseInt(e[1],10))/100,this.g=Math.min(100,parseInt(e[2],10))/100,this.b=Math.min(100,parseInt(e[3],10))/100,Z.toWorkingColorSpace(this,t),n(e[4]),this;break;case"hsl":case"hsla":if(e=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)){const r=parseFloat(e[1])/360,i=parseInt(e[2],10)/100,s=parseInt(e[3],10)/100;return n(e[4]),this.setHSL(r,i,s,t)}}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(e)){const e=r[1],n=e.length;if(3===n)return this.r=parseInt(e.charAt(0)+e.charAt(0),16)/255,this.g=parseInt(e.charAt(1)+e.charAt(1),16)/255,this.b=parseInt(e.charAt(2)+e.charAt(2),16)/255,Z.toWorkingColorSpace(this,t),this;if(6===n)return this.r=parseInt(e.charAt(0)+e.charAt(1),16)/255,this.g=parseInt(e.charAt(2)+e.charAt(3),16)/255,this.b=parseInt(e.charAt(4)+e.charAt(5),16)/255,Z.toWorkingColorSpace(this,t),this}return e&&e.length>0?this.setColorName(e,t):this}setColorName(e,t="srgb"){const n=J[e.toLowerCase()];return void 0!==n?this.setHex(n,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=X(e.r),this.g=X(e.g),this.b=X(e.b),this}copyLinearToSRGB(e){return this.r=Y(e.r),this.g=Y(e.g),this.b=Y(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e="srgb"){return Z.fromWorkingColorSpace(re(this,Q),e),U(255*Q.r,0,255)<<16^U(255*Q.g,0,255)<<8^U(255*Q.b,0,255)<<0}getHexString(e="srgb"){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t="srgb-linear"){Z.fromWorkingColorSpace(re(this,Q),t);const n=Q.r,r=Q.g,i=Q.b,s=Math.max(n,r,i),a=Math.min(n,r,i);let o,l;const c=(a+s)/2;if(a===s)o=0,l=0;else{const e=s-a;switch(l=c<=.5?e/(s+a):e/(2-s-a),s){case n:o=(r-i)/e+(r<i?6:0);break;case r:o=(i-n)/e+2;break;case i:o=(n-r)/e+4}o/=6}return e.h=o,e.s=l,e.l=c,e}getRGB(e,t="srgb-linear"){return Z.fromWorkingColorSpace(re(this,Q),t),e.r=Q.r,e.g=Q.g,e.b=Q.b,e}getStyle(e="srgb"){return Z.fromWorkingColorSpace(re(this,Q),e),e!==N?`color(${e} ${Q.r} ${Q.g} ${Q.b})`:`rgb(${255*Q.r|0},${255*Q.g|0},${255*Q.b|0})`}offsetHSL(e,t,n){return this.getHSL(ee),ee.h+=e,ee.s+=t,ee.l+=n,this.setHSL(ee.h,ee.s,ee.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(ee),e.getHSL(te);const n=$(ee.h,te.h,t),r=$(ee.s,te.s,t),i=$(ee.l,te.l,t);return this.setHSL(n,r,i),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),!0===e.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}let se;ie.NAMES=J;class ae{static getDataURL(e){if(/^data:/i.test(e.src))return e.src;if("undefined"==typeof HTMLCanvasElement)return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{void 0===se&&(se=q("canvas")),se.width=e.width,se.height=e.height;const n=se.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=se}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap){const t=q("canvas");t.width=e.width,t.height=e.height;const n=t.getContext("2d");n.drawImage(e,0,0,e.width,e.height);const r=n.getImageData(0,0,e.width,e.height),i=r.data;for(let e=0;e<i.length;e++)i[e]=255*X(i[e]/255);return n.putImageData(r,0,0),t}if(e.data){const t=e.data.slice(0);for(let e=0;e<t.length;e++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[e]=Math.floor(255*X(t[e]/255)):t[e]=X(t[e]);return{data:t,width:e.width,height:e.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}class oe{constructor(e=null){this.isSource=!0,this.uuid=B(),this.data=e,this.version=0}set needsUpdate(e){!0===e&&this.version++}toJSON(e){const t=void 0===e||"string"==typeof e;if(!t&&void 0!==e.images[this.uuid])return e.images[this.uuid];const n={uuid:this.uuid,url:""},r=this.data;if(null!==r){let e;if(Array.isArray(r)){e=[];for(let t=0,n=r.length;t<n;t++)r[t].isDataTexture?e.push(le(r[t].image)):e.push(le(r[t]))}else e=le(r);n.url=e}return t||(e.images[this.uuid]=n),n}}function le(e){return"undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap?ae.getDataURL(e):e.data?{data:Array.prototype.slice.call(e.data),width:e.width,height:e.height,type:e.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let ce=0;class ue extends F{constructor(e=ue.DEFAULT_IMAGE,t=ue.DEFAULT_MAPPING,n=1001,r=1001,i=1006,s=1008,a=1023,o=1009,l=1,c=3e3){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:ce++}),this.uuid=B(),this.name="",this.source=new oe(e),this.mipmaps=[],this.mapping=t,this.wrapS=n,this.wrapT=r,this.magFilter=i,this.minFilter=s,this.anisotropy=l,this.format=a,this.internalFormat=null,this.type=o,this.offset=new G(0,0),this.repeat=new G(1,1),this.center=new G(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new H,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=void 0===e||"string"==typeof e;if(!t&&void 0!==e.textures[this.uuid])return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(300!==this.mapping)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case o:e.x=e.x-Math.floor(e.x);break;case l:e.x=e.x<0?0:1;break;case c:1===Math.abs(Math.floor(e.x)%2)?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x)}if(e.y<0||e.y>1)switch(this.wrapT){case o:e.y=e.y-Math.floor(e.y);break;case l:e.y=e.y<0?0:1;break;case c:1===Math.abs(Math.floor(e.y)%2)?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y)}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){!0===e&&(this.version++,this.source.needsUpdate=!0)}}ue.DEFAULT_IMAGE=null,ue.DEFAULT_MAPPING=300;class he{constructor(e=0,t=0,n=0,r=1){this.isVector4=!0,this.x=e,this.y=t,this.z=n,this.w=r}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,r){return this.x=e,this.y=t,this.z=n,this.w=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=void 0!==e.w?e.w:1,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,r=this.z,i=this.w,s=e.elements;return this.x=s[0]*t+s[4]*n+s[8]*r+s[12]*i,this.y=s[1]*t+s[5]*n+s[9]*r+s[13]*i,this.z=s[2]*t+s[6]*n+s[10]*r+s[14]*i,this.w=s[3]*t+s[7]*n+s[11]*r+s[15]*i,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,r,i;const s=.01,a=.1,o=e.elements,l=o[0],c=o[4],u=o[8],h=o[1],d=o[5],p=o[9],f=o[2],m=o[6],g=o[10];if(Math.abs(c-h)<s&&Math.abs(u-f)<s&&Math.abs(p-m)<s){if(Math.abs(c+h)<a&&Math.abs(u+f)<a&&Math.abs(p+m)<a&&Math.abs(l+d+g-3)<a)return this.set(1,0,0,0),this;t=Math.PI;const e=(l+1)/2,o=(d+1)/2,y=(g+1)/2,v=(c+h)/4,x=(u+f)/4,b=(p+m)/4;return e>o&&e>y?e<s?(n=0,r=.707106781,i=.707106781):(n=Math.sqrt(e),r=v/n,i=x/n):o>y?o<s?(n=.707106781,r=0,i=.707106781):(r=Math.sqrt(o),n=v/r,i=b/r):y<s?(n=.707106781,r=.707106781,i=0):(i=Math.sqrt(y),n=x/i,r=b/i),this.set(n,r,i,t),this}let y=Math.sqrt((m-p)*(m-p)+(u-f)*(u-f)+(h-c)*(h-c));return Math.abs(y)<.001&&(y=1),this.x=(m-p)/y,this.y=(u-f)/y,this.z=(h-c)/y,this.w=Math.acos((l+d+g-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,n){return void 0!==n&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class de extends F{constructor(e,t,n={}){super(),this.isWebGLRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new he(0,0,e,t),this.scissorTest=!1,this.viewport=new he(0,0,e,t);const r={width:e,height:t,depth:1};this.texture=new ue(r,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.internalFormat=void 0!==n.internalFormat?n.internalFormat:null,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:h,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null,this.samples=void 0!==n.samples?n.samples:0}setSize(e,t,n=1){this.width===e&&this.height===t&&this.depth===n||(this.width=e,this.height=t,this.depth=n,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return(new this.constructor).copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new oe(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,null!==e.depthTexture&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class pe extends ue{constructor(e=null,t=1,n=1,r=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:n,depth:r},this.magFilter=u,this.minFilter=u,this.wrapR=l,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class fe{constructor(e=0,t=0,n=0,r=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=n,this._w=r}static slerp(e,t,n,r){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(e,t,r)}static slerpFlat(e,t,n,r,i,s,a){let o=n[r+0],l=n[r+1],c=n[r+2],u=n[r+3];const h=i[s+0],d=i[s+1],p=i[s+2],f=i[s+3];if(0===a)return e[t+0]=o,e[t+1]=l,e[t+2]=c,void(e[t+3]=u);if(1===a)return e[t+0]=h,e[t+1]=d,e[t+2]=p,void(e[t+3]=f);if(u!==f||o!==h||l!==d||c!==p){let e=1-a;const t=o*h+l*d+c*p+u*f,n=t>=0?1:-1,r=1-t*t;if(r>Number.EPSILON){const i=Math.sqrt(r),s=Math.atan2(i,t*n);e=Math.sin(e*s)/i,a=Math.sin(a*s)/i}const i=a*n;if(o=o*e+h*i,l=l*e+d*i,c=c*e+p*i,u=u*e+f*i,e===1-a){const e=1/Math.sqrt(o*o+l*l+c*c+u*u);o*=e,l*=e,c*=e,u*=e}}e[t]=o,e[t+1]=l,e[t+2]=c,e[t+3]=u}static multiplyQuaternionsFlat(e,t,n,r,i,s){const a=n[r],o=n[r+1],l=n[r+2],c=n[r+3],u=i[s],h=i[s+1],d=i[s+2],p=i[s+3];return e[t]=a*p+c*u+o*d-l*h,e[t+1]=o*p+c*h+l*u-a*d,e[t+2]=l*p+c*d+a*h-o*u,e[t+3]=c*p-a*u-o*h-l*d,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,r){return this._x=e,this._y=t,this._z=n,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!e||!e.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=e._x,r=e._y,i=e._z,s=e._order,a=Math.cos,o=Math.sin,l=a(n/2),c=a(r/2),u=a(i/2),h=o(n/2),d=o(r/2),p=o(i/2);switch(s){case"XYZ":this._x=h*c*u+l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u-h*d*p;break;case"YXZ":this._x=h*c*u+l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u+h*d*p;break;case"ZXY":this._x=h*c*u-l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u-h*d*p;break;case"ZYX":this._x=h*c*u-l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u+h*d*p;break;case"YZX":this._x=h*c*u+l*d*p,this._y=l*d*u+h*c*p,this._z=l*c*p-h*d*u,this._w=l*c*u-h*d*p;break;case"XZY":this._x=h*c*u-l*d*p,this._y=l*d*u-h*c*p,this._z=l*c*p+h*d*u,this._w=l*c*u+h*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!1!==t&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,r=Math.sin(n);return this._x=e.x*r,this._y=e.y*r,this._z=e.z*r,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],r=t[4],i=t[8],s=t[1],a=t[5],o=t[9],l=t[2],c=t[6],u=t[10],h=n+a+u;if(h>0){const e=.5/Math.sqrt(h+1);this._w=.25/e,this._x=(c-o)*e,this._y=(i-l)*e,this._z=(s-r)*e}else if(n>a&&n>u){const e=2*Math.sqrt(1+n-a-u);this._w=(c-o)/e,this._x=.25*e,this._y=(r+s)/e,this._z=(i+l)/e}else if(a>u){const e=2*Math.sqrt(1+a-n-u);this._w=(i-l)/e,this._x=(r+s)/e,this._y=.25*e,this._z=(o+c)/e}else{const e=2*Math.sqrt(1+u-n-a);this._w=(s-r)/e,this._x=(i+l)/e,this._y=(o+c)/e,this._z=.25*e}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(U(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(0===n)return this;const r=Math.min(1,t/n);return this.slerp(e,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return 0===e?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return void 0!==t?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,r=e._y,i=e._z,s=e._w,a=t._x,o=t._y,l=t._z,c=t._w;return this._x=n*c+s*a+r*l-i*o,this._y=r*c+s*o+i*a-n*l,this._z=i*c+s*l+n*o-r*a,this._w=s*c-n*a-r*o-i*l,this._onChangeCallback(),this}slerp(e,t){if(0===t)return this;if(1===t)return this.copy(e);const n=this._x,r=this._y,i=this._z,s=this._w;let a=s*e._w+n*e._x+r*e._y+i*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=s,this._x=n,this._y=r,this._z=i,this;const o=1-a*a;if(o<=Number.EPSILON){const e=1-t;return this._w=e*s+t*this._w,this._x=e*n+t*this._x,this._y=e*r+t*this._y,this._z=e*i+t*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(o),c=Math.atan2(l,a),u=Math.sin((1-t)*c)/l,h=Math.sin(t*c)/l;return this._w=s*u+this._w*h,this._x=n*u+this._x*h,this._y=r*u+this._y*h,this._z=i*u+this._z*h,this._onChangeCallback(),this}slerpQuaternions(e,t,n){return this.copy(e).slerp(t,n)}random(){const e=Math.random(),t=Math.sqrt(1-e),n=Math.sqrt(e),r=2*Math.PI*Math.random(),i=2*Math.PI*Math.random();return this.set(t*Math.cos(r),n*Math.sin(i),n*Math.cos(i),t*Math.sin(r))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class me{constructor(e=0,t=0,n=0){this.isVector3=!0,this.x=e,this.y=t,this.z=n}set(e,t,n){return void 0===n&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return void 0!==t?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(ye.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(ye.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,r=this.z,i=e.elements;return this.x=i[0]*t+i[3]*n+i[6]*r,this.y=i[1]*t+i[4]*n+i[7]*r,this.z=i[2]*t+i[5]*n+i[8]*r,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,r=this.z,i=e.elements,s=1/(i[3]*t+i[7]*n+i[11]*r+i[15]);return this.x=(i[0]*t+i[4]*n+i[8]*r+i[12])*s,this.y=(i[1]*t+i[5]*n+i[9]*r+i[13])*s,this.z=(i[2]*t+i[6]*n+i[10]*r+i[14])*s,this}applyQuaternion(e){const t=this.x,n=this.y,r=this.z,i=e.x,s=e.y,a=e.z,o=e.w,l=o*t+s*r-a*n,c=o*n+a*t-i*r,u=o*r+i*n-s*t,h=-i*t-s*n-a*r;return this.x=l*o+h*-i+c*-a-u*-s,this.y=c*o+h*-s+u*-i-l*-a,this.z=u*o+h*-a+l*-s-c*-i,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,r=this.z,i=e.elements;return this.x=i[0]*t+i[4]*n+i[8]*r,this.y=i[1]*t+i[5]*n+i[9]*r,this.z=i[2]*t+i[6]*n+i[10]*r,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e,t){return void 0!==t?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,r=e.y,i=e.z,s=t.x,a=t.y,o=t.z;return this.x=r*o-i*a,this.y=i*s-n*o,this.z=n*a-r*s,this}projectOnVector(e){const t=e.lengthSq();if(0===t)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return ge.copy(this).projectOnVector(e),this.sub(ge)}reflect(e){return this.sub(ge.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(0===t)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(U(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,r=this.z-e.z;return t*t+n*n+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const r=Math.sin(t)*e;return this.x=r*Math.sin(n),this.y=Math.cos(t)*e,this.z=r*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),r=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=r,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,4*t)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,3*t)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,n){return void 0!==n&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=2*(Math.random()-.5),t=Math.random()*Math.PI*2,n=Math.sqrt(1-e**2);return this.x=n*Math.cos(t),this.y=n*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const ge=new me,ye=new fe;class ve{constructor(e=new me(1/0,1/0,1/0),t=new me(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,n=1/0,r=1/0,i=-1/0,s=-1/0,a=-1/0;for(let o=0,l=e.length;o<l;o+=3){const l=e[o],c=e[o+1],u=e[o+2];l<t&&(t=l),c<n&&(n=c),u<r&&(r=u),l>i&&(i=l),c>s&&(s=c),u>a&&(a=u)}return this.min.set(t,n,r),this.max.set(i,s,a),this}setFromBufferAttribute(e){let t=1/0,n=1/0,r=1/0,i=-1/0,s=-1/0,a=-1/0;for(let o=0,l=e.count;o<l;o++){const l=e.getX(o),c=e.getY(o),u=e.getZ(o);l<t&&(t=l),c<n&&(n=c),u<r&&(r=u),l>i&&(i=l),c>s&&(s=c),u>a&&(a=u)}return this.min.set(t,n,r),this.max.set(i,s,a),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=be.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return(new this.constructor).copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const n=e.geometry;if(void 0!==n)if(t&&null!=n.attributes&&void 0!==n.attributes.position){const t=n.attributes.position;for(let n=0,r=t.count;n<r;n++)be.fromBufferAttribute(t,n).applyMatrix4(e.matrixWorld),this.expandByPoint(be)}else null===n.boundingBox&&n.computeBoundingBox(),we.copy(n.boundingBox),we.applyMatrix4(e.matrixWorld),this.union(we);const r=e.children;for(let e=0,n=r.length;e<n;e++)this.expandByObject(r[e],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,be),be.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Ce),Ie.subVectors(this.max,Ce),_e.subVectors(e.a,Ce),Se.subVectors(e.b,Ce),Me.subVectors(e.c,Ce),Te.subVectors(Se,_e),Ee.subVectors(Me,Se),Ae.subVectors(_e,Me);let t=[0,-Te.z,Te.y,0,-Ee.z,Ee.y,0,-Ae.z,Ae.y,Te.z,0,-Te.x,Ee.z,0,-Ee.x,Ae.z,0,-Ae.x,-Te.y,Te.x,0,-Ee.y,Ee.x,0,-Ae.y,Ae.x,0];return!!Re(t,_e,Se,Me,Ie)&&(t=[1,0,0,0,1,0,0,0,1],!!Re(t,_e,Se,Me,Ie)&&(Ne.crossVectors(Te,Ee),t=[Ne.x,Ne.y,Ne.z],Re(t,_e,Se,Me,Ie)))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return be.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=.5*this.getSize(be).length(),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()||(xe[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),xe[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),xe[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),xe[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),xe[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),xe[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),xe[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),xe[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(xe)),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const xe=[new me,new me,new me,new me,new me,new me,new me,new me],be=new me,we=new ve,_e=new me,Se=new me,Me=new me,Te=new me,Ee=new me,Ae=new me,Ce=new me,Ie=new me,Ne=new me,ke=new me;function Re(e,t,n,r,i){for(let s=0,a=e.length-3;s<=a;s+=3){ke.fromArray(e,s);const a=i.x*Math.abs(ke.x)+i.y*Math.abs(ke.y)+i.z*Math.abs(ke.z),o=t.dot(ke),l=n.dot(ke),c=r.dot(ke);if(Math.max(-Math.max(o,l,c),Math.min(o,l,c))>a)return!1}return!0}const De=new ve,Le=new me,Fe=new me,Pe=new me;class Oe{constructor(e=new me,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;void 0!==t?n.copy(t):De.setFromPoints(e).getCenter(n);let r=0;for(let t=0,i=e.length;t<i;t++)r=Math.max(r,n.distanceToSquared(e[t]));return this.radius=Math.sqrt(r),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){Pe.subVectors(e,this.center);const t=Pe.lengthSq();if(t>this.radius*this.radius){const e=Math.sqrt(t),n=.5*(e-this.radius);this.center.add(Pe.multiplyScalar(n/e)),this.radius+=n}return this}union(e){return!0===this.center.equals(e.center)?Fe.set(0,0,1).multiplyScalar(e.radius):Fe.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(Le.copy(e.center).add(Fe)),this.expandByPoint(Le.copy(e.center).sub(Fe)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const ze=new me,Be=new me,Ue=new me,$e=new me,Ve=new me,We=new me,Ge=new me;class He{constructor(e=new me,t=new me(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,ze)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=ze.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(ze.copy(this.direction).multiplyScalar(t).add(this.origin),ze.distanceToSquared(e))}distanceSqToSegment(e,t,n,r){Be.copy(e).add(t).multiplyScalar(.5),Ue.copy(t).sub(e).normalize(),$e.copy(this.origin).sub(Be);const i=.5*e.distanceTo(t),s=-this.direction.dot(Ue),a=$e.dot(this.direction),o=-$e.dot(Ue),l=$e.lengthSq(),c=Math.abs(1-s*s);let u,h,d,p;if(c>0)if(u=s*o-a,h=s*a-o,p=i*c,u>=0)if(h>=-p)if(h<=p){const e=1/c;u*=e,h*=e,d=u*(u+s*h+2*a)+h*(s*u+h+2*o)+l}else h=i,u=Math.max(0,-(s*h+a)),d=-u*u+h*(h+2*o)+l;else h=-i,u=Math.max(0,-(s*h+a)),d=-u*u+h*(h+2*o)+l;else h<=-p?(u=Math.max(0,-(-s*i+a)),h=u>0?-i:Math.min(Math.max(-i,-o),i),d=-u*u+h*(h+2*o)+l):h<=p?(u=0,h=Math.min(Math.max(-i,-o),i),d=h*(h+2*o)+l):(u=Math.max(0,-(s*i+a)),h=u>0?i:Math.min(Math.max(-i,-o),i),d=-u*u+h*(h+2*o)+l);else h=s>0?-i:i,u=Math.max(0,-(s*h+a)),d=-u*u+h*(h+2*o)+l;return n&&n.copy(this.direction).multiplyScalar(u).add(this.origin),r&&r.copy(Ue).multiplyScalar(h).add(Be),d}intersectSphere(e,t){ze.subVectors(e.center,this.origin);const n=ze.dot(this.direction),r=ze.dot(ze)-n*n,i=e.radius*e.radius;if(r>i)return null;const s=Math.sqrt(i-r),a=n-s,o=n+s;return a<0&&o<0?null:a<0?this.at(o,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(0===t)return 0===e.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return null===n?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return 0===t||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,r,i,s,a,o;const l=1/this.direction.x,c=1/this.direction.y,u=1/this.direction.z,h=this.origin;return l>=0?(n=(e.min.x-h.x)*l,r=(e.max.x-h.x)*l):(n=(e.max.x-h.x)*l,r=(e.min.x-h.x)*l),c>=0?(i=(e.min.y-h.y)*c,s=(e.max.y-h.y)*c):(i=(e.max.y-h.y)*c,s=(e.min.y-h.y)*c),n>s||i>r?null:((i>n||n!=n)&&(n=i),(s<r||r!=r)&&(r=s),u>=0?(a=(e.min.z-h.z)*u,o=(e.max.z-h.z)*u):(a=(e.max.z-h.z)*u,o=(e.min.z-h.z)*u),n>o||a>r?null:((a>n||n!=n)&&(n=a),(o<r||r!=r)&&(r=o),r<0?null:this.at(n>=0?n:r,t)))}intersectsBox(e){return null!==this.intersectBox(e,ze)}intersectTriangle(e,t,n,r,i){Ve.subVectors(t,e),We.subVectors(n,e),Ge.crossVectors(Ve,We);let s,a=this.direction.dot(Ge);if(a>0){if(r)return null;s=1}else{if(!(a<0))return null;s=-1,a=-a}$e.subVectors(this.origin,e);const o=s*this.direction.dot(We.crossVectors($e,We));if(o<0)return null;const l=s*this.direction.dot(Ve.cross($e));if(l<0)return null;if(o+l>a)return null;const c=-s*$e.dot(Ge);return c<0?null:this.at(c/a,i)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class je{constructor(){this.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,r,i,s,a,o,l,c,u,h,d,p,f,m){const g=this.elements;return g[0]=e,g[4]=t,g[8]=n,g[12]=r,g[1]=i,g[5]=s,g[9]=a,g[13]=o,g[2]=l,g[6]=c,g[10]=u,g[14]=h,g[3]=d,g[7]=p,g[11]=f,g[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new je).fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,r=1/qe.setFromMatrixColumn(e,0).length(),i=1/qe.setFromMatrixColumn(e,1).length(),s=1/qe.setFromMatrixColumn(e,2).length();return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=0,t[4]=n[4]*i,t[5]=n[5]*i,t[6]=n[6]*i,t[7]=0,t[8]=n[8]*s,t[9]=n[9]*s,t[10]=n[10]*s,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,n=e.x,r=e.y,i=e.z,s=Math.cos(n),a=Math.sin(n),o=Math.cos(r),l=Math.sin(r),c=Math.cos(i),u=Math.sin(i);if("XYZ"===e.order){const e=s*c,n=s*u,r=a*c,i=a*u;t[0]=o*c,t[4]=-o*u,t[8]=l,t[1]=n+r*l,t[5]=e-i*l,t[9]=-a*o,t[2]=i-e*l,t[6]=r+n*l,t[10]=s*o}else if("YXZ"===e.order){const e=o*c,n=o*u,r=l*c,i=l*u;t[0]=e+i*a,t[4]=r*a-n,t[8]=s*l,t[1]=s*u,t[5]=s*c,t[9]=-a,t[2]=n*a-r,t[6]=i+e*a,t[10]=s*o}else if("ZXY"===e.order){const e=o*c,n=o*u,r=l*c,i=l*u;t[0]=e-i*a,t[4]=-s*u,t[8]=r+n*a,t[1]=n+r*a,t[5]=s*c,t[9]=i-e*a,t[2]=-s*l,t[6]=a,t[10]=s*o}else if("ZYX"===e.order){const e=s*c,n=s*u,r=a*c,i=a*u;t[0]=o*c,t[4]=r*l-n,t[8]=e*l+i,t[1]=o*u,t[5]=i*l+e,t[9]=n*l-r,t[2]=-l,t[6]=a*o,t[10]=s*o}else if("YZX"===e.order){const e=s*o,n=s*l,r=a*o,i=a*l;t[0]=o*c,t[4]=i-e*u,t[8]=r*u+n,t[1]=u,t[5]=s*c,t[9]=-a*c,t[2]=-l*c,t[6]=n*u+r,t[10]=e-i*u}else if("XZY"===e.order){const e=s*o,n=s*l,r=a*o,i=a*l;t[0]=o*c,t[4]=-u,t[8]=l*c,t[1]=e*u+i,t[5]=s*c,t[9]=n*u-r,t[2]=r*u-n,t[6]=a*c,t[10]=i*u+e}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Ye,e,Ke)}lookAt(e,t,n){const r=this.elements;return Qe.subVectors(e,t),0===Qe.lengthSq()&&(Qe.z=1),Qe.normalize(),Ze.crossVectors(n,Qe),0===Ze.lengthSq()&&(1===Math.abs(n.z)?Qe.x+=1e-4:Qe.z+=1e-4,Qe.normalize(),Ze.crossVectors(n,Qe)),Ze.normalize(),Je.crossVectors(Qe,Ze),r[0]=Ze.x,r[4]=Je.x,r[8]=Qe.x,r[1]=Ze.y,r[5]=Je.y,r[9]=Qe.y,r[2]=Ze.z,r[6]=Je.z,r[10]=Qe.z,this}multiply(e,t){return void 0!==t?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,r=t.elements,i=this.elements,s=n[0],a=n[4],o=n[8],l=n[12],c=n[1],u=n[5],h=n[9],d=n[13],p=n[2],f=n[6],m=n[10],g=n[14],y=n[3],v=n[7],x=n[11],b=n[15],w=r[0],_=r[4],S=r[8],M=r[12],T=r[1],E=r[5],A=r[9],C=r[13],I=r[2],N=r[6],k=r[10],R=r[14],D=r[3],L=r[7],F=r[11],P=r[15];return i[0]=s*w+a*T+o*I+l*D,i[4]=s*_+a*E+o*N+l*L,i[8]=s*S+a*A+o*k+l*F,i[12]=s*M+a*C+o*R+l*P,i[1]=c*w+u*T+h*I+d*D,i[5]=c*_+u*E+h*N+d*L,i[9]=c*S+u*A+h*k+d*F,i[13]=c*M+u*C+h*R+d*P,i[2]=p*w+f*T+m*I+g*D,i[6]=p*_+f*E+m*N+g*L,i[10]=p*S+f*A+m*k+g*F,i[14]=p*M+f*C+m*R+g*P,i[3]=y*w+v*T+x*I+b*D,i[7]=y*_+v*E+x*N+b*L,i[11]=y*S+v*A+x*k+b*F,i[15]=y*M+v*C+x*R+b*P,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],r=e[8],i=e[12],s=e[1],a=e[5],o=e[9],l=e[13],c=e[2],u=e[6],h=e[10],d=e[14];return e[3]*(+i*o*u-r*l*u-i*a*h+n*l*h+r*a*d-n*o*d)+e[7]*(+t*o*d-t*l*h+i*s*h-r*s*d+r*l*c-i*o*c)+e[11]*(+t*l*u-t*a*d-i*s*u+n*s*d+i*a*c-n*l*c)+e[15]*(-r*a*c-t*o*u+t*a*h+r*s*u-n*s*h+n*o*c)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const r=this.elements;return e.isVector3?(r[12]=e.x,r[13]=e.y,r[14]=e.z):(r[12]=e,r[13]=t,r[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],i=e[3],s=e[4],a=e[5],o=e[6],l=e[7],c=e[8],u=e[9],h=e[10],d=e[11],p=e[12],f=e[13],m=e[14],g=e[15],y=u*m*l-f*h*l+f*o*d-a*m*d-u*o*g+a*h*g,v=p*h*l-c*m*l-p*o*d+s*m*d+c*o*g-s*h*g,x=c*f*l-p*u*l+p*a*d-s*f*d-c*a*g+s*u*g,b=p*u*o-c*f*o-p*a*h+s*f*h+c*a*m-s*u*m,w=t*y+n*v+r*x+i*b;if(0===w)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const _=1/w;return e[0]=y*_,e[1]=(f*h*i-u*m*i-f*r*d+n*m*d+u*r*g-n*h*g)*_,e[2]=(a*m*i-f*o*i+f*r*l-n*m*l-a*r*g+n*o*g)*_,e[3]=(u*o*i-a*h*i-u*r*l+n*h*l+a*r*d-n*o*d)*_,e[4]=v*_,e[5]=(c*m*i-p*h*i+p*r*d-t*m*d-c*r*g+t*h*g)*_,e[6]=(p*o*i-s*m*i-p*r*l+t*m*l+s*r*g-t*o*g)*_,e[7]=(s*h*i-c*o*i+c*r*l-t*h*l-s*r*d+t*o*d)*_,e[8]=x*_,e[9]=(p*u*i-c*f*i-p*n*d+t*f*d+c*n*g-t*u*g)*_,e[10]=(s*f*i-p*a*i+p*n*l-t*f*l-s*n*g+t*a*g)*_,e[11]=(c*a*i-s*u*i-c*n*l+t*u*l+s*n*d-t*a*d)*_,e[12]=b*_,e[13]=(c*f*r-p*u*r+p*n*h-t*f*h-c*n*m+t*u*m)*_,e[14]=(p*a*r-s*f*r-p*n*o+t*f*o+s*n*m-t*a*m)*_,e[15]=(s*u*r-c*a*r+c*n*o-t*u*o-s*n*h+t*a*h)*_,this}scale(e){const t=this.elements,n=e.x,r=e.y,i=e.z;return t[0]*=n,t[4]*=r,t[8]*=i,t[1]*=n,t[5]*=r,t[9]*=i,t[2]*=n,t[6]*=r,t[10]*=i,t[3]*=n,t[7]*=r,t[11]*=i,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,r))}makeTranslation(e,t,n){return this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),r=Math.sin(t),i=1-n,s=e.x,a=e.y,o=e.z,l=i*s,c=i*a;return this.set(l*s+n,l*a-r*o,l*o+r*a,0,l*a+r*o,c*a+n,c*o-r*s,0,l*o-r*a,c*o+r*s,i*o*o+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n,r,i,s){return this.set(1,n,i,0,e,1,s,0,t,r,1,0,0,0,0,1),this}compose(e,t,n){const r=this.elements,i=t._x,s=t._y,a=t._z,o=t._w,l=i+i,c=s+s,u=a+a,h=i*l,d=i*c,p=i*u,f=s*c,m=s*u,g=a*u,y=o*l,v=o*c,x=o*u,b=n.x,w=n.y,_=n.z;return r[0]=(1-(f+g))*b,r[1]=(d+x)*b,r[2]=(p-v)*b,r[3]=0,r[4]=(d-x)*w,r[5]=(1-(h+g))*w,r[6]=(m+y)*w,r[7]=0,r[8]=(p+v)*_,r[9]=(m-y)*_,r[10]=(1-(h+f))*_,r[11]=0,r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=1,this}decompose(e,t,n){const r=this.elements;let i=qe.set(r[0],r[1],r[2]).length();const s=qe.set(r[4],r[5],r[6]).length(),a=qe.set(r[8],r[9],r[10]).length();this.determinant()<0&&(i=-i),e.x=r[12],e.y=r[13],e.z=r[14],Xe.copy(this);const o=1/i,l=1/s,c=1/a;return Xe.elements[0]*=o,Xe.elements[1]*=o,Xe.elements[2]*=o,Xe.elements[4]*=l,Xe.elements[5]*=l,Xe.elements[6]*=l,Xe.elements[8]*=c,Xe.elements[9]*=c,Xe.elements[10]*=c,t.setFromRotationMatrix(Xe),n.x=i,n.y=s,n.z=a,this}makePerspective(e,t,n,r,i,s){void 0===s&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,o=2*i/(t-e),l=2*i/(n-r),c=(t+e)/(t-e),u=(n+r)/(n-r),h=-(s+i)/(s-i),d=-2*s*i/(s-i);return a[0]=o,a[4]=0,a[8]=c,a[12]=0,a[1]=0,a[5]=l,a[9]=u,a[13]=0,a[2]=0,a[6]=0,a[10]=h,a[14]=d,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(e,t,n,r,i,s){const a=this.elements,o=1/(t-e),l=1/(n-r),c=1/(s-i),u=(t+e)*o,h=(n+r)*l,d=(s+i)*c;return a[0]=2*o,a[4]=0,a[8]=0,a[12]=-u,a[1]=0,a[5]=2*l,a[9]=0,a[13]=-h,a[2]=0,a[6]=0,a[10]=-2*c,a[14]=-d,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let e=0;e<16;e++)if(t[e]!==n[e])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}const qe=new me,Xe=new je,Ye=new me(0,0,0),Ke=new me(1,1,1),Ze=new me,Je=new me,Qe=new me,et=new je,tt=new fe;class nt{constructor(e=0,t=0,n=0,r=nt.DefaultOrder){this.isEuler=!0,this._x=e,this._y=t,this._z=n,this._order=r}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,r=this._order){return this._x=e,this._y=t,this._z=n,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,n=!0){const r=e.elements,i=r[0],s=r[4],a=r[8],o=r[1],l=r[5],c=r[9],u=r[2],h=r[6],d=r[10];switch(t){case"XYZ":this._y=Math.asin(U(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-c,d),this._z=Math.atan2(-s,i)):(this._x=Math.atan2(h,l),this._z=0);break;case"YXZ":this._x=Math.asin(-U(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(a,d),this._z=Math.atan2(o,l)):(this._y=Math.atan2(-u,i),this._z=0);break;case"ZXY":this._x=Math.asin(U(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(-u,d),this._z=Math.atan2(-s,l)):(this._y=0,this._z=Math.atan2(o,i));break;case"ZYX":this._y=Math.asin(-U(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(h,d),this._z=Math.atan2(o,i)):(this._x=0,this._z=Math.atan2(-s,l));break;case"YZX":this._z=Math.asin(U(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-c,l),this._y=Math.atan2(-u,i)):(this._x=0,this._y=Math.atan2(a,d));break;case"XZY":this._z=Math.asin(-U(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(h,l),this._y=Math.atan2(a,i)):(this._x=Math.atan2(-c,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,!0===n&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return et.makeRotationFromQuaternion(e),this.setFromRotationMatrix(et,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return tt.setFromEuler(this),this.setFromQuaternion(tt,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],void 0!==e[3]&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}toVector3(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}nt.DefaultOrder="XYZ",nt.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class rt{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return 0!=(this.mask&e.mask)}isEnabled(e){return 0!=(this.mask&(1<<e|0))}}let it=0;const st=new me,at=new fe,ot=new je,lt=new me,ct=new me,ut=new me,ht=new fe,dt=new me(1,0,0),pt=new me(0,1,0),ft=new me(0,0,1),mt={type:"added"},gt={type:"removed"};class yt extends F{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:it++}),this.uuid=B(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=yt.DefaultUp.clone();const e=new me,t=new nt,n=new fe,r=new me(1,1,1);t._onChange((function(){n.setFromEuler(t,!1)})),n._onChange((function(){t.setFromQuaternion(n,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new je},normalMatrix:{value:new H}}),this.matrix=new je,this.matrixWorld=new je,this.matrixAutoUpdate=yt.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new rt,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return at.setFromAxisAngle(e,t),this.quaternion.multiply(at),this}rotateOnWorldAxis(e,t){return at.setFromAxisAngle(e,t),this.quaternion.premultiply(at),this}rotateX(e){return this.rotateOnAxis(dt,e)}rotateY(e){return this.rotateOnAxis(pt,e)}rotateZ(e){return this.rotateOnAxis(ft,e)}translateOnAxis(e,t){return st.copy(e).applyQuaternion(this.quaternion),this.position.add(st.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(dt,e)}translateY(e){return this.translateOnAxis(pt,e)}translateZ(e){return this.translateOnAxis(ft,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(ot.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?lt.copy(e):lt.set(e,t,n);const r=this.parent;this.updateWorldMatrix(!0,!1),ct.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?ot.lookAt(ct,lt,this.up):ot.lookAt(lt,ct,this.up),this.quaternion.setFromRotationMatrix(ot),r&&(ot.extractRotation(r.matrixWorld),at.setFromRotationMatrix(ot),this.quaternion.premultiply(at.invert()))}add(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(null!==e.parent&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(mt)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}const t=this.children.indexOf(e);return-1!==t&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(gt)),this}removeFromParent(){const e=this.parent;return null!==e&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(gt)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),ot.copy(this.matrixWorld).invert(),null!==e.parent&&(e.parent.updateWorldMatrix(!0,!1),ot.multiply(e.parent.matrixWorld)),e.applyMatrix4(ot),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,r=this.children.length;n<r;n++){const r=this.children[n].getObjectByProperty(e,t);if(void 0!==r)return r}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ct,e,ut),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ct,ht,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].traverse(e)}traverseVisible(e){if(!1===this.visible)return;e(this);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;null!==t&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].updateMatrixWorld(e)}updateWorldMatrix(e,t){const n=this.parent;if(!0===e&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===t){const e=this.children;for(let t=0,n=e.length;t<n;t++)e[t].updateWorldMatrix(!1,!0)}}toJSON(e){const t=void 0===e||"string"==typeof e,n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};function i(t,n){return void 0===t[n.uuid]&&(t[n.uuid]=n.toJSON(e)),n.uuid}if(r.uuid=this.uuid,r.type=this.type,""!==this.name&&(r.name=this.name),!0===this.castShadow&&(r.castShadow=!0),!0===this.receiveShadow&&(r.receiveShadow=!0),!1===this.visible&&(r.visible=!1),!1===this.frustumCulled&&(r.frustumCulled=!1),0!==this.renderOrder&&(r.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(r.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&(r.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=i(e.geometries,this.geometry);const t=this.geometry.parameters;if(void 0!==t&&void 0!==t.shapes){const n=t.shapes;if(Array.isArray(n))for(let t=0,r=n.length;t<r;t++){const r=n[t];i(e.shapes,r)}else i(e.shapes,n)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(i(e.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const t=[];for(let n=0,r=this.material.length;n<r;n++)t.push(i(e.materials,this.material[n]));r.material=t}else r.material=i(e.materials,this.material);if(this.children.length>0){r.children=[];for(let t=0;t<this.children.length;t++)r.children.push(this.children[t].toJSON(e).object)}if(this.animations.length>0){r.animations=[];for(let t=0;t<this.animations.length;t++){const n=this.animations[t];r.animations.push(i(e.animations,n))}}if(t){const t=s(e.geometries),r=s(e.materials),i=s(e.textures),a=s(e.images),o=s(e.shapes),l=s(e.skeletons),c=s(e.animations),u=s(e.nodes);t.length>0&&(n.geometries=t),r.length>0&&(n.materials=r),i.length>0&&(n.textures=i),a.length>0&&(n.images=a),o.length>0&&(n.shapes=o),l.length>0&&(n.skeletons=l),c.length>0&&(n.animations=c),u.length>0&&(n.nodes=u)}return n.object=r,n;function s(e){const t=[];for(const n in e){const r=e[n];delete r.metadata,t.push(r)}return t}}clone(e){return(new this.constructor).copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),!0===t)for(let t=0;t<e.children.length;t++){const n=e.children[t];this.add(n.clone())}return this}}yt.DefaultUp=new me(0,1,0),yt.DefaultMatrixAutoUpdate=!0;const vt=new me,xt=new me,bt=new me,wt=new me,_t=new me,St=new me,Mt=new me,Tt=new me,Et=new me,At=new me;class Ct{constructor(e=new me,t=new me,n=new me){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,r){r.subVectors(n,t),vt.subVectors(e,t),r.cross(vt);const i=r.lengthSq();return i>0?r.multiplyScalar(1/Math.sqrt(i)):r.set(0,0,0)}static getBarycoord(e,t,n,r,i){vt.subVectors(r,t),xt.subVectors(n,t),bt.subVectors(e,t);const s=vt.dot(vt),a=vt.dot(xt),o=vt.dot(bt),l=xt.dot(xt),c=xt.dot(bt),u=s*l-a*a;if(0===u)return i.set(-2,-1,-1);const h=1/u,d=(l*o-a*c)*h,p=(s*c-a*o)*h;return i.set(1-d-p,p,d)}static containsPoint(e,t,n,r){return this.getBarycoord(e,t,n,r,wt),wt.x>=0&&wt.y>=0&&wt.x+wt.y<=1}static getUV(e,t,n,r,i,s,a,o){return this.getBarycoord(e,t,n,r,wt),o.set(0,0),o.addScaledVector(i,wt.x),o.addScaledVector(s,wt.y),o.addScaledVector(a,wt.z),o}static isFrontFacing(e,t,n,r){return vt.subVectors(n,t),xt.subVectors(e,t),vt.cross(xt).dot(r)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,r){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[r]),this}setFromAttributeAndIndices(e,t,n,r){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,n),this.c.fromBufferAttribute(e,r),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return vt.subVectors(this.c,this.b),xt.subVectors(this.a,this.b),.5*vt.cross(xt).length()}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Ct.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Ct.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,r,i){return Ct.getUV(e,this.a,this.b,this.c,t,n,r,i)}containsPoint(e){return Ct.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Ct.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const n=this.a,r=this.b,i=this.c;let s,a;_t.subVectors(r,n),St.subVectors(i,n),Tt.subVectors(e,n);const o=_t.dot(Tt),l=St.dot(Tt);if(o<=0&&l<=0)return t.copy(n);Et.subVectors(e,r);const c=_t.dot(Et),u=St.dot(Et);if(c>=0&&u<=c)return t.copy(r);const h=o*u-c*l;if(h<=0&&o>=0&&c<=0)return s=o/(o-c),t.copy(n).addScaledVector(_t,s);At.subVectors(e,i);const d=_t.dot(At),p=St.dot(At);if(p>=0&&d<=p)return t.copy(i);const f=d*l-o*p;if(f<=0&&l>=0&&p<=0)return a=l/(l-p),t.copy(n).addScaledVector(St,a);const m=c*p-d*u;if(m<=0&&u-c>=0&&d-p>=0)return Mt.subVectors(i,r),a=(u-c)/(u-c+(d-p)),t.copy(r).addScaledVector(Mt,a);const g=1/(m+f+h);return s=f*g,a=h*g,t.copy(n).addScaledVector(_t,s).addScaledVector(St,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let It=0;class Nt extends F{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:It++}),this.uuid=B(),this.name="",this.type="Material",this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=r,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=R,this.stencilZFail=R,this.stencilZPass=R,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(void 0!==e)for(const t in e){const n=e[t];if(void 0===n){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if("shading"===t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===n;continue}const r=this[t];void 0!==r?r&&r.isColor?r.set(n):r&&r.isVector3&&n&&n.isVector3?r.copy(n):this[t]=n:console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.")}}toJSON(e){const t=void 0===e||"string"==typeof e;t&&(e={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function r(e){const t=[];for(const n in e){const r=e[n];delete r.metadata,t.push(r)}return t}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),void 0!==this.sheen&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),void 0!==this.iridescence&&(n.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(n.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,void 0!==this.combine&&(n.combine=this.combine)),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(n.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),void 0!==this.transmission&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid),void 0!==this.thickness&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid),void 0!==this.attenuationDistance&&(n.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(n.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(n.size=this.size),null!==this.shadowSide&&(n.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(n.blending=this.blending),0!==this.side&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),!0===this.transparent&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,void 0!==this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(n.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(n.flatShading=this.flatShading),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),!1===this.fog&&(n.fog=!1),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),t){const t=r(e.textures),i=r(e.images);t.length>0&&(n.textures=t),i.length>0&&(n.images=i)}return n}clone(){return(new this.constructor).copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(null!==t){const e=t.length;n=new Array(e);for(let r=0;r!==e;++r)n[r]=t[r].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){!0===e&&this.version++}get vertexTangents(){return console.warn("THREE."+this.type+": .vertexTangents has been removed."),!1}set vertexTangents(e){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}Nt.fromType=function(){return null};class kt extends Nt{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new ie(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const Rt=new me,Dt=new G;class Lt{constructor(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=void 0!==e?e.length/t:0,this.normalized=!0===n,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){!0===e&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let r=0,i=this.itemSize;r<i;r++)this.array[e+r]=t.array[n+r];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){const t=this.array;let n=0;for(let r=0,i=e.length;r<i;r++){let i=e[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),i=new ie),t[n++]=i.r,t[n++]=i.g,t[n++]=i.b}return this}copyVector2sArray(e){const t=this.array;let n=0;for(let r=0,i=e.length;r<i;r++){let i=e[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),i=new G),t[n++]=i.x,t[n++]=i.y}return this}copyVector3sArray(e){const t=this.array;let n=0;for(let r=0,i=e.length;r<i;r++){let i=e[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),i=new me),t[n++]=i.x,t[n++]=i.y,t[n++]=i.z}return this}copyVector4sArray(e){const t=this.array;let n=0;for(let r=0,i=e.length;r<i;r++){let i=e[r];void 0===i&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),i=new he),t[n++]=i.x,t[n++]=i.y,t[n++]=i.z,t[n++]=i.w}return this}applyMatrix3(e){if(2===this.itemSize)for(let t=0,n=this.count;t<n;t++)Dt.fromBufferAttribute(this,t),Dt.applyMatrix3(e),this.setXY(t,Dt.x,Dt.y);else if(3===this.itemSize)for(let t=0,n=this.count;t<n;t++)Rt.fromBufferAttribute(this,t),Rt.applyMatrix3(e),this.setXYZ(t,Rt.x,Rt.y,Rt.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)Rt.fromBufferAttribute(this,t),Rt.applyMatrix4(e),this.setXYZ(t,Rt.x,Rt.y,Rt.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Rt.fromBufferAttribute(this,t),Rt.applyNormalMatrix(e),this.setXYZ(t,Rt.x,Rt.y,Rt.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Rt.fromBufferAttribute(this,t),Rt.transformDirection(e),this.setXYZ(t,Rt.x,Rt.y,Rt.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=r,this}setXYZW(e,t,n,r,i){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=r,this.array[e+3]=i,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return""!==this.name&&(e.name=this.name),35044!==this.usage&&(e.usage=this.usage),0===this.updateRange.offset&&-1===this.updateRange.count||(e.updateRange=this.updateRange),e}}class Ft extends Lt{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class Pt extends Lt{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class Ot extends Lt{constructor(e,t,n){super(new Float32Array(e),t,n)}}let zt=0;const Bt=new je,Ut=new yt,$t=new me,Vt=new ve,Wt=new ve,Gt=new me;class Ht extends F{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:zt++}),this.uuid=B(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(j(e)?Pt:Ft)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return void 0!==this.attributes[e]}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;void 0!==t&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const t=(new H).getNormalMatrix(e);n.applyNormalMatrix(t),n.needsUpdate=!0}const r=this.attributes.tangent;return void 0!==r&&(r.transformDirection(e),r.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(e){return Bt.makeRotationFromQuaternion(e),this.applyMatrix4(Bt),this}rotateX(e){return Bt.makeRotationX(e),this.applyMatrix4(Bt),this}rotateY(e){return Bt.makeRotationY(e),this.applyMatrix4(Bt),this}rotateZ(e){return Bt.makeRotationZ(e),this.applyMatrix4(Bt),this}translate(e,t,n){return Bt.makeTranslation(e,t,n),this.applyMatrix4(Bt),this}scale(e,t,n){return Bt.makeScale(e,t,n),this.applyMatrix4(Bt),this}lookAt(e){return Ut.lookAt(e),Ut.updateMatrix(),this.applyMatrix4(Ut.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter($t).negate(),this.translate($t.x,$t.y,$t.z),this}setFromPoints(e){const t=[];for(let n=0,r=e.length;n<r;n++){const r=e[n];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new Ot(t,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new ve);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new me(-1/0,-1/0,-1/0),new me(1/0,1/0,1/0));if(void 0!==e){if(this.boundingBox.setFromBufferAttribute(e),t)for(let e=0,n=t.length;e<n;e++){const n=t[e];Vt.setFromBufferAttribute(n),this.morphTargetsRelative?(Gt.addVectors(this.boundingBox.min,Vt.min),this.boundingBox.expandByPoint(Gt),Gt.addVectors(this.boundingBox.max,Vt.max),this.boundingBox.expandByPoint(Gt)):(this.boundingBox.expandByPoint(Vt.min),this.boundingBox.expandByPoint(Vt.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Oe);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new me,1/0);if(e){const n=this.boundingSphere.center;if(Vt.setFromBufferAttribute(e),t)for(let e=0,n=t.length;e<n;e++){const n=t[e];Wt.setFromBufferAttribute(n),this.morphTargetsRelative?(Gt.addVectors(Vt.min,Wt.min),Vt.expandByPoint(Gt),Gt.addVectors(Vt.max,Wt.max),Vt.expandByPoint(Gt)):(Vt.expandByPoint(Wt.min),Vt.expandByPoint(Wt.max))}Vt.getCenter(n);let r=0;for(let t=0,i=e.count;t<i;t++)Gt.fromBufferAttribute(e,t),r=Math.max(r,n.distanceToSquared(Gt));if(t)for(let i=0,s=t.length;i<s;i++){const s=t[i],a=this.morphTargetsRelative;for(let t=0,i=s.count;t<i;t++)Gt.fromBufferAttribute(s,t),a&&($t.fromBufferAttribute(e,t),Gt.add($t)),r=Math.max(r,n.distanceToSquared(Gt))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(null===e||void 0===t.position||void 0===t.normal||void 0===t.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=e.array,r=t.position.array,i=t.normal.array,s=t.uv.array,a=r.length/3;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new Lt(new Float32Array(4*a),4));const o=this.getAttribute("tangent").array,l=[],c=[];for(let e=0;e<a;e++)l[e]=new me,c[e]=new me;const u=new me,h=new me,d=new me,p=new G,f=new G,m=new G,g=new me,y=new me;function v(e,t,n){u.fromArray(r,3*e),h.fromArray(r,3*t),d.fromArray(r,3*n),p.fromArray(s,2*e),f.fromArray(s,2*t),m.fromArray(s,2*n),h.sub(u),d.sub(u),f.sub(p),m.sub(p);const i=1/(f.x*m.y-m.x*f.y);isFinite(i)&&(g.copy(h).multiplyScalar(m.y).addScaledVector(d,-f.y).multiplyScalar(i),y.copy(d).multiplyScalar(f.x).addScaledVector(h,-m.x).multiplyScalar(i),l[e].add(g),l[t].add(g),l[n].add(g),c[e].add(y),c[t].add(y),c[n].add(y))}let x=this.groups;0===x.length&&(x=[{start:0,count:n.length}]);for(let e=0,t=x.length;e<t;++e){const t=x[e],r=t.start;for(let e=r,i=r+t.count;e<i;e+=3)v(n[e+0],n[e+1],n[e+2])}const b=new me,w=new me,_=new me,S=new me;function M(e){_.fromArray(i,3*e),S.copy(_);const t=l[e];b.copy(t),b.sub(_.multiplyScalar(_.dot(t))).normalize(),w.crossVectors(S,t);const n=w.dot(c[e])<0?-1:1;o[4*e]=b.x,o[4*e+1]=b.y,o[4*e+2]=b.z,o[4*e+3]=n}for(let e=0,t=x.length;e<t;++e){const t=x[e],r=t.start;for(let e=r,i=r+t.count;e<i;e+=3)M(n[e+0]),M(n[e+1]),M(n[e+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(void 0!==t){let n=this.getAttribute("normal");if(void 0===n)n=new Lt(new Float32Array(3*t.count),3),this.setAttribute("normal",n);else for(let e=0,t=n.count;e<t;e++)n.setXYZ(e,0,0,0);const r=new me,i=new me,s=new me,a=new me,o=new me,l=new me,c=new me,u=new me;if(e)for(let h=0,d=e.count;h<d;h+=3){const d=e.getX(h+0),p=e.getX(h+1),f=e.getX(h+2);r.fromBufferAttribute(t,d),i.fromBufferAttribute(t,p),s.fromBufferAttribute(t,f),c.subVectors(s,i),u.subVectors(r,i),c.cross(u),a.fromBufferAttribute(n,d),o.fromBufferAttribute(n,p),l.fromBufferAttribute(n,f),a.add(c),o.add(c),l.add(c),n.setXYZ(d,a.x,a.y,a.z),n.setXYZ(p,o.x,o.y,o.z),n.setXYZ(f,l.x,l.y,l.z)}else for(let e=0,a=t.count;e<a;e+=3)r.fromBufferAttribute(t,e+0),i.fromBufferAttribute(t,e+1),s.fromBufferAttribute(t,e+2),c.subVectors(s,i),u.subVectors(r,i),c.cross(u),n.setXYZ(e+0,c.x,c.y,c.z),n.setXYZ(e+1,c.x,c.y,c.z),n.setXYZ(e+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(e,t){if(!e||!e.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);void 0===t&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const r in n){if(void 0===e.attributes[r])continue;const i=n[r].array,s=e.attributes[r],a=s.array,o=s.itemSize*t,l=Math.min(a.length,i.length-o);for(let e=0,t=o;e<l;e++,t++)i[t]=a[e]}return this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)Gt.fromBufferAttribute(e,t),Gt.normalize(),e.setXYZ(t,Gt.x,Gt.y,Gt.z)}toNonIndexed(){function e(e,t){const n=e.array,r=e.itemSize,i=e.normalized,s=new n.constructor(t.length*r);let a=0,o=0;for(let i=0,l=t.length;i<l;i++){a=e.isInterleavedBufferAttribute?t[i]*e.data.stride+e.offset:t[i]*r;for(let e=0;e<r;e++)s[o++]=n[a++]}return new Lt(s,r,i)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Ht,n=this.index.array,r=this.attributes;for(const i in r){const s=e(r[i],n);t.setAttribute(i,s)}const i=this.morphAttributes;for(const r in i){const s=[],a=i[r];for(let t=0,r=a.length;t<r;t++){const r=e(a[t],n);s.push(r)}t.morphAttributes[r]=s}t.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let e=0,n=s.length;e<n;e++){const n=s[e];t.addGroup(n.start,n.count,n.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),void 0!==this.parameters){const t=this.parameters;for(const n in t)void 0!==t[n]&&(e[n]=t[n]);return e}e.data={attributes:{}};const t=this.index;null!==t&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const t in n){const r=n[t];e.data.attributes[t]=r.toJSON(e.data)}const r={};let i=!1;for(const t in this.morphAttributes){const n=this.morphAttributes[t],s=[];for(let t=0,r=n.length;t<r;t++){const r=n[t];s.push(r.toJSON(e.data))}s.length>0&&(r[t]=s,i=!0)}i&&(e.data.morphAttributes=r,e.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(e.data.groups=JSON.parse(JSON.stringify(s)));const a=this.boundingSphere;return null!==a&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return(new this.constructor).copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;null!==n&&this.setIndex(n.clone(t));const r=e.attributes;for(const e in r){const n=r[e];this.setAttribute(e,n.clone(t))}const i=e.morphAttributes;for(const e in i){const n=[],r=i[e];for(let e=0,i=r.length;e<i;e++)n.push(r[e].clone(t));this.morphAttributes[e]=n}this.morphTargetsRelative=e.morphTargetsRelative;const s=e.groups;for(let e=0,t=s.length;e<t;e++){const t=s[e];this.addGroup(t.start,t.count,t.materialIndex)}const a=e.boundingBox;null!==a&&(this.boundingBox=a.clone());const o=e.boundingSphere;return null!==o&&(this.boundingSphere=o.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,void 0!==e.parameters&&(this.parameters=Object.assign({},e.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}const jt=new je,qt=new He,Xt=new Oe,Yt=new me,Kt=new me,Zt=new me,Jt=new me,Qt=new me,en=new me,tn=new me,nn=new me,rn=new me,sn=new G,an=new G,on=new G,ln=new me,cn=new me;class un extends yt{constructor(e=new Ht,t=new kt){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),void 0!==e.morphTargetInfluences&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),void 0!==e.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){const n=e[t[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,t=n.length;e<t;e++){const t=n[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[t]=e}}}}raycast(e,t){const n=this.geometry,r=this.material,i=this.matrixWorld;if(void 0===r)return;if(null===n.boundingSphere&&n.computeBoundingSphere(),Xt.copy(n.boundingSphere),Xt.applyMatrix4(i),!1===e.ray.intersectsSphere(Xt))return;if(jt.copy(i).invert(),qt.copy(e.ray).applyMatrix4(jt),null!==n.boundingBox&&!1===qt.intersectsBox(n.boundingBox))return;let s;const a=n.index,o=n.attributes.position,l=n.morphAttributes.position,c=n.morphTargetsRelative,u=n.attributes.uv,h=n.attributes.uv2,d=n.groups,p=n.drawRange;if(null!==a)if(Array.isArray(r))for(let n=0,i=d.length;n<i;n++){const i=d[n],f=r[i.materialIndex];for(let n=Math.max(i.start,p.start),r=Math.min(a.count,Math.min(i.start+i.count,p.start+p.count));n<r;n+=3){const r=a.getX(n),d=a.getX(n+1),p=a.getX(n+2);s=hn(this,f,e,qt,o,l,c,u,h,r,d,p),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=i.materialIndex,t.push(s))}}else for(let n=Math.max(0,p.start),i=Math.min(a.count,p.start+p.count);n<i;n+=3){const i=a.getX(n),d=a.getX(n+1),p=a.getX(n+2);s=hn(this,r,e,qt,o,l,c,u,h,i,d,p),s&&(s.faceIndex=Math.floor(n/3),t.push(s))}else if(void 0!==o)if(Array.isArray(r))for(let n=0,i=d.length;n<i;n++){const i=d[n],a=r[i.materialIndex];for(let n=Math.max(i.start,p.start),r=Math.min(o.count,Math.min(i.start+i.count,p.start+p.count));n<r;n+=3)s=hn(this,a,e,qt,o,l,c,u,h,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),s.face.materialIndex=i.materialIndex,t.push(s))}else for(let n=Math.max(0,p.start),i=Math.min(o.count,p.start+p.count);n<i;n+=3)s=hn(this,r,e,qt,o,l,c,u,h,n,n+1,n+2),s&&(s.faceIndex=Math.floor(n/3),t.push(s))}}function hn(e,t,n,r,i,s,a,o,l,c,u,h){Yt.fromBufferAttribute(i,c),Kt.fromBufferAttribute(i,u),Zt.fromBufferAttribute(i,h);const d=e.morphTargetInfluences;if(s&&d){tn.set(0,0,0),nn.set(0,0,0),rn.set(0,0,0);for(let e=0,t=s.length;e<t;e++){const t=d[e],n=s[e];0!==t&&(Jt.fromBufferAttribute(n,c),Qt.fromBufferAttribute(n,u),en.fromBufferAttribute(n,h),a?(tn.addScaledVector(Jt,t),nn.addScaledVector(Qt,t),rn.addScaledVector(en,t)):(tn.addScaledVector(Jt.sub(Yt),t),nn.addScaledVector(Qt.sub(Kt),t),rn.addScaledVector(en.sub(Zt),t)))}Yt.add(tn),Kt.add(nn),Zt.add(rn)}e.isSkinnedMesh&&(e.boneTransform(c,Yt),e.boneTransform(u,Kt),e.boneTransform(h,Zt));const p=function(e,t,n,r,i,s,a,o){let l;if(l=1===t.side?r.intersectTriangle(a,s,i,!0,o):r.intersectTriangle(i,s,a,2!==t.side,o),null===l)return null;cn.copy(o),cn.applyMatrix4(e.matrixWorld);const c=n.ray.origin.distanceTo(cn);return c<n.near||c>n.far?null:{distance:c,point:cn.clone(),object:e}}(e,t,n,r,Yt,Kt,Zt,ln);if(p){o&&(sn.fromBufferAttribute(o,c),an.fromBufferAttribute(o,u),on.fromBufferAttribute(o,h),p.uv=Ct.getUV(ln,Yt,Kt,Zt,sn,an,on,new G)),l&&(sn.fromBufferAttribute(l,c),an.fromBufferAttribute(l,u),on.fromBufferAttribute(l,h),p.uv2=Ct.getUV(ln,Yt,Kt,Zt,sn,an,on,new G));const e={a:c,b:u,c:h,normal:new me,materialIndex:0};Ct.getNormal(Yt,Kt,Zt,e.normal),p.face=e}return p}class dn extends Ht{constructor(e=1,t=1,n=1,r=1,i=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:r,heightSegments:i,depthSegments:s};const a=this;r=Math.floor(r),i=Math.floor(i),s=Math.floor(s);const o=[],l=[],c=[],u=[];let h=0,d=0;function p(e,t,n,r,i,s,p,f,m,g,y){const v=s/m,x=p/g,b=s/2,w=p/2,_=f/2,S=m+1,M=g+1;let T=0,E=0;const A=new me;for(let s=0;s<M;s++){const a=s*x-w;for(let o=0;o<S;o++){const h=o*v-b;A[e]=h*r,A[t]=a*i,A[n]=_,l.push(A.x,A.y,A.z),A[e]=0,A[t]=0,A[n]=f>0?1:-1,c.push(A.x,A.y,A.z),u.push(o/m),u.push(1-s/g),T+=1}}for(let e=0;e<g;e++)for(let t=0;t<m;t++){const n=h+t+S*e,r=h+t+S*(e+1),i=h+(t+1)+S*(e+1),s=h+(t+1)+S*e;o.push(n,r,s),o.push(r,i,s),E+=6}a.addGroup(d,E,y),d+=E,h+=T}p("z","y","x",-1,-1,n,t,e,s,i,0),p("z","y","x",1,-1,n,t,-e,s,i,1),p("x","z","y",1,1,e,n,t,r,s,2),p("x","z","y",1,-1,e,n,-t,r,s,3),p("x","y","z",1,-1,e,t,n,r,i,4),p("x","y","z",-1,-1,e,t,-n,r,i,5),this.setIndex(o),this.setAttribute("position",new Ot(l,3)),this.setAttribute("normal",new Ot(c,3)),this.setAttribute("uv",new Ot(u,2))}static fromJSON(e){return new dn(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function pn(e){const t={};for(const n in e){t[n]={};for(const r in e[n]){const i=e[n][r];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?t[n][r]=i.clone():Array.isArray(i)?t[n][r]=i.slice():t[n][r]=i}}return t}function fn(e){const t={};for(let n=0;n<e.length;n++){const r=pn(e[n]);for(const e in r)t[e]=r[e]}return t}const mn={clone:pn,merge:fn};class gn extends Nt{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==e&&(void 0!==e.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=pn(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const n in this.uniforms){const r=this.uniforms[n].value;r&&r.isTexture?t.uniforms[n]={type:"t",value:r.toJSON(e).uuid}:r&&r.isColor?t.uniforms[n]={type:"c",value:r.getHex()}:r&&r.isVector2?t.uniforms[n]={type:"v2",value:r.toArray()}:r&&r.isVector3?t.uniforms[n]={type:"v3",value:r.toArray()}:r&&r.isVector4?t.uniforms[n]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?t.uniforms[n]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?t.uniforms[n]={type:"m4",value:r.toArray()}:t.uniforms[n]={value:r}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const n={};for(const e in this.extensions)!0===this.extensions[e]&&(n[e]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}}class yn extends yt{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new je,this.projectionMatrix=new je,this.projectionMatrixInverse=new je}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}class vn extends yn{constructor(e=50,t=1,n=.1,r=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=r,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=null===e.view?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=2*z*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(.5*O*this.fov);return.5*this.getFilmHeight()/e}getEffectiveFOV(){return 2*z*Math.atan(Math.tan(.5*O*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,n,r,i,s){this.aspect=e/t,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=r,this.view.width=i,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(.5*O*this.fov)/this.zoom,n=2*t,r=this.aspect*n,i=-.5*r;const s=this.view;if(null!==this.view&&this.view.enabled){const e=s.fullWidth,a=s.fullHeight;i+=s.offsetX*r/e,t-=s.offsetY*n/a,r*=s.width/e,n*=s.height/a}const a=this.filmOffset;0!==a&&(i+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(i,i+r,t,t-n,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,null!==this.view&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const xn=90;class bn extends yt{constructor(e,t,n){if(super(),this.type="CubeCamera",!0!==n.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const r=new vn(xn,1,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new me(1,0,0)),this.add(r);const i=new vn(xn,1,e,t);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new me(-1,0,0)),this.add(i);const s=new vn(xn,1,e,t);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new me(0,1,0)),this.add(s);const a=new vn(xn,1,e,t);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new me(0,-1,0)),this.add(a);const o=new vn(xn,1,e,t);o.layers=this.layers,o.up.set(0,-1,0),o.lookAt(new me(0,0,1)),this.add(o);const l=new vn(xn,1,e,t);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new me(0,0,-1)),this.add(l)}update(e,t){null===this.parent&&this.updateMatrixWorld();const n=this.renderTarget,[r,i,s,a,o,l]=this.children,c=e.getRenderTarget(),u=e.toneMapping,h=e.xr.enabled;e.toneMapping=0,e.xr.enabled=!1;const d=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0),e.render(t,r),e.setRenderTarget(n,1),e.render(t,i),e.setRenderTarget(n,2),e.render(t,s),e.setRenderTarget(n,3),e.render(t,a),e.setRenderTarget(n,4),e.render(t,o),n.texture.generateMipmaps=d,e.setRenderTarget(n,5),e.render(t,l),e.setRenderTarget(c),e.toneMapping=u,e.xr.enabled=h,n.texture.needsPMREMUpdate=!0}}class wn extends ue{constructor(e,t,n,r,s,a,o,l,c,u){super(e=void 0!==e?e:[],t=void 0!==t?t:i,n,r,s,a,o,l,c,u),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class _n extends de{constructor(e,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const n={width:e,height:e,depth:1},r=[n,n,n,n,n,n];this.texture=new wn(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==t.generateMipmaps&&t.generateMipmaps,this.texture.minFilter=void 0!==t.minFilter?t.minFilter:h}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={tEquirect:{value:null}},r="\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",i="\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",s=new dn(5,5,5),a=new gn({name:"CubemapFromEquirect",uniforms:pn(n),vertexShader:r,fragmentShader:i,side:1,blending:0});a.uniforms.tEquirect.value=t;const o=new un(s,a),l=t.minFilter;return t.minFilter===d&&(t.minFilter=h),new bn(1,10,this).update(e,o),t.minFilter=l,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,n,r){const i=e.getRenderTarget();for(let i=0;i<6;i++)e.setRenderTarget(this,i),e.clear(t,n,r);e.setRenderTarget(i)}}const Sn=new me,Mn=new me,Tn=new H;class En{constructor(e=new me(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,r){return this.normal.set(e,t,n),this.constant=r,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const r=Sn.subVectors(n,t).cross(Mn.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(r,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){const n=e.delta(Sn),r=this.normal.dot(n);if(0===r)return 0===this.distanceToPoint(e.start)?t.copy(e.start):null;const i=-(e.start.dot(this.normal)+this.constant)/r;return i<0||i>1?null:t.copy(n).multiplyScalar(i).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||Tn.getNormalMatrix(e),r=this.coplanarPoint(Sn).applyMatrix4(e),i=this.normal.applyMatrix3(n).normalize();return this.constant=-r.dot(i),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return(new this.constructor).copy(this)}}const An=new Oe,Cn=new me;class In{constructor(e=new En,t=new En,n=new En,r=new En,i=new En,s=new En){this.planes=[e,t,n,r,i,s]}set(e,t,n,r,i,s){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(n),a[3].copy(r),a[4].copy(i),a[5].copy(s),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e){const t=this.planes,n=e.elements,r=n[0],i=n[1],s=n[2],a=n[3],o=n[4],l=n[5],c=n[6],u=n[7],h=n[8],d=n[9],p=n[10],f=n[11],m=n[12],g=n[13],y=n[14],v=n[15];return t[0].setComponents(a-r,u-o,f-h,v-m).normalize(),t[1].setComponents(a+r,u+o,f+h,v+m).normalize(),t[2].setComponents(a+i,u+l,f+d,v+g).normalize(),t[3].setComponents(a-i,u-l,f-d,v-g).normalize(),t[4].setComponents(a-s,u-c,f-p,v-y).normalize(),t[5].setComponents(a+s,u+c,f+p,v+y).normalize(),this}intersectsObject(e){const t=e.geometry;return null===t.boundingSphere&&t.computeBoundingSphere(),An.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(An)}intersectsSprite(e){return An.center.set(0,0,0),An.radius=.7071067811865476,An.applyMatrix4(e.matrixWorld),this.intersectsSphere(An)}intersectsSphere(e){const t=this.planes,n=e.center,r=-e.radius;for(let e=0;e<6;e++)if(t[e].distanceToPoint(n)<r)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const r=t[n];if(Cn.x=r.normal.x>0?e.max.x:e.min.x,Cn.y=r.normal.y>0?e.max.y:e.min.y,Cn.z=r.normal.z>0?e.max.z:e.min.z,r.distanceToPoint(Cn)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}function Nn(){let e=null,t=!1,n=null,r=null;function i(t,s){n(t,s),r=e.requestAnimationFrame(i)}return{start:function(){!0!==t&&null!==n&&(r=e.requestAnimationFrame(i),t=!0)},stop:function(){e.cancelAnimationFrame(r),t=!1},setAnimationLoop:function(e){n=e},setContext:function(t){e=t}}}function kn(e,t){const n=t.isWebGL2,r=new WeakMap;return{get:function(e){return e.isInterleavedBufferAttribute&&(e=e.data),r.get(e)},remove:function(t){t.isInterleavedBufferAttribute&&(t=t.data);const n=r.get(t);n&&(e.deleteBuffer(n.buffer),r.delete(t))},update:function(t,i){if(t.isGLBufferAttribute){const e=r.get(t);return void((!e||e.version<t.version)&&r.set(t,{buffer:t.buffer,type:t.type,bytesPerElement:t.elementSize,version:t.version}))}t.isInterleavedBufferAttribute&&(t=t.data);const s=r.get(t);void 0===s?r.set(t,function(t,r){const i=t.array,s=t.usage,a=e.createBuffer();let o;if(e.bindBuffer(r,a),e.bufferData(r,i,s),t.onUploadCallback(),i instanceof Float32Array)o=5126;else if(i instanceof Uint16Array)if(t.isFloat16BufferAttribute){if(!n)throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");o=5131}else o=5123;else if(i instanceof Int16Array)o=5122;else if(i instanceof Uint32Array)o=5125;else if(i instanceof Int32Array)o=5124;else if(i instanceof Int8Array)o=5120;else if(i instanceof Uint8Array)o=5121;else{if(!(i instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+i);o=5121}return{buffer:a,type:o,bytesPerElement:i.BYTES_PER_ELEMENT,version:t.version}}(t,i)):s.version<t.version&&(function(t,r,i){const s=r.array,a=r.updateRange;e.bindBuffer(i,t),-1===a.count?e.bufferSubData(i,0,s):(n?e.bufferSubData(i,a.offset*s.BYTES_PER_ELEMENT,s,a.offset,a.count):e.bufferSubData(i,a.offset*s.BYTES_PER_ELEMENT,s.subarray(a.offset,a.offset+a.count)),a.count=-1)}(s.buffer,t,i),s.version=t.version)}}}class Rn extends Ht{constructor(e=1,t=1,n=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:r};const i=e/2,s=t/2,a=Math.floor(n),o=Math.floor(r),l=a+1,c=o+1,u=e/a,h=t/o,d=[],p=[],f=[],m=[];for(let e=0;e<c;e++){const t=e*h-s;for(let n=0;n<l;n++){const r=n*u-i;p.push(r,-t,0),f.push(0,0,1),m.push(n/a),m.push(1-e/o)}}for(let e=0;e<o;e++)for(let t=0;t<a;t++){const n=t+l*e,r=t+l*(e+1),i=t+1+l*(e+1),s=t+1+l*e;d.push(n,r,s),d.push(r,i,s)}this.setIndex(d),this.setAttribute("position",new Ot(p,3)),this.setAttribute("normal",new Ot(f,3)),this.setAttribute("uv",new Ot(m,2))}static fromJSON(e){return new Rn(e.width,e.height,e.widthSegments,e.heightSegments)}}const Dn={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\nvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",iridescence_fragment:"#ifdef USE_IRIDESCENCE\nconst mat3 XYZ_TO_REC709 = mat3(\n    3.2404542, -0.9692660,  0.0556434,\n   -1.5371385,  1.8760108, -0.2040259,\n   -0.4985314,  0.0415560,  1.0572252\n);\nvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n   vec3 sqrtF0 = sqrt( fresnel0 );\n   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n}\nvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n}\nfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n}\nvec3 evalSensitivity( float OPD, vec3 shift ) {\n   float phase = 2.0 * PI * OPD * 1.0e-9;\n   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );\n   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );\n   xyz /= 1.0685e-7;\n   vec3 srgb = XYZ_TO_REC709 * xyz;\n   return srgb;\n}\nvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n   vec3 I;\n   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n   float cosTheta2Sq = 1.0 - sinTheta2Sq;\n   if ( cosTheta2Sq < 0.0 ) {\n       return vec3( 1.0 );\n   }\n   float cosTheta2 = sqrt( cosTheta2Sq );\n   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n   float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n   float R21 = R12;\n   float T121 = 1.0 - R12;\n   float phi12 = 0.0;\n   if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n   float phi21 = PI - phi12;\n   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n   vec3 phi23 = vec3( 0.0 );\n   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;\n   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;\n   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;\n   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n   vec3 phi = vec3( phi21 ) + phi23;\n   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n   vec3 r123 = sqrt( R123 );\n   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n   vec3 C0 = R12 + Rs;\n   I = C0;\n   vec3 Cm = Rs - T121;\n   for ( int m = 1; m <= 2; ++m ) {\n       Cm *= r123;\n       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n       I += Cm * Sm;\n   }\n   return max( I, vec3( 0.0 ) );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\nfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\nif ( material.iridescenceThickness == 0.0 ) {\n\tmaterial.iridescence = 0.0;\n} else {\n\tmaterial.iridescence = saturate( material.iridescence );\n}\nif ( material.iridescence > 0.0 ) {\n\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",iridescence_pars_fragment:"#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"},Ln={common:{diffuse:{value:new ie(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new H},uv2Transform:{value:new H},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new G(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new ie(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new ie(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new H}},sprite:{diffuse:{value:new ie(16777215)},opacity:{value:1},center:{value:new G(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new H}}},Fn={basic:{uniforms:fn([Ln.common,Ln.specularmap,Ln.envmap,Ln.aomap,Ln.lightmap,Ln.fog]),vertexShader:Dn.meshbasic_vert,fragmentShader:Dn.meshbasic_frag},lambert:{uniforms:fn([Ln.common,Ln.specularmap,Ln.envmap,Ln.aomap,Ln.lightmap,Ln.emissivemap,Ln.fog,Ln.lights,{emissive:{value:new ie(0)}}]),vertexShader:Dn.meshlambert_vert,fragmentShader:Dn.meshlambert_frag},phong:{uniforms:fn([Ln.common,Ln.specularmap,Ln.envmap,Ln.aomap,Ln.lightmap,Ln.emissivemap,Ln.bumpmap,Ln.normalmap,Ln.displacementmap,Ln.fog,Ln.lights,{emissive:{value:new ie(0)},specular:{value:new ie(1118481)},shininess:{value:30}}]),vertexShader:Dn.meshphong_vert,fragmentShader:Dn.meshphong_frag},standard:{uniforms:fn([Ln.common,Ln.envmap,Ln.aomap,Ln.lightmap,Ln.emissivemap,Ln.bumpmap,Ln.normalmap,Ln.displacementmap,Ln.roughnessmap,Ln.metalnessmap,Ln.fog,Ln.lights,{emissive:{value:new ie(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Dn.meshphysical_vert,fragmentShader:Dn.meshphysical_frag},toon:{uniforms:fn([Ln.common,Ln.aomap,Ln.lightmap,Ln.emissivemap,Ln.bumpmap,Ln.normalmap,Ln.displacementmap,Ln.gradientmap,Ln.fog,Ln.lights,{emissive:{value:new ie(0)}}]),vertexShader:Dn.meshtoon_vert,fragmentShader:Dn.meshtoon_frag},matcap:{uniforms:fn([Ln.common,Ln.bumpmap,Ln.normalmap,Ln.displacementmap,Ln.fog,{matcap:{value:null}}]),vertexShader:Dn.meshmatcap_vert,fragmentShader:Dn.meshmatcap_frag},points:{uniforms:fn([Ln.points,Ln.fog]),vertexShader:Dn.points_vert,fragmentShader:Dn.points_frag},dashed:{uniforms:fn([Ln.common,Ln.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Dn.linedashed_vert,fragmentShader:Dn.linedashed_frag},depth:{uniforms:fn([Ln.common,Ln.displacementmap]),vertexShader:Dn.depth_vert,fragmentShader:Dn.depth_frag},normal:{uniforms:fn([Ln.common,Ln.bumpmap,Ln.normalmap,Ln.displacementmap,{opacity:{value:1}}]),vertexShader:Dn.meshnormal_vert,fragmentShader:Dn.meshnormal_frag},sprite:{uniforms:fn([Ln.sprite,Ln.fog]),vertexShader:Dn.sprite_vert,fragmentShader:Dn.sprite_frag},background:{uniforms:{uvTransform:{value:new H},t2D:{value:null}},vertexShader:Dn.background_vert,fragmentShader:Dn.background_frag},cube:{uniforms:fn([Ln.envmap,{opacity:{value:1}}]),vertexShader:Dn.cube_vert,fragmentShader:Dn.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Dn.equirect_vert,fragmentShader:Dn.equirect_frag},distanceRGBA:{uniforms:fn([Ln.common,Ln.displacementmap,{referencePosition:{value:new me},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Dn.distanceRGBA_vert,fragmentShader:Dn.distanceRGBA_frag},shadow:{uniforms:fn([Ln.lights,Ln.fog,{color:{value:new ie(0)},opacity:{value:1}}]),vertexShader:Dn.shadow_vert,fragmentShader:Dn.shadow_frag}};function Pn(e,t,n,r,i,s){const o=new ie(0);let l,c,u=!0===i?0:1,h=null,d=0,p=null;function f(e,t){n.buffers.color.setClear(e.r,e.g,e.b,t,s)}return{getClearColor:function(){return o},setClearColor:function(e,t=1){o.set(e),u=t,f(o,u)},getClearAlpha:function(){return u},setClearAlpha:function(e){u=e,f(o,u)},render:function(n,i){let s=!1,m=!0===i.isScene?i.background:null;m&&m.isTexture&&(m=t.get(m));const g=e.xr,y=g.getSession&&g.getSession();y&&"additive"===y.environmentBlendMode&&(m=null),null===m?f(o,u):m&&m.isColor&&(f(m,1),s=!0),(e.autoClear||s)&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),m&&(m.isCubeTexture||m.mapping===a)?(void 0===c&&(c=new un(new dn(1,1,1),new gn({name:"BackgroundCubeMaterial",uniforms:pn(Fn.cube.uniforms),vertexShader:Fn.cube.vertexShader,fragmentShader:Fn.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(e,t,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(c)),c.material.uniforms.envMap.value=m,c.material.uniforms.flipEnvMap.value=m.isCubeTexture&&!1===m.isRenderTargetTexture?-1:1,h===m&&d===m.version&&p===e.toneMapping||(c.material.needsUpdate=!0,h=m,d=m.version,p=e.toneMapping),c.layers.enableAll(),n.unshift(c,c.geometry,c.material,0,0,null)):m&&m.isTexture&&(void 0===l&&(l=new un(new Rn(2,2),new gn({name:"BackgroundMaterial",uniforms:pn(Fn.background.uniforms),vertexShader:Fn.background.vertexShader,fragmentShader:Fn.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(l)),l.material.uniforms.t2D.value=m,!0===m.matrixAutoUpdate&&m.updateMatrix(),l.material.uniforms.uvTransform.value.copy(m.matrix),h===m&&d===m.version&&p===e.toneMapping||(l.material.needsUpdate=!0,h=m,d=m.version,p=e.toneMapping),l.layers.enableAll(),n.unshift(l,l.geometry,l.material,0,0,null))}}}function On(e,t,n,r){const i=e.getParameter(34921),s=r.isWebGL2?null:t.get("OES_vertex_array_object"),a=r.isWebGL2||null!==s,o={},l=p(null);let c=l,u=!1;function h(t){return r.isWebGL2?e.bindVertexArray(t):s.bindVertexArrayOES(t)}function d(t){return r.isWebGL2?e.deleteVertexArray(t):s.deleteVertexArrayOES(t)}function p(e){const t=[],n=[],r=[];for(let e=0;e<i;e++)t[e]=0,n[e]=0,r[e]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:t,enabledAttributes:n,attributeDivisors:r,object:e,attributes:{},index:null}}function f(){const e=c.newAttributes;for(let t=0,n=e.length;t<n;t++)e[t]=0}function m(e){g(e,0)}function g(n,i){const s=c.newAttributes,a=c.enabledAttributes,o=c.attributeDivisors;s[n]=1,0===a[n]&&(e.enableVertexAttribArray(n),a[n]=1),o[n]!==i&&((r.isWebGL2?e:t.get("ANGLE_instanced_arrays"))[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,i),o[n]=i)}function y(){const t=c.newAttributes,n=c.enabledAttributes;for(let r=0,i=n.length;r<i;r++)n[r]!==t[r]&&(e.disableVertexAttribArray(r),n[r]=0)}function v(t,n,i,s,a,o){!0!==r.isWebGL2||5124!==i&&5125!==i?e.vertexAttribPointer(t,n,i,s,a,o):e.vertexAttribIPointer(t,n,i,a,o)}function x(){b(),u=!0,c!==l&&(c=l,h(c.object))}function b(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(i,l,d,x,b){let w=!1;if(a){const t=function(t,n,i){const a=!0===i.wireframe;let l=o[t.id];void 0===l&&(l={},o[t.id]=l);let c=l[n.id];void 0===c&&(c={},l[n.id]=c);let u=c[a];return void 0===u&&(u=p(r.isWebGL2?e.createVertexArray():s.createVertexArrayOES()),c[a]=u),u}(x,d,l);c!==t&&(c=t,h(c.object)),w=function(e,t,n,r){const i=c.attributes,s=t.attributes;let a=0;const o=n.getAttributes();for(const t in o)if(o[t].location>=0){const n=i[t];let r=s[t];if(void 0===r&&("instanceMatrix"===t&&e.instanceMatrix&&(r=e.instanceMatrix),"instanceColor"===t&&e.instanceColor&&(r=e.instanceColor)),void 0===n)return!0;if(n.attribute!==r)return!0;if(r&&n.data!==r.data)return!0;a++}return c.attributesNum!==a||c.index!==r}(i,x,d,b),w&&function(e,t,n,r){const i={},s=t.attributes;let a=0;const o=n.getAttributes();for(const t in o)if(o[t].location>=0){let n=s[t];void 0===n&&("instanceMatrix"===t&&e.instanceMatrix&&(n=e.instanceMatrix),"instanceColor"===t&&e.instanceColor&&(n=e.instanceColor));const r={};r.attribute=n,n&&n.data&&(r.data=n.data),i[t]=r,a++}c.attributes=i,c.attributesNum=a,c.index=r}(i,x,d,b)}else{const e=!0===l.wireframe;c.geometry===x.id&&c.program===d.id&&c.wireframe===e||(c.geometry=x.id,c.program=d.id,c.wireframe=e,w=!0)}null!==b&&n.update(b,34963),(w||u)&&(u=!1,function(i,s,a,o){if(!1===r.isWebGL2&&(i.isInstancedMesh||o.isInstancedBufferGeometry)&&null===t.get("ANGLE_instanced_arrays"))return;f();const l=o.attributes,c=a.getAttributes(),u=s.defaultAttributeValues;for(const t in c){const r=c[t];if(r.location>=0){let s=l[t];if(void 0===s&&("instanceMatrix"===t&&i.instanceMatrix&&(s=i.instanceMatrix),"instanceColor"===t&&i.instanceColor&&(s=i.instanceColor)),void 0!==s){const t=s.normalized,a=s.itemSize,l=n.get(s);if(void 0===l)continue;const c=l.buffer,u=l.type,h=l.bytesPerElement;if(s.isInterleavedBufferAttribute){const n=s.data,l=n.stride,d=s.offset;if(n.isInstancedInterleavedBuffer){for(let e=0;e<r.locationSize;e++)g(r.location+e,n.meshPerAttribute);!0!==i.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=n.meshPerAttribute*n.count)}else for(let e=0;e<r.locationSize;e++)m(r.location+e);e.bindBuffer(34962,c);for(let e=0;e<r.locationSize;e++)v(r.location+e,a/r.locationSize,u,t,l*h,(d+a/r.locationSize*e)*h)}else{if(s.isInstancedBufferAttribute){for(let e=0;e<r.locationSize;e++)g(r.location+e,s.meshPerAttribute);!0!==i.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=s.meshPerAttribute*s.count)}else for(let e=0;e<r.locationSize;e++)m(r.location+e);e.bindBuffer(34962,c);for(let e=0;e<r.locationSize;e++)v(r.location+e,a/r.locationSize,u,t,a*h,a/r.locationSize*e*h)}}else if(void 0!==u){const n=u[t];if(void 0!==n)switch(n.length){case 2:e.vertexAttrib2fv(r.location,n);break;case 3:e.vertexAttrib3fv(r.location,n);break;case 4:e.vertexAttrib4fv(r.location,n);break;default:e.vertexAttrib1fv(r.location,n)}}}}y()}(i,l,d,x),null!==b&&e.bindBuffer(34963,n.get(b).buffer))},reset:x,resetDefaultState:b,dispose:function(){x();for(const e in o){const t=o[e];for(const e in t){const n=t[e];for(const e in n)d(n[e].object),delete n[e];delete t[e]}delete o[e]}},releaseStatesOfGeometry:function(e){if(void 0===o[e.id])return;const t=o[e.id];for(const e in t){const n=t[e];for(const e in n)d(n[e].object),delete n[e];delete t[e]}delete o[e.id]},releaseStatesOfProgram:function(e){for(const t in o){const n=o[t];if(void 0===n[e.id])continue;const r=n[e.id];for(const e in r)d(r[e].object),delete r[e];delete n[e.id]}},initAttributes:f,enableAttribute:m,disableUnusedAttributes:y}}function zn(e,t,n,r){const i=r.isWebGL2;let s;this.setMode=function(e){s=e},this.render=function(t,r){e.drawArrays(s,t,r),n.update(r,s,1)},this.renderInstances=function(r,a,o){if(0===o)return;let l,c;if(i)l=e,c="drawArraysInstanced";else if(l=t.get("ANGLE_instanced_arrays"),c="drawArraysInstancedANGLE",null===l)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[c](s,r,a,o),n.update(a,s,o)}}function Bn(e,t,n){let r;function i(t){if("highp"===t){if(e.getShaderPrecisionFormat(35633,36338).precision>0&&e.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";t="mediump"}return"mediump"===t&&e.getShaderPrecisionFormat(35633,36337).precision>0&&e.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const s="undefined"!=typeof WebGL2RenderingContext&&e instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&e instanceof WebGL2ComputeRenderingContext;let a=void 0!==n.precision?n.precision:"highp";const o=i(a);o!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",o,"instead."),a=o);const l=s||t.has("WEBGL_draw_buffers"),c=!0===n.logarithmicDepthBuffer,u=e.getParameter(34930),h=e.getParameter(35660),d=e.getParameter(3379),p=e.getParameter(34076),f=e.getParameter(34921),m=e.getParameter(36347),g=e.getParameter(36348),y=e.getParameter(36349),v=h>0,x=s||t.has("OES_texture_float");return{isWebGL2:s,drawBuffers:l,getMaxAnisotropy:function(){if(void 0!==r)return r;if(!0===t.has("EXT_texture_filter_anisotropic")){const n=t.get("EXT_texture_filter_anisotropic");r=e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else r=0;return r},getMaxPrecision:i,precision:a,logarithmicDepthBuffer:c,maxTextures:u,maxVertexTextures:h,maxTextureSize:d,maxCubemapSize:p,maxAttributes:f,maxVertexUniforms:m,maxVaryings:g,maxFragmentUniforms:y,vertexTextures:v,floatFragmentTextures:x,floatVertexTextures:v&&x,maxSamples:s?e.getParameter(36183):0}}function Un(e){const t=this;let n=null,r=0,i=!1,s=!1;const a=new En,o=new H,l={value:null,needsUpdate:!1};function c(){l.value!==n&&(l.value=n,l.needsUpdate=r>0),t.numPlanes=r,t.numIntersection=0}function u(e,n,r,i){const s=null!==e?e.length:0;let c=null;if(0!==s){if(c=l.value,!0!==i||null===c){const t=r+4*s,i=n.matrixWorldInverse;o.getNormalMatrix(i),(null===c||c.length<t)&&(c=new Float32Array(t));for(let t=0,n=r;t!==s;++t,n+=4)a.copy(e[t]).applyMatrix4(i,o),a.normal.toArray(c,n),c[n+3]=a.constant}l.value=c,l.needsUpdate=!0}return t.numPlanes=s,t.numIntersection=0,c}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(e,t,s){const a=0!==e.length||t||0!==r||i;return i=t,n=u(e,s,0),r=e.length,a},this.beginShadows=function(){s=!0,u(null)},this.endShadows=function(){s=!1,c()},this.setState=function(t,a,o){const h=t.clippingPlanes,d=t.clipIntersection,p=t.clipShadows,f=e.get(t);if(!i||null===h||0===h.length||s&&!p)s?u(null):c();else{const e=s?0:r,t=4*e;let i=f.clippingState||null;l.value=i,i=u(h,a,t,o);for(let e=0;e!==t;++e)i[e]=n[e];f.clippingState=i,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=e}}}function $n(e){let t=new WeakMap;function n(e,t){return 303===t?e.mapping=i:304===t&&(e.mapping=s),e}function r(e){const n=e.target;n.removeEventListener("dispose",r);const i=t.get(n);void 0!==i&&(t.delete(n),i.dispose())}return{get:function(i){if(i&&i.isTexture&&!1===i.isRenderTargetTexture){const s=i.mapping;if(303===s||304===s){if(t.has(i))return n(t.get(i).texture,i.mapping);{const s=i.image;if(s&&s.height>0){const a=new _n(s.height/2);return a.fromEquirectangularTexture(e,i),t.set(i,a),i.addEventListener("dispose",r),n(a.texture,i.mapping)}return null}}}return i},dispose:function(){t=new WeakMap}}}Fn.physical={uniforms:fn([Fn.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new G(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new ie(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new G},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new ie(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new ie(1,1,1)},specularColorMap:{value:null}}]),vertexShader:Dn.meshphysical_vert,fragmentShader:Dn.meshphysical_frag};class Vn extends yn{constructor(e=-1,t=1,n=1,r=-1,i=.1,s=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=r,this.near=i,this.far=s,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=null===e.view?null:Object.assign({},e.view),this}setViewOffset(e,t,n,r,i,s){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=r,this.view.width=i,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let i=n-e,s=n+e,a=r+t,o=r-t;if(null!==this.view&&this.view.enabled){const e=(this.right-this.left)/this.view.fullWidth/this.zoom,t=(this.top-this.bottom)/this.view.fullHeight/this.zoom;i+=e*this.view.offsetX,s=i+e*this.view.width,a-=t*this.view.offsetY,o=a-t*this.view.height}this.projectionMatrix.makeOrthographic(i,s,a,o,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,null!==this.view&&(t.object.view=Object.assign({},this.view)),t}}const Wn=[.125,.215,.35,.446,.526,.582],Gn=new Vn,Hn=new ie;let jn=null;const qn=(1+Math.sqrt(5))/2,Xn=1/qn,Yn=[new me(1,1,1),new me(-1,1,1),new me(1,1,-1),new me(-1,1,-1),new me(0,qn,Xn),new me(0,qn,-Xn),new me(Xn,0,qn),new me(-Xn,0,qn),new me(qn,Xn,0),new me(-qn,Xn,0)];class Kn{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,r=100){jn=this._renderer.getRenderTarget(),this._setSize(256);const i=this._allocateTargets();return i.depthBuffer=!0,this._sceneToCubeUV(e,n,r,i),t>0&&this._blur(i,0,0,t),this._applyPMREM(i),this._cleanup(i),i}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=er(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=Qn(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(jn),e.scissorTest=!1,Jn(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===i||e.mapping===s?this._setSize(0===e.image.length?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),jn=this._renderer.getRenderTarget();const n=t||this._allocateTargets();return this._textureToCubeUV(e,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,n={magFilter:h,minFilter:h,generateMipmaps:!1,type:g,format:v,encoding:C,depthBuffer:!1},r=Zn(e,t,n);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==e){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=Zn(e,t,n);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=function(e){const t=[],n=[],r=[];let i=e;const s=e-4+1+Wn.length;for(let a=0;a<s;a++){const s=Math.pow(2,i);n.push(s);let o=1/s;a>e-4?o=Wn[a-e+4-1]:0===a&&(o=0),r.push(o);const l=1/(s-2),c=-l,u=1+l,h=[c,c,u,c,u,u,c,c,u,u,c,u],d=6,p=6,f=3,m=2,g=1,y=new Float32Array(f*p*d),v=new Float32Array(m*p*d),x=new Float32Array(g*p*d);for(let e=0;e<d;e++){const t=e%3*2/3-1,n=e>2?0:-1,r=[t,n,0,t+2/3,n,0,t+2/3,n+1,0,t,n,0,t+2/3,n+1,0,t,n+1,0];y.set(r,f*p*e),v.set(h,m*p*e);const i=[e,e,e,e,e,e];x.set(i,g*p*e)}const b=new Ht;b.setAttribute("position",new Lt(y,f)),b.setAttribute("uv",new Lt(v,m)),b.setAttribute("faceIndex",new Lt(x,g)),t.push(b),i>4&&i--}return{lodPlanes:t,sizeLods:n,sigmas:r}}(r)),this._blurMaterial=function(e,t,n){const r=new Float32Array(20),i=new me(0,1,0);return new gn({name:"SphericalGaussianBlur",defines:{n:20,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/n,CUBEUV_MAX_MIP:`${e}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:r},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}(r,e,t)}return r}_compileMaterial(e){const t=new un(this._lodPlanes[0],e);this._renderer.compile(t,Gn)}_sceneToCubeUV(e,t,n,r){const i=new vn(90,1,t,n),s=[1,-1,1,1,1,1],a=[1,1,1,-1,-1,-1],o=this._renderer,l=o.autoClear,c=o.toneMapping;o.getClearColor(Hn),o.toneMapping=0,o.autoClear=!1;const u=new kt({name:"PMREM.Background",side:1,depthWrite:!1,depthTest:!1}),h=new un(new dn,u);let d=!1;const p=e.background;p?p.isColor&&(u.color.copy(p),e.background=null,d=!0):(u.color.copy(Hn),d=!0);for(let t=0;t<6;t++){const n=t%3;0===n?(i.up.set(0,s[t],0),i.lookAt(a[t],0,0)):1===n?(i.up.set(0,0,s[t]),i.lookAt(0,a[t],0)):(i.up.set(0,s[t],0),i.lookAt(0,0,a[t]));const l=this._cubeSize;Jn(r,n*l,t>2?l:0,l,l),o.setRenderTarget(r),d&&o.render(h,i),o.render(e,i)}h.geometry.dispose(),h.material.dispose(),o.toneMapping=c,o.autoClear=l,e.background=p}_textureToCubeUV(e,t){const n=this._renderer,r=e.mapping===i||e.mapping===s;r?(null===this._cubemapMaterial&&(this._cubemapMaterial=er()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===e.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=Qn());const a=r?this._cubemapMaterial:this._equirectMaterial,o=new un(this._lodPlanes[0],a);a.uniforms.envMap.value=e;const l=this._cubeSize;Jn(t,0,0,3*l,2*l),n.setRenderTarget(t),n.render(o,Gn)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let t=1;t<this._lodPlanes.length;t++){const n=Math.sqrt(this._sigmas[t]*this._sigmas[t]-this._sigmas[t-1]*this._sigmas[t-1]),r=Yn[(t-1)%Yn.length];this._blur(e,t-1,t,n,r)}t.autoClear=n}_blur(e,t,n,r,i){const s=this._pingPongRenderTarget;this._halfBlur(e,s,t,n,r,"latitudinal",i),this._halfBlur(s,e,n,n,r,"longitudinal",i)}_halfBlur(e,t,n,r,i,s,a){const o=this._renderer,l=this._blurMaterial;"latitudinal"!==s&&"longitudinal"!==s&&console.error("blur direction must be either latitudinal or longitudinal!");const c=new un(this._lodPlanes[r],l),u=l.uniforms,h=this._sizeLods[n]-1,d=isFinite(i)?Math.PI/(2*h):2*Math.PI/39,p=i/d,f=isFinite(i)?1+Math.floor(3*p):20;f>20&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);const m=[];let g=0;for(let e=0;e<20;++e){const t=e/p,n=Math.exp(-t*t/2);m.push(n),0===e?g+=n:e<f&&(g+=2*n)}for(let e=0;e<m.length;e++)m[e]=m[e]/g;u.envMap.value=e.texture,u.samples.value=f,u.weights.value=m,u.latitudinal.value="latitudinal"===s,a&&(u.poleAxis.value=a);const{_lodMax:y}=this;u.dTheta.value=d,u.mipInt.value=y-n;const v=this._sizeLods[r];Jn(t,3*v*(r>y-4?r-y+4:0),4*(this._cubeSize-v),3*v,2*v),o.setRenderTarget(t),o.render(c,Gn)}}function Zn(e,t,n){const r=new de(e,t,n);return r.texture.mapping=a,r.texture.name="PMREM.cubeUv",r.scissorTest=!0,r}function Jn(e,t,n,r,i){e.viewport.set(t,n,r,i),e.scissor.set(t,n,r,i)}function Qn(){return new gn({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function er(){return new gn({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function tr(e){let t=new WeakMap,n=null;function r(e){const n=e.target;n.removeEventListener("dispose",r);const i=t.get(n);void 0!==i&&(t.delete(n),i.dispose())}return{get:function(a){if(a&&a.isTexture){const o=a.mapping,l=303===o||304===o,c=o===i||o===s;if(l||c){if(a.isRenderTargetTexture&&!0===a.needsPMREMUpdate){a.needsPMREMUpdate=!1;let r=t.get(a);return null===n&&(n=new Kn(e)),r=l?n.fromEquirectangular(a,r):n.fromCubemap(a,r),t.set(a,r),r.texture}if(t.has(a))return t.get(a).texture;{const i=a.image;if(l&&i&&i.height>0||c&&i&&function(e){let t=0;for(let n=0;n<6;n++)void 0!==e[n]&&t++;return 6===t}(i)){null===n&&(n=new Kn(e));const i=l?n.fromEquirectangular(a):n.fromCubemap(a);return t.set(a,i),a.addEventListener("dispose",r),i.texture}return null}}}return a},dispose:function(){t=new WeakMap,null!==n&&(n.dispose(),n=null)}}}function nr(e){const t={};function n(n){if(void 0!==t[n])return t[n];let r;switch(n){case"WEBGL_depth_texture":r=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=e.getExtension(n)}return t[n]=r,r}return{has:function(e){return null!==n(e)},init:function(e){e.isWebGL2?n("EXT_color_buffer_float"):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture")},get:function(e){const t=n(e);return null===t&&console.warn("THREE.WebGLRenderer: "+e+" extension not supported."),t}}}function rr(e,t,n,r){const i={},s=new WeakMap;function a(e){const o=e.target;null!==o.index&&t.remove(o.index);for(const e in o.attributes)t.remove(o.attributes[e]);o.removeEventListener("dispose",a),delete i[o.id];const l=s.get(o);l&&(t.remove(l),s.delete(o)),r.releaseStatesOfGeometry(o),!0===o.isInstancedBufferGeometry&&delete o._maxInstanceCount,n.memory.geometries--}function o(e){const n=[],r=e.index,i=e.attributes.position;let a=0;if(null!==r){const e=r.array;a=r.version;for(let t=0,r=e.length;t<r;t+=3){const r=e[t+0],i=e[t+1],s=e[t+2];n.push(r,i,i,s,s,r)}}else{const e=i.array;a=i.version;for(let t=0,r=e.length/3-1;t<r;t+=3){const e=t+0,r=t+1,i=t+2;n.push(e,r,r,i,i,e)}}const o=new(j(n)?Pt:Ft)(n,1);o.version=a;const l=s.get(e);l&&t.remove(l),s.set(e,o)}return{get:function(e,t){return!0===i[t.id]||(t.addEventListener("dispose",a),i[t.id]=!0,n.memory.geometries++),t},update:function(e){const n=e.attributes;for(const e in n)t.update(n[e],34962);const r=e.morphAttributes;for(const e in r){const n=r[e];for(let e=0,r=n.length;e<r;e++)t.update(n[e],34962)}},getWireframeAttribute:function(e){const t=s.get(e);if(t){const n=e.index;null!==n&&t.version<n.version&&o(e)}else o(e);return s.get(e)}}}function ir(e,t,n,r){const i=r.isWebGL2;let s,a,o;this.setMode=function(e){s=e},this.setIndex=function(e){a=e.type,o=e.bytesPerElement},this.render=function(t,r){e.drawElements(s,r,a,t*o),n.update(r,s,1)},this.renderInstances=function(r,l,c){if(0===c)return;let u,h;if(i)u=e,h="drawElementsInstanced";else if(u=t.get("ANGLE_instanced_arrays"),h="drawElementsInstancedANGLE",null===u)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");u[h](s,l,a,r*o,c),n.update(l,s,c)}}function sr(e){const t={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:t,programs:null,autoReset:!0,reset:function(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0},update:function(e,n,r){switch(t.calls++,n){case 4:t.triangles+=r*(e/3);break;case 1:t.lines+=r*(e/2);break;case 3:t.lines+=r*(e-1);break;case 2:t.lines+=r*e;break;case 0:t.points+=r*e;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",n)}}}}function ar(e,t){return e[0]-t[0]}function or(e,t){return Math.abs(t[1])-Math.abs(e[1])}function lr(e,t){let n=1;const r=t.isInterleavedBufferAttribute?t.data.array:t.array;r instanceof Int8Array?n=127:r instanceof Int16Array?n=32767:r instanceof Int32Array?n=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",r),e.divideScalar(n)}function cr(e,t,n){const r={},i=new Float32Array(8),s=new WeakMap,a=new he,o=[];for(let e=0;e<8;e++)o[e]=[e,0];return{update:function(l,c,u,h){const d=l.morphTargetInfluences;if(!0===t.isWebGL2){const p=c.morphAttributes.position||c.morphAttributes.normal||c.morphAttributes.color,f=void 0!==p?p.length:0;let g=s.get(c);if(void 0===g||g.count!==f){void 0!==g&&g.texture.dispose();const x=void 0!==c.morphAttributes.position,b=void 0!==c.morphAttributes.normal,w=void 0!==c.morphAttributes.color,_=c.morphAttributes.position||[],S=c.morphAttributes.normal||[],M=c.morphAttributes.color||[];let T=0;!0===x&&(T=1),!0===b&&(T=2),!0===w&&(T=3);let E=c.attributes.position.count*T,A=1;E>t.maxTextureSize&&(A=Math.ceil(E/t.maxTextureSize),E=t.maxTextureSize);const C=new Float32Array(E*A*4*f),I=new pe(C,E,A,f);I.type=m,I.needsUpdate=!0;const N=4*T;for(let R=0;R<f;R++){const D=_[R],L=S[R],F=M[R],P=E*A*4*R;for(let O=0;O<D.count;O++){const z=O*N;!0===x&&(a.fromBufferAttribute(D,O),!0===D.normalized&&lr(a,D),C[P+z+0]=a.x,C[P+z+1]=a.y,C[P+z+2]=a.z,C[P+z+3]=0),!0===b&&(a.fromBufferAttribute(L,O),!0===L.normalized&&lr(a,L),C[P+z+4]=a.x,C[P+z+5]=a.y,C[P+z+6]=a.z,C[P+z+7]=0),!0===w&&(a.fromBufferAttribute(F,O),!0===F.normalized&&lr(a,F),C[P+z+8]=a.x,C[P+z+9]=a.y,C[P+z+10]=a.z,C[P+z+11]=4===F.itemSize?a.w:1)}}function k(){I.dispose(),s.delete(c),c.removeEventListener("dispose",k)}g={count:f,texture:I,size:new G(E,A)},s.set(c,g),c.addEventListener("dispose",k)}let y=0;for(let B=0;B<d.length;B++)y+=d[B];const v=c.morphTargetsRelative?1:1-y;h.getUniforms().setValue(e,"morphTargetBaseInfluence",v),h.getUniforms().setValue(e,"morphTargetInfluences",d),h.getUniforms().setValue(e,"morphTargetsTexture",g.texture,n),h.getUniforms().setValue(e,"morphTargetsTextureSize",g.size)}else{const U=void 0===d?0:d.length;let $=r[c.id];if(void 0===$||$.length!==U){$=[];for(let q=0;q<U;q++)$[q]=[q,0];r[c.id]=$}for(let X=0;X<U;X++){const Y=$[X];Y[0]=X,Y[1]=d[X]}$.sort(or);for(let K=0;K<8;K++)K<U&&$[K][1]?(o[K][0]=$[K][0],o[K][1]=$[K][1]):(o[K][0]=Number.MAX_SAFE_INTEGER,o[K][1]=0);o.sort(ar);const V=c.morphAttributes.position,W=c.morphAttributes.normal;let H=0;for(let Z=0;Z<8;Z++){const J=o[Z],Q=J[0],ee=J[1];Q!==Number.MAX_SAFE_INTEGER&&ee?(V&&c.getAttribute("morphTarget"+Z)!==V[Q]&&c.setAttribute("morphTarget"+Z,V[Q]),W&&c.getAttribute("morphNormal"+Z)!==W[Q]&&c.setAttribute("morphNormal"+Z,W[Q]),i[Z]=ee,H+=ee):(V&&!0===c.hasAttribute("morphTarget"+Z)&&c.deleteAttribute("morphTarget"+Z),W&&!0===c.hasAttribute("morphNormal"+Z)&&c.deleteAttribute("morphNormal"+Z),i[Z]=0)}const j=c.morphTargetsRelative?1:1-H;h.getUniforms().setValue(e,"morphTargetBaseInfluence",j),h.getUniforms().setValue(e,"morphTargetInfluences",i)}}}}function ur(e,t,n,r){let i=new WeakMap;function s(e){const t=e.target;t.removeEventListener("dispose",s),n.remove(t.instanceMatrix),null!==t.instanceColor&&n.remove(t.instanceColor)}return{update:function(e){const a=r.render.frame,o=e.geometry,l=t.get(e,o);return i.get(l)!==a&&(t.update(l),i.set(l,a)),e.isInstancedMesh&&(!1===e.hasEventListener("dispose",s)&&e.addEventListener("dispose",s),n.update(e.instanceMatrix,34962),null!==e.instanceColor&&n.update(e.instanceColor,34962)),l},dispose:function(){i=new WeakMap}}}const hr=new ue,dr=new pe,pr=new class extends ue{constructor(e=null,t=1,n=1,r=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:n,depth:r},this.magFilter=u,this.minFilter=u,this.wrapR=l,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}},fr=new wn,mr=[],gr=[],yr=new Float32Array(16),vr=new Float32Array(9),xr=new Float32Array(4);function br(e,t,n){const r=e[0];if(r<=0||r>0)return e;const i=t*n;let s=mr[i];if(void 0===s&&(s=new Float32Array(i),mr[i]=s),0!==t){r.toArray(s,0);for(let r=1,i=0;r!==t;++r)i+=n,e[r].toArray(s,i)}return s}function wr(e,t){if(e.length!==t.length)return!1;for(let n=0,r=e.length;n<r;n++)if(e[n]!==t[n])return!1;return!0}function _r(e,t){for(let n=0,r=t.length;n<r;n++)e[n]=t[n]}function Sr(e,t){let n=gr[t];void 0===n&&(n=new Int32Array(t),gr[t]=n);for(let r=0;r!==t;++r)n[r]=e.allocateTextureUnit();return n}function Mr(e,t){const n=this.cache;n[0]!==t&&(e.uniform1f(this.addr,t),n[0]=t)}function Tr(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y||(e.uniform2f(this.addr,t.x,t.y),n[0]=t.x,n[1]=t.y);else{if(wr(n,t))return;e.uniform2fv(this.addr,t),_r(n,t)}}function Er(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z||(e.uniform3f(this.addr,t.x,t.y,t.z),n[0]=t.x,n[1]=t.y,n[2]=t.z);else if(void 0!==t.r)n[0]===t.r&&n[1]===t.g&&n[2]===t.b||(e.uniform3f(this.addr,t.r,t.g,t.b),n[0]=t.r,n[1]=t.g,n[2]=t.b);else{if(wr(n,t))return;e.uniform3fv(this.addr,t),_r(n,t)}}function Ar(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z&&n[3]===t.w||(e.uniform4f(this.addr,t.x,t.y,t.z,t.w),n[0]=t.x,n[1]=t.y,n[2]=t.z,n[3]=t.w);else{if(wr(n,t))return;e.uniform4fv(this.addr,t),_r(n,t)}}function Cr(e,t){const n=this.cache,r=t.elements;if(void 0===r){if(wr(n,t))return;e.uniformMatrix2fv(this.addr,!1,t),_r(n,t)}else{if(wr(n,r))return;xr.set(r),e.uniformMatrix2fv(this.addr,!1,xr),_r(n,r)}}function Ir(e,t){const n=this.cache,r=t.elements;if(void 0===r){if(wr(n,t))return;e.uniformMatrix3fv(this.addr,!1,t),_r(n,t)}else{if(wr(n,r))return;vr.set(r),e.uniformMatrix3fv(this.addr,!1,vr),_r(n,r)}}function Nr(e,t){const n=this.cache,r=t.elements;if(void 0===r){if(wr(n,t))return;e.uniformMatrix4fv(this.addr,!1,t),_r(n,t)}else{if(wr(n,r))return;yr.set(r),e.uniformMatrix4fv(this.addr,!1,yr),_r(n,r)}}function kr(e,t){const n=this.cache;n[0]!==t&&(e.uniform1i(this.addr,t),n[0]=t)}function Rr(e,t){const n=this.cache;wr(n,t)||(e.uniform2iv(this.addr,t),_r(n,t))}function Dr(e,t){const n=this.cache;wr(n,t)||(e.uniform3iv(this.addr,t),_r(n,t))}function Lr(e,t){const n=this.cache;wr(n,t)||(e.uniform4iv(this.addr,t),_r(n,t))}function Fr(e,t){const n=this.cache;n[0]!==t&&(e.uniform1ui(this.addr,t),n[0]=t)}function Pr(e,t){const n=this.cache;wr(n,t)||(e.uniform2uiv(this.addr,t),_r(n,t))}function Or(e,t){const n=this.cache;wr(n,t)||(e.uniform3uiv(this.addr,t),_r(n,t))}function zr(e,t){const n=this.cache;wr(n,t)||(e.uniform4uiv(this.addr,t),_r(n,t))}function Br(e,t,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(e.uniform1i(this.addr,i),r[0]=i),n.setTexture2D(t||hr,i)}function Ur(e,t,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(e.uniform1i(this.addr,i),r[0]=i),n.setTexture3D(t||pr,i)}function $r(e,t,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(e.uniform1i(this.addr,i),r[0]=i),n.setTextureCube(t||fr,i)}function Vr(e,t,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(e.uniform1i(this.addr,i),r[0]=i),n.setTexture2DArray(t||dr,i)}function Wr(e,t){e.uniform1fv(this.addr,t)}function Gr(e,t){const n=br(t,this.size,2);e.uniform2fv(this.addr,n)}function Hr(e,t){const n=br(t,this.size,3);e.uniform3fv(this.addr,n)}function jr(e,t){const n=br(t,this.size,4);e.uniform4fv(this.addr,n)}function qr(e,t){const n=br(t,this.size,4);e.uniformMatrix2fv(this.addr,!1,n)}function Xr(e,t){const n=br(t,this.size,9);e.uniformMatrix3fv(this.addr,!1,n)}function Yr(e,t){const n=br(t,this.size,16);e.uniformMatrix4fv(this.addr,!1,n)}function Kr(e,t){e.uniform1iv(this.addr,t)}function Zr(e,t){e.uniform2iv(this.addr,t)}function Jr(e,t){e.uniform3iv(this.addr,t)}function Qr(e,t){e.uniform4iv(this.addr,t)}function ei(e,t){e.uniform1uiv(this.addr,t)}function ti(e,t){e.uniform2uiv(this.addr,t)}function ni(e,t){e.uniform3uiv(this.addr,t)}function ri(e,t){e.uniform4uiv(this.addr,t)}function ii(e,t,n){const r=t.length,i=Sr(n,r);e.uniform1iv(this.addr,i);for(let e=0;e!==r;++e)n.setTexture2D(t[e]||hr,i[e])}function si(e,t,n){const r=t.length,i=Sr(n,r);e.uniform1iv(this.addr,i);for(let e=0;e!==r;++e)n.setTexture3D(t[e]||pr,i[e])}function ai(e,t,n){const r=t.length,i=Sr(n,r);e.uniform1iv(this.addr,i);for(let e=0;e!==r;++e)n.setTextureCube(t[e]||fr,i[e])}function oi(e,t,n){const r=t.length,i=Sr(n,r);e.uniform1iv(this.addr,i);for(let e=0;e!==r;++e)n.setTexture2DArray(t[e]||dr,i[e])}class li{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.setValue=function(e){switch(e){case 5126:return Mr;case 35664:return Tr;case 35665:return Er;case 35666:return Ar;case 35674:return Cr;case 35675:return Ir;case 35676:return Nr;case 5124:case 35670:return kr;case 35667:case 35671:return Rr;case 35668:case 35672:return Dr;case 35669:case 35673:return Lr;case 5125:return Fr;case 36294:return Pr;case 36295:return Or;case 36296:return zr;case 35678:case 36198:case 36298:case 36306:case 35682:return Br;case 35679:case 36299:case 36307:return Ur;case 35680:case 36300:case 36308:case 36293:return $r;case 36289:case 36303:case 36311:case 36292:return Vr}}(t.type)}}class ci{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.size=t.size,this.setValue=function(e){switch(e){case 5126:return Wr;case 35664:return Gr;case 35665:return Hr;case 35666:return jr;case 35674:return qr;case 35675:return Xr;case 35676:return Yr;case 5124:case 35670:return Kr;case 35667:case 35671:return Zr;case 35668:case 35672:return Jr;case 35669:case 35673:return Qr;case 5125:return ei;case 36294:return ti;case 36295:return ni;case 36296:return ri;case 35678:case 36198:case 36298:case 36306:case 35682:return ii;case 35679:case 36299:case 36307:return si;case 35680:case 36300:case 36308:case 36293:return ai;case 36289:case 36303:case 36311:case 36292:return oi}}(t.type)}}class ui{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,n){const r=this.seq;for(let i=0,s=r.length;i!==s;++i){const s=r[i];s.setValue(e,t[s.id],n)}}}const hi=/(\w+)(\])?(\[|\.)?/g;function di(e,t){e.seq.push(t),e.map[t.id]=t}function pi(e,t,n){const r=e.name,i=r.length;for(hi.lastIndex=0;;){const s=hi.exec(r),a=hi.lastIndex;let o=s[1];const l="]"===s[2],c=s[3];if(l&&(o|=0),void 0===c||"["===c&&a+2===i){di(n,void 0===c?new li(o,e,t):new ci(o,e,t));break}{let e=n.map[o];void 0===e&&(e=new ui(o),di(n,e)),n=e}}}class fi{constructor(e,t){this.seq=[],this.map={};const n=e.getProgramParameter(t,35718);for(let r=0;r<n;++r){const n=e.getActiveUniform(t,r);pi(n,e.getUniformLocation(t,n.name),this)}}setValue(e,t,n,r){const i=this.map[t];void 0!==i&&i.setValue(e,n,r)}setOptional(e,t,n){const r=t[n];void 0!==r&&this.setValue(e,n,r)}static upload(e,t,n,r){for(let i=0,s=t.length;i!==s;++i){const s=t[i],a=n[s.id];!1!==a.needsUpdate&&s.setValue(e,a.value,r)}}static seqWithValue(e,t){const n=[];for(let r=0,i=e.length;r!==i;++r){const i=e[r];i.id in t&&n.push(i)}return n}}function mi(e,t,n){const r=e.createShader(t);return e.shaderSource(r,n),e.compileShader(r),r}let gi=0;function yi(e,t,n){const r=e.getShaderParameter(t,35713),i=e.getShaderInfoLog(t).trim();if(r&&""===i)return"";const s=/ERROR: 0:(\d+)/.exec(i);if(s){const r=parseInt(s[1]);return n.toUpperCase()+"\n\n"+i+"\n\n"+function(e,t){const n=e.split("\n"),r=[],i=Math.max(t-6,0),s=Math.min(t+6,n.length);for(let e=i;e<s;e++){const i=e+1;r.push(`${i===t?">":" "} ${i}: ${n[e]}`)}return r.join("\n")}(e.getShaderSource(t),r)}return i}function vi(e,t){const n=function(e){switch(e){case C:return["Linear","( value )"];case I:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",e),["Linear","( value )"]}}(t);return"vec4 "+e+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function xi(e,t){let n;switch(t){case 1:n="Linear";break;case 2:n="Reinhard";break;case 3:n="OptimizedCineon";break;case 4:n="ACESFilmic";break;case 5:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),n="Linear"}return"vec3 "+e+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function bi(e){return""!==e}function wi(e,t){return e.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function _i(e,t){return e.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const Si=/^[ \t]*#include +<([\w\d./]+)>/gm;function Mi(e){return e.replace(Si,Ti)}function Ti(e,t){const n=Dn[t];if(void 0===n)throw new Error("Can not resolve #include <"+t+">");return Mi(n)}const Ei=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Ai=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Ci(e){return e.replace(Ai,Ni).replace(Ei,Ii)}function Ii(e,t,n,r){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Ni(0,t,n,r)}function Ni(e,t,n,r){let i="";for(let e=parseInt(t);e<parseInt(n);e++)i+=r.replace(/\[\s*i\s*\]/g,"[ "+e+" ]").replace(/UNROLLED_LOOP_INDEX/g,e);return i}function ki(e){let t="precision "+e.precision+" float;\nprecision "+e.precision+" int;";return"highp"===e.precision?t+="\n#define HIGH_PRECISION":"mediump"===e.precision?t+="\n#define MEDIUM_PRECISION":"lowp"===e.precision&&(t+="\n#define LOW_PRECISION"),t}function Ri(e,t,n,r){const o=e.getContext(),l=n.defines;let c=n.vertexShader,u=n.fragmentShader;const h=function(e){let t="SHADOWMAP_TYPE_BASIC";return 1===e.shadowMapType?t="SHADOWMAP_TYPE_PCF":2===e.shadowMapType?t="SHADOWMAP_TYPE_PCF_SOFT":3===e.shadowMapType&&(t="SHADOWMAP_TYPE_VSM"),t}(n),d=function(e){let t="ENVMAP_TYPE_CUBE";if(e.envMap)switch(e.envMapMode){case i:case s:t="ENVMAP_TYPE_CUBE";break;case a:t="ENVMAP_TYPE_CUBE_UV"}return t}(n),p=function(e){let t="ENVMAP_MODE_REFLECTION";return e.envMap&&e.envMapMode===s&&(t="ENVMAP_MODE_REFRACTION"),t}(n),f=function(e){let t="ENVMAP_BLENDING_NONE";if(e.envMap)switch(e.combine){case 0:t="ENVMAP_BLENDING_MULTIPLY";break;case 1:t="ENVMAP_BLENDING_MIX";break;case 2:t="ENVMAP_BLENDING_ADD"}return t}(n),m=function(e){const t=e.envMapCubeUVHeight;if(null===t)return null;const n=Math.log2(t)-2,r=1/t;return{texelWidth:1/(3*Math.max(Math.pow(2,n),112)),texelHeight:r,maxMip:n}}(n),g=n.isWebGL2?"":function(e){return[e.extensionDerivatives||e.envMapCubeUVHeight||e.bumpMap||e.tangentSpaceNormalMap||e.clearcoatNormalMap||e.flatShading||"physical"===e.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(e.extensionFragDepth||e.logarithmicDepthBuffer)&&e.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",e.extensionDrawBuffers&&e.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(e.extensionShaderTextureLOD||e.envMap||e.transmission)&&e.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(bi).join("\n")}(n),y=function(e){const t=[];for(const n in e){const r=e[n];!1!==r&&t.push("#define "+n+" "+r)}return t.join("\n")}(l),v=o.createProgram();let x,b,w=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(x=[y].filter(bi).join("\n"),x.length>0&&(x+="\n"),b=[g,y].filter(bi).join("\n"),b.length>0&&(b+="\n")):(x=[ki(n),"#define SHADER_NAME "+n.shaderName,y,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"",n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+p:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularColorMap?"#define USE_SPECULARCOLORMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.sheenColorMap?"#define USE_SHEENCOLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.morphColors&&n.isWebGL2?"#define USE_MORPHCOLORS":"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+n.morphTextureStride:"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+h:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(bi).join("\n"),b=[g,ki(n),"#define SHADER_NAME "+n.shaderName,y,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+d:"",n.envMap?"#define "+p:"",n.envMap?"#define "+f:"",m?"#define CUBEUV_TEXEL_WIDTH "+m.texelWidth:"",m?"#define CUBEUV_TEXEL_HEIGHT "+m.texelHeight:"",m?"#define CUBEUV_MAX_MIP "+m.maxMip+".0":"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescence?"#define USE_IRIDESCENCE":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularColorMap?"#define USE_SPECULARCOLORMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.sheen?"#define USE_SHEEN":"",n.sheenColorMap?"#define USE_SHEENCOLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+h:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==n.toneMapping?"#define TONE_MAPPING":"",0!==n.toneMapping?Dn.tonemapping_pars_fragment:"",0!==n.toneMapping?xi("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.opaque?"#define OPAQUE":"",Dn.encodings_pars_fragment,vi("linearToOutputTexel",n.outputEncoding),n.useDepthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(bi).join("\n")),c=Mi(c),c=wi(c,n),c=_i(c,n),u=Mi(u),u=wi(u,n),u=_i(u,n),c=Ci(c),u=Ci(u),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(w="#version 300 es\n",x=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+x,b=["#define varying in",n.glslVersion===D?"":"layout(location = 0) out highp vec4 pc_fragColor;",n.glslVersion===D?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+b);const _=w+b+u,S=mi(o,35633,w+x+c),M=mi(o,35632,_);if(o.attachShader(v,S),o.attachShader(v,M),void 0!==n.index0AttributeName?o.bindAttribLocation(v,0,n.index0AttributeName):!0===n.morphTargets&&o.bindAttribLocation(v,0,"position"),o.linkProgram(v),e.debug.checkShaderErrors){const e=o.getProgramInfoLog(v).trim(),t=o.getShaderInfoLog(S).trim(),n=o.getShaderInfoLog(M).trim();let r=!0,i=!0;if(!1===o.getProgramParameter(v,35714)){r=!1;const t=yi(o,S,"vertex"),n=yi(o,M,"fragment");console.error("THREE.WebGLProgram: Shader Error "+o.getError()+" - VALIDATE_STATUS "+o.getProgramParameter(v,35715)+"\n\nProgram Info Log: "+e+"\n"+t+"\n"+n)}else""!==e?console.warn("THREE.WebGLProgram: Program Info Log:",e):""!==t&&""!==n||(i=!1);i&&(this.diagnostics={runnable:r,programLog:e,vertexShader:{log:t,prefix:x},fragmentShader:{log:n,prefix:b}})}let T,E;return o.deleteShader(S),o.deleteShader(M),this.getUniforms=function(){return void 0===T&&(T=new fi(o,v)),T},this.getAttributes=function(){return void 0===E&&(E=function(e,t){const n={},r=e.getProgramParameter(t,35721);for(let i=0;i<r;i++){const r=e.getActiveAttrib(t,i),s=r.name;let a=1;35674===r.type&&(a=2),35675===r.type&&(a=3),35676===r.type&&(a=4),n[s]={type:r.type,location:e.getAttribLocation(t,s),locationSize:a}}return n}(o,v)),E},this.destroy=function(){r.releaseStatesOfProgram(this),o.deleteProgram(v),this.program=void 0},this.name=n.shaderName,this.id=gi++,this.cacheKey=t,this.usedTimes=1,this.program=v,this.vertexShader=S,this.fragmentShader=M,this}let Di=0;class Li{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,n=e.fragmentShader,r=this._getShaderStage(t),i=this._getShaderStage(n),s=this._getShaderCacheForMaterial(e);return!1===s.has(r)&&(s.add(r),r.usedTimes++),!1===s.has(i)&&(s.add(i),i.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const e of t)e.usedTimes--,0===e.usedTimes&&this.shaderCache.delete(e.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;return!1===t.has(e)&&t.set(e,new Set),t.get(e)}_getShaderStage(e){const t=this.shaderCache;if(!1===t.has(e)){const n=new Fi(e);t.set(e,n)}return t.get(e)}}class Fi{constructor(e){this.id=Di++,this.code=e,this.usedTimes=0}}function Pi(e,t,n,r,i,s,o){const l=new rt,c=new Li,u=[],h=i.isWebGL2,d=i.logarithmicDepthBuffer,p=i.vertexTextures;let f=i.precision;const m={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};return{getParameters:function(s,l,u,g,y){const v=g.fog,x=y.geometry,b=s.isMeshStandardMaterial?g.environment:null,w=(s.isMeshStandardMaterial?n:t).get(s.envMap||b),_=w&&w.mapping===a?w.image.height:null,S=m[s.type];null!==s.precision&&(f=i.getMaxPrecision(s.precision),f!==s.precision&&console.warn("THREE.WebGLProgram.getParameters:",s.precision,"not supported, using",f,"instead."));const M=x.morphAttributes.position||x.morphAttributes.normal||x.morphAttributes.color,T=void 0!==M?M.length:0;let E,A,N,k,R=0;if(void 0!==x.morphAttributes.position&&(R=1),void 0!==x.morphAttributes.normal&&(R=2),void 0!==x.morphAttributes.color&&(R=3),S){const e=Fn[S];E=e.vertexShader,A=e.fragmentShader}else E=s.vertexShader,A=s.fragmentShader,c.update(s),N=c.getVertexShaderID(s),k=c.getFragmentShaderID(s);const D=e.getRenderTarget(),L=s.alphaTest>0,F=s.clearcoat>0,P=s.iridescence>0;return{isWebGL2:h,shaderID:S,shaderName:s.type,vertexShader:E,fragmentShader:A,defines:s.defines,customVertexShaderID:N,customFragmentShaderID:k,isRawShaderMaterial:!0===s.isRawShaderMaterial,glslVersion:s.glslVersion,precision:f,instancing:!0===y.isInstancedMesh,instancingColor:!0===y.isInstancedMesh&&null!==y.instanceColor,supportsVertexTextures:p,outputEncoding:null===D?e.outputEncoding:!0===D.isXRRenderTarget?D.texture.encoding:C,map:!!s.map,matcap:!!s.matcap,envMap:!!w,envMapMode:w&&w.mapping,envMapCubeUVHeight:_,lightMap:!!s.lightMap,aoMap:!!s.aoMap,emissiveMap:!!s.emissiveMap,bumpMap:!!s.bumpMap,normalMap:!!s.normalMap,objectSpaceNormalMap:1===s.normalMapType,tangentSpaceNormalMap:0===s.normalMapType,decodeVideoTexture:!!s.map&&!0===s.map.isVideoTexture&&s.map.encoding===I,clearcoat:F,clearcoatMap:F&&!!s.clearcoatMap,clearcoatRoughnessMap:F&&!!s.clearcoatRoughnessMap,clearcoatNormalMap:F&&!!s.clearcoatNormalMap,iridescence:P,iridescenceMap:P&&!!s.iridescenceMap,iridescenceThicknessMap:P&&!!s.iridescenceThicknessMap,displacementMap:!!s.displacementMap,roughnessMap:!!s.roughnessMap,metalnessMap:!!s.metalnessMap,specularMap:!!s.specularMap,specularIntensityMap:!!s.specularIntensityMap,specularColorMap:!!s.specularColorMap,opaque:!1===s.transparent&&1===s.blending,alphaMap:!!s.alphaMap,alphaTest:L,gradientMap:!!s.gradientMap,sheen:s.sheen>0,sheenColorMap:!!s.sheenColorMap,sheenRoughnessMap:!!s.sheenRoughnessMap,transmission:s.transmission>0,transmissionMap:!!s.transmissionMap,thicknessMap:!!s.thicknessMap,combine:s.combine,vertexTangents:!!s.normalMap&&!!x.attributes.tangent,vertexColors:s.vertexColors,vertexAlphas:!0===s.vertexColors&&!!x.attributes.color&&4===x.attributes.color.itemSize,vertexUvs:!!(s.map||s.bumpMap||s.normalMap||s.specularMap||s.alphaMap||s.emissiveMap||s.roughnessMap||s.metalnessMap||s.clearcoatMap||s.clearcoatRoughnessMap||s.clearcoatNormalMap||s.iridescenceMap||s.iridescenceThicknessMap||s.displacementMap||s.transmissionMap||s.thicknessMap||s.specularIntensityMap||s.specularColorMap||s.sheenColorMap||s.sheenRoughnessMap),uvsVertexOnly:!(s.map||s.bumpMap||s.normalMap||s.specularMap||s.alphaMap||s.emissiveMap||s.roughnessMap||s.metalnessMap||s.clearcoatNormalMap||s.iridescenceMap||s.iridescenceThicknessMap||s.transmission>0||s.transmissionMap||s.thicknessMap||s.specularIntensityMap||s.specularColorMap||s.sheen>0||s.sheenColorMap||s.sheenRoughnessMap||!s.displacementMap),fog:!!v,useFog:!0===s.fog,fogExp2:v&&v.isFogExp2,flatShading:!!s.flatShading,sizeAttenuation:s.sizeAttenuation,logarithmicDepthBuffer:d,skinning:!0===y.isSkinnedMesh,morphTargets:void 0!==x.morphAttributes.position,morphNormals:void 0!==x.morphAttributes.normal,morphColors:void 0!==x.morphAttributes.color,morphTargetsCount:T,morphTextureStride:R,numDirLights:l.directional.length,numPointLights:l.point.length,numSpotLights:l.spot.length,numRectAreaLights:l.rectArea.length,numHemiLights:l.hemi.length,numDirLightShadows:l.directionalShadowMap.length,numPointLightShadows:l.pointShadowMap.length,numSpotLightShadows:l.spotShadowMap.length,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:s.dithering,shadowMapEnabled:e.shadowMap.enabled&&u.length>0,shadowMapType:e.shadowMap.type,toneMapping:s.toneMapped?e.toneMapping:0,physicallyCorrectLights:e.physicallyCorrectLights,premultipliedAlpha:s.premultipliedAlpha,doubleSided:2===s.side,flipSided:1===s.side,useDepthPacking:!!s.depthPacking,depthPacking:s.depthPacking||0,index0AttributeName:s.index0AttributeName,extensionDerivatives:s.extensions&&s.extensions.derivatives,extensionFragDepth:s.extensions&&s.extensions.fragDepth,extensionDrawBuffers:s.extensions&&s.extensions.drawBuffers,extensionShaderTextureLOD:s.extensions&&s.extensions.shaderTextureLOD,rendererExtensionFragDepth:h||r.has("EXT_frag_depth"),rendererExtensionDrawBuffers:h||r.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:h||r.has("EXT_shader_texture_lod"),customProgramCacheKey:s.customProgramCacheKey()}},getProgramCacheKey:function(t){const n=[];if(t.shaderID?n.push(t.shaderID):(n.push(t.customVertexShaderID),n.push(t.customFragmentShaderID)),void 0!==t.defines)for(const e in t.defines)n.push(e),n.push(t.defines[e]);return!1===t.isRawShaderMaterial&&(function(e,t){e.push(t.precision),e.push(t.outputEncoding),e.push(t.envMapMode),e.push(t.envMapCubeUVHeight),e.push(t.combine),e.push(t.vertexUvs),e.push(t.fogExp2),e.push(t.sizeAttenuation),e.push(t.morphTargetsCount),e.push(t.morphAttributeCount),e.push(t.numDirLights),e.push(t.numPointLights),e.push(t.numSpotLights),e.push(t.numHemiLights),e.push(t.numRectAreaLights),e.push(t.numDirLightShadows),e.push(t.numPointLightShadows),e.push(t.numSpotLightShadows),e.push(t.shadowMapType),e.push(t.toneMapping),e.push(t.numClippingPlanes),e.push(t.numClipIntersection),e.push(t.depthPacking)}(n,t),function(e,t){l.disableAll(),t.isWebGL2&&l.enable(0),t.supportsVertexTextures&&l.enable(1),t.instancing&&l.enable(2),t.instancingColor&&l.enable(3),t.map&&l.enable(4),t.matcap&&l.enable(5),t.envMap&&l.enable(6),t.lightMap&&l.enable(7),t.aoMap&&l.enable(8),t.emissiveMap&&l.enable(9),t.bumpMap&&l.enable(10),t.normalMap&&l.enable(11),t.objectSpaceNormalMap&&l.enable(12),t.tangentSpaceNormalMap&&l.enable(13),t.clearcoat&&l.enable(14),t.clearcoatMap&&l.enable(15),t.clearcoatRoughnessMap&&l.enable(16),t.clearcoatNormalMap&&l.enable(17),t.iridescence&&l.enable(18),t.iridescenceMap&&l.enable(19),t.iridescenceThicknessMap&&l.enable(20),t.displacementMap&&l.enable(21),t.specularMap&&l.enable(22),t.roughnessMap&&l.enable(23),t.metalnessMap&&l.enable(24),t.gradientMap&&l.enable(25),t.alphaMap&&l.enable(26),t.alphaTest&&l.enable(27),t.vertexColors&&l.enable(28),t.vertexAlphas&&l.enable(29),t.vertexUvs&&l.enable(30),t.vertexTangents&&l.enable(31),t.uvsVertexOnly&&l.enable(32),t.fog&&l.enable(33),e.push(l.mask),l.disableAll(),t.useFog&&l.enable(0),t.flatShading&&l.enable(1),t.logarithmicDepthBuffer&&l.enable(2),t.skinning&&l.enable(3),t.morphTargets&&l.enable(4),t.morphNormals&&l.enable(5),t.morphColors&&l.enable(6),t.premultipliedAlpha&&l.enable(7),t.shadowMapEnabled&&l.enable(8),t.physicallyCorrectLights&&l.enable(9),t.doubleSided&&l.enable(10),t.flipSided&&l.enable(11),t.useDepthPacking&&l.enable(12),t.dithering&&l.enable(13),t.specularIntensityMap&&l.enable(14),t.specularColorMap&&l.enable(15),t.transmission&&l.enable(16),t.transmissionMap&&l.enable(17),t.thicknessMap&&l.enable(18),t.sheen&&l.enable(19),t.sheenColorMap&&l.enable(20),t.sheenRoughnessMap&&l.enable(21),t.decodeVideoTexture&&l.enable(22),t.opaque&&l.enable(23),e.push(l.mask)}(n,t),n.push(e.outputEncoding)),n.push(t.customProgramCacheKey),n.join()},getUniforms:function(e){const t=m[e.type];let n;if(t){const e=Fn[t];n=mn.clone(e.uniforms)}else n=e.uniforms;return n},acquireProgram:function(t,n){let r;for(let e=0,t=u.length;e<t;e++){const t=u[e];if(t.cacheKey===n){r=t,++r.usedTimes;break}}return void 0===r&&(r=new Ri(e,n,t,s),u.push(r)),r},releaseProgram:function(e){if(0==--e.usedTimes){const t=u.indexOf(e);u[t]=u[u.length-1],u.pop(),e.destroy()}},releaseShaderCache:function(e){c.remove(e)},programs:u,dispose:function(){c.dispose()}}}function Oi(){let e=new WeakMap;return{get:function(t){let n=e.get(t);return void 0===n&&(n={},e.set(t,n)),n},remove:function(t){e.delete(t)},update:function(t,n,r){e.get(t)[n]=r},dispose:function(){e=new WeakMap}}}function zi(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id}function Bi(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id}function Ui(){const e=[];let t=0;const n=[],r=[],i=[];function s(n,r,i,s,a,o){let l=e[t];return void 0===l?(l={id:n.id,object:n,geometry:r,material:i,groupOrder:s,renderOrder:n.renderOrder,z:a,group:o},e[t]=l):(l.id=n.id,l.object=n,l.geometry=r,l.material=i,l.groupOrder=s,l.renderOrder=n.renderOrder,l.z=a,l.group=o),t++,l}return{opaque:n,transmissive:r,transparent:i,init:function(){t=0,n.length=0,r.length=0,i.length=0},push:function(e,t,a,o,l,c){const u=s(e,t,a,o,l,c);a.transmission>0?r.push(u):!0===a.transparent?i.push(u):n.push(u)},unshift:function(e,t,a,o,l,c){const u=s(e,t,a,o,l,c);a.transmission>0?r.unshift(u):!0===a.transparent?i.unshift(u):n.unshift(u)},finish:function(){for(let n=t,r=e.length;n<r;n++){const t=e[n];if(null===t.id)break;t.id=null,t.object=null,t.geometry=null,t.material=null,t.group=null}},sort:function(e,t){n.length>1&&n.sort(e||zi),r.length>1&&r.sort(t||Bi),i.length>1&&i.sort(t||Bi)}}}function $i(){let e=new WeakMap;return{get:function(t,n){let r;return!1===e.has(t)?(r=new Ui,e.set(t,[r])):n>=e.get(t).length?(r=new Ui,e.get(t).push(r)):r=e.get(t)[n],r},dispose:function(){e=new WeakMap}}}function Vi(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":n={direction:new me,color:new ie};break;case"SpotLight":n={position:new me,direction:new me,color:new ie,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new me,color:new ie,distance:0,decay:0};break;case"HemisphereLight":n={direction:new me,skyColor:new ie,groundColor:new ie};break;case"RectAreaLight":n={color:new ie,position:new me,halfWidth:new me,halfHeight:new me}}return e[t.id]=n,n}}}let Wi=0;function Gi(e,t){return(t.castShadow?1:0)-(e.castShadow?1:0)}function Hi(e,t){const n=new Vi,r=function(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new G};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new G,shadowCameraNear:1,shadowCameraFar:1e3}}return e[t.id]=n,n}}}(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let e=0;e<9;e++)i.probe.push(new me);const s=new me,a=new je,o=new je;return{setup:function(s,a){let o=0,l=0,c=0;for(let e=0;e<9;e++)i.probe[e].set(0,0,0);let u=0,h=0,d=0,p=0,f=0,m=0,g=0,y=0;s.sort(Gi);const v=!0!==a?Math.PI:1;for(let e=0,t=s.length;e<t;e++){const t=s[e],a=t.color,x=t.intensity,b=t.distance,w=t.shadow&&t.shadow.map?t.shadow.map.texture:null;if(t.isAmbientLight)o+=a.r*x*v,l+=a.g*x*v,c+=a.b*x*v;else if(t.isLightProbe)for(let e=0;e<9;e++)i.probe[e].addScaledVector(t.sh.coefficients[e],x);else if(t.isDirectionalLight){const e=n.get(t);if(e.color.copy(t.color).multiplyScalar(t.intensity*v),t.castShadow){const e=t.shadow,n=r.get(t);n.shadowBias=e.bias,n.shadowNormalBias=e.normalBias,n.shadowRadius=e.radius,n.shadowMapSize=e.mapSize,i.directionalShadow[u]=n,i.directionalShadowMap[u]=w,i.directionalShadowMatrix[u]=t.shadow.matrix,m++}i.directional[u]=e,u++}else if(t.isSpotLight){const e=n.get(t);if(e.position.setFromMatrixPosition(t.matrixWorld),e.color.copy(a).multiplyScalar(x*v),e.distance=b,e.coneCos=Math.cos(t.angle),e.penumbraCos=Math.cos(t.angle*(1-t.penumbra)),e.decay=t.decay,t.castShadow){const e=t.shadow,n=r.get(t);n.shadowBias=e.bias,n.shadowNormalBias=e.normalBias,n.shadowRadius=e.radius,n.shadowMapSize=e.mapSize,i.spotShadow[d]=n,i.spotShadowMap[d]=w,i.spotShadowMatrix[d]=t.shadow.matrix,y++}i.spot[d]=e,d++}else if(t.isRectAreaLight){const e=n.get(t);e.color.copy(a).multiplyScalar(x),e.halfWidth.set(.5*t.width,0,0),e.halfHeight.set(0,.5*t.height,0),i.rectArea[p]=e,p++}else if(t.isPointLight){const e=n.get(t);if(e.color.copy(t.color).multiplyScalar(t.intensity*v),e.distance=t.distance,e.decay=t.decay,t.castShadow){const e=t.shadow,n=r.get(t);n.shadowBias=e.bias,n.shadowNormalBias=e.normalBias,n.shadowRadius=e.radius,n.shadowMapSize=e.mapSize,n.shadowCameraNear=e.camera.near,n.shadowCameraFar=e.camera.far,i.pointShadow[h]=n,i.pointShadowMap[h]=w,i.pointShadowMatrix[h]=t.shadow.matrix,g++}i.point[h]=e,h++}else if(t.isHemisphereLight){const e=n.get(t);e.skyColor.copy(t.color).multiplyScalar(x*v),e.groundColor.copy(t.groundColor).multiplyScalar(x*v),i.hemi[f]=e,f++}}p>0&&(t.isWebGL2||!0===e.has("OES_texture_float_linear")?(i.rectAreaLTC1=Ln.LTC_FLOAT_1,i.rectAreaLTC2=Ln.LTC_FLOAT_2):!0===e.has("OES_texture_half_float_linear")?(i.rectAreaLTC1=Ln.LTC_HALF_1,i.rectAreaLTC2=Ln.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=o,i.ambient[1]=l,i.ambient[2]=c;const x=i.hash;x.directionalLength===u&&x.pointLength===h&&x.spotLength===d&&x.rectAreaLength===p&&x.hemiLength===f&&x.numDirectionalShadows===m&&x.numPointShadows===g&&x.numSpotShadows===y||(i.directional.length=u,i.spot.length=d,i.rectArea.length=p,i.point.length=h,i.hemi.length=f,i.directionalShadow.length=m,i.directionalShadowMap.length=m,i.pointShadow.length=g,i.pointShadowMap.length=g,i.spotShadow.length=y,i.spotShadowMap.length=y,i.directionalShadowMatrix.length=m,i.pointShadowMatrix.length=g,i.spotShadowMatrix.length=y,x.directionalLength=u,x.pointLength=h,x.spotLength=d,x.rectAreaLength=p,x.hemiLength=f,x.numDirectionalShadows=m,x.numPointShadows=g,x.numSpotShadows=y,i.version=Wi++)},setupView:function(e,t){let n=0,r=0,l=0,c=0,u=0;const h=t.matrixWorldInverse;for(let t=0,d=e.length;t<d;t++){const d=e[t];if(d.isDirectionalLight){const e=i.directional[n];e.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),e.direction.sub(s),e.direction.transformDirection(h),n++}else if(d.isSpotLight){const e=i.spot[l];e.position.setFromMatrixPosition(d.matrixWorld),e.position.applyMatrix4(h),e.direction.setFromMatrixPosition(d.matrixWorld),s.setFromMatrixPosition(d.target.matrixWorld),e.direction.sub(s),e.direction.transformDirection(h),l++}else if(d.isRectAreaLight){const e=i.rectArea[c];e.position.setFromMatrixPosition(d.matrixWorld),e.position.applyMatrix4(h),o.identity(),a.copy(d.matrixWorld),a.premultiply(h),o.extractRotation(a),e.halfWidth.set(.5*d.width,0,0),e.halfHeight.set(0,.5*d.height,0),e.halfWidth.applyMatrix4(o),e.halfHeight.applyMatrix4(o),c++}else if(d.isPointLight){const e=i.point[r];e.position.setFromMatrixPosition(d.matrixWorld),e.position.applyMatrix4(h),r++}else if(d.isHemisphereLight){const e=i.hemi[u];e.direction.setFromMatrixPosition(d.matrixWorld),e.direction.transformDirection(h),u++}}},state:i}}function ji(e,t){const n=new Hi(e,t),r=[],i=[];return{init:function(){r.length=0,i.length=0},state:{lightsArray:r,shadowsArray:i,lights:n},setupLights:function(e){n.setup(r,e)},setupLightsView:function(e){n.setupView(r,e)},pushLight:function(e){r.push(e)},pushShadow:function(e){i.push(e)}}}function qi(e,t){let n=new WeakMap;return{get:function(r,i=0){let s;return!1===n.has(r)?(s=new ji(e,t),n.set(r,[s])):i>=n.get(r).length?(s=new ji(e,t),n.get(r).push(s)):s=n.get(r)[i],s},dispose:function(){n=new WeakMap}}}class Xi extends Nt{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class Yi extends Nt{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.referencePosition=new me,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}function Ki(e,t,n){let r=new In;const i=new G,s=new G,a=new he,o=new Xi({depthPacking:3201}),l=new Yi,c={},h=n.maxTextureSize,d={0:1,1:0,2:2},p=new gn({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new G},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),f=p.clone();f.defines.HORIZONTAL_PASS=1;const m=new Ht;m.setAttribute("position",new Lt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const g=new un(m,p),y=this;function x(n,r){const i=t.update(g);p.defines.VSM_SAMPLES!==n.blurSamples&&(p.defines.VSM_SAMPLES=n.blurSamples,f.defines.VSM_SAMPLES=n.blurSamples,p.needsUpdate=!0,f.needsUpdate=!0),p.uniforms.shadow_pass.value=n.map.texture,p.uniforms.resolution.value=n.mapSize,p.uniforms.radius.value=n.radius,e.setRenderTarget(n.mapPass),e.clear(),e.renderBufferDirect(r,null,i,p,g,null),f.uniforms.shadow_pass.value=n.mapPass.texture,f.uniforms.resolution.value=n.mapSize,f.uniforms.radius.value=n.radius,e.setRenderTarget(n.map),e.clear(),e.renderBufferDirect(r,null,i,f,g,null)}function b(t,n,r,i,s,a){let u=null;const h=!0===r.isPointLight?t.customDistanceMaterial:t.customDepthMaterial;if(u=void 0!==h?h:!0===r.isPointLight?l:o,e.localClippingEnabled&&!0===n.clipShadows&&0!==n.clippingPlanes.length||n.displacementMap&&0!==n.displacementScale||n.alphaMap&&n.alphaTest>0){const e=u.uuid,t=n.uuid;let r=c[e];void 0===r&&(r={},c[e]=r);let i=r[t];void 0===i&&(i=u.clone(),r[t]=i),u=i}return u.visible=n.visible,u.wireframe=n.wireframe,u.side=3===a?null!==n.shadowSide?n.shadowSide:n.side:null!==n.shadowSide?n.shadowSide:d[n.side],u.alphaMap=n.alphaMap,u.alphaTest=n.alphaTest,u.clipShadows=n.clipShadows,u.clippingPlanes=n.clippingPlanes,u.clipIntersection=n.clipIntersection,u.displacementMap=n.displacementMap,u.displacementScale=n.displacementScale,u.displacementBias=n.displacementBias,u.wireframeLinewidth=n.wireframeLinewidth,u.linewidth=n.linewidth,!0===r.isPointLight&&!0===u.isMeshDistanceMaterial&&(u.referencePosition.setFromMatrixPosition(r.matrixWorld),u.nearDistance=i,u.farDistance=s),u}function w(n,i,s,a,o){if(!1===n.visible)return;if(n.layers.test(i.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&3===o)&&(!n.frustumCulled||r.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,n.matrixWorld);const r=t.update(n),i=n.material;if(Array.isArray(i)){const t=r.groups;for(let l=0,c=t.length;l<c;l++){const c=t[l],u=i[c.materialIndex];if(u&&u.visible){const t=b(n,u,a,s.near,s.far,o);e.renderBufferDirect(s,null,r,t,n,c)}}}else if(i.visible){const t=b(n,i,a,s.near,s.far,o);e.renderBufferDirect(s,null,r,t,n,null)}}const l=n.children;for(let e=0,t=l.length;e<t;e++)w(l[e],i,s,a,o)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(t,n,o){if(!1===y.enabled)return;if(!1===y.autoUpdate&&!1===y.needsUpdate)return;if(0===t.length)return;const l=e.getRenderTarget(),c=e.getActiveCubeFace(),d=e.getActiveMipmapLevel(),p=e.state;p.setBlending(0),p.buffers.color.setClear(1,1,1,1),p.buffers.depth.setTest(!0),p.setScissorTest(!1);for(let l=0,c=t.length;l<c;l++){const c=t[l],d=c.shadow;if(void 0===d){console.warn("THREE.WebGLShadowMap:",c,"has no shadow.");continue}if(!1===d.autoUpdate&&!1===d.needsUpdate)continue;i.copy(d.mapSize);const f=d.getFrameExtents();if(i.multiply(f),s.copy(d.mapSize),(i.x>h||i.y>h)&&(i.x>h&&(s.x=Math.floor(h/f.x),i.x=s.x*f.x,d.mapSize.x=s.x),i.y>h&&(s.y=Math.floor(h/f.y),i.y=s.y*f.y,d.mapSize.y=s.y)),null!==d.map||d.isPointLightShadow||3!==this.type||(d.map=new de(i.x,i.y),d.map.texture.name=c.name+".shadowMap",d.mapPass=new de(i.x,i.y),d.camera.updateProjectionMatrix()),null===d.map){const e={minFilter:u,magFilter:u,format:v};d.map=new de(i.x,i.y,e),d.map.texture.name=c.name+".shadowMap",d.camera.updateProjectionMatrix()}e.setRenderTarget(d.map),e.clear();const m=d.getViewportCount();for(let e=0;e<m;e++){const t=d.getViewport(e);a.set(s.x*t.x,s.y*t.y,s.x*t.z,s.y*t.w),p.viewport(a),d.updateMatrices(c,e),r=d.getFrustum(),w(n,o,d.camera,c,this.type)}d.isPointLightShadow||3!==this.type||x(d,o),d.needsUpdate=!1}y.needsUpdate=!1,e.setRenderTarget(l,c,d)}}function Zi(e,t,n){const i=n.isWebGL2,s=new function(){let t=!1;const n=new he;let r=null;const i=new he(0,0,0,0);return{setMask:function(n){r===n||t||(e.colorMask(n,n,n,n),r=n)},setLocked:function(e){t=e},setClear:function(t,r,s,a,o){!0===o&&(t*=a,r*=a,s*=a),n.set(t,r,s,a),!1===i.equals(n)&&(e.clearColor(t,r,s,a),i.copy(n))},reset:function(){t=!1,r=null,i.set(-1,0,0,0)}}},a=new function(){let t=!1,n=null,r=null,i=null;return{setTest:function(e){e?B(2929):U(2929)},setMask:function(r){n===r||t||(e.depthMask(r),n=r)},setFunc:function(t){if(r!==t){if(t)switch(t){case 0:e.depthFunc(512);break;case 1:e.depthFunc(519);break;case 2:e.depthFunc(513);break;case 3:default:e.depthFunc(515);break;case 4:e.depthFunc(514);break;case 5:e.depthFunc(518);break;case 6:e.depthFunc(516);break;case 7:e.depthFunc(517)}else e.depthFunc(515);r=t}},setLocked:function(e){t=e},setClear:function(t){i!==t&&(e.clearDepth(t),i=t)},reset:function(){t=!1,n=null,r=null,i=null}}},o=new function(){let t=!1,n=null,r=null,i=null,s=null,a=null,o=null,l=null,c=null;return{setTest:function(e){t||(e?B(2960):U(2960))},setMask:function(r){n===r||t||(e.stencilMask(r),n=r)},setFunc:function(t,n,a){r===t&&i===n&&s===a||(e.stencilFunc(t,n,a),r=t,i=n,s=a)},setOp:function(t,n,r){a===t&&o===n&&l===r||(e.stencilOp(t,n,r),a=t,o=n,l=r)},setLocked:function(e){t=e},setClear:function(t){c!==t&&(e.clearStencil(t),c=t)},reset:function(){t=!1,n=null,r=null,i=null,s=null,a=null,o=null,l=null,c=null}}};let l={},c={},u=new WeakMap,h=[],d=null,p=!1,f=null,m=null,g=null,y=null,v=null,x=null,b=null,w=!1,_=null,S=null,M=null,T=null,E=null;const A=e.getParameter(35661);let C=!1,I=0;const N=e.getParameter(7938);-1!==N.indexOf("WebGL")?(I=parseFloat(/^WebGL (\d)/.exec(N)[1]),C=I>=1):-1!==N.indexOf("OpenGL ES")&&(I=parseFloat(/^OpenGL ES (\d)/.exec(N)[1]),C=I>=2);let k=null,R={};const D=e.getParameter(3088),L=e.getParameter(2978),F=(new he).fromArray(D),P=(new he).fromArray(L);function O(t,n,r){const i=new Uint8Array(4),s=e.createTexture();e.bindTexture(t,s),e.texParameteri(t,10241,9728),e.texParameteri(t,10240,9728);for(let t=0;t<r;t++)e.texImage2D(n+t,0,6408,1,1,0,6408,5121,i);return s}const z={};function B(t){!0!==l[t]&&(e.enable(t),l[t]=!0)}function U(t){!1!==l[t]&&(e.disable(t),l[t]=!1)}z[3553]=O(3553,3553,1),z[34067]=O(34067,34069,6),s.setClear(0,0,0,1),a.setClear(1),o.setClear(0),B(2929),a.setFunc(3),G(!1),H(1),B(2884),W(0);const $={[r]:32774,101:32778,102:32779};if(i)$[103]=32775,$[104]=32776;else{const e=t.get("EXT_blend_minmax");null!==e&&($[103]=e.MIN_EXT,$[104]=e.MAX_EXT)}const V={200:0,201:1,202:768,204:770,210:776,208:774,206:772,203:769,205:771,209:775,207:773};function W(t,n,i,s,a,o,l,c){if(0!==t){if(!1===p&&(B(3042),p=!0),5===t)a=a||n,o=o||i,l=l||s,n===m&&a===v||(e.blendEquationSeparate($[n],$[a]),m=n,v=a),i===g&&s===y&&o===x&&l===b||(e.blendFuncSeparate(V[i],V[s],V[o],V[l]),g=i,y=s,x=o,b=l),f=t,w=null;else if(t!==f||c!==w){if(m===r&&v===r||(e.blendEquation(32774),m=r,v=r),c)switch(t){case 1:e.blendFuncSeparate(1,771,1,771);break;case 2:e.blendFunc(1,1);break;case 3:e.blendFuncSeparate(0,769,0,1);break;case 4:e.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}else switch(t){case 1:e.blendFuncSeparate(770,771,1,771);break;case 2:e.blendFunc(770,1);break;case 3:e.blendFuncSeparate(0,769,0,1);break;case 4:e.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}g=null,y=null,x=null,b=null,f=t,w=c}}else!0===p&&(U(3042),p=!1)}function G(t){_!==t&&(t?e.frontFace(2304):e.frontFace(2305),_=t)}function H(t){0!==t?(B(2884),t!==S&&(1===t?e.cullFace(1029):2===t?e.cullFace(1028):e.cullFace(1032))):U(2884),S=t}function j(t,n,r){t?(B(32823),T===n&&E===r||(e.polygonOffset(n,r),T=n,E=r)):U(32823)}function q(t){void 0===t&&(t=33984+A-1),k!==t&&(e.activeTexture(t),k=t)}return{buffers:{color:s,depth:a,stencil:o},enable:B,disable:U,bindFramebuffer:function(t,n){return c[t]!==n&&(e.bindFramebuffer(t,n),c[t]=n,i&&(36009===t&&(c[36160]=n),36160===t&&(c[36009]=n)),!0)},drawBuffers:function(r,i){let s=h,a=!1;if(r)if(s=u.get(i),void 0===s&&(s=[],u.set(i,s)),r.isWebGLMultipleRenderTargets){const e=r.texture;if(s.length!==e.length||36064!==s[0]){for(let t=0,n=e.length;t<n;t++)s[t]=36064+t;s.length=e.length,a=!0}}else 36064!==s[0]&&(s[0]=36064,a=!0);else 1029!==s[0]&&(s[0]=1029,a=!0);a&&(n.isWebGL2?e.drawBuffers(s):t.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))},useProgram:function(t){return d!==t&&(e.useProgram(t),d=t,!0)},setBlending:W,setMaterial:function(e,t){2===e.side?U(2884):B(2884);let n=1===e.side;t&&(n=!n),G(n),1===e.blending&&!1===e.transparent?W(0):W(e.blending,e.blendEquation,e.blendSrc,e.blendDst,e.blendEquationAlpha,e.blendSrcAlpha,e.blendDstAlpha,e.premultipliedAlpha),a.setFunc(e.depthFunc),a.setTest(e.depthTest),a.setMask(e.depthWrite),s.setMask(e.colorWrite);const r=e.stencilWrite;o.setTest(r),r&&(o.setMask(e.stencilWriteMask),o.setFunc(e.stencilFunc,e.stencilRef,e.stencilFuncMask),o.setOp(e.stencilFail,e.stencilZFail,e.stencilZPass)),j(e.polygonOffset,e.polygonOffsetFactor,e.polygonOffsetUnits),!0===e.alphaToCoverage?B(32926):U(32926)},setFlipSided:G,setCullFace:H,setLineWidth:function(t){t!==M&&(C&&e.lineWidth(t),M=t)},setPolygonOffset:j,setScissorTest:function(e){e?B(3089):U(3089)},activeTexture:q,bindTexture:function(t,n){null===k&&q();let r=R[k];void 0===r&&(r={type:void 0,texture:void 0},R[k]=r),r.type===t&&r.texture===n||(e.bindTexture(t,n||z[t]),r.type=t,r.texture=n)},unbindTexture:function(){const t=R[k];void 0!==t&&void 0!==t.type&&(e.bindTexture(t.type,null),t.type=void 0,t.texture=void 0)},compressedTexImage2D:function(){try{e.compressedTexImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage2D:function(){try{e.texImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage3D:function(){try{e.texImage3D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texStorage2D:function(){try{e.texStorage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texStorage3D:function(){try{e.texStorage3D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texSubImage2D:function(){try{e.texSubImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texSubImage3D:function(){try{e.texSubImage3D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},compressedTexSubImage2D:function(){try{e.compressedTexSubImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},scissor:function(t){!1===F.equals(t)&&(e.scissor(t.x,t.y,t.z,t.w),F.copy(t))},viewport:function(t){!1===P.equals(t)&&(e.viewport(t.x,t.y,t.z,t.w),P.copy(t))},reset:function(){e.disable(3042),e.disable(2884),e.disable(2929),e.disable(32823),e.disable(3089),e.disable(2960),e.disable(32926),e.blendEquation(32774),e.blendFunc(1,0),e.blendFuncSeparate(1,0,1,0),e.colorMask(!0,!0,!0,!0),e.clearColor(0,0,0,0),e.depthMask(!0),e.depthFunc(513),e.clearDepth(1),e.stencilMask(4294967295),e.stencilFunc(519,0,4294967295),e.stencilOp(7680,7680,7680),e.clearStencil(0),e.cullFace(1029),e.frontFace(2305),e.polygonOffset(0,0),e.activeTexture(33984),e.bindFramebuffer(36160,null),!0===i&&(e.bindFramebuffer(36009,null),e.bindFramebuffer(36008,null)),e.useProgram(null),e.lineWidth(1),e.scissor(0,0,e.canvas.width,e.canvas.height),e.viewport(0,0,e.canvas.width,e.canvas.height),l={},k=null,R={},c={},u=new WeakMap,h=[],d=null,p=!1,f=null,m=null,g=null,y=null,v=null,x=null,b=null,w=!1,_=null,S=null,M=null,T=null,E=null,F.set(0,0,e.canvas.width,e.canvas.height),P.set(0,0,e.canvas.width,e.canvas.height),s.reset(),a.reset(),o.reset()}}}function Ji(e,t,n,r,i,s,a){const w=i.isWebGL2,_=i.maxTextures,S=i.maxCubemapSize,M=i.maxTextureSize,T=i.maxSamples,E=t.has("WEBGL_multisampled_render_to_texture")?t.get("WEBGL_multisampled_render_to_texture"):null,A=/OculusBrowser/g.test(navigator.userAgent),N=new WeakMap;let k;const R=new WeakMap;let D=!1;try{D="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(e){}function F(e,t){return D?new OffscreenCanvas(e,t):q("canvas")}function P(e,t,n,r){let i=1;if((e.width>r||e.height>r)&&(i=r/Math.max(e.width,e.height)),i<1||!0===t){if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap){const r=t?W:Math.floor,s=r(i*e.width),a=r(i*e.height);void 0===k&&(k=F(s,a));const o=n?F(s,a):k;return o.width=s,o.height=a,o.getContext("2d").drawImage(e,0,0,s,a),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+e.width+"x"+e.height+") to ("+s+"x"+a+")."),o}return"data"in e&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+e.width+"x"+e.height+")."),e}return e}function O(e){return V(e.width)&&V(e.height)}function z(e,t){return e.generateMipmaps&&t&&e.minFilter!==u&&e.minFilter!==h}function B(t){e.generateMipmap(t)}function U(n,r,i,s,a=!1){if(!1===w)return r;if(null!==n){if(void 0!==e[n])return e[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let o=r;return 6403===r&&(5126===i&&(o=33326),5131===i&&(o=33325),5121===i&&(o=33321)),33319===r&&(5126===i&&(o=33328),5131===i&&(o=33327),5121===i&&(o=33323)),6408===r&&(5126===i&&(o=34836),5131===i&&(o=34842),5121===i&&(o=s===I&&!1===a?35907:32856),32819===i&&(o=32854),32820===i&&(o=32855)),33325!==o&&33326!==o&&33327!==o&&33328!==o&&34842!==o&&34836!==o||t.get("EXT_color_buffer_float"),o}function $(e,t,n){return!0===z(e,n)||e.isFramebufferTexture&&e.minFilter!==u&&e.minFilter!==h?Math.log2(Math.max(t.width,t.height))+1:void 0!==e.mipmaps&&e.mipmaps.length>0?e.mipmaps.length:e.isCompressedTexture&&Array.isArray(e.image)?t.mipmaps.length:1}function G(e){return e===u||1004===e||1005===e?9728:9729}function H(e){const t=e.target;t.removeEventListener("dispose",H),function(e){const t=r.get(e);if(void 0===t.__webglInit)return;const n=e.source,i=R.get(n);if(i){const r=i[t.__cacheKey];r.usedTimes--,0===r.usedTimes&&X(e),0===Object.keys(i).length&&R.delete(n)}r.remove(e)}(t),t.isVideoTexture&&N.delete(t)}function j(t){const n=t.target;n.removeEventListener("dispose",j),function(t){const n=t.texture,i=r.get(t),s=r.get(n);if(void 0!==s.__webglTexture&&(e.deleteTexture(s.__webglTexture),a.memory.textures--),t.depthTexture&&t.depthTexture.dispose(),t.isWebGLCubeRenderTarget)for(let t=0;t<6;t++)e.deleteFramebuffer(i.__webglFramebuffer[t]),i.__webglDepthbuffer&&e.deleteRenderbuffer(i.__webglDepthbuffer[t]);else{if(e.deleteFramebuffer(i.__webglFramebuffer),i.__webglDepthbuffer&&e.deleteRenderbuffer(i.__webglDepthbuffer),i.__webglMultisampledFramebuffer&&e.deleteFramebuffer(i.__webglMultisampledFramebuffer),i.__webglColorRenderbuffer)for(let t=0;t<i.__webglColorRenderbuffer.length;t++)i.__webglColorRenderbuffer[t]&&e.deleteRenderbuffer(i.__webglColorRenderbuffer[t]);i.__webglDepthRenderbuffer&&e.deleteRenderbuffer(i.__webglDepthRenderbuffer)}if(t.isWebGLMultipleRenderTargets)for(let t=0,i=n.length;t<i;t++){const i=r.get(n[t]);i.__webglTexture&&(e.deleteTexture(i.__webglTexture),a.memory.textures--),r.remove(n[t])}r.remove(n),r.remove(t)}(n)}function X(t){const n=r.get(t);e.deleteTexture(n.__webglTexture);const i=t.source;delete R.get(i)[n.__cacheKey],a.memory.textures--}let Y=0;function K(e,t){const i=r.get(e);if(e.isVideoTexture&&function(e){const t=a.render.frame;N.get(e)!==t&&(N.set(e,t),e.update())}(e),!1===e.isRenderTargetTexture&&e.version>0&&i.__version!==e.version){const n=e.image;if(null===n)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else{if(!1!==n.complete)return void te(i,e,t);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(33984+t),n.bindTexture(3553,i.__webglTexture)}const Z={[o]:10497,[l]:33071,[c]:33648},J={[u]:9728,1004:9984,1005:9986,[h]:9729,1007:9985,[d]:9987};function Q(n,s,a){if(a?(e.texParameteri(n,10242,Z[s.wrapS]),e.texParameteri(n,10243,Z[s.wrapT]),32879!==n&&35866!==n||e.texParameteri(n,32882,Z[s.wrapR]),e.texParameteri(n,10240,J[s.magFilter]),e.texParameteri(n,10241,J[s.minFilter])):(e.texParameteri(n,10242,33071),e.texParameteri(n,10243,33071),32879!==n&&35866!==n||e.texParameteri(n,32882,33071),s.wrapS===l&&s.wrapT===l||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),e.texParameteri(n,10240,G(s.magFilter)),e.texParameteri(n,10241,G(s.minFilter)),s.minFilter!==u&&s.minFilter!==h&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===t.has("EXT_texture_filter_anisotropic")){const a=t.get("EXT_texture_filter_anisotropic");if(s.type===m&&!1===t.has("OES_texture_float_linear"))return;if(!1===w&&s.type===g&&!1===t.has("OES_texture_half_float_linear"))return;(s.anisotropy>1||r.get(s).__currentAnisotropy)&&(e.texParameterf(n,a.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(s.anisotropy,i.getMaxAnisotropy())),r.get(s).__currentAnisotropy=s.anisotropy)}}function ee(t,n){let r=!1;void 0===t.__webglInit&&(t.__webglInit=!0,n.addEventListener("dispose",H));const i=n.source;let s=R.get(i);void 0===s&&(s={},R.set(i,s));const o=function(e){const t=[];return t.push(e.wrapS),t.push(e.wrapT),t.push(e.magFilter),t.push(e.minFilter),t.push(e.anisotropy),t.push(e.internalFormat),t.push(e.format),t.push(e.type),t.push(e.generateMipmaps),t.push(e.premultiplyAlpha),t.push(e.flipY),t.push(e.unpackAlignment),t.push(e.encoding),t.join()}(n);if(o!==t.__cacheKey){void 0===s[o]&&(s[o]={texture:e.createTexture(),usedTimes:0},a.memory.textures++,r=!0),s[o].usedTimes++;const i=s[t.__cacheKey];void 0!==i&&(s[t.__cacheKey].usedTimes--,0===i.usedTimes&&X(n)),t.__cacheKey=o,t.__webglTexture=s[o].texture}return r}function te(t,r,i){let a=3553;r.isDataArrayTexture&&(a=35866),r.isData3DTexture&&(a=32879);const o=ee(t,r),c=r.source;if(n.activeTexture(33984+i),n.bindTexture(a,t.__webglTexture),c.version!==c.__currentVersion||!0===o){e.pixelStorei(37440,r.flipY),e.pixelStorei(37441,r.premultiplyAlpha),e.pixelStorei(3317,r.unpackAlignment),e.pixelStorei(37443,0);const t=function(e){return!w&&(e.wrapS!==l||e.wrapT!==l||e.minFilter!==u&&e.minFilter!==h)}(r)&&!1===O(r.image);let i=P(r.image,t,!1,M);i=le(r,i);const d=O(i)||w,p=s.convert(r.format,r.encoding);let g,_=s.convert(r.type),S=U(r.internalFormat,p,_,r.encoding,r.isVideoTexture);Q(a,r,d);const T=r.mipmaps,E=w&&!0!==r.isVideoTexture,A=void 0===c.__currentVersion||!0===o,C=$(r,i,d);if(r.isDepthTexture)S=6402,w?S=r.type===m?36012:r.type===f?33190:r.type===y?35056:33189:r.type===m&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),r.format===x&&6402===S&&1012!==r.type&&r.type!==f&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),r.type=f,_=s.convert(r.type)),r.format===b&&6402===S&&(S=34041,r.type!==y&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),r.type=y,_=s.convert(r.type))),A&&(E?n.texStorage2D(3553,1,S,i.width,i.height):n.texImage2D(3553,0,S,i.width,i.height,0,p,_,null));else if(r.isDataTexture)if(T.length>0&&d){E&&A&&n.texStorage2D(3553,C,S,T[0].width,T[0].height);for(let e=0,t=T.length;e<t;e++)g=T[e],E?n.texSubImage2D(3553,e,0,0,g.width,g.height,p,_,g.data):n.texImage2D(3553,e,S,g.width,g.height,0,p,_,g.data);r.generateMipmaps=!1}else E?(A&&n.texStorage2D(3553,C,S,i.width,i.height),n.texSubImage2D(3553,0,0,0,i.width,i.height,p,_,i.data)):n.texImage2D(3553,0,S,i.width,i.height,0,p,_,i.data);else if(r.isCompressedTexture){E&&A&&n.texStorage2D(3553,C,S,T[0].width,T[0].height);for(let e=0,t=T.length;e<t;e++)g=T[e],r.format!==v?null!==p?E?n.compressedTexSubImage2D(3553,e,0,0,g.width,g.height,p,g.data):n.compressedTexImage2D(3553,e,S,g.width,g.height,0,g.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):E?n.texSubImage2D(3553,e,0,0,g.width,g.height,p,_,g.data):n.texImage2D(3553,e,S,g.width,g.height,0,p,_,g.data)}else if(r.isDataArrayTexture)E?(A&&n.texStorage3D(35866,C,S,i.width,i.height,i.depth),n.texSubImage3D(35866,0,0,0,0,i.width,i.height,i.depth,p,_,i.data)):n.texImage3D(35866,0,S,i.width,i.height,i.depth,0,p,_,i.data);else if(r.isData3DTexture)E?(A&&n.texStorage3D(32879,C,S,i.width,i.height,i.depth),n.texSubImage3D(32879,0,0,0,0,i.width,i.height,i.depth,p,_,i.data)):n.texImage3D(32879,0,S,i.width,i.height,i.depth,0,p,_,i.data);else if(r.isFramebufferTexture){if(A)if(E)n.texStorage2D(3553,C,S,i.width,i.height);else{let e=i.width,t=i.height;for(let r=0;r<C;r++)n.texImage2D(3553,r,S,e,t,0,p,_,null),e>>=1,t>>=1}}else if(T.length>0&&d){E&&A&&n.texStorage2D(3553,C,S,T[0].width,T[0].height);for(let e=0,t=T.length;e<t;e++)g=T[e],E?n.texSubImage2D(3553,e,0,0,p,_,g):n.texImage2D(3553,e,S,p,_,g);r.generateMipmaps=!1}else E?(A&&n.texStorage2D(3553,C,S,i.width,i.height),n.texSubImage2D(3553,0,0,0,p,_,i)):n.texImage2D(3553,0,S,p,_,i);z(r,d)&&B(a),c.__currentVersion=c.version,r.onUpdate&&r.onUpdate(r)}t.__version=r.version}function ne(t,i,a,o,l){const c=s.convert(a.format,a.encoding),u=s.convert(a.type),h=U(a.internalFormat,c,u,a.encoding);r.get(i).__hasExternalTextures||(32879===l||35866===l?n.texImage3D(l,0,h,i.width,i.height,i.depth,0,c,u,null):n.texImage2D(l,0,h,i.width,i.height,0,c,u,null)),n.bindFramebuffer(36160,t),oe(i)?E.framebufferTexture2DMultisampleEXT(36160,o,l,r.get(a).__webglTexture,0,se(i)):e.framebufferTexture2D(36160,o,l,r.get(a).__webglTexture,0),n.bindFramebuffer(36160,null)}function re(t,n,r){if(e.bindRenderbuffer(36161,t),n.depthBuffer&&!n.stencilBuffer){let i=33189;if(r||oe(n)){const t=n.depthTexture;t&&t.isDepthTexture&&(t.type===m?i=36012:t.type===f&&(i=33190));const r=se(n);oe(n)?E.renderbufferStorageMultisampleEXT(36161,r,i,n.width,n.height):e.renderbufferStorageMultisample(36161,r,i,n.width,n.height)}else e.renderbufferStorage(36161,i,n.width,n.height);e.framebufferRenderbuffer(36160,36096,36161,t)}else if(n.depthBuffer&&n.stencilBuffer){const i=se(n);r&&!1===oe(n)?e.renderbufferStorageMultisample(36161,i,35056,n.width,n.height):oe(n)?E.renderbufferStorageMultisampleEXT(36161,i,35056,n.width,n.height):e.renderbufferStorage(36161,34041,n.width,n.height),e.framebufferRenderbuffer(36160,33306,36161,t)}else{const t=!0===n.isWebGLMultipleRenderTargets?n.texture:[n.texture];for(let i=0;i<t.length;i++){const a=t[i],o=s.convert(a.format,a.encoding),l=s.convert(a.type),c=U(a.internalFormat,o,l,a.encoding),u=se(n);r&&!1===oe(n)?e.renderbufferStorageMultisample(36161,u,c,n.width,n.height):oe(n)?E.renderbufferStorageMultisampleEXT(36161,u,c,n.width,n.height):e.renderbufferStorage(36161,c,n.width,n.height)}}e.bindRenderbuffer(36161,null)}function ie(t){const i=r.get(t),s=!0===t.isWebGLCubeRenderTarget;if(t.depthTexture&&!i.__autoAllocateDepthBuffer){if(s)throw new Error("target.depthTexture not supported in Cube render targets");!function(t,i){if(i&&i.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(36160,t),!i.depthTexture||!i.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");r.get(i.depthTexture).__webglTexture&&i.depthTexture.image.width===i.width&&i.depthTexture.image.height===i.height||(i.depthTexture.image.width=i.width,i.depthTexture.image.height=i.height,i.depthTexture.needsUpdate=!0),K(i.depthTexture,0);const s=r.get(i.depthTexture).__webglTexture,a=se(i);if(i.depthTexture.format===x)oe(i)?E.framebufferTexture2DMultisampleEXT(36160,36096,3553,s,0,a):e.framebufferTexture2D(36160,36096,3553,s,0);else{if(i.depthTexture.format!==b)throw new Error("Unknown depthTexture format");oe(i)?E.framebufferTexture2DMultisampleEXT(36160,33306,3553,s,0,a):e.framebufferTexture2D(36160,33306,3553,s,0)}}(i.__webglFramebuffer,t)}else if(s){i.__webglDepthbuffer=[];for(let r=0;r<6;r++)n.bindFramebuffer(36160,i.__webglFramebuffer[r]),i.__webglDepthbuffer[r]=e.createRenderbuffer(),re(i.__webglDepthbuffer[r],t,!1)}else n.bindFramebuffer(36160,i.__webglFramebuffer),i.__webglDepthbuffer=e.createRenderbuffer(),re(i.__webglDepthbuffer,t,!1);n.bindFramebuffer(36160,null)}function se(e){return Math.min(T,e.samples)}function oe(e){const n=r.get(e);return w&&e.samples>0&&!0===t.has("WEBGL_multisampled_render_to_texture")&&!1!==n.__useRenderToTexture}function le(e,n){const r=e.encoding,i=e.format,s=e.type;return!0===e.isCompressedTexture||!0===e.isVideoTexture||e.format===L||r!==C&&(r===I?!1===w?!0===t.has("EXT_sRGB")&&i===v?(e.format=L,e.minFilter=h,e.generateMipmaps=!1):n=ae.sRGBToLinear(n):i===v&&s===p||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",r)),n}this.allocateTextureUnit=function(){const e=Y;return e>=_&&console.warn("THREE.WebGLTextures: Trying to use "+e+" texture units while this GPU supports only "+_),Y+=1,e},this.resetTextureUnits=function(){Y=0},this.setTexture2D=K,this.setTexture2DArray=function(e,t){const i=r.get(e);e.version>0&&i.__version!==e.version?te(i,e,t):(n.activeTexture(33984+t),n.bindTexture(35866,i.__webglTexture))},this.setTexture3D=function(e,t){const i=r.get(e);e.version>0&&i.__version!==e.version?te(i,e,t):(n.activeTexture(33984+t),n.bindTexture(32879,i.__webglTexture))},this.setTextureCube=function(t,i){const a=r.get(t);t.version>0&&a.__version!==t.version?function(t,r,i){if(6!==r.image.length)return;const a=ee(t,r),o=r.source;if(n.activeTexture(33984+i),n.bindTexture(34067,t.__webglTexture),o.version!==o.__currentVersion||!0===a){e.pixelStorei(37440,r.flipY),e.pixelStorei(37441,r.premultiplyAlpha),e.pixelStorei(3317,r.unpackAlignment),e.pixelStorei(37443,0);const t=r.isCompressedTexture||r.image[0].isCompressedTexture,i=r.image[0]&&r.image[0].isDataTexture,l=[];for(let e=0;e<6;e++)l[e]=t||i?i?r.image[e].image:r.image[e]:P(r.image[e],!1,!0,S),l[e]=le(r,l[e]);const c=l[0],u=O(c)||w,h=s.convert(r.format,r.encoding),d=s.convert(r.type),p=U(r.internalFormat,h,d,r.encoding),f=w&&!0!==r.isVideoTexture,m=void 0===o.__currentVersion||!0===a;let g,y=$(r,c,u);if(Q(34067,r,u),t){f&&m&&n.texStorage2D(34067,y,p,c.width,c.height);for(let e=0;e<6;e++){g=l[e].mipmaps;for(let t=0;t<g.length;t++){const i=g[t];r.format!==v?null!==h?f?n.compressedTexSubImage2D(34069+e,t,0,0,i.width,i.height,h,i.data):n.compressedTexImage2D(34069+e,t,p,i.width,i.height,0,i.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):f?n.texSubImage2D(34069+e,t,0,0,i.width,i.height,h,d,i.data):n.texImage2D(34069+e,t,p,i.width,i.height,0,h,d,i.data)}}}else{g=r.mipmaps,f&&m&&(g.length>0&&y++,n.texStorage2D(34067,y,p,l[0].width,l[0].height));for(let e=0;e<6;e++)if(i){f?n.texSubImage2D(34069+e,0,0,0,l[e].width,l[e].height,h,d,l[e].data):n.texImage2D(34069+e,0,p,l[e].width,l[e].height,0,h,d,l[e].data);for(let t=0;t<g.length;t++){const r=g[t].image[e].image;f?n.texSubImage2D(34069+e,t+1,0,0,r.width,r.height,h,d,r.data):n.texImage2D(34069+e,t+1,p,r.width,r.height,0,h,d,r.data)}}else{f?n.texSubImage2D(34069+e,0,0,0,h,d,l[e]):n.texImage2D(34069+e,0,p,h,d,l[e]);for(let t=0;t<g.length;t++){const r=g[t];f?n.texSubImage2D(34069+e,t+1,0,0,h,d,r.image[e]):n.texImage2D(34069+e,t+1,p,h,d,r.image[e])}}}z(r,u)&&B(34067),o.__currentVersion=o.version,r.onUpdate&&r.onUpdate(r)}t.__version=r.version}(a,t,i):(n.activeTexture(33984+i),n.bindTexture(34067,a.__webglTexture))},this.rebindTextures=function(e,t,n){const i=r.get(e);void 0!==t&&ne(i.__webglFramebuffer,e,e.texture,36064,3553),void 0!==n&&ie(e)},this.setupRenderTarget=function(t){const o=t.texture,l=r.get(t),c=r.get(o);t.addEventListener("dispose",j),!0!==t.isWebGLMultipleRenderTargets&&(void 0===c.__webglTexture&&(c.__webglTexture=e.createTexture()),c.__version=o.version,a.memory.textures++);const u=!0===t.isWebGLCubeRenderTarget,h=!0===t.isWebGLMultipleRenderTargets,d=O(t)||w;if(u){l.__webglFramebuffer=[];for(let t=0;t<6;t++)l.__webglFramebuffer[t]=e.createFramebuffer()}else{if(l.__webglFramebuffer=e.createFramebuffer(),h)if(i.drawBuffers){const n=t.texture;for(let t=0,i=n.length;t<i;t++){const i=r.get(n[t]);void 0===i.__webglTexture&&(i.__webglTexture=e.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(w&&t.samples>0&&!1===oe(t)){const r=h?o:[o];l.__webglMultisampledFramebuffer=e.createFramebuffer(),l.__webglColorRenderbuffer=[],n.bindFramebuffer(36160,l.__webglMultisampledFramebuffer);for(let n=0;n<r.length;n++){const i=r[n];l.__webglColorRenderbuffer[n]=e.createRenderbuffer(),e.bindRenderbuffer(36161,l.__webglColorRenderbuffer[n]);const a=s.convert(i.format,i.encoding),o=s.convert(i.type),c=U(i.internalFormat,a,o,i.encoding),u=se(t);e.renderbufferStorageMultisample(36161,u,c,t.width,t.height),e.framebufferRenderbuffer(36160,36064+n,36161,l.__webglColorRenderbuffer[n])}e.bindRenderbuffer(36161,null),t.depthBuffer&&(l.__webglDepthRenderbuffer=e.createRenderbuffer(),re(l.__webglDepthRenderbuffer,t,!0)),n.bindFramebuffer(36160,null)}}if(u){n.bindTexture(34067,c.__webglTexture),Q(34067,o,d);for(let e=0;e<6;e++)ne(l.__webglFramebuffer[e],t,o,36064,34069+e);z(o,d)&&B(34067),n.unbindTexture()}else if(h){const e=t.texture;for(let i=0,s=e.length;i<s;i++){const s=e[i],a=r.get(s);n.bindTexture(3553,a.__webglTexture),Q(3553,s,d),ne(l.__webglFramebuffer,t,s,36064+i,3553),z(s,d)&&B(3553)}n.unbindTexture()}else{let e=3553;(t.isWebGL3DRenderTarget||t.isWebGLArrayRenderTarget)&&(w?e=t.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),n.bindTexture(e,c.__webglTexture),Q(e,o,d),ne(l.__webglFramebuffer,t,o,36064,e),z(o,d)&&B(e),n.unbindTexture()}t.depthBuffer&&ie(t)},this.updateRenderTargetMipmap=function(e){const t=O(e)||w,i=!0===e.isWebGLMultipleRenderTargets?e.texture:[e.texture];for(let s=0,a=i.length;s<a;s++){const a=i[s];if(z(a,t)){const t=e.isWebGLCubeRenderTarget?34067:3553,i=r.get(a).__webglTexture;n.bindTexture(t,i),B(t),n.unbindTexture()}}},this.updateMultisampleRenderTarget=function(t){if(w&&t.samples>0&&!1===oe(t)){const i=t.isWebGLMultipleRenderTargets?t.texture:[t.texture],s=t.width,a=t.height;let o=16384;const l=[],c=t.stencilBuffer?33306:36096,u=r.get(t),h=!0===t.isWebGLMultipleRenderTargets;if(h)for(let t=0;t<i.length;t++)n.bindFramebuffer(36160,u.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(36160,36064+t,36161,null),n.bindFramebuffer(36160,u.__webglFramebuffer),e.framebufferTexture2D(36009,36064+t,3553,null,0);n.bindFramebuffer(36008,u.__webglMultisampledFramebuffer),n.bindFramebuffer(36009,u.__webglFramebuffer);for(let n=0;n<i.length;n++){l.push(36064+n),t.depthBuffer&&l.push(c);const d=void 0!==u.__ignoreDepthValues&&u.__ignoreDepthValues;if(!1===d&&(t.depthBuffer&&(o|=256),t.stencilBuffer&&(o|=1024)),h&&e.framebufferRenderbuffer(36008,36064,36161,u.__webglColorRenderbuffer[n]),!0===d&&(e.invalidateFramebuffer(36008,[c]),e.invalidateFramebuffer(36009,[c])),h){const t=r.get(i[n]).__webglTexture;e.framebufferTexture2D(36009,36064,3553,t,0)}e.blitFramebuffer(0,0,s,a,0,0,s,a,o,9728),A&&e.invalidateFramebuffer(36008,l)}if(n.bindFramebuffer(36008,null),n.bindFramebuffer(36009,null),h)for(let t=0;t<i.length;t++){n.bindFramebuffer(36160,u.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(36160,36064+t,36161,u.__webglColorRenderbuffer[t]);const s=r.get(i[t]).__webglTexture;n.bindFramebuffer(36160,u.__webglFramebuffer),e.framebufferTexture2D(36009,36064+t,3553,s,0)}n.bindFramebuffer(36009,u.__webglMultisampledFramebuffer)}},this.setupDepthRenderbuffer=ie,this.setupFrameBufferTexture=ne,this.useMultisampledRTT=oe}function Qi(e,t,n){const r=n.isWebGL2;return{convert:function(n,i=null){let s;if(n===p)return 5121;if(1017===n)return 32819;if(1018===n)return 32820;if(1010===n)return 5120;if(1011===n)return 5122;if(1012===n)return 5123;if(1013===n)return 5124;if(n===f)return 5125;if(n===m)return 5126;if(n===g)return r?5131:(s=t.get("OES_texture_half_float"),null!==s?s.HALF_FLOAT_OES:null);if(1021===n)return 6406;if(n===v)return 6408;if(1024===n)return 6409;if(1025===n)return 6410;if(n===x)return 6402;if(n===b)return 34041;if(1028===n)return 6403;if(1022===n)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(n===L)return s=t.get("EXT_sRGB"),null!==s?s.SRGB_ALPHA_EXT:null;if(1029===n)return 36244;if(1030===n)return 33319;if(1031===n)return 33320;if(1033===n)return 36249;if(n===w||n===_||n===S||n===M)if(i===I){if(s=t.get("WEBGL_compressed_texture_s3tc_srgb"),null===s)return null;if(n===w)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(n===_)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(n===S)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(n===M)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(s=t.get("WEBGL_compressed_texture_s3tc"),null===s)return null;if(n===w)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===_)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===S)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===M)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(35840===n||35841===n||35842===n||35843===n){if(s=t.get("WEBGL_compressed_texture_pvrtc"),null===s)return null;if(35840===n)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(35841===n)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(35842===n)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(35843===n)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(36196===n)return s=t.get("WEBGL_compressed_texture_etc1"),null!==s?s.COMPRESSED_RGB_ETC1_WEBGL:null;if(37492===n||37496===n){if(s=t.get("WEBGL_compressed_texture_etc"),null===s)return null;if(37492===n)return i===I?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(37496===n)return i===I?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}if(37808===n||37809===n||37810===n||37811===n||37812===n||37813===n||37814===n||37815===n||37816===n||37817===n||37818===n||37819===n||37820===n||37821===n){if(s=t.get("WEBGL_compressed_texture_astc"),null===s)return null;if(37808===n)return i===I?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(37809===n)return i===I?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(37810===n)return i===I?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(37811===n)return i===I?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(37812===n)return i===I?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(37813===n)return i===I?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(37814===n)return i===I?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(37815===n)return i===I?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(37816===n)return i===I?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(37817===n)return i===I?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(37818===n)return i===I?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(37819===n)return i===I?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(37820===n)return i===I?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(37821===n)return i===I?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}if(36492===n){if(s=t.get("EXT_texture_compression_bptc"),null===s)return null;if(36492===n)return i===I?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT}return n===y?r?34042:(s=t.get("WEBGL_depth_texture"),null!==s?s.UNSIGNED_INT_24_8_WEBGL:null):void 0!==e[n]?e[n]:null}}}class es extends vn{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}class ts extends yt{constructor(){super(),this.isGroup=!0,this.type="Group"}}const ns={type:"move"};class rs{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new ts,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new ts,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new me,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new me),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new ts,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new me,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new me),this._grip}dispatchEvent(e){return null!==this._targetRay&&this._targetRay.dispatchEvent(e),null!==this._grip&&this._grip.dispatchEvent(e),null!==this._hand&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(e,t,n){let r=null,i=null,s=null;const a=this._targetRay,o=this._grip,l=this._hand;if(e&&"visible-blurred"!==t.session.visibilityState)if(null!==a&&(r=t.getPose(e.targetRaySpace,n),null!==r&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),r.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(r.linearVelocity)):a.hasLinearVelocity=!1,r.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(r.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(ns))),l&&e.hand){s=!0;for(const r of e.hand.values()){const e=t.getJointPose(r,n);if(void 0===l.joints[r.jointName]){const e=new ts;e.matrixAutoUpdate=!1,e.visible=!1,l.joints[r.jointName]=e,l.add(e)}const i=l.joints[r.jointName];null!==e&&(i.matrix.fromArray(e.transform.matrix),i.matrix.decompose(i.position,i.rotation,i.scale),i.jointRadius=e.radius),i.visible=null!==e}const r=l.joints["index-finger-tip"],i=l.joints["thumb-tip"],a=r.position.distanceTo(i.position),o=.02,c=.005;l.inputState.pinching&&a>o+c?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!l.inputState.pinching&&a<=o-c&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else null!==o&&e.gripSpace&&(i=t.getPose(e.gripSpace,n),null!==i&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),i.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(i.linearVelocity)):o.hasLinearVelocity=!1,i.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(i.angularVelocity)):o.hasAngularVelocity=!1));return null!==a&&(a.visible=null!==r),null!==o&&(o.visible=null!==i),null!==l&&(l.visible=null!==s),this}}class is extends ue{constructor(e,t,n,r,i,s,a,o,l,c){if((c=void 0!==c?c:x)!==x&&c!==b)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&c===x&&(n=f),void 0===n&&c===b&&(n=y),super(null,r,i,s,a,o,c,n,l),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=void 0!==a?a:u,this.minFilter=void 0!==o?o:u,this.flipY=!1,this.generateMipmaps=!1}}class ss extends F{constructor(e,t){super();const n=this;let r=null,i=1,s=null,a="local-floor",o=null,l=null,c=null,u=null,h=null,d=null;const m=t.getContextAttributes();let g=null,w=null;const _=[],S=new Map,M=new vn;M.layers.enable(1),M.viewport=new he;const T=new vn;T.layers.enable(2),T.viewport=new he;const E=[M,T],A=new es;A.layers.enable(1),A.layers.enable(2);let C=null,N=null;function k(e){const t=S.get(e.inputSource);void 0!==t&&t.dispatchEvent({type:e.type,data:e.inputSource})}function R(){r.removeEventListener("select",k),r.removeEventListener("selectstart",k),r.removeEventListener("selectend",k),r.removeEventListener("squeeze",k),r.removeEventListener("squeezestart",k),r.removeEventListener("squeezeend",k),r.removeEventListener("end",R),r.removeEventListener("inputsourceschange",D),S.forEach((function(e,t){void 0!==e&&e.disconnect(t)})),S.clear(),C=null,N=null,e.setRenderTarget(g),h=null,u=null,c=null,r=null,w=null,z.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function D(e){const t=r.inputSources;for(let e=0;e<t.length;e++){const n="right"===t[e].handedness?1:0;S.set(t[e],_[n])}for(let t=0;t<e.removed.length;t++){const n=e.removed[t],r=S.get(n);r&&(r.dispatchEvent({type:"disconnected",data:n}),S.delete(n))}for(let t=0;t<e.added.length;t++){const n=e.added[t],r=S.get(n);r&&r.dispatchEvent({type:"connected",data:n})}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(e){let t=_[e];return void 0===t&&(t=new rs,_[e]=t),t.getTargetRaySpace()},this.getControllerGrip=function(e){let t=_[e];return void 0===t&&(t=new rs,_[e]=t),t.getGripSpace()},this.getHand=function(e){let t=_[e];return void 0===t&&(t=new rs,_[e]=t),t.getHandSpace()},this.setFramebufferScaleFactor=function(e){i=e,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(e){a=e,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return o||s},this.setReferenceSpace=function(e){o=e},this.getBaseLayer=function(){return null!==u?u:h},this.getBinding=function(){return c},this.getFrame=function(){return d},this.getSession=function(){return r},this.setSession=async function(l){if(r=l,null!==r){if(g=e.getRenderTarget(),r.addEventListener("select",k),r.addEventListener("selectstart",k),r.addEventListener("selectend",k),r.addEventListener("squeeze",k),r.addEventListener("squeezestart",k),r.addEventListener("squeezeend",k),r.addEventListener("end",R),r.addEventListener("inputsourceschange",D),!0!==m.xrCompatible&&await t.makeXRCompatible(),void 0===r.renderState.layers||!1===e.capabilities.isWebGL2){const n={antialias:void 0!==r.renderState.layers||m.antialias,alpha:m.alpha,depth:m.depth,stencil:m.stencil,framebufferScaleFactor:i};h=new XRWebGLLayer(r,t,n),r.updateRenderState({baseLayer:h}),w=new de(h.framebufferWidth,h.framebufferHeight,{format:v,type:p,encoding:e.outputEncoding})}else{let n=null,s=null,a=null;m.depth&&(a=m.stencil?35056:33190,n=m.stencil?b:x,s=m.stencil?y:f);const o={colorFormat:e.outputEncoding===I?35907:32856,depthFormat:a,scaleFactor:i};c=new XRWebGLBinding(r,t),u=c.createProjectionLayer(o),r.updateRenderState({layers:[u]}),w=new de(u.textureWidth,u.textureHeight,{format:v,type:p,depthTexture:new is(u.textureWidth,u.textureHeight,s,void 0,void 0,void 0,void 0,void 0,void 0,n),stencilBuffer:m.stencil,encoding:e.outputEncoding,samples:m.antialias?4:0}),e.properties.get(w).__ignoreDepthValues=u.ignoreDepthValues}w.isXRRenderTarget=!0,this.setFoveation(1),o=null,s=await r.requestReferenceSpace(a),z.setContext(r),z.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};const L=new me,F=new me;function P(e,t){null===t?e.matrixWorld.copy(e.matrix):e.matrixWorld.multiplyMatrices(t.matrixWorld,e.matrix),e.matrixWorldInverse.copy(e.matrixWorld).invert()}this.updateCamera=function(e){if(null===r)return;A.near=T.near=M.near=e.near,A.far=T.far=M.far=e.far,C===A.near&&N===A.far||(r.updateRenderState({depthNear:A.near,depthFar:A.far}),C=A.near,N=A.far);const t=e.parent,n=A.cameras;P(A,t);for(let e=0;e<n.length;e++)P(n[e],t);A.matrixWorld.decompose(A.position,A.quaternion,A.scale),e.position.copy(A.position),e.quaternion.copy(A.quaternion),e.scale.copy(A.scale),e.matrix.copy(A.matrix),e.matrixWorld.copy(A.matrixWorld);const i=e.children;for(let e=0,t=i.length;e<t;e++)i[e].updateMatrixWorld(!0);2===n.length?function(e,t,n){L.setFromMatrixPosition(t.matrixWorld),F.setFromMatrixPosition(n.matrixWorld);const r=L.distanceTo(F),i=t.projectionMatrix.elements,s=n.projectionMatrix.elements,a=i[14]/(i[10]-1),o=i[14]/(i[10]+1),l=(i[9]+1)/i[5],c=(i[9]-1)/i[5],u=(i[8]-1)/i[0],h=(s[8]+1)/s[0],d=a*u,p=a*h,f=r/(-u+h),m=f*-u;t.matrixWorld.decompose(e.position,e.quaternion,e.scale),e.translateX(m),e.translateZ(f),e.matrixWorld.compose(e.position,e.quaternion,e.scale),e.matrixWorldInverse.copy(e.matrixWorld).invert();const g=a+f,y=o+f,v=d-m,x=p+(r-m),b=l*o/y*g,w=c*o/y*g;e.projectionMatrix.makePerspective(v,x,b,w,g,y)}(A,M,T):A.projectionMatrix.copy(M.projectionMatrix)},this.getCamera=function(){return A},this.getFoveation=function(){return null!==u?u.fixedFoveation:null!==h?h.fixedFoveation:void 0},this.setFoveation=function(e){null!==u&&(u.fixedFoveation=e),null!==h&&void 0!==h.fixedFoveation&&(h.fixedFoveation=e)};let O=null;const z=new Nn;z.setAnimationLoop((function(t,n){if(l=n.getViewerPose(o||s),d=n,null!==l){const t=l.views;null!==h&&(e.setRenderTargetFramebuffer(w,h.framebuffer),e.setRenderTarget(w));let n=!1;t.length!==A.cameras.length&&(A.cameras.length=0,n=!0);for(let r=0;r<t.length;r++){const i=t[r];let s=null;if(null!==h)s=h.getViewport(i);else{const t=c.getViewSubImage(u,i);s=t.viewport,0===r&&(e.setRenderTargetTextures(w,t.colorTexture,u.ignoreDepthValues?void 0:t.depthStencilTexture),e.setRenderTarget(w))}let a=E[r];void 0===a&&(a=new vn,a.layers.enable(r),a.viewport=new he,E[r]=a),a.matrix.fromArray(i.transform.matrix),a.projectionMatrix.fromArray(i.projectionMatrix),a.viewport.set(s.x,s.y,s.width,s.height),0===r&&A.matrix.copy(a.matrix),!0===n&&A.cameras.push(a)}}const i=r.inputSources;for(let e=0;e<_.length;e++){const t=i[e],r=S.get(t);void 0!==r&&r.update(t,n,o||s)}O&&O(t,n),d=null})),this.setAnimationLoop=function(e){O=e},this.dispose=function(){}}}function as(e,t){function n(n,r){n.opacity.value=r.opacity,r.color&&n.diffuse.value.copy(r.color),r.emissive&&n.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),r.map&&(n.map.value=r.map),r.alphaMap&&(n.alphaMap.value=r.alphaMap),r.bumpMap&&(n.bumpMap.value=r.bumpMap,n.bumpScale.value=r.bumpScale,1===r.side&&(n.bumpScale.value*=-1)),r.displacementMap&&(n.displacementMap.value=r.displacementMap,n.displacementScale.value=r.displacementScale,n.displacementBias.value=r.displacementBias),r.emissiveMap&&(n.emissiveMap.value=r.emissiveMap),r.normalMap&&(n.normalMap.value=r.normalMap,n.normalScale.value.copy(r.normalScale),1===r.side&&n.normalScale.value.negate()),r.specularMap&&(n.specularMap.value=r.specularMap),r.alphaTest>0&&(n.alphaTest.value=r.alphaTest);const i=t.get(r).envMap;if(i&&(n.envMap.value=i,n.flipEnvMap.value=i.isCubeTexture&&!1===i.isRenderTargetTexture?-1:1,n.reflectivity.value=r.reflectivity,n.ior.value=r.ior,n.refractionRatio.value=r.refractionRatio),r.lightMap){n.lightMap.value=r.lightMap;const t=!0!==e.physicallyCorrectLights?Math.PI:1;n.lightMapIntensity.value=r.lightMapIntensity*t}let s,a;r.aoMap&&(n.aoMap.value=r.aoMap,n.aoMapIntensity.value=r.aoMapIntensity),r.map?s=r.map:r.specularMap?s=r.specularMap:r.displacementMap?s=r.displacementMap:r.normalMap?s=r.normalMap:r.bumpMap?s=r.bumpMap:r.roughnessMap?s=r.roughnessMap:r.metalnessMap?s=r.metalnessMap:r.alphaMap?s=r.alphaMap:r.emissiveMap?s=r.emissiveMap:r.clearcoatMap?s=r.clearcoatMap:r.clearcoatNormalMap?s=r.clearcoatNormalMap:r.clearcoatRoughnessMap?s=r.clearcoatRoughnessMap:r.iridescenceMap?s=r.iridescenceMap:r.iridescenceThicknessMap?s=r.iridescenceThicknessMap:r.specularIntensityMap?s=r.specularIntensityMap:r.specularColorMap?s=r.specularColorMap:r.transmissionMap?s=r.transmissionMap:r.thicknessMap?s=r.thicknessMap:r.sheenColorMap?s=r.sheenColorMap:r.sheenRoughnessMap&&(s=r.sheenRoughnessMap),void 0!==s&&(s.isWebGLRenderTarget&&(s=s.texture),!0===s.matrixAutoUpdate&&s.updateMatrix(),n.uvTransform.value.copy(s.matrix)),r.aoMap?a=r.aoMap:r.lightMap&&(a=r.lightMap),void 0!==a&&(a.isWebGLRenderTarget&&(a=a.texture),!0===a.matrixAutoUpdate&&a.updateMatrix(),n.uv2Transform.value.copy(a.matrix))}return{refreshFogUniforms:function(e,t){e.fogColor.value.copy(t.color),t.isFog?(e.fogNear.value=t.near,e.fogFar.value=t.far):t.isFogExp2&&(e.fogDensity.value=t.density)},refreshMaterialUniforms:function(e,r,i,s,a){r.isMeshBasicMaterial||r.isMeshLambertMaterial?n(e,r):r.isMeshToonMaterial?(n(e,r),function(e,t){t.gradientMap&&(e.gradientMap.value=t.gradientMap)}(e,r)):r.isMeshPhongMaterial?(n(e,r),function(e,t){e.specular.value.copy(t.specular),e.shininess.value=Math.max(t.shininess,1e-4)}(e,r)):r.isMeshStandardMaterial?(n(e,r),function(e,n){e.roughness.value=n.roughness,e.metalness.value=n.metalness,n.roughnessMap&&(e.roughnessMap.value=n.roughnessMap),n.metalnessMap&&(e.metalnessMap.value=n.metalnessMap),t.get(n).envMap&&(e.envMapIntensity.value=n.envMapIntensity)}(e,r),r.isMeshPhysicalMaterial&&function(e,t,n){e.ior.value=t.ior,t.sheen>0&&(e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen),e.sheenRoughness.value=t.sheenRoughness,t.sheenColorMap&&(e.sheenColorMap.value=t.sheenColorMap),t.sheenRoughnessMap&&(e.sheenRoughnessMap.value=t.sheenRoughnessMap)),t.clearcoat>0&&(e.clearcoat.value=t.clearcoat,e.clearcoatRoughness.value=t.clearcoatRoughness,t.clearcoatMap&&(e.clearcoatMap.value=t.clearcoatMap),t.clearcoatRoughnessMap&&(e.clearcoatRoughnessMap.value=t.clearcoatRoughnessMap),t.clearcoatNormalMap&&(e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),e.clearcoatNormalMap.value=t.clearcoatNormalMap,1===t.side&&e.clearcoatNormalScale.value.negate())),t.iridescence>0&&(e.iridescence.value=t.iridescence,e.iridescenceIOR.value=t.iridescenceIOR,e.iridescenceThicknessMinimum.value=t.iridescenceThicknessRange[0],e.iridescenceThicknessMaximum.value=t.iridescenceThicknessRange[1],t.iridescenceMap&&(e.iridescenceMap.value=t.iridescenceMap),t.iridescenceThicknessMap&&(e.iridescenceThicknessMap.value=t.iridescenceThicknessMap)),t.transmission>0&&(e.transmission.value=t.transmission,e.transmissionSamplerMap.value=n.texture,e.transmissionSamplerSize.value.set(n.width,n.height),t.transmissionMap&&(e.transmissionMap.value=t.transmissionMap),e.thickness.value=t.thickness,t.thicknessMap&&(e.thicknessMap.value=t.thicknessMap),e.attenuationDistance.value=t.attenuationDistance,e.attenuationColor.value.copy(t.attenuationColor)),e.specularIntensity.value=t.specularIntensity,e.specularColor.value.copy(t.specularColor),t.specularIntensityMap&&(e.specularIntensityMap.value=t.specularIntensityMap),t.specularColorMap&&(e.specularColorMap.value=t.specularColorMap)}(e,r,a)):r.isMeshMatcapMaterial?(n(e,r),function(e,t){t.matcap&&(e.matcap.value=t.matcap)}(e,r)):r.isMeshDepthMaterial?n(e,r):r.isMeshDistanceMaterial?(n(e,r),function(e,t){e.referencePosition.value.copy(t.referencePosition),e.nearDistance.value=t.nearDistance,e.farDistance.value=t.farDistance}(e,r)):r.isMeshNormalMaterial?n(e,r):r.isLineBasicMaterial?(function(e,t){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity}(e,r),r.isLineDashedMaterial&&function(e,t){e.dashSize.value=t.dashSize,e.totalSize.value=t.dashSize+t.gapSize,e.scale.value=t.scale}(e,r)):r.isPointsMaterial?function(e,t,n,r){let i;e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.size.value=t.size*n,e.scale.value=.5*r,t.map&&(e.map.value=t.map),t.alphaMap&&(e.alphaMap.value=t.alphaMap),t.alphaTest>0&&(e.alphaTest.value=t.alphaTest),t.map?i=t.map:t.alphaMap&&(i=t.alphaMap),void 0!==i&&(!0===i.matrixAutoUpdate&&i.updateMatrix(),e.uvTransform.value.copy(i.matrix))}(e,r,i,s):r.isSpriteMaterial?function(e,t){let n;e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.rotation.value=t.rotation,t.map&&(e.map.value=t.map),t.alphaMap&&(e.alphaMap.value=t.alphaMap),t.alphaTest>0&&(e.alphaTest.value=t.alphaTest),t.map?n=t.map:t.alphaMap&&(n=t.alphaMap),void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),e.uvTransform.value.copy(n.matrix))}(e,r):r.isShadowMaterial?(e.color.value.copy(r.color),e.opacity.value=r.opacity):r.isShaderMaterial&&(r.uniformsNeedUpdate=!1)}}}function os(e={}){this.isWebGLRenderer=!0;const t=void 0!==e.canvas?e.canvas:function(){const e=q("canvas");return e.style.display="block",e}(),n=void 0!==e.context?e.context:null,r=void 0===e.depth||e.depth,i=void 0===e.stencil||e.stencil,s=void 0!==e.antialias&&e.antialias,a=void 0===e.premultipliedAlpha||e.premultipliedAlpha,o=void 0!==e.preserveDrawingBuffer&&e.preserveDrawingBuffer,l=void 0!==e.powerPreference?e.powerPreference:"default",c=void 0!==e.failIfMajorPerformanceCaveat&&e.failIfMajorPerformanceCaveat;let u;u=null!==n?n.getContextAttributes().alpha:void 0!==e.alpha&&e.alpha;let h=null,f=null;const y=[],x=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=C,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1,Object.defineProperties(this,{gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});const b=this;let w=!1,_=0,S=0,M=null,T=-1,E=null;const A=new he,I=new he;let N=null,k=t.width,R=t.height,D=1,L=null,F=null;const P=new he(0,0,k,R),O=new he(0,0,k,R);let z=!1;const B=new In;let U=!1,$=!1,V=null;const H=new je,j=new G,X=new me,Y={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function K(){return null===M?D:1}let Z,J,Q,ee,te,ne,re,ie,se,ae,oe,le,ce,ue,pe,fe,ge,ye,ve,xe,be,we,_e,Se=n;function Me(e,n){for(let r=0;r<e.length;r++){const i=e[r],s=t.getContext(i,n);if(null!==s)return s}return null}try{const e={alpha:!0,depth:r,stencil:i,antialias:s,premultipliedAlpha:a,preserveDrawingBuffer:o,powerPreference:l,failIfMajorPerformanceCaveat:c};if("setAttribute"in t&&t.setAttribute("data-engine","three.js r141"),t.addEventListener("webglcontextlost",Ae,!1),t.addEventListener("webglcontextrestored",Ce,!1),t.addEventListener("webglcontextcreationerror",Ie,!1),null===Se){const t=["webgl2","webgl","experimental-webgl"];if(!0===b.isWebGL1Renderer&&t.shift(),Se=Me(t,e),null===Se)throw Me(t)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===Se.getShaderPrecisionFormat&&(Se.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(e){throw console.error("THREE.WebGLRenderer: "+e.message),e}function Te(){Z=new nr(Se),J=new Bn(Se,Z,e),Z.init(J),we=new Qi(Se,Z,J),Q=new Zi(Se,Z,J),ee=new sr(Se),te=new Oi,ne=new Ji(Se,Z,Q,te,J,we,ee),re=new $n(b),ie=new tr(b),se=new kn(Se,J),_e=new On(Se,Z,se,J),ae=new rr(Se,se,ee,_e),oe=new ur(Se,ae,se,ee),ve=new cr(Se,J,ne),fe=new Un(te),le=new Pi(b,re,ie,Z,J,_e,fe),ce=new as(b,te),ue=new $i,pe=new qi(Z,J),ye=new Pn(b,re,Q,oe,u,a),ge=new Ki(b,oe,J),xe=new zn(Se,Z,ee,J),be=new ir(Se,Z,ee,J),ee.programs=le.programs,b.capabilities=J,b.extensions=Z,b.properties=te,b.renderLists=ue,b.shadowMap=ge,b.state=Q,b.info=ee}Te();const Ee=new ss(b,Se);function Ae(e){e.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),w=!0}function Ce(){console.log("THREE.WebGLRenderer: Context Restored."),w=!1;const e=ee.autoReset,t=ge.enabled,n=ge.autoUpdate,r=ge.needsUpdate,i=ge.type;Te(),ee.autoReset=e,ge.enabled=t,ge.autoUpdate=n,ge.needsUpdate=r,ge.type=i}function Ie(e){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",e.statusMessage)}function Ne(e){const t=e.target;t.removeEventListener("dispose",Ne),function(e){(function(e){const t=te.get(e).programs;void 0!==t&&(t.forEach((function(e){le.releaseProgram(e)})),e.isShaderMaterial&&le.releaseShaderCache(e))})(e),te.remove(e)}(t)}this.xr=Ee,this.getContext=function(){return Se},this.getContextAttributes=function(){return Se.getContextAttributes()},this.forceContextLoss=function(){const e=Z.get("WEBGL_lose_context");e&&e.loseContext()},this.forceContextRestore=function(){const e=Z.get("WEBGL_lose_context");e&&e.restoreContext()},this.getPixelRatio=function(){return D},this.setPixelRatio=function(e){void 0!==e&&(D=e,this.setSize(k,R,!1))},this.getSize=function(e){return e.set(k,R)},this.setSize=function(e,n,r){Ee.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(k=e,R=n,t.width=Math.floor(e*D),t.height=Math.floor(n*D),!1!==r&&(t.style.width=e+"px",t.style.height=n+"px"),this.setViewport(0,0,e,n))},this.getDrawingBufferSize=function(e){return e.set(k*D,R*D).floor()},this.setDrawingBufferSize=function(e,n,r){k=e,R=n,D=r,t.width=Math.floor(e*r),t.height=Math.floor(n*r),this.setViewport(0,0,e,n)},this.getCurrentViewport=function(e){return e.copy(A)},this.getViewport=function(e){return e.copy(P)},this.setViewport=function(e,t,n,r){e.isVector4?P.set(e.x,e.y,e.z,e.w):P.set(e,t,n,r),Q.viewport(A.copy(P).multiplyScalar(D).floor())},this.getScissor=function(e){return e.copy(O)},this.setScissor=function(e,t,n,r){e.isVector4?O.set(e.x,e.y,e.z,e.w):O.set(e,t,n,r),Q.scissor(I.copy(O).multiplyScalar(D).floor())},this.getScissorTest=function(){return z},this.setScissorTest=function(e){Q.setScissorTest(z=e)},this.setOpaqueSort=function(e){L=e},this.setTransparentSort=function(e){F=e},this.getClearColor=function(e){return e.copy(ye.getClearColor())},this.setClearColor=function(){ye.setClearColor.apply(ye,arguments)},this.getClearAlpha=function(){return ye.getClearAlpha()},this.setClearAlpha=function(){ye.setClearAlpha.apply(ye,arguments)},this.clear=function(e=!0,t=!0,n=!0){let r=0;e&&(r|=16384),t&&(r|=256),n&&(r|=1024),Se.clear(r)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Ae,!1),t.removeEventListener("webglcontextrestored",Ce,!1),t.removeEventListener("webglcontextcreationerror",Ie,!1),ue.dispose(),pe.dispose(),te.dispose(),re.dispose(),ie.dispose(),oe.dispose(),_e.dispose(),le.dispose(),Ee.dispose(),Ee.removeEventListener("sessionstart",Re),Ee.removeEventListener("sessionend",De),V&&(V.dispose(),V=null),Le.stop()},this.renderBufferDirect=function(e,t,n,r,i,s){null===t&&(t=Y);const a=i.isMesh&&i.matrixWorld.determinant()<0,o=function(e,t,n,r,i){!0!==t.isScene&&(t=Y),ne.resetTextureUnits();const s=t.fog,a=r.isMeshStandardMaterial?t.environment:null,o=null===M?b.outputEncoding:!0===M.isXRRenderTarget?M.texture.encoding:C,l=(r.isMeshStandardMaterial?ie:re).get(r.envMap||a),c=!0===r.vertexColors&&!!n.attributes.color&&4===n.attributes.color.itemSize,u=!!r.normalMap&&!!n.attributes.tangent,h=!!n.morphAttributes.position,d=!!n.morphAttributes.normal,p=!!n.morphAttributes.color,m=r.toneMapped?b.toneMapping:0,g=n.morphAttributes.position||n.morphAttributes.normal||n.morphAttributes.color,y=void 0!==g?g.length:0,v=te.get(r),x=f.state.lights;if(!0===U&&(!0===$||e!==E)){const t=e===E&&r.id===T;fe.setState(r,e,t)}let w=!1;r.version===v.__version?v.needsLights&&v.lightsStateVersion!==x.state.version||v.outputEncoding!==o||i.isInstancedMesh&&!1===v.instancing?w=!0:i.isInstancedMesh||!0!==v.instancing?i.isSkinnedMesh&&!1===v.skinning?w=!0:i.isSkinnedMesh||!0!==v.skinning?v.envMap!==l||!0===r.fog&&v.fog!==s?w=!0:void 0===v.numClippingPlanes||v.numClippingPlanes===fe.numPlanes&&v.numIntersection===fe.numIntersection?(v.vertexAlphas!==c||v.vertexTangents!==u||v.morphTargets!==h||v.morphNormals!==d||v.morphColors!==p||v.toneMapping!==m||!0===J.isWebGL2&&v.morphTargetsCount!==y)&&(w=!0):w=!0:w=!0:w=!0:(w=!0,v.__version=r.version);let _=v.currentProgram;!0===w&&(_=Be(r,t,i));let S=!1,A=!1,I=!1;const N=_.getUniforms(),k=v.uniforms;if(Q.useProgram(_.program)&&(S=!0,A=!0,I=!0),r.id!==T&&(T=r.id,A=!0),S||E!==e){if(N.setValue(Se,"projectionMatrix",e.projectionMatrix),J.logarithmicDepthBuffer&&N.setValue(Se,"logDepthBufFC",2/(Math.log(e.far+1)/Math.LN2)),E!==e&&(E=e,A=!0,I=!0),r.isShaderMaterial||r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshStandardMaterial||r.envMap){const t=N.map.cameraPosition;void 0!==t&&t.setValue(Se,X.setFromMatrixPosition(e.matrixWorld))}(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial)&&N.setValue(Se,"isOrthographic",!0===e.isOrthographicCamera),(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial||r.isShadowMaterial||i.isSkinnedMesh)&&N.setValue(Se,"viewMatrix",e.matrixWorldInverse)}if(i.isSkinnedMesh){N.setOptional(Se,i,"bindMatrix"),N.setOptional(Se,i,"bindMatrixInverse");const e=i.skeleton;e&&(J.floatVertexTextures?(null===e.boneTexture&&e.computeBoneTexture(),N.setValue(Se,"boneTexture",e.boneTexture,ne),N.setValue(Se,"boneTextureSize",e.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const L=n.morphAttributes;var F,P;return(void 0!==L.position||void 0!==L.normal||void 0!==L.color&&!0===J.isWebGL2)&&ve.update(i,n,r,_),(A||v.receiveShadow!==i.receiveShadow)&&(v.receiveShadow=i.receiveShadow,N.setValue(Se,"receiveShadow",i.receiveShadow)),A&&(N.setValue(Se,"toneMappingExposure",b.toneMappingExposure),v.needsLights&&(P=I,(F=k).ambientLightColor.needsUpdate=P,F.lightProbe.needsUpdate=P,F.directionalLights.needsUpdate=P,F.directionalLightShadows.needsUpdate=P,F.pointLights.needsUpdate=P,F.pointLightShadows.needsUpdate=P,F.spotLights.needsUpdate=P,F.spotLightShadows.needsUpdate=P,F.rectAreaLights.needsUpdate=P,F.hemisphereLights.needsUpdate=P),s&&!0===r.fog&&ce.refreshFogUniforms(k,s),ce.refreshMaterialUniforms(k,r,D,R,V),fi.upload(Se,v.uniformsList,k,ne)),r.isShaderMaterial&&!0===r.uniformsNeedUpdate&&(fi.upload(Se,v.uniformsList,k,ne),r.uniformsNeedUpdate=!1),r.isSpriteMaterial&&N.setValue(Se,"center",i.center),N.setValue(Se,"modelViewMatrix",i.modelViewMatrix),N.setValue(Se,"normalMatrix",i.normalMatrix),N.setValue(Se,"modelMatrix",i.matrixWorld),_}(e,t,n,r,i);Q.setMaterial(r,a);let l=n.index;const c=n.attributes.position;if(null===l){if(void 0===c||0===c.count)return}else if(0===l.count)return;let u,h=1;!0===r.wireframe&&(l=ae.getWireframeAttribute(n),h=2),_e.setup(i,r,o,n,l);let d=xe;null!==l&&(u=se.get(l),d=be,d.setIndex(u));const p=null!==l?l.count:c.count,m=n.drawRange.start*h,g=n.drawRange.count*h,y=null!==s?s.start*h:0,v=null!==s?s.count*h:1/0,x=Math.max(m,y),w=Math.min(p,m+g,y+v)-1,_=Math.max(0,w-x+1);if(0!==_){if(i.isMesh)!0===r.wireframe?(Q.setLineWidth(r.wireframeLinewidth*K()),d.setMode(1)):d.setMode(4);else if(i.isLine){let e=r.linewidth;void 0===e&&(e=1),Q.setLineWidth(e*K()),i.isLineSegments?d.setMode(1):i.isLineLoop?d.setMode(2):d.setMode(3)}else i.isPoints?d.setMode(0):i.isSprite&&d.setMode(4);if(i.isInstancedMesh)d.renderInstances(x,_,i.count);else if(n.isInstancedBufferGeometry){const e=Math.min(n.instanceCount,n._maxInstanceCount);d.renderInstances(x,_,e)}else d.render(x,_)}},this.compile=function(e,t){f=pe.get(e),f.init(),x.push(f),e.traverseVisible((function(e){e.isLight&&e.layers.test(t.layers)&&(f.pushLight(e),e.castShadow&&f.pushShadow(e))})),f.setupLights(b.physicallyCorrectLights),e.traverse((function(t){const n=t.material;if(n)if(Array.isArray(n))for(let r=0;r<n.length;r++)Be(n[r],e,t);else Be(n,e,t)})),x.pop(),f=null};let ke=null;function Re(){Le.stop()}function De(){Le.start()}const Le=new Nn;function Fe(e,t,n,r){if(!1===e.visible)return;if(e.layers.test(t.layers))if(e.isGroup)n=e.renderOrder;else if(e.isLOD)!0===e.autoUpdate&&e.update(t);else if(e.isLight)f.pushLight(e),e.castShadow&&f.pushShadow(e);else if(e.isSprite){if(!e.frustumCulled||B.intersectsSprite(e)){r&&X.setFromMatrixPosition(e.matrixWorld).applyMatrix4(H);const t=oe.update(e),i=e.material;i.visible&&h.push(e,t,i,n,X.z,null)}}else if((e.isMesh||e.isLine||e.isPoints)&&(e.isSkinnedMesh&&e.skeleton.frame!==ee.render.frame&&(e.skeleton.update(),e.skeleton.frame=ee.render.frame),!e.frustumCulled||B.intersectsObject(e))){r&&X.setFromMatrixPosition(e.matrixWorld).applyMatrix4(H);const t=oe.update(e),i=e.material;if(Array.isArray(i)){const r=t.groups;for(let s=0,a=r.length;s<a;s++){const a=r[s],o=i[a.materialIndex];o&&o.visible&&h.push(e,t,o,n,X.z,a)}}else i.visible&&h.push(e,t,i,n,X.z,null)}const i=e.children;for(let e=0,s=i.length;e<s;e++)Fe(i[e],t,n,r)}function Pe(e,t,n,r){const i=e.opaque,a=e.transmissive,o=e.transparent;f.setupLightsView(n),a.length>0&&function(e,t,n){const r=J.isWebGL2;null===V&&(V=new de(1,1,{generateMipmaps:!0,type:Z.has("EXT_color_buffer_half_float")?g:p,minFilter:d,samples:r&&!0===s?4:0})),b.getDrawingBufferSize(j),r?V.setSize(j.x,j.y):V.setSize(W(j.x),W(j.y));const i=b.getRenderTarget();b.setRenderTarget(V),b.clear();const a=b.toneMapping;b.toneMapping=0,Oe(e,t,n),b.toneMapping=a,ne.updateMultisampleRenderTarget(V),ne.updateRenderTargetMipmap(V),b.setRenderTarget(i)}(i,t,n),r&&Q.viewport(A.copy(r)),i.length>0&&Oe(i,t,n),a.length>0&&Oe(a,t,n),o.length>0&&Oe(o,t,n),Q.buffers.depth.setTest(!0),Q.buffers.depth.setMask(!0),Q.buffers.color.setMask(!0),Q.setPolygonOffset(!1)}function Oe(e,t,n){const r=!0===t.isScene?t.overrideMaterial:null;for(let i=0,s=e.length;i<s;i++){const s=e[i],a=s.object,o=s.geometry,l=null===r?s.material:r,c=s.group;a.layers.test(n.layers)&&ze(a,t,n,o,l,c)}}function ze(e,t,n,r,i,s){e.onBeforeRender(b,t,n,r,i,s),e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,e.matrixWorld),e.normalMatrix.getNormalMatrix(e.modelViewMatrix),i.onBeforeRender(b,t,n,r,e,s),!0===i.transparent&&2===i.side?(i.side=1,i.needsUpdate=!0,b.renderBufferDirect(n,t,r,i,e,s),i.side=0,i.needsUpdate=!0,b.renderBufferDirect(n,t,r,i,e,s),i.side=2):b.renderBufferDirect(n,t,r,i,e,s),e.onAfterRender(b,t,n,r,i,s)}function Be(e,t,n){!0!==t.isScene&&(t=Y);const r=te.get(e),i=f.state.lights,s=f.state.shadowsArray,a=i.state.version,o=le.getParameters(e,i.state,s,t,n),l=le.getProgramCacheKey(o);let c=r.programs;r.environment=e.isMeshStandardMaterial?t.environment:null,r.fog=t.fog,r.envMap=(e.isMeshStandardMaterial?ie:re).get(e.envMap||r.environment),void 0===c&&(e.addEventListener("dispose",Ne),c=new Map,r.programs=c);let u=c.get(l);if(void 0!==u){if(r.currentProgram===u&&r.lightsStateVersion===a)return Ue(e,o),u}else o.uniforms=le.getUniforms(e),e.onBuild(n,o,b),e.onBeforeCompile(o,b),u=le.acquireProgram(o,l),c.set(l,u),r.uniforms=o.uniforms;const h=r.uniforms;(e.isShaderMaterial||e.isRawShaderMaterial)&&!0!==e.clipping||(h.clippingPlanes=fe.uniform),Ue(e,o),r.needsLights=function(e){return e.isMeshLambertMaterial||e.isMeshToonMaterial||e.isMeshPhongMaterial||e.isMeshStandardMaterial||e.isShadowMaterial||e.isShaderMaterial&&!0===e.lights}(e),r.lightsStateVersion=a,r.needsLights&&(h.ambientLightColor.value=i.state.ambient,h.lightProbe.value=i.state.probe,h.directionalLights.value=i.state.directional,h.directionalLightShadows.value=i.state.directionalShadow,h.spotLights.value=i.state.spot,h.spotLightShadows.value=i.state.spotShadow,h.rectAreaLights.value=i.state.rectArea,h.ltc_1.value=i.state.rectAreaLTC1,h.ltc_2.value=i.state.rectAreaLTC2,h.pointLights.value=i.state.point,h.pointLightShadows.value=i.state.pointShadow,h.hemisphereLights.value=i.state.hemi,h.directionalShadowMap.value=i.state.directionalShadowMap,h.directionalShadowMatrix.value=i.state.directionalShadowMatrix,h.spotShadowMap.value=i.state.spotShadowMap,h.spotShadowMatrix.value=i.state.spotShadowMatrix,h.pointShadowMap.value=i.state.pointShadowMap,h.pointShadowMatrix.value=i.state.pointShadowMatrix);const d=u.getUniforms(),p=fi.seqWithValue(d.seq,h);return r.currentProgram=u,r.uniformsList=p,u}function Ue(e,t){const n=te.get(e);n.outputEncoding=t.outputEncoding,n.instancing=t.instancing,n.skinning=t.skinning,n.morphTargets=t.morphTargets,n.morphNormals=t.morphNormals,n.morphColors=t.morphColors,n.morphTargetsCount=t.morphTargetsCount,n.numClippingPlanes=t.numClippingPlanes,n.numIntersection=t.numClipIntersection,n.vertexAlphas=t.vertexAlphas,n.vertexTangents=t.vertexTangents,n.toneMapping=t.toneMapping}Le.setAnimationLoop((function(e){ke&&ke(e)})),"undefined"!=typeof self&&Le.setContext(self),this.setAnimationLoop=function(e){ke=e,Ee.setAnimationLoop(e),null===e?Le.stop():Le.start()},Ee.addEventListener("sessionstart",Re),Ee.addEventListener("sessionend",De),this.render=function(e,t){if(void 0!==t&&!0!==t.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===w)return;!0===e.autoUpdate&&e.updateMatrixWorld(),null===t.parent&&t.updateMatrixWorld(),!0===Ee.enabled&&!0===Ee.isPresenting&&(!0===Ee.cameraAutoUpdate&&Ee.updateCamera(t),t=Ee.getCamera()),!0===e.isScene&&e.onBeforeRender(b,e,t,M),f=pe.get(e,x.length),f.init(),x.push(f),H.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),B.setFromProjectionMatrix(H),$=this.localClippingEnabled,U=fe.init(this.clippingPlanes,$,t),h=ue.get(e,y.length),h.init(),y.push(h),Fe(e,t,0,b.sortObjects),h.finish(),!0===b.sortObjects&&h.sort(L,F),!0===U&&fe.beginShadows();const n=f.state.shadowsArray;if(ge.render(n,e,t),!0===U&&fe.endShadows(),!0===this.info.autoReset&&this.info.reset(),ye.render(h,e),f.setupLights(b.physicallyCorrectLights),t.isArrayCamera){const n=t.cameras;for(let t=0,r=n.length;t<r;t++){const r=n[t];Pe(h,e,r,r.viewport)}}else Pe(h,e,t);null!==M&&(ne.updateMultisampleRenderTarget(M),ne.updateRenderTargetMipmap(M)),!0===e.isScene&&e.onAfterRender(b,e,t),_e.resetDefaultState(),T=-1,E=null,x.pop(),f=x.length>0?x[x.length-1]:null,y.pop(),h=y.length>0?y[y.length-1]:null},this.getActiveCubeFace=function(){return _},this.getActiveMipmapLevel=function(){return S},this.getRenderTarget=function(){return M},this.setRenderTargetTextures=function(e,t,n){te.get(e.texture).__webglTexture=t,te.get(e.depthTexture).__webglTexture=n;const r=te.get(e);r.__hasExternalTextures=!0,r.__hasExternalTextures&&(r.__autoAllocateDepthBuffer=void 0===n,r.__autoAllocateDepthBuffer||!0===Z.has("WEBGL_multisampled_render_to_texture")&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),r.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(e,t){const n=te.get(e);n.__webglFramebuffer=t,n.__useDefaultFramebuffer=void 0===t},this.setRenderTarget=function(e,t=0,n=0){M=e,_=t,S=n;let r=!0;if(e){const t=te.get(e);void 0!==t.__useDefaultFramebuffer?(Q.bindFramebuffer(36160,null),r=!1):void 0===t.__webglFramebuffer?ne.setupRenderTarget(e):t.__hasExternalTextures&&ne.rebindTextures(e,te.get(e.texture).__webglTexture,te.get(e.depthTexture).__webglTexture)}let i=null,s=!1,a=!1;if(e){const n=e.texture;(n.isData3DTexture||n.isDataArrayTexture)&&(a=!0);const r=te.get(e).__webglFramebuffer;e.isWebGLCubeRenderTarget?(i=r[t],s=!0):i=J.isWebGL2&&e.samples>0&&!1===ne.useMultisampledRTT(e)?te.get(e).__webglMultisampledFramebuffer:r,A.copy(e.viewport),I.copy(e.scissor),N=e.scissorTest}else A.copy(P).multiplyScalar(D).floor(),I.copy(O).multiplyScalar(D).floor(),N=z;if(Q.bindFramebuffer(36160,i)&&J.drawBuffers&&r&&Q.drawBuffers(e,i),Q.viewport(A),Q.scissor(I),Q.setScissorTest(N),s){const r=te.get(e.texture);Se.framebufferTexture2D(36160,36064,34069+t,r.__webglTexture,n)}else if(a){const r=te.get(e.texture),i=t||0;Se.framebufferTextureLayer(36160,36064,r.__webglTexture,n||0,i)}T=-1},this.readRenderTargetPixels=function(e,t,n,r,i,s,a){if(!e||!e.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let o=te.get(e).__webglFramebuffer;if(e.isWebGLCubeRenderTarget&&void 0!==a&&(o=o[a]),o){Q.bindFramebuffer(36160,o);try{const a=e.texture,o=a.format,l=a.type;if(o!==v&&we.convert(o)!==Se.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const c=l===g&&(Z.has("EXT_color_buffer_half_float")||J.isWebGL2&&Z.has("EXT_color_buffer_float"));if(!(l===p||we.convert(l)===Se.getParameter(35738)||l===m&&(J.isWebGL2||Z.has("OES_texture_float")||Z.has("WEBGL_color_buffer_float"))||c))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");t>=0&&t<=e.width-r&&n>=0&&n<=e.height-i&&Se.readPixels(t,n,r,i,we.convert(o),we.convert(l),s)}finally{const e=null!==M?te.get(M).__webglFramebuffer:null;Q.bindFramebuffer(36160,e)}}},this.copyFramebufferToTexture=function(e,t,n=0){const r=Math.pow(2,-n),i=Math.floor(t.image.width*r),s=Math.floor(t.image.height*r);ne.setTexture2D(t,0),Se.copyTexSubImage2D(3553,n,0,0,e.x,e.y,i,s),Q.unbindTexture()},this.copyTextureToTexture=function(e,t,n,r=0){const i=t.image.width,s=t.image.height,a=we.convert(n.format),o=we.convert(n.type);ne.setTexture2D(n,0),Se.pixelStorei(37440,n.flipY),Se.pixelStorei(37441,n.premultiplyAlpha),Se.pixelStorei(3317,n.unpackAlignment),t.isDataTexture?Se.texSubImage2D(3553,r,e.x,e.y,i,s,a,o,t.image.data):t.isCompressedTexture?Se.compressedTexSubImage2D(3553,r,e.x,e.y,t.mipmaps[0].width,t.mipmaps[0].height,a,t.mipmaps[0].data):Se.texSubImage2D(3553,r,e.x,e.y,a,o,t.image),0===r&&n.generateMipmaps&&Se.generateMipmap(3553),Q.unbindTexture()},this.copyTextureToTexture3D=function(e,t,n,r,i=0){if(b.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const s=e.max.x-e.min.x+1,a=e.max.y-e.min.y+1,o=e.max.z-e.min.z+1,l=we.convert(r.format),c=we.convert(r.type);let u;if(r.isData3DTexture)ne.setTexture3D(r,0),u=32879;else{if(!r.isDataArrayTexture)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");ne.setTexture2DArray(r,0),u=35866}Se.pixelStorei(37440,r.flipY),Se.pixelStorei(37441,r.premultiplyAlpha),Se.pixelStorei(3317,r.unpackAlignment);const h=Se.getParameter(3314),d=Se.getParameter(32878),p=Se.getParameter(3316),f=Se.getParameter(3315),m=Se.getParameter(32877),g=n.isCompressedTexture?n.mipmaps[0]:n.image;Se.pixelStorei(3314,g.width),Se.pixelStorei(32878,g.height),Se.pixelStorei(3316,e.min.x),Se.pixelStorei(3315,e.min.y),Se.pixelStorei(32877,e.min.z),n.isDataTexture||n.isData3DTexture?Se.texSubImage3D(u,i,t.x,t.y,t.z,s,a,o,l,c,g.data):n.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),Se.compressedTexSubImage3D(u,i,t.x,t.y,t.z,s,a,o,l,g.data)):Se.texSubImage3D(u,i,t.x,t.y,t.z,s,a,o,l,c,g),Se.pixelStorei(3314,h),Se.pixelStorei(32878,d),Se.pixelStorei(3316,p),Se.pixelStorei(3315,f),Se.pixelStorei(32877,m),0===i&&r.generateMipmaps&&Se.generateMipmap(u),Q.unbindTexture()},this.initTexture=function(e){ne.setTexture2D(e,0),Q.unbindTexture()},this.resetState=function(){_=0,S=0,M=null,Q.reset(),_e.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}(class extends os{}).prototype.isWebGL1Renderer=!0;class ls extends Nt{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new ie(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}function cs(){let e=0,t=0,n=0,r=0;function i(i,s,a,o){e=i,t=a,n=-3*i+3*s-2*a-o,r=2*i-2*s+a+o}return{initCatmullRom:function(e,t,n,r,s){i(t,n,s*(n-e),s*(r-t))},initNonuniformCatmullRom:function(e,t,n,r,s,a,o){let l=(t-e)/s-(n-e)/(s+a)+(n-t)/a,c=(n-t)/a-(r-t)/(a+o)+(r-n)/o;l*=a,c*=a,i(t,n,l,c)},calc:function(i){const s=i*i;return e+t*i+n*s+r*(s*i)}}}new me,new cs,new cs,new cs,new me,new me,new me,new Ct;class us extends Nt{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new ie(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ie(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new G(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}const hs={ShadowMaterial:class extends Nt{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new ie(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}},SpriteMaterial:class extends Nt{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new ie(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}},RawShaderMaterial:class extends gn{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}},ShaderMaterial:gn,PointsMaterial:class extends Nt{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new ie(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}},MeshPhysicalMaterial:class extends us{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new G(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return U(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new ie(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new ie(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new ie(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._iridescence=0,this._transmission=0,this.setValues(e)}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}},MeshStandardMaterial:us,MeshPhongMaterial:class extends Nt{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new ie(16777215),this.specular=new ie(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ie(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new G(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}},MeshToonMaterial:class extends Nt{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new ie(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ie(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new G(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}},MeshNormalMaterial:class extends Nt{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new G(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}},MeshLambertMaterial:class extends Nt{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new ie(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ie(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}},MeshDepthMaterial:Xi,MeshDistanceMaterial:Yi,MeshBasicMaterial:kt,MeshMatcapMaterial:class extends Nt{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new ie(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new G(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}},LineDashedMaterial:class extends ls{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}},LineBasicMaterial:ls,Material:Nt};Nt.fromType=function(e){return new hs[e]};const ds={arraySlice:function(e,t,n){return ds.isTypedArray(e)?new e.constructor(e.subarray(t,void 0!==n?n:e.length)):e.slice(t,n)},convertArray:function(e,t,n){return!e||!n&&e.constructor===t?e:"number"==typeof t.BYTES_PER_ELEMENT?new t(e):Array.prototype.slice.call(e)},isTypedArray:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)},getKeyframeOrder:function(e){const t=e.length,n=new Array(t);for(let e=0;e!==t;++e)n[e]=e;return n.sort((function(t,n){return e[t]-e[n]})),n},sortedArray:function(e,t,n){const r=e.length,i=new e.constructor(r);for(let s=0,a=0;a!==r;++s){const r=n[s]*t;for(let n=0;n!==t;++n)i[a++]=e[r+n]}return i},flattenJSON:function(e,t,n,r){let i=1,s=e[0];for(;void 0!==s&&void 0===s[r];)s=e[i++];if(void 0===s)return;let a=s[r];if(void 0!==a)if(Array.isArray(a))do{a=s[r],void 0!==a&&(t.push(s.time),n.push.apply(n,a)),s=e[i++]}while(void 0!==s);else if(void 0!==a.toArray)do{a=s[r],void 0!==a&&(t.push(s.time),a.toArray(n,n.length)),s=e[i++]}while(void 0!==s);else do{a=s[r],void 0!==a&&(t.push(s.time),n.push(a)),s=e[i++]}while(void 0!==s)},subclip:function(e,t,n,r,i=30){const s=e.clone();s.name=t;const a=[];for(let e=0;e<s.tracks.length;++e){const t=s.tracks[e],o=t.getValueSize(),l=[],c=[];for(let e=0;e<t.times.length;++e){const s=t.times[e]*i;if(!(s<n||s>=r)){l.push(t.times[e]);for(let n=0;n<o;++n)c.push(t.values[e*o+n])}}0!==l.length&&(t.times=ds.convertArray(l,t.times.constructor),t.values=ds.convertArray(c,t.values.constructor),a.push(t))}s.tracks=a;let o=1/0;for(let e=0;e<s.tracks.length;++e)o>s.tracks[e].times[0]&&(o=s.tracks[e].times[0]);for(let e=0;e<s.tracks.length;++e)s.tracks[e].shift(-1*o);return s.resetDuration(),s},makeClipAdditive:function(e,t=0,n=e,r=30){r<=0&&(r=30);const i=n.tracks.length,s=t/r;for(let t=0;t<i;++t){const r=n.tracks[t],i=r.ValueTypeName;if("bool"===i||"string"===i)continue;const a=e.tracks.find((function(e){return e.name===r.name&&e.ValueTypeName===i}));if(void 0===a)continue;let o=0;const l=r.getValueSize();r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(o=l/3);let c=0;const u=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=u/3);const h=r.times.length-1;let d;if(s<=r.times[0]){const e=o,t=l-o;d=ds.arraySlice(r.values,e,t)}else if(s>=r.times[h]){const e=h*l+o,t=e+l-o;d=ds.arraySlice(r.values,e,t)}else{const e=r.createInterpolant(),t=o,n=l-o;e.evaluate(s),d=ds.arraySlice(e.resultBuffer,t,n)}"quaternion"===i&&(new fe).fromArray(d).normalize().conjugate().toArray(d);const p=a.times.length;for(let e=0;e<p;++e){const t=e*u+c;if("quaternion"===i)fe.multiplyQuaternionsFlat(a.values,t,d,0,a.values,t);else{const e=u-2*c;for(let n=0;n<e;++n)a.values[t+n]-=d[n]}}}return e.blendMode=2501,e}};class ps{constructor(e,t,n,r){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=void 0!==r?r:new t.constructor(n),this.sampleValues=t,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let n=this._cachedIndex,r=t[n],i=t[n-1];e:{t:{let s;n:{r:if(!(e<r)){for(let s=n+2;;){if(void 0===r){if(e<i)break r;return n=t.length,this._cachedIndex=n,this.copySampleValue_(n-1)}if(n===s)break;if(i=r,r=t[++n],e<r)break t}s=t.length;break n}if(e>=i)break e;{const a=t[1];e<a&&(n=2,i=a);for(let s=n-2;;){if(void 0===i)return this._cachedIndex=0,this.copySampleValue_(0);if(n===s)break;if(r=i,i=t[--n-1],e>=i)break t}s=n,n=0}}for(;n<s;){const r=n+s>>>1;e<t[r]?s=r:n=r+1}if(r=t[n],i=t[n-1],void 0===i)return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===r)return n=t.length,this._cachedIndex=n,this.copySampleValue_(n-1)}this._cachedIndex=n,this.intervalChanged_(n,i,r)}return this.interpolate_(n,i,e,r)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,r=this.valueSize,i=e*r;for(let e=0;e!==r;++e)t[e]=n[i+e];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class fs extends ps{constructor(e,t,n,r){super(e,t,n,r),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:2400,endingEnd:2400}}intervalChanged_(e,t,n){const r=this.parameterPositions;let i=e-2,s=e+1,a=r[i],o=r[s];if(void 0===a)switch(this.getSettings_().endingStart){case 2401:i=e,a=2*t-n;break;case 2402:i=r.length-2,a=t+r[i]-r[i+1];break;default:i=e,a=n}if(void 0===o)switch(this.getSettings_().endingEnd){case 2401:s=e,o=2*n-t;break;case 2402:s=1,o=n+r[1]-r[0];break;default:s=e-1,o=t}const l=.5*(n-t),c=this.valueSize;this._weightPrev=l/(t-a),this._weightNext=l/(o-n),this._offsetPrev=i*c,this._offsetNext=s*c}interpolate_(e,t,n,r){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=e*a,l=o-a,c=this._offsetPrev,u=this._offsetNext,h=this._weightPrev,d=this._weightNext,p=(n-t)/(r-t),f=p*p,m=f*p,g=-h*m+2*h*f-h*p,y=(1+h)*m+(-1.5-2*h)*f+(-.5+h)*p+1,v=(-1-d)*m+(1.5+d)*f+.5*p,x=d*m-d*f;for(let e=0;e!==a;++e)i[e]=g*s[c+e]+y*s[l+e]+v*s[o+e]+x*s[u+e];return i}}class ms extends ps{constructor(e,t,n,r){super(e,t,n,r)}interpolate_(e,t,n,r){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=e*a,l=o-a,c=(n-t)/(r-t),u=1-c;for(let e=0;e!==a;++e)i[e]=s[l+e]*u+s[o+e]*c;return i}}class gs extends ps{constructor(e,t,n,r){super(e,t,n,r)}interpolate_(e){return this.copySampleValue_(e-1)}}class ys{constructor(e,t,n,r){if(void 0===e)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===t||0===t.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=ds.convertArray(t,this.TimeBufferType),this.values=ds.convertArray(n,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:ds.convertArray(e.times,Array),values:ds.convertArray(e.values,Array)};const t=e.getInterpolation();t!==e.DefaultInterpolation&&(n.interpolation=t)}return n.type=e.ValueTypeName,n}InterpolantFactoryMethodDiscrete(e){return new gs(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new ms(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new fs(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case T:t=this.InterpolantFactoryMethodDiscrete;break;case E:t=this.InterpolantFactoryMethodLinear;break;case A:t=this.InterpolantFactoryMethodSmooth}if(void 0===t){const t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(e===this.DefaultInterpolation)throw new Error(t);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",t),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return T;case this.InterpolantFactoryMethodLinear:return E;case this.InterpolantFactoryMethodSmooth:return A}}getValueSize(){return this.values.length/this.times.length}shift(e){if(0!==e){const t=this.times;for(let n=0,r=t.length;n!==r;++n)t[n]+=e}return this}scale(e){if(1!==e){const t=this.times;for(let n=0,r=t.length;n!==r;++n)t[n]*=e}return this}trim(e,t){const n=this.times,r=n.length;let i=0,s=r-1;for(;i!==r&&n[i]<e;)++i;for(;-1!==s&&n[s]>t;)--s;if(++s,0!==i||s!==r){i>=s&&(s=Math.max(s,1),i=s-1);const e=this.getValueSize();this.times=ds.arraySlice(n,i,s),this.values=ds.arraySlice(this.values,i*e,s*e)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,r=this.values,i=n.length;0===i&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let s=null;for(let t=0;t!==i;t++){const r=n[t];if("number"==typeof r&&isNaN(r)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,t,r),e=!1;break}if(null!==s&&s>r){console.error("THREE.KeyframeTrack: Out of order keys.",this,t,r,s),e=!1;break}s=r}if(void 0!==r&&ds.isTypedArray(r))for(let t=0,n=r.length;t!==n;++t){const n=r[t];if(isNaN(n)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,t,n),e=!1;break}}return e}optimize(){const e=ds.arraySlice(this.times),t=ds.arraySlice(this.values),n=this.getValueSize(),r=this.getInterpolation()===A,i=e.length-1;let s=1;for(let a=1;a<i;++a){let i=!1;const o=e[a];if(o!==e[a+1]&&(1!==a||o!==e[0]))if(r)i=!0;else{const e=a*n,r=e-n,s=e+n;for(let a=0;a!==n;++a){const n=t[e+a];if(n!==t[r+a]||n!==t[s+a]){i=!0;break}}}if(i){if(a!==s){e[s]=e[a];const r=a*n,i=s*n;for(let e=0;e!==n;++e)t[i+e]=t[r+e]}++s}}if(i>0){e[s]=e[i];for(let e=i*n,r=s*n,a=0;a!==n;++a)t[r+a]=t[e+a];++s}return s!==e.length?(this.times=ds.arraySlice(e,0,s),this.values=ds.arraySlice(t,0,s*n)):(this.times=e,this.values=t),this}clone(){const e=ds.arraySlice(this.times,0),t=ds.arraySlice(this.values,0),n=new(0,this.constructor)(this.name,e,t);return n.createInterpolant=this.createInterpolant,n}}ys.prototype.TimeBufferType=Float32Array,ys.prototype.ValueBufferType=Float32Array,ys.prototype.DefaultInterpolation=E;class vs extends ys{}vs.prototype.ValueTypeName="bool",vs.prototype.ValueBufferType=Array,vs.prototype.DefaultInterpolation=T,vs.prototype.InterpolantFactoryMethodLinear=void 0,vs.prototype.InterpolantFactoryMethodSmooth=void 0;(class extends ys{}).prototype.ValueTypeName="color";(class extends ys{}).prototype.ValueTypeName="number";class xs extends ps{constructor(e,t,n,r){super(e,t,n,r)}interpolate_(e,t,n,r){const i=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=(n-t)/(r-t);let l=e*a;for(let e=l+a;l!==e;l+=4)fe.slerpFlat(i,0,s,l-a,s,l,o);return i}}class bs extends ys{InterpolantFactoryMethodLinear(e){return new xs(this.times,this.values,this.getValueSize(),e)}}bs.prototype.ValueTypeName="quaternion",bs.prototype.DefaultInterpolation=E,bs.prototype.InterpolantFactoryMethodSmooth=void 0;class ws extends ys{}ws.prototype.ValueTypeName="string",ws.prototype.ValueBufferType=Array,ws.prototype.DefaultInterpolation=T,ws.prototype.InterpolantFactoryMethodLinear=void 0,ws.prototype.InterpolantFactoryMethodSmooth=void 0;(class extends ys{}).prototype.ValueTypeName="vector";new class{constructor(e,t,n){const r=this;let i,s=!1,a=0,o=0;const l=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(e){o++,!1===s&&void 0!==r.onStart&&r.onStart(e,a,o),s=!0},this.itemEnd=function(e){a++,void 0!==r.onProgress&&r.onProgress(e,a,o),a===o&&(s=!1,void 0!==r.onLoad&&r.onLoad())},this.itemError=function(e){void 0!==r.onError&&r.onError(e)},this.resolveURL=function(e){return i?i(e):e},this.setURLModifier=function(e){return i=e,this},this.addHandler=function(e,t){return l.push(e,t),this},this.removeHandler=function(e){const t=l.indexOf(e);return-1!==t&&l.splice(t,2),this},this.getHandler=function(e){for(let t=0,n=l.length;t<n;t+=2){const n=l[t],r=l[t+1];if(n.global&&(n.lastIndex=0),n.test(e))return r}return null}}};const _s=new RegExp("[\\[\\]\\.:\\/]","g"),Ss="[^\\[\\]\\.:\\/]",Ms="[^"+"\\[\\]\\.:\\/".replace("\\.","")+"]",Ts=/((?:WC+[\/:])*)/.source.replace("WC",Ss),Es=/(WCOD+)?/.source.replace("WCOD",Ms),As=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Ss),Cs=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Ss),Is=new RegExp("^"+Ts+Es+As+Cs+"$"),Ns=["material","materials","bones"];class ks{constructor(e,t,n){this.path=t,this.parsedPath=n||ks.parseTrackName(t),this.node=ks.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,n){return e&&e.isAnimationObjectGroup?new ks.Composite(e,t,n):new ks(e,t,n)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(_s,"")}static parseTrackName(e){const t=Is.exec(e);if(null===t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},r=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==r&&-1!==r){const e=n.nodeName.substring(r+1);-1!==Ns.indexOf(e)&&(n.nodeName=n.nodeName.substring(0,r),n.objectName=e)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n}static findNode(e,t){if(void 0===t||""===t||"."===t||-1===t||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(void 0!==n)return n}if(e.children){const n=function(e){for(let r=0;r<e.length;r++){const i=e[r];if(i.name===t||i.uuid===t)return i;const s=n(i.children);if(s)return s}return null},r=n(e.children);if(r)return r}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)e[t++]=n[r]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let r=0,i=n.length;r!==i;++r)n[r]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,n=t.objectName,r=t.propertyName;let i=t.propertyIndex;if(e||(e=ks.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let r=t.objectIndex;switch(n){case"materials":if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);e=e.material.materials;break;case"bones":if(!e.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);e=e.skeleton.bones;for(let t=0;t<e.length;t++)if(e[t].name===r){r=t;break}break;default:if(void 0===e[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);e=e[n]}if(void 0!==r){if(void 0===e[r])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);e=e[r]}}const s=e[r];if(void 0===s){const n=t.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+n+"."+r+" but it wasn't found.",e)}let a=this.Versioning.None;this.targetObject=e,void 0!==e.needsUpdate?a=this.Versioning.NeedsUpdate:void 0!==e.matrixWorldNeedsUpdate&&(a=this.Versioning.MatrixWorldNeedsUpdate);let o=this.BindingType.Direct;if(void 0!==i){if("morphTargetInfluences"===r){if(!e.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!e.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==e.morphTargetDictionary[i]&&(i=e.morphTargetDictionary[i])}o=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=i}else void 0!==s.fromArray&&void 0!==s.toArray?(o=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(o=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=r;this.getValue=this.GetterByBindingType[o],this.setValue=this.SetterByBindingTypeAndVersioning[o][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}ks.Composite=class{constructor(e,t,n){const r=n||ks.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,r)}getValue(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,r=this._bindings[n];void 0!==r&&r.getValue(e,t)}setValue(e,t){const n=this._bindings;for(let r=this._targetGroup.nCachedObjects_,i=n.length;r!==i;++r)n[r].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}},ks.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},ks.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},ks.prototype.GetterByBindingType=[ks.prototype._getValue_direct,ks.prototype._getValue_array,ks.prototype._getValue_arrayElement,ks.prototype._getValue_toArray],ks.prototype.SetterByBindingTypeAndVersioning=[[ks.prototype._setValue_direct,ks.prototype._setValue_direct_setNeedsUpdate,ks.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[ks.prototype._setValue_array,ks.prototype._setValue_array_setNeedsUpdate,ks.prototype._setValue_array_setMatrixWorldNeedsUpdate],[ks.prototype._setValue_arrayElement,ks.prototype._setValue_arrayElement_setNeedsUpdate,ks.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[ks.prototype._setValue_fromArray,ks.prototype._setValue_fromArray_setNeedsUpdate,ks.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];const Rs=new ArrayBuffer(4),Ds=(new Float32Array(Rs),new Uint32Array(Rs),new Uint32Array(512)),Ls=new Uint32Array(512);for(let e=0;e<256;++e){const t=e-127;t<-27?(Ds[e]=0,Ds[256|e]=32768,Ls[e]=24,Ls[256|e]=24):t<-14?(Ds[e]=1024>>-t-14,Ds[256|e]=1024>>-t-14|32768,Ls[e]=-t-1,Ls[256|e]=-t-1):t<=15?(Ds[e]=t+15<<10,Ds[256|e]=t+15<<10|32768,Ls[e]=13,Ls[256|e]=13):t<128?(Ds[e]=31744,Ds[256|e]=64512,Ls[e]=24,Ls[256|e]=24):(Ds[e]=31744,Ds[256|e]=64512,Ls[e]=13,Ls[256|e]=13)}const Fs=new Uint32Array(2048),Ps=new Uint32Array(64),Os=new Uint32Array(64);for(let e=1;e<1024;++e){let t=e<<13,n=0;for(;0==(8388608&t);)t<<=1,n-=8388608;t&=-8388609,n+=947912704,Fs[e]=t|n}for(let e=1024;e<2048;++e)Fs[e]=939524096+(e-1024<<13);for(let e=1;e<31;++e)Ps[e]=e<<23;Ps[31]=1199570944,Ps[32]=2147483648;for(let e=33;e<63;++e)Ps[e]=2147483648+(e-32<<23);Ps[63]=3347054592;for(let e=1;e<64;++e)32!==e&&(Os[e]=1024);"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:"141"}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__="141");const zs=new nt(0,0,0,"YXZ"),Bs=new me,Us={type:"change"},$s={type:"lock"},Vs={type:"unlock"},Ws=Math.PI/2;class Gs extends F{constructor(e,t){super(),void 0===t&&(console.warn('THREE.PointerLockControls: The second parameter "domElement" is now mandatory.'),t=document.body),this.domElement=t,this.isLocked=!1,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.pointerSpeed=1;const n=this;function r(t){if(!1===n.isLocked)return;const r=t.movementX||t.mozMovementX||t.webkitMovementX||0,i=t.movementY||t.mozMovementY||t.webkitMovementY||0;zs.setFromQuaternion(e.quaternion),zs.y-=.002*r*n.pointerSpeed,zs.x-=.002*i*n.pointerSpeed,zs.x=Math.max(Ws-n.maxPolarAngle,Math.min(Ws-n.minPolarAngle,zs.x)),e.quaternion.setFromEuler(zs),n.dispatchEvent(Us)}function i(){n.domElement.ownerDocument.pointerLockElement===n.domElement?(n.dispatchEvent($s),n.isLocked=!0):(n.dispatchEvent(Vs),n.isLocked=!1)}function s(){console.error("THREE.PointerLockControls: Unable to use Pointer Lock API")}this.connect=function(){n.domElement.ownerDocument.addEventListener("mousemove",r),n.domElement.ownerDocument.addEventListener("pointerlockchange",i),n.domElement.ownerDocument.addEventListener("pointerlockerror",s)},this.disconnect=function(){n.domElement.ownerDocument.removeEventListener("mousemove",r),n.domElement.ownerDocument.removeEventListener("pointerlockchange",i),n.domElement.ownerDocument.removeEventListener("pointerlockerror",s)},this.dispose=function(){this.disconnect()},this.getObject=function(){return e},this.getDirection=function(){const t=new me(0,0,-1);return function(n){return n.copy(t).applyQuaternion(e.quaternion)}}(),this.moveForward=function(t){Bs.setFromMatrixColumn(e.matrix,0),Bs.crossVectors(e.up,Bs),e.position.addScaledVector(Bs,t)},this.moveRight=function(t){Bs.setFromMatrixColumn(e.matrix,0),e.position.addScaledVector(Bs,t)},this.lock=function(){this.domElement.requestPointerLock()},this.unlock=function(){n.domElement.ownerDocument.exitPointerLock()},this.connect()}}},5079:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>i});var r=function(){var e=0,t=document.createElement("div");function n(e){return t.appendChild(e.dom),e}function i(n){for(var r=0;r<t.children.length;r++)t.children[r].style.display=r===n?"block":"none";e=n}t.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",t.addEventListener("click",(function(n){n.preventDefault(),i(++e%t.children.length)}),!1);var s=(performance||Date).now(),a=s,o=0,l=n(new r.Panel("FPS","#0ff","#002")),c=n(new r.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var u=n(new r.Panel("MB","#f08","#201"));return i(0),{REVISION:16,dom:t,addPanel:n,showPanel:i,begin:function(){s=(performance||Date).now()},end:function(){o++;var e=(performance||Date).now();if(c.update(e-s,200),e>=a+1e3&&(l.update(1e3*o/(e-a),100),a=e,o=0,u)){var t=performance.memory;u.update(t.usedJSHeapSize/1048576,t.jsHeapSizeLimit/1048576)}return e},update:function(){s=this.end()},domElement:t,setMode:i}};r.Panel=function(e,t,n){var r=1/0,i=0,s=Math.round,a=s(window.devicePixelRatio||1),o=80*a,l=48*a,c=3*a,u=2*a,h=3*a,d=15*a,p=74*a,f=30*a,m=document.createElement("canvas");m.width=o,m.height=l,m.style.cssText="width:80px;height:48px";var g=m.getContext("2d");return g.font="bold "+9*a+"px Helvetica,Arial,sans-serif",g.textBaseline="top",g.fillStyle=n,g.fillRect(0,0,o,l),g.fillStyle=t,g.fillText(e,c,u),g.fillRect(h,d,p,f),g.fillStyle=n,g.globalAlpha=.9,g.fillRect(h,d,p,f),{dom:m,update:function(l,y){r=Math.min(r,l),i=Math.max(i,l),g.fillStyle=n,g.globalAlpha=1,g.fillRect(0,0,o,d),g.fillStyle=t,g.fillText(s(l)+" "+e+" ("+s(r)+"-"+s(i)+")",c,u),g.drawImage(m,h+a,d,p-a,f,h,d,p-a,f),g.fillRect(h+p-a,d,a,f),g.fillStyle=n,g.globalAlpha=.9,g.fillRect(h+p-a,d,a,s((1-l/y)*f))}}};const i=r}},e=>{e(e.s=8929)}]);